(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["common"],{

  /***/ "./lib/assets/javascripts/builder/components/background-importer/background-import-limit-view.js":
  /*!*******************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/background-importer/background-import-limit-view.js ***!
    \*******************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./background-import-limit.tpl */ "./lib/assets/javascripts/builder/components/background-importer/background-import-limit.tpl");
  var Notifier = __webpack_require__(/*! builder/components/notifier/notifier */ "./lib/assets/javascripts/builder/components/notifier/notifier.js");
  
  /**
   *  Import limit message within background importer
   *
   */
  
  module.exports = CoreView.extend({
    initialize: function initialize(opts) {
      if (!opts.userModel) throw new Error('userModel is required');
      if (!opts.configModel) throw new Error('configModel is required');
  
      this._userModel = opts.userModel;
      this._configModel = opts.configModel;
  
      this._notification = Notifier.addNotification({
        status: 'error',
        closable: true,
        button: false,
        info: this._getInfo()
      });
  
      this._initBinds();
    },
  
    _initBinds: function _initBinds() {
      this._notification.on('notification:close', this._closeHandler, this);
      this.add_related_model(this._notification);
    },
  
    _closeHandler: function _closeHandler() {
      this.clean();
    },
  
    _getInfo: function _getInfo() {
      var importQuota = this._userModel.getMaxConcurrentImports();
      var isUpgradeable = !this._configModel.get('cartodb_com_hosted') && importQuota === 1;
  
      return template({
        upgradeUrl: window.upgrade_url,
        isUpgradeable: isUpgradeable,
        importQuota: importQuota
      });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/background-importer/error-details-view.js":
  /*!*********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/background-importer/error-details-view.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var defaultTemplate = __webpack_require__(/*! ./error-details.tpl */ "./lib/assets/javascripts/builder/components/background-importer/error-details.tpl");
  var upgradeErrorTemplate = __webpack_require__(/*! ./upgrade-errors.tpl */ "./lib/assets/javascripts/builder/components/background-importer/upgrade-errors.tpl");
  var UPGRADE_ERROR_CODES = [8001, 8002, 8005, 8007];
  
  /**
   * Error details view, to be used together with an error object from an import model.
   *
   */
  
  module.exports = CoreView.extend({
    initialize: function initialize(opts) {
      if (!opts.userModel) throw new Error('userModel is required');
      if (!opts.configModel) throw new Error('configModel is required');
      if (!opts.error) throw new Error('error is required');
  
      this._userModel = opts.userModel;
      this._configModel = opts.configModel;
      this._error = opts.error;
    },
  
    render: function render() {
      var isUpgradeError = _.contains(UPGRADE_ERROR_CODES, this._error.errorCode);
      var upgradeUrl = this._configModel.get('upgrade_url');
      var userCanUpgrade = upgradeUrl && !this._configModel.get('cartodb_com_hosted') && (!this._userModel.isInsideOrg() || this._userModel.isOrgOwner());
      var template = this._getTemplate(isUpgradeError);
  
      var html = template({
        errorCode: this._error.errorCode,
        title: this._error.title,
        text: this._error.what_about,
        itemQueueId: this._error.item_queue_id,
        originalUrl: this._error.originalUrl,
        httpResponseCode: this._error.httpResponseCode,
        httpResponseCodeMessage: this._error.httpRresponseCodeMessage,
        userCanUpgrade: userCanUpgrade,
        showTrial: this._userModel.canStartTrial(),
        upgradeUrl: upgradeUrl
      });
  
      this.$el.html(html);
  
      return this;
    },
  
    _getTemplate: function _getTemplate(isUpgradeError) {
      var template = defaultTemplate;
  
      if (isUpgradeError) {
        template = upgradeErrorTemplate;
      }
      return template;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/background-importer/twitter-import-details-view.js":
  /*!******************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/background-importer/twitter-import-details-view.js ***!
    \******************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var template = __webpack_require__(/*! ./twitter-import-details.tpl */ "./lib/assets/javascripts/builder/components/background-importer/twitter-import-details.tpl");
  
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['userModel', 'modalModel'];
  
  /**
   *  When a Twitter import finishes, this dialog displays
   *  all the info about the price/cost etc.
   *
   */
  module.exports = CoreView.extend({
  
    className: 'TwitterImportDetails',
  
    events: {
      'click .js-close': '_onCloseClick'
    },
  
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
    },
  
    render: function render() {
      var imp = this.model.get('import');
      var userTwitterValues = this._userModel.get('twitter');
      var availableTweets = userTwitterValues.quota - userTwitterValues.monthly_use;
  
      this.$el.html(template({
        datasetTotalRows: imp.tweets_georeferenced,
        datasetTotalRowsFormatted: Utils.formatNumber(imp.tweets_georeferenced),
        tweetsCost: imp.tweets_cost,
        tweetsCostFormatted: Utils.formatNumber(imp.tweets_cost),
        availableTweets: availableTweets,
        availableTweetsFormatted: Utils.formatNumber(availableTweets),
        tweetsOverquota: imp.tweets_overquota,
        tweetsOverquotaFormatted: Utils.formatNumber(imp.tweets_overquota),
        blockSizeFormatted: Utils.formatNumber(userTwitterValues.block_size),
        blockPriceFormatted: Utils.formatNumber(userTwitterValues.block_price)
      }));
  
      return this;
    },
  
    _onCloseClick: function _onCloseClick() {
      this._modalModel.destroy();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/background-importer/warnings-details-view.js":
  /*!************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/background-importer/warnings-details-view.js ***!
    \************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var partialImportDetailsTemplate = __webpack_require__(/*! ./warning-partial-import-details.tpl */ "./lib/assets/javascripts/builder/components/background-importer/warning-partial-import-details.tpl");
  var tooManyFilesDetailsTemplate = __webpack_require__(/*! ./warning-too-many-files-details.tpl */ "./lib/assets/javascripts/builder/components/background-importer/warning-too-many-files-details.tpl");
  var tooManyRowsConnectorTemplate = __webpack_require__(/*! ./warning-too-many-rows-connector-details.tpl */ "./lib/assets/javascripts/builder/components/background-importer/warning-too-many-rows-connector-details.tpl");
  
  /**
   * Error details view, to be used together with an error object from an import model.
   *
   */
  
  module.exports = CoreView.extend({
  
    initialize: function initialize(opts) {
      if (!opts.userModel) throw new Error('userModel is required');
      if (!opts.warnings) throw new Error('warnings is required');
  
      this._userModel = this.options.userModel;
      this._warnings = this.options.warnings;
    },
  
    render: function render() {
      var warnings = this._warnings;
      var template = this._getTemplate(warnings);
  
      this.$el.html(template({
        userMaxLayers: warnings.user_max_layers,
        maxTablesPerImport: warnings.max_tables_per_import,
        maxRowsPerConnectorImport: warnings.max_rows_per_connection
      }));
  
      return this;
    },
  
    _getTemplate: function _getTemplate(warnings) {
      if (warnings.user_max_layers && warnings.max_tables_per_import) {
        return warnings.user_max_layers < warnings.max_tables_per_import ? partialImportDetailsTemplate : tooManyFilesDetailsTemplate;
      } else if (warnings.user_max_layers) {
        return partialImportDetailsTemplate;
      } else if (warnings.max_tables_per_import) {
        return tooManyFilesDetailsTemplate;
      } else if (warnings.max_rows_per_connection) {
        return tooManyRowsConnectorTemplate;
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/carousel-form-view.js":
  /*!*************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/carousel-form-view.js ***!
    \*************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var CarouselView = __webpack_require__(/*! ./custom-carousel/custom-carousel-view */ "./lib/assets/javascripts/builder/components/custom-carousel/custom-carousel-view.js");
  
  /**
   *  Carousel form view
   */
  
  module.exports = CoreView.extend({
    module: 'components:carousel-form-view',
  
    className: 'js-aggregationTypes',
  
    initialize: function initialize(opts) {
      if (!opts.collection) throw new Error('Carousel collection is required');
      if (!opts.template) throw new Error('template is required');
      this.template = opts.template;
      this._initBinds();
    },
  
    render: function render() {
      var selectedItem = this.collection.getSelected();
      var selectedName = selectedItem && selectedItem.getName();
      this.$el.html(this.template({
        name: selectedName
      }));
      this._initViews();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.collection.bind('change:highlighted', this._onChangeHighlighted, this);
    },
  
    _initViews: function _initViews() {
      var carousel = new CarouselView(_.extend(this.options, {
        collection: this.collection
      }));
  
      if (!this.$('.js-selector').length) throw new Error('HTML element with js-selector class is required');
  
      this.$('.js-selector').append(carousel.render().el);
      carousel.initScroll();
      this.addView(carousel);
    },
  
    _onChangeHighlighted: function _onChangeHighlighted() {
      var item = this.collection.getHighlighted() || this.collection.getSelected();
      if (item) {
        var $el = this.$('.js-highlight');
        if ($el) {
          $el.text(item.getName());
        }
      }
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/code-mirror/cartocss.code-mirror.js":
  /*!***************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/code-mirror/cartocss.code-mirror.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var COLOR_KEYWORDS = __webpack_require__(/*! builder/helpers/color-keywords */ "./lib/assets/javascripts/builder/helpers/color-keywords.js");
  
  /*
    LESS mode - http://www.lesscss.org/
    Ported to CodeMirror by Peter Kroon <plakroon@gmail.com>
    Report bugs/issues here: https://github.com/marijnh/CodeMirror/issues  GitHub: @peterkroon
  */
  
  module.exports = function (CodeMirror) {
    CodeMirror.defineMode('cartocss', function (config) {
      var indentUnit = config.indentUnit;
      var type;
  
      function ret(style, tp) {
        type = tp;
        return style;
      }
      // html tags
      var tags = 'a abbr acronym address applet area article aside audio b base basefont bdi bdo big blockquote body br button canvas caption cite code col colgroup command datalist dd del details dfn dir div dl dt em embed fieldset figcaption figure font footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html i iframe img input ins keygen kbd label legend li link map mark menu meta meter nav noframes noscript object ol optgroup option output p param pre progress q rp rt ruby s samp script section select small source span strike strong style sub summary sup table tbody td textarea tfoot th thead time title tr track tt u ul var video wbr'.split(' ');
      var colorKeywords = keySet(COLOR_KEYWORDS);
  
      function inTagsArray(val) {
        for (var i = 0; i < tags.length; i++) {
          if (val === tags[i]) return true;
        }
      }
  
      var selectors = /(^\:root$|^\:nth\-child$|^\:nth\-last\-child$|^\:nth\-of\-type$|^\:nth\-last\-of\-type$|^\:first\-child$|^\:last\-child$|^\:first\-of\-type$|^\:last\-of\-type$|^\:only\-child$|^\:only\-of\-type$|^\:empty$|^\:link|^\:visited$|^\:active$|^\:hover$|^\:focus$|^\:target$|^\:lang$|^\:enabled^\:disabled$|^\:checked$|^\:first\-line$|^\:first\-letter$|^\:before$|^\:after$|^\:not$|^\:required$|^\:invalid$)/;
  
      function tokenBase(stream, state) {
        var ch = stream.next();
  
        if (ch === '@') {
          stream.eatWhile(/[\w\-]/);
          return ret('meta', stream.current());
        } else if (ch === '/' && stream.eat('*')) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else if (ch === '<' && stream.eat('!')) {
          state.tokenize = tokenSGMLComment;
          return tokenSGMLComment(stream, state);
        } else if (ch === '=') ret(null, 'compare');else if (ch === '|' && stream.eat('=')) return ret(null, 'compare');else if (ch === '\'' || ch === '\'') {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        } else if (ch === '/') {
          // e.g.: .png will not be parsed as a class
          if (stream.eat('/')) {
            state.tokenize = tokenSComment;
            return tokenSComment(stream, state);
          } else {
            if (type === 'string' || type === '(') {
              return ret('string', 'string');
            }
            if (state.stack[state.stack.length - 1] !== undefined) {
              return ret(null, ch);
            }
            stream.eatWhile(/[\a-zA-Z0-9\-_.\s]/);
            if (/\/|\)|#/.test(stream.peek() || stream.eatSpace() && stream.peek() === ')') || stream.eol()) {
              return ret('string', 'string'); // let url(/images/logo.png) without quotes return as string
            }
          }
        } else if (ch === '!') {
          stream.match(/^\s*\w*/);
          return ret('keyword', 'important');
        } else if (/\d/.test(ch)) {
          stream.eatWhile(/[\w.%]/);
          return ret('number', 'unit');
        } else if (/[,+<>*\/]/.test(ch)) {
          if (stream.peek() === '=' || type === 'a') {
            return ret('string', 'string');
          }
          return ret(null, 'select-op');
        } else if (/[;{}:\[\]()~\|]/.test(ch)) {
          if (ch === ':') {
            stream.eatWhile(/[a-z\\\-]/);
  
            if (selectors.test(stream.current())) {
              return ret('tag', 'tag');
            } else if (stream.peek() === ':') {
              // ::-webkit-search-decoration
              stream.next();
              stream.eatWhile(/[a-z\\\-]/);
              if (stream.current().match(/\:\:\-(o|ms|moz|webkit)\-/)) {
                return ret('string', 'string');
              }
              if (selectors.test(stream.current().substring(1))) {
                return ret('tag', 'tag');
              }
              return ret(null, ch);
            } else {
              return ret(null, ch);
            }
          } else if (ch === '~') {
            if (type === 'r') {
              return ret('string', 'string');
            }
          } else {
            return ret(null, ch);
          }
        } else if (ch === '.') {
          if (type === '(' || type === 'string') {
            return ret('string', 'string'); // allow url(../image.png)
          }
          stream.eatWhile(/[\a-zA-Z0-9\-_]/);
          if (stream.peek() === ' ') {
            stream.eatSpace();
          }
          if (stream.peek() === ')') {
            return ret('number', 'unit'); // rgba(0,0,0,.25);
          }
          return ret('tag', 'tag');
        } else if (ch === '#') {
          // we don't eat white-space, we want the hex color and or id only
          stream.eatWhile(/[A-Za-z0-9]/);
          // check if there is a proper hex color length e.g. #eee || #eeeEEE
          if (stream.current().length === 4 || stream.current().length === 7) {
            if (stream.current().match(/[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3}/, false) != null) {
              // is there a valid hex color value present in the current stream
              // when not a valid hex value, parse as id
              if (stream.current().substring(1) !== stream.current().match(/[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3}/, false)[0]) {
                return ret('atom', 'tag');
              }
              // eat white-space
              stream.eatSpace();
              // when hex value declaration doesn't end with [;,] but is does with a slash/cc comment treat it as an id, just like the other hex values that don't end with[;,]
              if (/[\/<>.({!$%^&*_\-\\?=+\|#'~`]/.test(stream.peek())) {
                return ret('atom', 'tag');
              } else if (stream.peek() === '}') {
                // #time { color: #aaa }
                return ret('color', 'unit');
              } else if (/[a-zA-Z\\]/.test(stream.peek())) {
                // we have a valid hex color value, parse as id whenever an element/class is defined after the hex(id) value e.g. #eee aaa || #eee .aaa
                return ret('color', 'unit');
              } else if (stream.eol()) {
                // when a hex value is on the end of a line, parse as id
                return ret('color', 'unit');
              } else {
                // default
                return ret('color', 'unit');
              }
            } else {
              // when not a valid hexvalue in the current stream e.g. #footer
              stream.eatWhile(/[\w\\\-]/);
              return ret('atom', 'tag');
            }
          } else {
            // when not a valid hexvalue length
            stream.eatWhile(/[\w\\\-]/);
            return ret('atom', 'tag');
          }
        } else if (ch === '&') {
          stream.eatWhile(/[\w\-]/);
          return ret(null, ch);
        } else {
          stream.eatWhile(/[\w\\\-_%.{]/);
          if (type === 'string') {
            return ret('string', 'string');
          } else if (stream.current().match(/(^http$|^https$)/) != null) {
            stream.eatWhile(/[\w\\\-_%.{:\/]/);
            return ret('string', 'string');
          } else if (stream.peek() === '<' || stream.peek() === '>') {
            return ret('tag', 'tag');
          } else if (/\(/.test(stream.peek())) {
            return ret(null, ch);
          } else if (stream.peek() === '/' && state.stack[state.stack.length - 1] !== undefined) {
            // url(dir/center/image.png)
            return ret('string', 'string');
          } else if (stream.current().match(/\-\d|\-.\d/)) {
            // match e.g.: -5px -0.4 etc... only colorize the minus sign
            // commment out these 2 comment if you want the minus sign to be parsed as null -500px
            // stream.backUp(stream.current().length-1);
            // return ret(null, ch); //console.log( stream.current() );
            return ret('number', 'unit');
          } else if (inTagsArray(stream.current().toLowerCase())) {
            // match html tags
            return ret('tag', 'tag');
          } else if (/\/|[\s\)]/.test(stream.peek() || stream.eol() || stream.eatSpace() && stream.peek() === '/') && stream.current().indexOf('.') !== -1) {
            if (stream.current().substring(stream.current().length - 1, stream.current().length) === '{') {
              stream.backUp(1);
              return ret('tag', 'tag');
            } // end if
            stream.eatSpace();
            if (/[{<>.a-zA-Z\/]/.test(stream.peek()) || stream.eol()) return ret('tag', 'tag'); // e.g. button.icon-plus
            return ret('string', 'string'); // let url(/images/logo.png) without quotes return as string
          } else if (stream.eol() || stream.peek() === '[' || stream.peek() === '#' || type === 'tag') {
            if (stream.current().substring(stream.current().length - 1, stream.current().length) === '{') stream.backUp(1);
            return ret('tag', 'tag');
          } else if (type === 'compare' || type === 'a' || type === '(') {
            return ret('string', 'string');
          } else if (type === '|' || stream.current() === '-' || type === '[') {
            return ret(null, ch);
          } else if (stream.peek() === ':') {
            stream.next();
            var t_v = stream.peek() === ':';
            if (!t_v) {
              var old_pos = stream.pos;
              var sc = stream.current().length;
              stream.eatWhile(/[a-z\\\-]/);
              var new_pos = stream.pos;
              if (stream.current().substring(sc - 1).match(selectors) != null) {
                stream.backUp(new_pos - (old_pos - 1));
                return ret('tag', 'tag');
              } else stream.backUp(new_pos - (old_pos - 1));
            } else {
              stream.backUp(1);
            }
            if (t_v) return ret('tag', 'tag');else return ret('variable', 'variable');
  
            // It is a color variable?
          } else if (colorKeywords.hasOwnProperty(stream.current())) {
            return ret('color', 'unit');
          } else {
            return ret('variable', 'variable');
          }
        }
      }
  
      function keySet(array) {
        var keys = {};
        for (var i = 0; i < array.length; ++i) {
          keys[array[i]] = true;
        }
        return keys;
      }
  
      function tokenSComment(stream, state) {
        // SComment = Slash comment
        stream.skipToEnd();
        state.tokenize = tokenBase;
        return ret('comment', 'comment');
      }
  
      function tokenCComment(stream, state) {
        var maybeEnd = false;
        var ch;
        while ((ch = stream.next()) != null) {
          if (maybeEnd && ch === '/') {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = ch === '*';
        }
        return ret('comment', 'comment');
      }
  
      function tokenSGMLComment(stream, state) {
        var dashes = 0;
        var ch;
        while ((ch = stream.next()) != null) {
          if (dashes >= 2 && ch === '>') {
            state.tokenize = tokenBase;
            break;
          }
          dashes = ch === '-' ? dashes + 1 : 0;
        }
        return ret('comment', 'comment');
      }
  
      function tokenString(quote) {
        return function (stream, state) {
          var escaped = false;
          var ch;
          while ((ch = stream.next()) != null) {
            if (ch === quote && !escaped) {
              break;
            }
            escaped = !escaped && ch === '\\';
          }
          if (!escaped) state.tokenize = tokenBase;
          return ret('string', 'string');
        };
      }
  
      return {
        startState: function startState(base) {
          return {
            tokenize: tokenBase,
            baseIndent: base || 0,
            stack: []
          };
        },
  
        token: function token(stream, state) {
          if (stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);
  
          var context = state.stack[state.stack.length - 1];
          if (type === 'hash' && context === 'rule') style = 'atom';else if (style === 'variable') {
            if (context === 'rule') style = null; // 'tag'
            else if (!context || context === '@media{') {
                style = stream.current() === 'when' ? 'variable' : /[\s,|\s\)|\s]/.test(stream.peek()) ? 'tag' : type;
              }
          }
  
          if (context === 'rule' && /^[\{\};]$/.test(type)) {
            state.stack.pop();
          }
          if (type === '{') {
            if (context === '@media') state.stack[state.stack.length - 1] = '@media{';else state.stack.push('{');
          } else if (type === '}') state.stack.pop();else if (type === '@media') state.stack.push('@media');else if (context === '{' && type !== 'comment') state.stack.push('rule');
          return style;
        },
  
        indent: function indent(state, textAfter) {
          var n = state.stack.length;
          if (/^\}/.test(textAfter)) {
            n -= state.stack[state.stack.length - 1] === 'rule' ? 2 : 1;
          }
          return state.baseIndent + n * indentUnit;
        },
  
        electricChars: '}'
      };
    });
  
    CodeMirror.defineMIME('text/x-carto', 'cartocss');
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/code-mirror/code-mirror-view.js":
  /*!***********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/code-mirror/code-mirror-view.js ***!
    \***********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CodeMirror = __webpack_require__(/*! codemirror */ "./node_modules/codemirror/lib/codemirror.js");
  var ColorPicker = __webpack_require__(/*! ./colorpicker.code-mirror */ "./lib/assets/javascripts/builder/components/code-mirror/colorpicker.code-mirror.js");
  var template = __webpack_require__(/*! ./code-mirror.tpl */ "./lib/assets/javascripts/builder/components/code-mirror/code-mirror.tpl");
  var bulletTemplate = __webpack_require__(/*! ./code-mirror-bullet.tpl */ "./lib/assets/javascripts/builder/components/code-mirror/code-mirror-bullet.tpl");
  var errorTemplate = __webpack_require__(/*! ./code-mirror-error.tpl */ "./lib/assets/javascripts/builder/components/code-mirror/code-mirror-error.tpl");
  var warningTemplate = __webpack_require__(/*! ./code-mirror-warning.tpl */ "./lib/assets/javascripts/builder/components/code-mirror/code-mirror-warning.tpl");
  var DATA_SERVICES = __webpack_require__(/*! ./data-services */ "./lib/assets/javascripts/builder/components/code-mirror/data-services.js");
  
  __webpack_require__(/*! ./mode/sql */ "./lib/assets/javascripts/builder/components/code-mirror/mode/sql.js")(CodeMirror);
  __webpack_require__(/*! ./mode/mustache */ "./lib/assets/javascripts/builder/components/code-mirror/mode/mustache.js")(CodeMirror);
  __webpack_require__(/*! ./cartocss.code-mirror */ "./lib/assets/javascripts/builder/components/code-mirror/cartocss.code-mirror.js")(CodeMirror);
  __webpack_require__(/*! ./scroll.code-mirror */ "./lib/assets/javascripts/builder/components/code-mirror/scroll.code-mirror.js")(CodeMirror);
  __webpack_require__(/*! ./show-hint.code-mirror */ "./lib/assets/javascripts/builder/components/code-mirror/show-hint.code-mirror.js")(CodeMirror);
  __webpack_require__(/*! ./hint/custom-list-hint */ "./lib/assets/javascripts/builder/components/code-mirror/hint/custom-list-hint.js")(CodeMirror);
  __webpack_require__(/*! ./searchcursor.code-mirror */ "./lib/assets/javascripts/builder/components/code-mirror/searchcursor.code-mirror.js")(CodeMirror);
  __webpack_require__(/*! ./placeholder.code-mirror */ "./lib/assets/javascripts/builder/components/code-mirror/placeholder.code-mirror.js")(CodeMirror);
  
  var ESCAPE_KEY_CODE = 27;
  var RETURN_KEY_CODE = 13;
  
  var NOHINT = [ESCAPE_KEY_CODE, RETURN_KEY_CODE];
  
  var ADDONS = {
    'color-picker': ColorPicker
  };
  
  module.exports = CoreView.extend({
    module: 'components:code-mirror:code-mirror-view',
  
    className: 'Editor-content',
  
    options: {
      readonly: false,
      lineNumbers: true,
      autocompleteChars: 3
    },
  
    initialize: function initialize(opts) {
      if (!opts) throw new Error('options for codemirror are required.');
      if (!opts.model) throw new Error('Model for codemirror is required.');
      if (opts.model.get('content') === void 0 && opts.placeholder === void 0) throw new Error('Content property or placeholder for codemirror is required.');
      if (!opts.tips) throw new Error('tip messages are required');
  
      this._autocompleteChars = opts.autocompleteChars || this.options.autocompleteChars;
      this._mode = opts.mode || 'cartocss';
      this._addons = opts.addons;
      this._hints = opts.hints;
      this._autocompletePrefix = opts.autocompletePrefix;
      this._autocompleteTriggers = opts.autocompleteTriggers;
      this._autocompleteSuffix = opts.autocompleteSuffix;
      this._errorTemplate = opts.errorTemplate || errorTemplate;
      this._warningTemplate = opts.warningTemplate || warningTemplate;
      this._warnings = null;
      this._tips = opts.tips;
      this._lineWithErrors = [];
      this._onInputRead = _.bind(this._onKeyUpEditor, this);
      this._placeholder = opts.placeholder;
    },
  
    render: function render() {
      this.$el.html(template({
        content: this.model.get('content'),
        tips: this._tips.join(' '),
        warnings: this._warnings
      }));
  
      this._initViews();
      this._bindEvents();
      this._showErrors();
      return this;
    },
  
    _initViews: function _initViews() {
      var options = _.defaults(_.extend({}, this.model.toJSON()), this.options);
  
      var isReadOnly = options.readonly;
      var hasLineNumbers = options.lineNumbers;
  
      var extraKeys = {
        'Ctrl-S': this.triggerApplyEvent.bind(this),
        'Cmd-S': this.triggerApplyEvent.bind(this),
        'Ctrl-Space': this._completeIfAfterCtrlSpace.bind(this)
      };
  
      this.editor = CodeMirror.fromTextArea(this.$('.js-editor').get(0), {
        lineNumbers: hasLineNumbers,
        theme: 'material',
        mode: this._mode,
        scrollbarStyle: 'simple',
        lineWrapping: true,
        readOnly: isReadOnly,
        extraKeys: extraKeys,
        placeholder: this._placeholder
      });
      this.editor.on('change', _.debounce(this._onCodeMirrorChange.bind(this), 150), this);
  
      if (!_.isEmpty(this._addons)) {
        _.each(this._addons, function (addon) {
          var Class = ADDONS[addon];
          var addonView = new Class({
            editor: this.editor
          });
          addonView.bind('codeSaved', this.triggerApplyEvent, this);
          this.$el.append(addonView.el);
          this.addView(addonView);
        }, this);
      }
  
      if (this._hints) {
        this.editor.on('keyup', this._onInputRead);
      }
  
      this._toggleReadOnly();
  
      setTimeout(function () {
        this.editor && this.editor.refresh();
      }.bind(this), 0);
    },
  
    _completeIfAfterCtrlSpace: function _completeIfAfterCtrlSpace(cm) {
      var autocompletePrefix = this._autocompletePrefix;
      var opts = {};
      var cur = cm.getCursor();
  
      if (autocompletePrefix && cm.getRange(CodeMirror.Pos(cur.line, cur.ch - autocompletePrefix.length), cur) !== autocompletePrefix) {
        opts = { autocompletePrefix: autocompletePrefix };
      }
  
      return this._completeAfter(cm, opts);
    },
  
    updateHints: function updateHints(hints) {
      this._hints = hints;
    },
  
    _onKeyUpEditor: function _onKeyUpEditor(cm, event) {
      var code = event.keyCode;
      var hints = this._hints;
      var autocompleteChars = this._autocompleteChars - 1;
      var autocompletePrefix = this._autocompletePrefix;
  
      if (NOHINT.indexOf(code) === -1) {
        var self = this;
  
        if (this._autocompleteTimeout) clearTimeout(this._autocompleteTimeout);
  
        this._autocompleteTimeout = setTimeout(function () {
          var opts = {};
          var cur = cm.getCursor();
          var str = cm.getTokenAt(cur).string;
          str = str.toLowerCase();
  
          if (autocompletePrefix && cm.getRange(CodeMirror.Pos(cur.line, cur.ch - autocompletePrefix.length), cur) !== autocompletePrefix) {
            opts = { autocompletePrefix: autocompletePrefix };
          }
  
          return self._completeAfter(cm, opts, function () {
            var autocompleteHandler = function autocompleteHandler(listItem) {
              // every list can be an array of strings or an array of objects {text, type}
              var hit = _.isObject(listItem) ? listItem.text : listItem;
              hit = hit.toLowerCase();
              return hit.indexOf(str) !== -1;
            };
  
            if (str.length > autocompleteChars) {
              var listHints = _.filter(hints, autocompleteHandler);
  
              return listHints.length > 0 || autocompletePrefix && autocompletePrefix === str;
            }
          });
        }, 150);
      }
    },
  
    _onCodeMirrorChange: function _onCodeMirrorChange() {
      this.trigger('codeChanged');
    },
  
    _completeAfter: function _completeAfter(cm, opts, pred) {
      if (!pred || pred()) {
        if (!cm.state.completionActive) {
          this._showAutocomplete(cm, _.extend({}, opts));
        }
      }
  
      return CodeMirror.Pass;
    },
  
    _showAutocomplete: function _showAutocomplete(cm, opts) {
      var autocompletePrefix = opts && opts.autocompletePrefix;
  
      CodeMirror.showHint(cm, CodeMirror.hint['custom-list'], {
        completeSingle: false,
        list: this._hints,
        autocompletePrefix: autocompletePrefix,
        autocompleteSuffix: this._autocompleteSuffix
      });
    },
  
    _showWarning: function _showWarning(warnings) {
      var $warning = this._getWarning();
      var hasNodes = $warning.children().length;
  
      if (warnings && !hasNodes) {
        $warning.append(this._warningTemplate(warnings));
      }
    },
  
    _hideWarning: function _hideWarning() {
      var $warning = this._getWarning();
      var hasNodes = $warning.children().length;
  
      if (hasNodes) {
        $warning.children()[0].remove();
      }
    },
  
    _bindEvents: function _bindEvents() {
      var self = this;
      this.editor.on('change', function (editor, changed) {
        var content = self.getContent();
        var dataService = self._containsDataService(content);
  
        if (dataService) {
          self._showWarning('Quota error ' + dataService);
        } else {
          self._hideWarning();
        }
  
        self.model.set('content', content, { silent: true });
      });
  
      this.model.on('change:content', function () {
        this.setContent(this.model.get('content'));
      }, this);
  
      this.model.on('change:readonly', this._toggleReadOnly, this);
  
      this.model.on('change:errors', function () {
        this._showErrors();
      }, this);
  
      this.model.on('undo redo', function () {
        this.setContent(this.model.get('content'));
      }, this);
    },
  
    _toggleReadOnly: function _toggleReadOnly() {
      var isReadOnly = !!this.model.get('readonly');
      this.editor.setOption('readOnly', isReadOnly);
      if (isReadOnly) {
        this.editor.setOption('theme', '');
        this._getInfo().hide();
      } else {
        this.editor.setOption('theme', 'material');
        this._getInfo().show();
      }
    },
  
    search: function search(query, caseInsensitive) {
      var cursor = this.editor.getSearchCursor(query, null, true);
      cursor.find();
      return cursor.pos;
    },
  
    markReadOnly: function markReadOnly(from, to) {
      var options = { readOnly: true, inclusiveLeft: true };
      this.editor.markText(from, to, options);
  
      for (var i = from.line; i <= to.line; i++) {
        this.editor.addLineClass(i, 'background', 'CodeMirror-readonlyLine');
      }
    },
  
    setContent: function setContent(value) {
      this.editor.setValue(value);
    },
  
    getContent: function getContent() {
      return this.editor.getValue();
    },
  
    triggerApplyEvent: function triggerApplyEvent() {
      this.trigger('codeSaved', this.getContent(), this);
    },
  
    destroyEditor: function destroyEditor() {
      this.editor.off('change');
      var el = this.editor.getWrapperElement();
      var parent = el.parentNode;
      parent && parent.removeChild(el);
      this.editor = null;
    },
  
    _getInfo: function _getInfo() {
      return this.$('.js-console');
    },
  
    _getConsole: function _getConsole() {
      return this.$('.js-console-error');
    },
  
    _getWarning: function _getWarning() {
      return this.$('.js-warning');
    },
  
    _getCode: function _getCode() {
      return this.$('.CodeMirror-code');
    },
  
    _containsDataService: function _containsDataService(content) {
      return _.find(DATA_SERVICES, function (dataService) {
        return content.indexOf(dataService) !== -1;
      });
    },
  
    _removeErrors: function _removeErrors() {
      this._getConsole().empty();
      _.each(this._lineWithErrors, function ($line) {
        $line.find('.CodeMirror-bullet').remove();
        $line.find('.CodeMirror-linenumber').removeClass('has-error');
      });
  
      this._lineWithErrors = [];
    },
  
    _showErrors: function _showErrors() {
      var errors = this.model.get('errors');
      this._removeErrors();
  
      if (errors && errors.length > 0) {
        _.each(errors, function (err) {
          this._renderError(err);
          this._renderBullet(err);
        }, this);
      }
    },
  
    _renderBullet: function _renderBullet(error) {
      var line = error.line;
      var $line;
      if (line) {
        $line = this._getCode().children().eq(+line - 1);
        $line.append(bulletTemplate);
        $line.find('.CodeMirror-linenumber').addClass('has-error');
        this._lineWithErrors.push($line);
      }
    },
  
    _renderError: function _renderError(error) {
      this._getConsole().append(this._errorTemplate(error));
    },
  
    clean: function clean() {
      this.destroyEditor();
      CoreView.prototype.clean.apply(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/code-mirror/colorpicker.code-mirror.js":
  /*!******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/code-mirror/colorpicker.code-mirror.js ***!
    \******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var ColorPicker = __webpack_require__(/*! builder/components/color-picker/color-picker.js */ "./lib/assets/javascripts/builder/components/color-picker/color-picker.js");
  var COLOR_KEYWORDS = __webpack_require__(/*! builder/helpers/color-keywords */ "./lib/assets/javascripts/builder/helpers/color-keywords.js");
  
  /**
   *  Show color picker when user clicks over
   *  a color in the Codemirror editor.
   *
   *  new CodemirrorColorPicker({
   *    editor: codemirror-editor...
   *  })
   */
  
  var REQUIRED_OPTS = ['editor'];
  
  var STYLE = _.template('1px solid  <%- color %>');
  var COLORPICKER_HEIGHT = 220;
  
  var stopPropagation = function stopPropagation(e) {
    e.stopPropagation();
  };
  
  module.exports = CoreView.extend({
    initialize: function initialize(opts) {
      _.each(REQUIRED_OPTS, function (item) {
        if (opts[item] === undefined) throw new Error(item + ' is required');
        this['_' + item] = opts[item];
      }, this);
  
      this._updateColors = _.debounce(this._updateColors, 5).bind(this);
      this._onDocumentClick = this._onDocumentClick.bind(this);
      this._editor = opts.editor;
      this._initBinds();
    },
  
    _initBinds: function _initBinds() {
      var self = this;
      var destroyPicker = function () {
        this._destroyPicker();
      }.bind(this);
  
      this._enableUpdateBind();
  
      this._editor.on('mousedown', function (cm, ev) {
        _.delay(self._onClick.bind(self, cm, ev), 50);
      });
  
      this._editor.on('keydown', destroyPicker);
      this._editor.on('viewportChange', destroyPicker);
      this._editor.on('scroll', destroyPicker);
  
      var wrapper = this._editor.getWrapperElement();
      wrapper.addEventListener('click', stopPropagation);
    },
  
    _disableBinds: function _disableBinds() {
      var wrapper = this._editor.getWrapperElement();
      wrapper.removeEventListener('click', stopPropagation);
      this._editor.off(null, null, this);
    },
  
    _enableUpdateBind: function _enableUpdateBind() {
      this._editor.on('update', this._updateColors);
    },
  
    _disableUpdateBind: function _disableUpdateBind() {
      this._editor.off('update', this._updateColors);
    },
  
    _onClick: function _onClick(cm, ev) {
      var cursor = this._editor.getCursor(true);
      var token = this._editor.getTokenAt(cursor);
  
      if (token.type === 'color') {
        this._createPicker(ev, cursor, token);
      } else {
        this._destroyPicker();
      }
    },
  
    _updateColors: function _updateColors(cm) {
      var wrapper = cm.getWrapperElement();
      _.each(wrapper.querySelectorAll('.cm-color'), function (node) {
        this._paintColor(node.textContent, node);
      }, this);
    },
  
    _replaceColor: function _replaceColor(color, target) {
      var cursor = this._editor.getCursor();
      var nameMatch = this._getMatch(cursor, 'name');
      var hexMatch = this._getMatch(cursor, 'hex');
      var match = nameMatch || hexMatch;
      var start;
      var end;
  
      if (match) {
        start = {
          line: cursor.line,
          ch: match.start
        };
        end = {
          line: cursor.line,
          ch: match.end
        };
  
        this._editor.replaceRange(color, start, end, 'paste');
  
        var wrapper = this._editor.getWrapperElement();
        _.each(wrapper.querySelectorAll('.cm-color'), function (node) {
          var nodeStyle = node.style;
          var nodeColor = node.innerText;
          if (!nodeStyle || !nodeStyle.borderBottom) {
            this._paintColor(nodeColor, node);
          }
        }, this);
      }
    },
  
    _paintColor: function _paintColor(color, target) {
      target.style.borderBottom = STYLE({ color: color });
    },
  
    _getMatch: function _getMatch(cursor, type) {
      if (!type) return;
      var re;
  
      switch (type.toLowerCase()) {
        case 'name':
          re = new RegExp(COLOR_KEYWORDS.join('|'), 'g');
          break;
        case 'hsl':
          re = /hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)/g;
          break;
        case 'rgb':
          re = /rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)/;
          break;
        case 'hex':
          re = /#[a-fA-F0-9]{3,6}/g;
          break;
        default:
          console.log('Invalid color match selection');
          return;
      }
  
      var line = this._editor.getLine(cursor.line);
      var match = re.exec(line);
  
      while (match) {
        var val = match[0];
        var len = val.length;
        var start = match.index;
        var end = match.index + len;
        if (cursor.ch >= start && cursor.ch <= end) {
          match = null;
          return {
            start: start,
            end: end,
            string: val
          };
        }
        match = re.exec(line);
      }
    },
  
    _createPicker: function _createPicker(ev, cursor, token) {
      var cursorCoords = this._editor.cursorCoords();
      this._destroyPicker();
  
      this._colorPicker = new ColorPicker({
        className: 'Editor-boxModal ColorPicker--cm Editor-boxModal--darked Editor-FormDialog CDB-Text',
        value: token.string,
        disableOpacity: true
      });
      this._colorPicker.$el.attr('data-colorpicker-cid', this.cid);
      this._colorPicker.bind('change', _.debounce(this._onColorPickerChange.bind(this, ev), 5), this);
  
      var top = cursorCoords.top + 20;
      var maxTop = $(window).outerHeight();
  
      if (top + COLORPICKER_HEIGHT > maxTop) {
        top = cursorCoords.top - COLORPICKER_HEIGHT - 20;
      }
  
      this._colorPicker.$el.css({
        left: cursorCoords.left,
        top: top
      });
  
      document.body.appendChild(this._colorPicker.render().el);
      document.addEventListener('click', this._onDocumentClick);
    },
  
    _onDocumentClick: function _onDocumentClick(e) {
      var $el = $(e.target);
      if ($el.closest('[data-colorpicker-cid="' + this.cid + '"]').length === 0) {
        this._destroyPicker();
      }
    },
  
    _onColorPickerChange: function _onColorPickerChange(ev, values) {
      this._disableUpdateBind();
      this._replaceColor(values.hex, ev.target);
      this.trigger('codeSaved');
      this._enableUpdateBind();
    },
  
    _destroyPicker: function _destroyPicker() {
      if (this._colorPicker) {
        this.removeView(this._colorPicker);
        this._colorPicker.clean();
        delete this._colorPicker;
      }
  
      document.removeEventListener('click', this._onDocumentClick);
    },
  
    clean: function clean() {
      this._disableBinds();
      CoreView.prototype.clean.call(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/code-mirror/data-services.js":
  /*!********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/code-mirror/data-services.js ***!
    \********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  module.exports = ['cdb_geocode_street_point', 'cdb_isodistance', 'cdb_isochrone', 'OBS_GetDemographicSnapshot', 'cdb_route_point_to_point', 'cdb_route_with_waypoints'];
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/code-mirror/hint/custom-list-hint.js":
  /*!****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/code-mirror/hint/custom-list-hint.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  module.exports = function (CodeMirror) {
    var Pos = CodeMirror.Pos;
  
    function arrayContains(arr, item) {
      return arr.indexOf(item) !== -1;
    }
  
    function scriptHint(editor, keywords, getToken, options) {
      // Find the token at the cursor
      var cur = editor.getCursor();
      var token = getToken(editor, cur);
      var tprop = token;
      var context = [];
      token.state = CodeMirror.innerMode(editor.getMode(), token.state).state;
  
      // If it's not a 'word-style' token, ignore the token.
      if (!/^[\w$_-]*$/.test(token.string)) {
        token = tprop = {
          start: cur.ch,
          end: cur.ch,
          string: '',
          state: token.state,
          type: token.string === '.' ? 'property' : null
        };
      }
      // If it is a property, find out what it is a property of.
      while (tprop.type === 'property') {
        tprop = getToken(editor, Pos(cur.line, tprop.start));
        if (tprop.string !== '.') return;
        tprop = getToken(editor, Pos(cur.line, tprop.start));
        if (tprop.string === ')') {
          var level = 1;
          do {
            tprop = getToken(editor, Pos(cur.line, tprop.start));
            switch (tprop.string) {
              case ')':
                level++;
                break;
              case '(':
                level--;
                break;
              default:
                break;
            }
          } while (level > 0);
          tprop = getToken(editor, Pos(cur.line, tprop.start));
          if (tprop.type.indexOf('variable') === 0) tprop.type = 'function';else return; // no clue
        }
        context.push(tprop);
      }
  
      return {
        list: getCompletions(token, context, keywords, options),
        from: Pos(cur.line, token.start),
        to: Pos(cur.line, token.end)
      };
    }
  
    function columnsHint(editor, options) {
      return scriptHint(editor, [], /* javascriptKeywords */
      function (e, cur) {
        return e.getTokenAt(cur);
      }, options);
    }
  
    CodeMirror.registerHelper('hint', 'custom-list', columnsHint);
  
    function getCompletions(token, context, keywords, options) {
      var found = [];
      var start = token.string.toLowerCase();
  
      function maybeAdd(str) {
        var hit = _.isObject(str) ? str.text : str;
        hit = hit.toLowerCase();
        if (hit.indexOf(start) === 0 && start !== hit && !arrayContains(found, hit)) {
          found.push(str);
        }
      }
  
      function gatherCompletions(obj) {
        for (var name in obj) {
          maybeAdd(obj[name]);
        }
      }
  
      gatherCompletions(options.list);
      _.each(keywords, maybeAdd);
  
      return found;
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/code-mirror/mode/mustache.js":
  /*!********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/code-mirror/mode/mustache.js ***!
    \********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  module.exports = function (CodeMirror) {
    CodeMirror.defineMode('mustache', function () {
      return {
        token: function token(stream, state) {
          var ch;
  
          if (stream.match('{{')) {
            ch = stream.peek();
            if (ch == null || ch != null && ch.match(/[{]{1,}/)) {
              stream.next();
              return 'mustache-error';
            } else if (ch != null && ch.match(/[a-zA-Z\u00C0-\u024F_]+/)) {
              return null;
            }
          }
  
          if (stream.match('}}')) {
            ch = stream.peek();
            if (ch != null && ch.match(/[}]{1,}/)) {
              stream.next();
              return 'mustache-error';
            } else if (ch == null) {
              return null;
            }
          }
  
          if (stream.match('}')) {
            ch = stream.peek();
            if (ch == null || ch != null && ch.match(/[}]{1,}/)) {
              stream.next();
              return 'mustache-error';
            }
          }
  
          if (stream.match('{')) {
            ch = stream.peek();
            if (ch == null || ch != null && ch.match(/[{]{1,}/)) {
              stream.next();
              return 'mustache-error';
            }
          }
  
          // Delimiter character
          if (stream.match(/[a-zA-Z\u00C0-\u024F_]+/, true)) {
            return 'mustache-text';
          }
  
          // jump to the next item, needed OR CRASH
          stream.next();
        }
      };
    });
  
    (function () {
      var sqlKeywords = '{{  }}';
  
      function set(str) {
        var obj = {};
        var words = str.split(' ');
        for (var i = 0; i < words.length; ++i) {
          obj[words[i]] = true;
        }return obj;
      }
  
      CodeMirror.defineMIME('text/mustache', {
        name: 'mustache',
        client: set('source'),
        keywords: set(sqlKeywords)
      });
    })();
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/code-mirror/mode/sql.js":
  /*!***************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/code-mirror/mode/sql.js ***!
    \***************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  // CodeMirror, copyright (c) by Marijn Haverbeke and others
  // Distributed under an MIT license: http://codemirror.net/LICENSE
  
  /* eslint-disable */
  module.exports = function (CodeMirror) {
    "use strict";
  
    CodeMirror.defineMode("sql", function (config, parserConfig) {
      "use strict";
  
      var client = parserConfig.client || {},
          atoms = parserConfig.atoms || { "false": true, "true": true, "null": true },
          builtin = parserConfig.builtin || {},
          keywords = parserConfig.keywords || {},
          operatorChars = parserConfig.operatorChars || /^[*+\-%<>!=&|~^]/,
          support = parserConfig.support || {},
          hooks = parserConfig.hooks || {},
          dateSQL = parserConfig.dateSQL || { "date": true, "time": true, "timestamp": true };
  
      function tokenBase(stream, state) {
        var ch = stream.next();
  
        // call hooks from the mime type
        if (hooks[ch]) {
          var result = hooks[ch](stream, state);
          if (result !== false) return result;
        }
  
        if (support.hexNumber == true && (ch == "0" && stream.match(/^[xX][0-9a-fA-F]+/) || (ch == "x" || ch == "X") && stream.match(/^'[0-9a-fA-F]+'/))) {
          // hex
          // ref: http://dev.mysql.com/doc/refman/5.5/en/hexadecimal-literals.html
          return "number";
        } else if (support.binaryNumber == true && ((ch == "b" || ch == "B") && stream.match(/^'[01]+'/) || ch == "0" && stream.match(/^b[01]+/))) {
          // bitstring
          // ref: http://dev.mysql.com/doc/refman/5.5/en/bit-field-literals.html
          return "number";
        } else if (ch.charCodeAt(0) > 47 && ch.charCodeAt(0) < 58) {
          // numbers
          // ref: http://dev.mysql.com/doc/refman/5.5/en/number-literals.html
          stream.match(/^[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/);
          support.decimallessFloat == true && stream.eat('.');
          return "number";
        } else if (ch == "?" && (stream.eatSpace() || stream.eol() || stream.eat(";"))) {
          // placeholders
          return "variable-3";
        } else if (ch == "'" || ch == '"' && support.doubleQuote) {
          // strings
          // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html
          state.tokenize = tokenLiteral(ch);
          return state.tokenize(stream, state);
        } else if ((support.nCharCast == true && (ch == "n" || ch == "N") || support.charsetCast == true && ch == "_" && stream.match(/[a-z][a-z0-9]*/i)) && (stream.peek() == "'" || stream.peek() == '"')) {
          // charset casting: _utf8'str', N'str', n'str'
          // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html
          return "keyword";
        } else if (/^[\(\),\;\[\]]/.test(ch)) {
          // no highlighting
          return null;
        } else if (support.commentSlashSlash && ch == "/" && stream.eat("/")) {
          // 1-line comment
          stream.skipToEnd();
          return "comment";
        } else if (support.commentHash && ch == "#" || ch == "-" && stream.eat("-") && (!support.commentSpaceRequired || stream.eat(" "))) {
          // 1-line comments
          // ref: https://kb.askmonty.org/en/comment-syntax/
          stream.skipToEnd();
          return "comment";
        } else if (ch == "/" && stream.eat("*")) {
          // multi-line comments
          // ref: https://kb.askmonty.org/en/comment-syntax/
          state.tokenize = tokenComment;
          return state.tokenize(stream, state);
        } else if (ch == ".") {
          // .1 for 0.1
          if (support.zerolessFloat == true && stream.match(/^(?:\d+(?:e[+-]?\d+)?)/i)) {
            return "number";
          }
          // .table_name (ODBC)
          // // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html
          if (support.ODBCdotTable == true && stream.match(/^[a-zA-Z_]+/)) {
            return "variable-2";
          }
        } else if (operatorChars.test(ch)) {
          // operators
          stream.eatWhile(operatorChars);
          return null;
        } else if (ch == '{' && (stream.match(/^( )*(d|D|t|T|ts|TS)( )*'[^']*'( )*}/) || stream.match(/^( )*(d|D|t|T|ts|TS)( )*"[^"]*"( )*}/))) {
          // dates (weird ODBC syntax)
          // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html
          return "number";
        } else {
          stream.eatWhile(/^[_\w\d]/);
          var word = stream.current().toLowerCase();
          // dates (standard SQL syntax)
          // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html
          if (dateSQL.hasOwnProperty(word) && (stream.match(/^( )+'[^']*'/) || stream.match(/^( )+"[^"]*"/))) return "number";
          if (atoms.hasOwnProperty(word)) return "atom";
          if (builtin.hasOwnProperty(word)) return "builtin";
          if (keywords.hasOwnProperty(word)) return "keyword";
          if (client.hasOwnProperty(word)) return "string-2";
          return null;
        }
      }
  
      // 'string', with char specified in quote escaped by '\'
      function tokenLiteral(quote) {
        return function (stream, state) {
          var escaped = false,
              ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && !escaped) {
              state.tokenize = tokenBase;
              break;
            }
            escaped = !escaped && ch == "\\";
          }
          return "string";
        };
      }
      function tokenComment(stream, state) {
        while (true) {
          if (stream.skipTo("*")) {
            stream.next();
            if (stream.eat("/")) {
              state.tokenize = tokenBase;
              break;
            }
          } else {
            stream.skipToEnd();
            break;
          }
        }
        return "comment";
      }
  
      function pushContext(stream, state, type) {
        state.context = {
          prev: state.context,
          indent: stream.indentation(),
          col: stream.column(),
          type: type
        };
      }
  
      function popContext(state) {
        state.indent = state.context.indent;
        state.context = state.context.prev;
      }
  
      return {
        startState: function startState() {
          return { tokenize: tokenBase, context: null };
        },
  
        token: function token(stream, state) {
          if (stream.sol()) {
            if (state.context && state.context.align == null) state.context.align = false;
          }
          if (stream.eatSpace()) return null;
  
          var style = state.tokenize(stream, state);
          if (style == "comment") return style;
  
          if (state.context && state.context.align == null) state.context.align = true;
  
          var tok = stream.current();
          if (tok == "(") pushContext(stream, state, ")");else if (tok == "[") pushContext(stream, state, "]");else if (state.context && state.context.type == tok) popContext(state);
          return style;
        },
  
        indent: function indent(state, textAfter) {
          var cx = state.context;
          if (!cx) return CodeMirror.Pass;
          var closing = textAfter.charAt(0) == cx.type;
          if (cx.align) return cx.col + (closing ? 0 : 1);else return cx.indent + (closing ? 0 : config.indentUnit);
        },
  
        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        lineComment: support.commentSlashSlash ? "//" : support.commentHash ? "#" : null
      };
    });
  
    (function () {
      "use strict";
  
      // `identifier`
  
      function hookIdentifier(stream) {
        // MySQL/MariaDB identifiers
        // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html
        var ch;
        while ((ch = stream.next()) != null) {
          if (ch == "`" && !stream.eat("`")) return "variable-2";
        }
        stream.backUp(stream.current().length - 1);
        return stream.eatWhile(/\w/) ? "variable-2" : null;
      }
  
      // variable token
      function hookVar(stream) {
        // variables
        // @@prefix.varName @varName
        // varName can be quoted with ` or ' or "
        // ref: http://dev.mysql.com/doc/refman/5.5/en/user-variables.html
        if (stream.eat("@")) {
          stream.match(/^session\./);
          stream.match(/^local\./);
          stream.match(/^global\./);
        }
  
        if (stream.eat("'")) {
          stream.match(/^.*'/);
          return "variable-2";
        } else if (stream.eat('"')) {
          stream.match(/^.*"/);
          return "variable-2";
        } else if (stream.eat("`")) {
          stream.match(/^.*`/);
          return "variable-2";
        } else if (stream.match(/^[0-9a-zA-Z$\.\_]+/)) {
          return "variable-2";
        }
        return null;
      };
  
      // short client keyword token
      function hookClient(stream) {
        // \N means NULL
        // ref: http://dev.mysql.com/doc/refman/5.5/en/null-values.html
        if (stream.eat("N")) {
          return "atom";
        }
        // \g, etc
        // ref: http://dev.mysql.com/doc/refman/5.5/en/mysql-commands.html
        return stream.match(/^[a-zA-Z.#!?]/) ? "variable-2" : null;
      }
  
      // these keywords are used by all SQL dialects (however, a mode can still overwrite it)
      var sqlKeywords = "alter and as asc between by count create delete desc distinct drop from group having in insert into is join like not on or order select set table union update values where limit ";
  
      // turn a space-separated list into an array
      function set(str) {
        var obj = {},
            words = str.split(" ");
        for (var i = 0; i < words.length; ++i) {
          obj[words[i]] = true;
        }return obj;
      }
  
      CodeMirror.defineMIME("text/x-pgsql", {
        name: "sql",
        client: set("source"),
        // http://www.postgresql.org/docs/9.5/static/sql-keywords-appendix.html
        keywords: set(sqlKeywords + "a abort abs absent absolute access according action ada add admin after aggregate all allocate also always analyse analyze any are array array_agg array_max_cardinality asensitive assertion assignment asymmetric at atomic attribute attributes authorization avg backward base64 before begin begin_frame begin_partition bernoulli binary bit_length blob blocked bom both breadth c cache call called cardinality cascade cascaded case cast catalog catalog_name ceil ceiling chain characteristics characters character_length character_set_catalog character_set_name character_set_schema char_length check checkpoint class class_origin clob close cluster coalesce cobol collate collation collation_catalog collation_name collation_schema collect column columns column_name command_function command_function_code comment comments commit committed concurrently condition condition_number configuration conflict connect connection connection_name constraint constraints constraint_catalog constraint_name constraint_schema constructor contains content continue control conversion convert copy corr corresponding cost covar_pop covar_samp cross csv cube cume_dist current current_catalog current_date current_default_transform_group current_path current_role current_row current_schema current_time current_timestamp current_transform_group_for_type current_user cursor cursor_name cycle data database datalink datetime_interval_code datetime_interval_precision day db deallocate dec declare default defaults deferrable deferred defined definer degree delimiter delimiters dense_rank depth deref derived describe descriptor deterministic diagnostics dictionary disable discard disconnect dispatch dlnewcopy dlpreviouscopy dlurlcomplete dlurlcompleteonly dlurlcompletewrite dlurlpath dlurlpathonly dlurlpathwrite dlurlscheme dlurlserver dlvalue do document domain dynamic dynamic_function dynamic_function_code each element else empty enable encoding encrypted end end-exec end_frame end_partition enforced enum equals escape event every except exception exclude excluding exclusive exec execute exists exp explain expression extension external extract false family fetch file filter final first first_value flag float floor following for force foreign fortran forward found frame_row free freeze fs full function functions fusion g general generated get global go goto grant granted greatest grouping groups handler header hex hierarchy hold hour id identity if ignore ilike immediate immediately immutable implementation implicit import including increment indent index indexes indicator inherit inherits initially inline inner inout input insensitive instance instantiable instead integrity intersect intersection invoker isnull isolation k key key_member key_type label lag language large last last_value lateral lead leading leakproof least left length level library like_regex link listen ln load local localtime localtimestamp location locator lock locked logged lower m map mapping match matched materialized max maxvalue max_cardinality member merge message_length message_octet_length message_text method min minute minvalue mod mode modifies module month more move multiset mumps name names namespace national natural nchar nclob nesting new next nfc nfd nfkc nfkd nil no none normalize normalized nothing notify notnull nowait nth_value ntile null nullable nullif nulls number object occurrences_regex octets octet_length of off offset oids old only open operator option options ordering ordinality others out outer output over overlaps overlay overriding owned owner p pad parameter parameter_mode parameter_name parameter_ordinal_position parameter_specific_catalog parameter_specific_name parameter_specific_schema parser partial partition pascal passing passthrough password percent percentile_cont percentile_disc percent_rank period permission placing plans pli policy portion position position_regex power precedes preceding prepare prepared preserve primary prior privileges procedural procedure program public quote range rank read reads reassign recheck recovery recursive ref references referencing refresh regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy regr_syy reindex relative release rename repeatable replace replica requiring reset respect restart restore restrict result return returned_cardinality returned_length returned_octet_length returned_sqlstate returning returns revoke right role rollback rollup routine routine_catalog routine_name routine_schema row rows row_count row_number rule savepoint scale schema schema_name scope scope_catalog scope_name scope_schema scroll search second section security selective self sensitive sequence sequences serializable server server_name session session_user setof sets share show similar simple size skip snapshot some source space specific specifictype specific_name sql sqlcode sqlerror sqlexception sqlstate sqlwarning sqrt stable standalone start state statement static statistics stddev_pop stddev_samp stdin stdout storage strict strip structure style subclass_origin submultiset substring substring_regex succeeds sum symmetric sysid system system_time system_user t tables tablesample tablespace table_name temp template temporary then ties timezone_hour timezone_minute to token top_level_count trailing transaction transactions_committed transactions_rolled_back transaction_active transform transforms translate translate_regex translation treat trigger trigger_catalog trigger_name trigger_schema trim trim_array true truncate trusted type types uescape unbounded uncommitted under unencrypted unique unknown unlink unlisten unlogged unnamed unnest until untyped upper uri usage user user_defined_type_catalog user_defined_type_code user_defined_type_name user_defined_type_schema using vacuum valid validate validator value value_of varbinary variadic var_pop var_samp verbose version versioning view views volatile when whenever whitespace width_bucket window within work wrapper write xmlagg xmlattributes xmlbinary xmlcast xmlcomment xmlconcat xmldeclaration xmldocument xmlelement xmlexists xmlforest xmliterate xmlnamespaces xmlparse xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltext xmlvalidate year yes loop repeat"),
        // http://www.postgresql.org/docs/9.5/static/datatype.html
        builtin: set("bigint int8 bigserial serial8 bit varying varbit boolean bool box bytea character char varchar cidr circle date double precision float8 inet integer int int4 interval json jsonb line lseg macaddr money numeric decimal path pg_lsn point polygon real float4 smallint int2 smallserial serial2 serial serial4 text time without zone with timetz timestamp timestamptz tsquery tsvector txid_snapshot uuid xml"),
        atoms: set("false true null unknown"),
        operatorChars: /^[*+\-%<>!=&|^]/,
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber nCharCast charsetCast commentHash commentSpaceRequired")
      });
    })();
  };
  
  /* eslint-enable */
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/code-mirror/placeholder.code-mirror.js":
  /*!******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/code-mirror/placeholder.code-mirror.js ***!
    \******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  // CodeMirror, copyright (c) by Marijn Haverbeke and others
  // Distributed under an MIT license: http://codemirror.net/LICENSE
  
  /* eslint-disable */
  module.exports = function (CodeMirror) {
    CodeMirror.defineOption("placeholder", "", function (cm, val, old) {
      var prev = old && old != CodeMirror.Init;
      if (val && !prev) {
        cm.on("blur", onBlur);
        cm.on("change", onChange);
        cm.on("swapDoc", onChange);
        onChange(cm);
      } else if (!val && prev) {
        cm.off("blur", onBlur);
        cm.off("change", onChange);
        cm.off("swapDoc", onChange);
        clearPlaceholder(cm);
        var wrapper = cm.getWrapperElement();
        wrapper.className = wrapper.className.replace(" CodeMirror-empty", "");
      }
  
      if (val && !cm.hasFocus()) onBlur(cm);
    });
  
    function clearPlaceholder(cm) {
      if (cm.state.placeholder) {
        cm.state.placeholder.parentNode.removeChild(cm.state.placeholder);
        cm.state.placeholder = null;
      }
    }
    function setPlaceholder(cm) {
      clearPlaceholder(cm);
      var elt = cm.state.placeholder = document.createElement("pre");
      elt.style.cssText = "height: 0; overflow: visible";
      elt.className = "CodeMirror-placeholder";
      var placeHolder = cm.getOption("placeholder");
      if (typeof placeHolder == "string") placeHolder = document.createTextNode(placeHolder);
      elt.appendChild(placeHolder);
      cm.display.lineSpace.insertBefore(elt, cm.display.lineSpace.firstChild);
    }
  
    function onBlur(cm) {
      if (isEmpty(cm)) setPlaceholder(cm);
    }
    function onChange(cm) {
      var wrapper = cm.getWrapperElement(),
          empty = isEmpty(cm);
      wrapper.className = wrapper.className.replace(" CodeMirror-empty", "") + (empty ? " CodeMirror-empty" : "");
  
      if (empty) setPlaceholder(cm);else clearPlaceholder(cm);
    }
  
    function isEmpty(cm) {
      return cm.lineCount() === 1 && cm.getLine(0) === "";
    }
  };
  /* eslint-enable */
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/code-mirror/scroll.code-mirror.js":
  /*!*************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/code-mirror/scroll.code-mirror.js ***!
    \*************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  // CodeMirror, copyright (c) by Marijn Haverbeke and others
  // Distributed under an MIT license: http://codemirror.net/LICENSE
  
  module.exports = function (CodeMirror) {
    function Bar(cls, orientation, scroll) {
      this.orientation = orientation;
      this.scroll = scroll;
      this.screen = this.total = this.size = 1;
      this.pos = 0;
  
      this.node = document.createElement('div');
      this.node.className = cls + '-' + orientation;
      this.inner = this.node.appendChild(document.createElement('div'));
  
      var self = this;
      CodeMirror.on(this.inner, 'mousedown', function (e) {
        if (e.which !== 1) return;
        CodeMirror.e_preventDefault(e);
        var axis = self.orientation === 'horizontal' ? 'pageX' : 'pageY';
        var start = e[axis];
        var startpos = self.pos;
        function done() {
          CodeMirror.off(document, 'mousemove', move);
          CodeMirror.off(document, 'mouseup', done);
        }
        function move(e) {
          if (e.which !== 1) return done();
          self.moveTo(startpos + (e[axis] - start) * (self.total / self.size));
        }
        CodeMirror.on(document, 'mousemove', move);
        CodeMirror.on(document, 'mouseup', done);
      });
  
      CodeMirror.on(this.node, 'click', function (e) {
        CodeMirror.e_preventDefault(e);
        var innerBox = self.inner.getBoundingClientRect();
        var where;
        if (self.orientation === 'horizontal') {
          where = e.clientX < innerBox.left ? -1 : e.clientX > innerBox.right ? 1 : 0;
        } else {
          where = e.clientY < innerBox.top ? -1 : e.clientY > innerBox.bottom ? 1 : 0;
        }
        self.moveTo(self.pos + where * self.screen);
      });
  
      function onWheel(e) {
        var moved = CodeMirror.wheelEventPixels(e)[self.orientation === 'horizontal' ? 'x' : 'y'];
        var oldPos = self.pos;
        self.moveTo(self.pos + moved);
        if (self.pos !== oldPos) {
          CodeMirror.e_preventDefault(e);
        }
      }
      CodeMirror.on(this.node, 'mousewheel', onWheel);
      CodeMirror.on(this.node, 'DOMMouseScroll', onWheel);
    }
  
    Bar.prototype.setPos = function (pos, force) {
      if (pos < 0) pos = 0;
      if (pos > this.total - this.screen) pos = this.total - this.screen;
      if (!force && pos === this.pos) return false;
      this.pos = pos;
      this.inner.style[this.orientation === 'horizontal' ? 'left' : 'top'] = pos * (this.size / this.total) + 'px';
      return true;
    };
  
    Bar.prototype.moveTo = function (pos) {
      if (this.setPos(pos)) this.scroll(pos, this.orientation);
    };
  
    var minButtonSize = 10;
  
    Bar.prototype.update = function (scrollSize, clientSize, barSize) {
      var sizeChanged = this.screen !== clientSize || this.total !== scrollSize || this.size !== barSize;
      if (sizeChanged) {
        this.screen = clientSize;
        this.total = scrollSize;
        this.size = barSize;
      }
  
      var buttonSize = this.screen * (this.size / this.total);
      if (buttonSize < minButtonSize) {
        this.size -= minButtonSize - buttonSize;
        buttonSize = minButtonSize;
      }
      this.inner.style[this.orientation === 'horizontal' ? 'width' : 'height'] = buttonSize + 'px';
      this.setPos(this.pos, sizeChanged);
    };
  
    function SimpleScrollbars(cls, place, scroll) {
      this.addClass = cls;
      this.horiz = new Bar(cls, 'horizontal', scroll);
      place(this.horiz.node);
      this.vert = new Bar(cls, 'vertical', scroll);
      place(this.vert.node);
      this.width = null;
    }
  
    SimpleScrollbars.prototype.update = function (measure) {
      if (this.width == null) {
        var style = window.getComputedStyle ? window.getComputedStyle(this.horiz.node) : this.horiz.node.currentStyle;
        if (style) {
          this.width = parseInt(style.height, 10);
        }
      }
      var width = this.width || 0;
  
      var needsH = measure.scrollWidth > measure.clientWidth + 1;
      var needsV = measure.scrollHeight > measure.clientHeight + 1;
      this.vert.node.style.display = needsV ? 'block' : 'none';
      this.horiz.node.style.display = needsH ? 'block' : 'none';
  
      if (needsV) {
        this.vert.update(measure.scrollHeight, measure.clientHeight, measure.viewHeight - (needsH ? width : 0));
        this.vert.node.style.bottom = needsH ? width + 'px' : '0';
      }
      if (needsH) {
        this.horiz.update(measure.scrollWidth, measure.clientWidth, measure.viewWidth - (needsV ? width : 0) - measure.barLeft);
        this.horiz.node.style.right = needsV ? width + 'px' : '0';
        this.horiz.node.style.left = measure.barLeft + 'px';
      }
  
      return { right: needsV ? width : 0, bottom: needsH ? width : 0 };
    };
  
    SimpleScrollbars.prototype.setScrollTop = function (pos) {
      this.vert.setPos(pos);
    };
  
    SimpleScrollbars.prototype.setScrollLeft = function (pos) {
      this.horiz.setPos(pos);
    };
  
    SimpleScrollbars.prototype.clear = function () {
      var parent = this.horiz.node.parentNode;
      parent.removeChild(this.horiz.node);
      parent.removeChild(this.vert.node);
    };
  
    CodeMirror.scrollbarModel.simple = function (place, scroll) {
      return new SimpleScrollbars('CodeMirror-simplescroll', place, scroll);
    };
  
    CodeMirror.scrollbarModel.overlay = function (place, scroll) {
      return new SimpleScrollbars('CodeMirror-overlayscroll', place, scroll);
    };
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/code-mirror/searchcursor.code-mirror.js":
  /*!*******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/code-mirror/searchcursor.code-mirror.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  // CodeMirror, copyright (c) by Marijn Haverbeke and others
  // Distributed under an MIT license: http://codemirror.net/LICENSE
  
  module.exports = function (CodeMirror) {
    /*eslint-disable */
    var Pos = CodeMirror.Pos;
  
    function SearchCursor(doc, query, pos, caseFold) {
      this.atOccurrence = false;this.doc = doc;
      if (caseFold == null && typeof query == "string") caseFold = false;
  
      pos = pos ? doc.clipPos(pos) : Pos(0, 0);
      this.pos = { from: pos, to: pos };
  
      // The matches method is filled in based on the type of query.
      // It takes a position and a direction, and returns an object
      // describing the next occurrence of the query, or null if no
      // more matches were found.
      if (typeof query != "string") {
        // Regexp match
        if (!query.global) query = new RegExp(query.source, query.ignoreCase ? "ig" : "g");
        this.matches = function (reverse, pos) {
          if (reverse) {
            query.lastIndex = 0;
            var line = doc.getLine(pos.line).slice(0, pos.ch),
                cutOff = 0,
                match,
                start;
            for (;;) {
              query.lastIndex = cutOff;
              var newMatch = query.exec(line);
              if (!newMatch) break;
              match = newMatch;
              start = match.index;
              cutOff = match.index + (match[0].length || 1);
              if (cutOff == line.length) break;
            }
            var matchLen = match && match[0].length || 0;
            if (!matchLen) {
              if (start == 0 && line.length == 0) {
                match = undefined;
              } else if (start != doc.getLine(pos.line).length) {
                matchLen++;
              }
            }
          } else {
            query.lastIndex = pos.ch;
            var line = doc.getLine(pos.line),
                match = query.exec(line);
            var matchLen = match && match[0].length || 0;
            var start = match && match.index;
            if (start + matchLen != line.length && !matchLen) matchLen = 1;
          }
          if (match && matchLen) return { from: Pos(pos.line, start),
            to: Pos(pos.line, start + matchLen),
            match: match };
        };
      } else {
        // String query
        var origQuery = query;
        if (caseFold) query = query.toLowerCase();
        var fold = caseFold ? function (str) {
          return str.toLowerCase();
        } : function (str) {
          return str;
        };
        var target = query.split("\n");
        // Different methods for single-line and multi-line queries
        if (target.length == 1) {
          if (!query.length) {
            // Empty string would match anything and never progress, so
            // we define it to match nothing instead.
            this.matches = function () {};
          } else {
            this.matches = function (reverse, pos) {
              if (reverse) {
                var orig = doc.getLine(pos.line).slice(0, pos.ch),
                    line = fold(orig);
                var match = line.lastIndexOf(query);
                if (match > -1) {
                  match = adjustPos(orig, line, match);
                  return { from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length) };
                }
              } else {
                var orig = doc.getLine(pos.line).slice(pos.ch),
                    line = fold(orig);
                var match = line.indexOf(query);
                if (match > -1) {
                  match = adjustPos(orig, line, match) + pos.ch;
                  return { from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length) };
                }
              }
            };
          }
        } else {
          var origTarget = origQuery.split("\n");
          this.matches = function (reverse, pos) {
            var last = target.length - 1;
            if (reverse) {
              if (pos.line - (target.length - 1) < doc.firstLine()) return;
              if (fold(doc.getLine(pos.line).slice(0, origTarget[last].length)) != target[target.length - 1]) return;
              var to = Pos(pos.line, origTarget[last].length);
              for (var ln = pos.line - 1, i = last - 1; i >= 1; --i, --ln) {
                if (target[i] != fold(doc.getLine(ln))) return;
              }var line = doc.getLine(ln),
                  cut = line.length - origTarget[0].length;
              if (fold(line.slice(cut)) != target[0]) return;
              return { from: Pos(ln, cut), to: to };
            } else {
              if (pos.line + (target.length - 1) > doc.lastLine()) return;
              var line = doc.getLine(pos.line),
                  cut = line.length - origTarget[0].length;
              if (fold(line.slice(cut)) != target[0]) return;
              var from = Pos(pos.line, cut);
              for (var ln = pos.line + 1, i = 1; i < last; ++i, ++ln) {
                if (target[i] != fold(doc.getLine(ln))) return;
              }if (fold(doc.getLine(ln).slice(0, origTarget[last].length)) != target[last]) return;
              return { from: from, to: Pos(ln, origTarget[last].length) };
            }
          };
        }
      }
    }
  
    SearchCursor.prototype = {
      findNext: function findNext() {
        return this.find(false);
      },
      findPrevious: function findPrevious() {
        return this.find(true);
      },
  
      find: function find(reverse) {
        var self = this,
            pos = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);
        function savePosAndFail(line) {
          var pos = Pos(line, 0);
          self.pos = { from: pos, to: pos };
          self.atOccurrence = false;
          return false;
        }
  
        for (;;) {
          if (this.pos = this.matches(reverse, pos)) {
            this.atOccurrence = true;
            return this.pos.match || true;
          }
          if (reverse) {
            if (!pos.line) return savePosAndFail(0);
            pos = Pos(pos.line - 1, this.doc.getLine(pos.line - 1).length);
          } else {
            var maxLine = this.doc.lineCount();
            if (pos.line == maxLine - 1) return savePosAndFail(maxLine);
            pos = Pos(pos.line + 1, 0);
          }
        }
      },
  
      from: function from() {
        if (this.atOccurrence) return this.pos.from;
      },
      to: function to() {
        if (this.atOccurrence) return this.pos.to;
      },
  
      replace: function replace(newText, origin) {
        if (!this.atOccurrence) return;
        var lines = CodeMirror.splitLines(newText);
        this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);
        this.pos.to = Pos(this.pos.from.line + lines.length - 1, lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));
      }
    };
  
    // Maps a position in a case-folded line back to a position in the original line
    // (compensating for codepoints increasing in number during folding)
    function adjustPos(orig, folded, pos) {
      if (orig.length == folded.length) return pos;
      for (var pos1 = Math.min(pos, orig.length);;) {
        var len1 = orig.slice(0, pos1).toLowerCase().length;
        if (len1 < pos) ++pos1;else if (len1 > pos) --pos1;else return pos1;
      }
    }
  
    CodeMirror.defineExtension("getSearchCursor", function (query, pos, caseFold) {
      return new SearchCursor(this.doc, query, pos, caseFold);
    });
    CodeMirror.defineDocExtension("getSearchCursor", function (query, pos, caseFold) {
      return new SearchCursor(this, query, pos, caseFold);
    });
  
    CodeMirror.defineExtension("selectMatches", function (query, caseFold) {
      var ranges = [];
      var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);
      while (cur.findNext()) {
        if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0) break;
        ranges.push({ anchor: cur.from(), head: cur.to() });
      }
      if (ranges.length) this.setSelections(ranges, 0);
    });
    /* eslint-enable */
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/code-mirror/show-hint.code-mirror.js":
  /*!****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/code-mirror/show-hint.code-mirror.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  // CodeMirror, copyright (c) by Marijn Haverbeke and others
  // Distributed under an MIT license: http://codemirror.net/LICENSE
  
  /* eslint-disable */
  module.exports = function (CodeMirror) {
    "use strict";
  
    var HINT_ELEMENT_CLASS = "CodeMirror-hint";
    var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";
  
    // This is the old interface, kept around for now to stay
    // backwards-compatible.
    CodeMirror.showHint = function (cm, getHints, options) {
      if (!getHints) return cm.showHint(options);
      if (options && options.async) getHints.async = true;
      var newOpts = { hint: getHints };
      if (options) for (var prop in options) {
        newOpts[prop] = options[prop];
      }return cm.showHint(newOpts);
    };
  
    CodeMirror.defineExtension("showHint", function (options) {
      options = parseOptions(this, this.getCursor("start"), options);
      var selections = this.listSelections();
      if (selections.length > 1) return;
      // By default, don't allow completion when something is selected.
      // A hint function can have a `supportsSelection` property to
      // indicate that it can handle selections.
      if (this.somethingSelected()) {
        if (!options.hint.supportsSelection) return;
        // Don't try with cross-line selections
        for (var i = 0; i < selections.length; i++) {
          if (selections[i].head.line != selections[i].anchor.line) return;
        }
      }
  
      if (this.state.completionActive) this.state.completionActive.close();
      var completion = this.state.completionActive = new Completion(this, options);
      if (!completion.options.hint) return;
  
      CodeMirror.signal(this, "startCompletion", this);
      completion.update(true);
    });
  
    function Completion(cm, options) {
      this.cm = cm;
      this.options = options;
      this.widget = null;
      this.debounce = 0;
      this.tick = 0;
      this.startPos = this.cm.getCursor("start");
      this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;
  
      var self = this;
      cm.on("cursorActivity", this.activityFunc = function () {
        self.cursorActivity();
      });
    }
  
    var requestAnimationFrame = window.requestAnimationFrame || function (fn) {
      return setTimeout(fn, 1000 / 60);
    };
    var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;
  
    Completion.prototype = {
      close: function close() {
        if (!this.active()) return;
        this.cm.state.completionActive = null;
        this.tick = null;
        this.cm.off("cursorActivity", this.activityFunc);
  
        if (this.widget && this.data) CodeMirror.signal(this.data, "close");
        if (this.widget) this.widget.close();
        CodeMirror.signal(this.cm, "endCompletion", this.cm);
      },
  
      active: function active() {
        return this.cm.state.completionActive == this;
      },
  
      pick: function pick(data, i) {
        var completion = data.list[i];
        if (completion.hint) completion.hint(this.cm, data, completion);else this.cm.replaceRange(getText(completion, this.options), completion.from || data.from, completion.to || data.to, "complete");
        CodeMirror.signal(data, "pick", completion);
        this.close();
      },
  
      cursorActivity: function cursorActivity() {
        if (this.debounce) {
          cancelAnimationFrame(this.debounce);
          this.debounce = 0;
        }
  
        var pos = this.cm.getCursor(),
            line = this.cm.getLine(pos.line);
        if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch || pos.ch < this.startPos.ch || this.cm.somethingSelected() || pos.ch && this.options.closeCharacters.test(line.charAt(pos.ch - 1))) {
          this.close();
        } else {
          var self = this;
          this.debounce = requestAnimationFrame(function () {
            self.update();
          });
          if (this.widget) this.widget.disable();
        }
      },
  
      update: function update(first) {
        if (this.tick == null) return;
        var self = this,
            myTick = ++this.tick;
        fetchHints(this.options.hint, this.cm, this.options, function (data) {
          if (self.tick == myTick) self.finishUpdate(data, first);
        });
      },
  
      finishUpdate: function finishUpdate(data, first) {
        if (this.data) CodeMirror.signal(this.data, "update");
  
        var picked = this.widget && this.widget.picked || first && this.options.completeSingle;
        if (this.widget) this.widget.close();
  
        if (data && this.data && isNewCompletion(this.data, data)) return;
        this.data = data;
  
        if (data && data.list.length) {
          if (picked && data.list.length == 1) {
            this.pick(data, 0);
          } else {
            this.widget = new Widget(this, data);
            CodeMirror.signal(data, "shown");
          }
        }
      }
    };
  
    function isNewCompletion(old, nw) {
      var moved = CodeMirror.cmpPos(nw.from, old.from);
      return moved > 0 && old.to.ch - old.from.ch != nw.to.ch - nw.from.ch;
    }
  
    function parseOptions(cm, pos, options) {
      var editor = cm.options.hintOptions;
      var out = {};
      for (var prop in defaultOptions) {
        out[prop] = defaultOptions[prop];
      }if (editor) for (var prop in editor) {
        if (editor[prop] !== undefined) out[prop] = editor[prop];
      }if (options) for (var prop in options) {
        if (options[prop] !== undefined) out[prop] = options[prop];
      }if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos);
      return out;
    }
  
    function getText(completion, options) {
      var autocompleteSuffix = options && options.autocompleteSuffix ? options.autocompleteSuffix : '';
      var autocompletePrefix = options && options.autocompletePrefix ? options.autocompletePrefix : '';
  
      if (typeof completion !== "string") {
        completion = completion.text;
      }
  
      return autocompletePrefix + completion + autocompleteSuffix;
    }
  
    function getType(completion) {
      if (typeof completion == "string") return '';else return completion.type;
    }
  
    function buildKeyMap(completion, handle) {
      var baseMap = {
        Up: function Up() {
          handle.moveFocus(-1);
        },
        Down: function Down() {
          handle.moveFocus(1);
        },
        PageUp: function PageUp() {
          handle.moveFocus(-handle.menuSize() + 1, true);
        },
        PageDown: function PageDown() {
          handle.moveFocus(handle.menuSize() - 1, true);
        },
        Home: function Home() {
          handle.setFocus(0);
        },
        End: function End() {
          handle.setFocus(handle.length - 1);
        },
        Enter: handle.pick,
        Tab: handle.pick,
        Esc: handle.close
      };
      var custom = completion.options.customKeys;
      var ourMap = custom ? {} : baseMap;
      function addBinding(key, val) {
        var bound;
        if (typeof val != "string") bound = function bound(cm) {
          return val(cm, handle);
        };
        // This mechanism is deprecated
        else if (baseMap.hasOwnProperty(val)) bound = baseMap[val];else bound = val;
        ourMap[key] = bound;
      }
      if (custom) for (var key in custom) {
        if (custom.hasOwnProperty(key)) addBinding(key, custom[key]);
      }var extra = completion.options.extraKeys;
      if (extra) for (var key in extra) {
        if (extra.hasOwnProperty(key)) addBinding(key, extra[key]);
      }return ourMap;
    }
  
    function getHintElement(hintsElement, el) {
      while (el && el != hintsElement) {
        if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el;
        el = el.parentNode;
      }
    }
  
    function styleHint(hint) {
      var element = document.createElement(hint.displayText || getText(hint));
      element = document.createElement("span");
      element.className = 'CDB-Size-small has-letter';
      element.innerHTML = hint.displayText || getText(hint);
  
      var type = getType(hint);
      if (type) {
        element.className = 'CDB-Size-small has-letter';
        element.dataset.type = type;
      }
  
      return element;
    }
  
    function Widget(completion, data) {
      this.completion = completion;
      this.data = data;
      this.picked = false;
      var widget = this,
          cm = completion.cm;
  
      var hints = this.hints = document.createElement("ul");
      hints.className = "CodeMirror-hints";
      this.selectedHint = data.selectedHint || 0;
  
      var element;
      var completions = data.list;
      for (var i = 0; i < completions.length; ++i) {
        var elt = hints.appendChild(document.createElement("li")),
            cur = completions[i];
        var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
        if (cur.className != null) className = cur.className + " " + className;
        elt.className = className;
        if (cur.render) cur.render(elt, data, cur);else {
          element = styleHint(cur);
          elt.appendChild(element);
        }
  
        elt.hintId = i;
      }
  
      var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
      var left = pos.left,
          top = pos.bottom,
          below = true;
      hints.style.left = left + "px";
      hints.style.top = top + "px";
      // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
      var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);
      var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);
      (completion.options.container || document.body).appendChild(hints);
      var box = hints.getBoundingClientRect(),
          overlapY = box.bottom - winH;
      if (overlapY > 0) {
        var height = box.bottom - box.top,
            curTop = pos.top - (pos.bottom - box.top);
        if (curTop - height > 0) {
          // Fits above cursor
          hints.style.top = (top = pos.top - height) + "px";
          below = false;
        } else if (height > winH) {
          hints.style.height = winH - 5 + "px";
          hints.style.top = (top = pos.bottom - box.top) + "px";
          var cursor = cm.getCursor();
          if (data.from.ch != cursor.ch) {
            pos = cm.cursorCoords(cursor);
            hints.style.left = (left = pos.left) + "px";
            box = hints.getBoundingClientRect();
          }
        }
      }
      var overlapX = box.right - winW;
      if (overlapX > 0) {
        if (box.right - box.left > winW) {
          hints.style.width = winW - 5 + "px";
          overlapX -= box.right - box.left - winW;
        }
        hints.style.left = (left = pos.left - overlapX) + "px";
      }
  
      cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
        moveFocus: function moveFocus(n, avoidWrap) {
          widget.changeActive(widget.selectedHint + n, avoidWrap);
        },
        setFocus: function setFocus(n) {
          widget.changeActive(n);
        },
        menuSize: function menuSize() {
          return widget.screenAmount();
        },
        length: completions.length,
        close: function close() {
          completion.close();
        },
        pick: function pick() {
          widget.pick();
        },
        data: data
      }));
  
      if (completion.options.closeOnUnfocus) {
        var closingOnBlur;
        cm.on("blur", this.onBlur = function () {
          closingOnBlur = setTimeout(function () {
            completion.close();
          }, 100);
        });
        cm.on("focus", this.onFocus = function () {
          clearTimeout(closingOnBlur);
        });
      }
  
      var startScroll = cm.getScrollInfo();
      cm.on("scroll", this.onScroll = function () {
        var curScroll = cm.getScrollInfo(),
            editor = cm.getWrapperElement().getBoundingClientRect();
        var newTop = top + startScroll.top - curScroll.top;
        var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);
        if (!below) point += hints.offsetHeight;
        if (point <= editor.top || point >= editor.bottom) return completion.close();
        hints.style.top = newTop + "px";
        hints.style.left = left + startScroll.left - curScroll.left + "px";
      });
  
      CodeMirror.on(hints, "dblclick", function (e) {
        var t = getHintElement(hints, e.target || e.srcElement);
        if (t && t.hintId != null) {
          widget.changeActive(t.hintId);widget.pick();
        }
      });
  
      CodeMirror.on(hints, "click", function (e) {
        var t = getHintElement(hints, e.target || e.srcElement);
        if (t && t.hintId != null) {
          widget.changeActive(t.hintId);
          if (completion.options.completeOnSingleClick) widget.pick();
        }
      });
  
      CodeMirror.on(hints, "mousedown", function () {
        setTimeout(function () {
          cm.focus();
        }, 20);
      });
  
      CodeMirror.signal(data, "select", completions[0], hints.firstChild);
      return true;
    }
  
    Widget.prototype = {
      close: function close() {
        if (this.completion.widget != this) return;
        this.completion.widget = null;
        this.hints.parentNode.removeChild(this.hints);
        this.completion.cm.removeKeyMap(this.keyMap);
  
        var cm = this.completion.cm;
        if (this.completion.options.closeOnUnfocus) {
          cm.off("blur", this.onBlur);
          cm.off("focus", this.onFocus);
        }
        cm.off("scroll", this.onScroll);
      },
  
      disable: function disable() {
        this.completion.cm.removeKeyMap(this.keyMap);
        var widget = this;
        this.keyMap = { Enter: function Enter() {
            widget.picked = true;
          } };
        this.completion.cm.addKeyMap(this.keyMap);
      },
  
      pick: function pick() {
        this.completion.pick(this.data, this.selectedHint);
      },
  
      changeActive: function changeActive(i, avoidWrap) {
        if (i >= this.data.list.length) i = avoidWrap ? this.data.list.length - 1 : 0;else if (i < 0) i = avoidWrap ? 0 : this.data.list.length - 1;
        if (this.selectedHint == i) return;
        var node = this.hints.childNodes[this.selectedHint];
        node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
        node = this.hints.childNodes[this.selectedHint = i];
        node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
        if (node.offsetTop < this.hints.scrollTop) this.hints.scrollTop = node.offsetTop - 3;else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight) this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;
        CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);
      },
  
      screenAmount: function screenAmount() {
        return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
      }
    };
  
    function applicableHelpers(cm, helpers) {
      if (!cm.somethingSelected()) return helpers;
      var result = [];
      for (var i = 0; i < helpers.length; i++) {
        if (helpers[i].supportsSelection) result.push(helpers[i]);
      }return result;
    }
  
    function fetchHints(hint, cm, options, callback) {
      if (hint.async) {
        hint(cm, callback, options);
      } else {
        var result = hint(cm, options);
        if (result && result.then) result.then(callback);else callback(result);
      }
    }
  
    function resolveAutoHints(cm, pos) {
      var helpers = cm.getHelpers(pos, "hint"),
          words;
      if (helpers.length) {
        var resolved = function resolved(cm, callback, options) {
          var app = applicableHelpers(cm, helpers);
          function run(i) {
            if (i == app.length) return callback(null);
            fetchHints(app[i], cm, options, function (result) {
              if (result && result.list.length > 0) callback(result);else run(i + 1);
            });
          }
          run(0);
        };
        resolved.async = true;
        resolved.supportsSelection = true;
        return resolved;
      } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
        return function (cm) {
          return CodeMirror.hint.fromList(cm, { words: words });
        };
      } else if (CodeMirror.hint.anyword) {
        return function (cm, options) {
          return CodeMirror.hint.anyword(cm, options);
        };
      } else {
        return function () {};
      }
    }
  
    CodeMirror.registerHelper("hint", "auto", {
      resolve: resolveAutoHints
    });
  
    CodeMirror.registerHelper("hint", "fromList", function (cm, options) {
      var cur = cm.getCursor(),
          token = cm.getTokenAt(cur);
      var to = CodeMirror.Pos(cur.line, token.end);
      if (token.string && /\w/.test(token.string[token.string.length - 1])) {
        var term = token.string,
            from = CodeMirror.Pos(cur.line, token.start);
      } else {
        var term = "",
            from = to;
      }
      var found = [];
      for (var i = 0; i < options.words.length; i++) {
        var word = options.words[i];
        if (word.slice(0, term.length) == term) found.push(word);
      }
  
      if (found.length) return { list: found, from: from, to: to };
    });
  
    CodeMirror.commands.autocomplete = CodeMirror.showHint;
  
    var defaultOptions = {
      hint: CodeMirror.hint.auto,
      completeSingle: true,
      alignWithWord: true,
      closeCharacters: /[\s()\[\]{};:>,]/,
      closeOnUnfocus: true,
      completeOnSingleClick: true,
      container: null,
      customKeys: null,
      extraKeys: null
    };
  
    CodeMirror.defineOption("hintOptions", null);
  };
  /* eslint-enable */
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/color-picker/color-picker.js":
  /*!********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/color-picker/color-picker.js ***!
    \********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./template.tpl */ "./lib/assets/javascripts/builder/components/color-picker/template.tpl");
  var colorPickerTemplate = __webpack_require__(/*! ./color-picker-template.tpl */ "./lib/assets/javascripts/builder/components/color-picker/color-picker-template.tpl");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  
  __webpack_require__(/*! bootstrap-colorpicker */ "./node_modules/bootstrap-colorpicker/dist/js/bootstrap-colorpicker.js");
  
  var ESCAPE_KEY_CODE = 27;
  
  module.exports = CoreView.extend({
    events: {
      'blur .js-hex': '_onChangeHex',
      'blur .js-inputColor': '_onChangeColorValue',
      'blur .js-a': '_onChangeOpacity'
    },
  
    initialize: function initialize(opts) {
      var opacity = opts.opacity != null ? opts.opacity : 1;
  
      this.model = new Backbone.Model({
        hex: opts.value,
        opacity: opacity
      });
  
      this._onEscape = this._onEscapePressed.bind(this);
      this._initBinds();
    },
  
    render: function render() {
      var hex = this.model.get('hex');
      var rgb = Utils.hexToRGB(this._sanitizeHex());
      var color = _.extend(rgb, {
        hex: hex,
        opacity: this.model.get('opacity'),
        opacityDisabled: this.options.disableOpacity
      });
  
      this.$el.append(template(color));
  
      var rgbaTemplate = _.template('rgba(<%- r %>, <%- g %>, <%- b %>, <%- opacity %>)');
  
      this.$('.js-colorPicker').colorpicker({
        color: rgbaTemplate(color),
        format: 'rgba',
        container: true,
        horizontal: true,
        inline: true,
        customClass: 'ColorPicker',
        template: colorPickerTemplate(),
        slidersHorz: {
          saturation: {
            maxLeft: 206,
            maxTop: 95,
            callLeft: 'setSaturation',
            callTop: 'setBrightness'
          },
          hue: {
            maxLeft: 180,
            maxTop: 0,
            callLeft: 'setHue',
            callTop: false
          },
          alpha: {
            maxLeft: 180,
            maxTop: 0,
            callLeft: 'setAlpha',
            callTop: false
          }
        }
      });
  
      if (this.options.disableOpacity) {
        this.$('.js-colorPicker .js-alpha').addClass('is-hidden');
      }
  
      var setNewColor = function (e) {
        var rgb = e.color.toRGB();
        var hex = e.color.toHex();
        this.model.set({ hex: hex, r: rgb.r, g: rgb.g, b: rgb.b, opacity: rgb.a });
        this.$('.js-color').css('opacity', rgb.a);
      }.bind(this);
  
      this.$('.js-colorPicker').colorpicker().on('changeColor', setNewColor);
  
      this._initDocumentBinds();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change:hex', this._onChangeColor, this);
      this.model.bind('change:r', this._onChangeColor, this);
      this.model.bind('change:g', this._onChangeColor, this);
      this.model.bind('change:b', this._onChangeColor, this);
      this.model.bind('change:opacity', this._onChangeColor, this);
    },
  
    _onEscapePressed: function _onEscapePressed(ev) {
      if (ev.which === ESCAPE_KEY_CODE) {
        this.remove();
      }
    },
  
    _initDocumentBinds: function _initDocumentBinds() {
      $(document).on('keydown', this._onEscape);
    },
  
    _destroyDocumentBinds: function _destroyDocumentBinds() {
      $(document).off('keydown', this._onEscape);
    },
  
    _sanitizeHex: function _sanitizeHex() {
      return Utils.sanitizeHex(this.model.get('hex'));
    },
  
    _onChangeColor: function _onChangeColor() {
      this.trigger('change', {
        opacity: this.model.get('opacity'),
        hex: this.model.get('hex')
      }, this);
  
      this.$('.js-hex').val(this.model.get('hex'));
      this.$('.js-r').val(this.model.get('r'));
      this.$('.js-g').val(this.model.get('g'));
      this.$('.js-b').val(this.model.get('b'));
      this.$('.js-a').val(this.model.get('opacity'));
    },
  
    _onChangeOpacity: function _onChangeOpacity() {
      var opacity = +this.$('.js-a').val();
      if (_.isNumber(opacity) && opacity >= 0 && opacity <= 1) {
        this.setColor(this.model.get('hex'), opacity);
      }
    },
  
    _onChangeColorValue: function _onChangeColorValue(e) {
      this.$(e.target).removeClass('has-error');
  
      var r = +this.$('.js-r').val();
      var g = +this.$('.js-g').val();
      var b = +this.$('.js-b').val();
  
      var hex = Utils.rgbToHex(r, g, b);
  
      if (Utils.isValidHex(hex)) {
        this.setColor(hex);
      } else {
        this.$(e.target).addClass('has-error');
      }
    },
  
    _onChangeHex: function _onChangeHex(e) {
      this.$(e.target).removeClass('has-error');
  
      var hex = this.$('.js-hex').val();
  
      if (Utils.isValidHex(hex)) {
        this.setColor(hex);
      } else {
        this.$(e.target).addClass('has-error');
      }
    },
  
    setColor: function setColor(hex, opacity) {
      if (_.isUndefined(opacity)) {
        opacity = this.model.get('opacity') || 1;
      }
  
      this.$('.js-colorPicker').colorpicker('setValue', Utils.hexToRGBA(hex, opacity));
    },
  
    clean: function clean() {
      this._destroyDocumentBinds();
      this.trigger('onClean', this);
      CoreView.prototype.clean.apply(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/context-menu/context-menu-view.js":
  /*!*************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/context-menu/context-menu-view.js ***!
    \*************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var CustomListView = __webpack_require__(/*! builder/components/custom-list/custom-list-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-view.js");
  var CustomListItemView = __webpack_require__(/*! builder/components/custom-list/custom-list-item-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item-view.js");
  var itemTemplate = __webpack_require__(/*! builder/components/custom-list/custom-list-item.tpl */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item.tpl");
  var magicPositioner = __webpack_require__(/*! builder/helpers/magic-positioner */ "./lib/assets/javascripts/builder/helpers/magic-positioner.js");
  var DropdownOverlayView = __webpack_require__(/*! builder/components/dropdown-overlay/dropdown-overlay-view */ "./lib/assets/javascripts/builder/components/dropdown-overlay/dropdown-overlay-view.js");
  
  var ESCAPE_KEY_CODE = 27;
  
  /*
   *  A context menu
   */
  module.exports = CoreView.extend({
  
    options: {
      position: {
        x: 0,
        y: 0
      },
      offset: {
        x: 0,
        y: 15
      },
      itemTemplate: itemTemplate,
      itemView: CustomListItemView
    },
  
    className: 'CDB-Box-modal CDB-SelectItem CustomList CustomList--small',
    tagName: 'div',
  
    initialize: function initialize(opts) {
      opts = opts || {};
      if (!opts.collection) throw new Error('collection option is required');
      if (!opts.triggerElementID) throw new Error('element id is required');
  
      this._triggerElementID = opts.triggerElementID;
  
      this.model = new Backbone.Model({
        visible: false
      });
  
      this._onEscapePressed = this._onEscapePressed.bind(this);
  
      this._initBinds();
    },
  
    _initBinds: function _initBinds() {
      this.model.on('change:visible', function (mdl, isVisible) {
        this.render();
        if (isVisible) {
          this._initDocumentBinds();
        } else {
          this._destroyDocumentBinds();
        }
      }, this);
      this.collection.on('change:selected', this.hide, this);
      this.add_related_model(this.collection);
    },
  
    _initDocumentBinds: function _initDocumentBinds() {
      $(document).on('keydown', this._onEscapePressed);
    },
  
    _destroyDocumentBinds: function _destroyDocumentBinds() {
      $(document).off('keydown', this._onEscapePressed);
    },
  
    render: function render() {
      var $body = $('body');
      var posX = (this.options.position.x || 0) + this.options.offset.x;
      var posY = (this.options.position.y || 0) + this.options.offset.y;
  
      this.clearSubViews();
      this.$el.empty();
      this._renderList();
  
      this.$el.toggle(this.isVisible());
  
      $body.append(this.el);
  
      this.$el.css(magicPositioner({
        parentView: $body,
        posX: posX,
        posY: posY
      }));
  
      this.dropdownOverlay = new DropdownOverlayView({
        visible: this.isVisible(),
        onClickAction: this.hide.bind(this)
      });
      this.addView(this.dropdownOverlay);
  
      return this;
    },
  
    _onEscapePressed: function _onEscapePressed(ev) {
      if (ev.which === ESCAPE_KEY_CODE) {
        this.hide();
      }
    },
  
    _renderList: function _renderList() {
      this._listView = new CustomListView({
        model: this.model,
        collection: this.collection,
        typeLabel: '',
        itemView: this.options.itemView,
        itemTemplate: this.options.itemTemplate,
        size: 5
      });
      this.$el.append(this._listView.render().el);
      this.addView(this._listView);
    },
  
    show: function show() {
      this.model.set('visible', true);
    },
  
    hide: function hide() {
      this.model.set('visible', false);
    },
  
    toggle: function toggle() {
      this.model.set('visible', !this.model.get('visible'));
    },
  
    isVisible: function isVisible() {
      return this.model.get('visible');
    },
  
    clean: function clean() {
      this._destroyDocumentBinds();
      CoreView.prototype.clean.apply(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/custom-carousel/custom-carousel-collection.js":
  /*!*************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/custom-carousel/custom-carousel-collection.js ***!
    \*************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CustomCarouselModel = __webpack_require__(/*! ./custom-carousel-item-model */ "./lib/assets/javascripts/builder/components/custom-carousel/custom-carousel-item-model.js");
  
  /*
   *  Custom list collection, it parses pairs like:
   *
   *  [{ val, label }]
   *  ["string"]
   */
  
  module.exports = Backbone.Collection.extend({
  
    model: function model(attrs, opts) {
      var d = {};
      if (typeof attrs === 'string') {
        d.val = attrs;
      } else {
        d = attrs;
      }
      return new CustomCarouselModel(d);
    },
  
    initialize: function initialize() {
      this._initBinds();
    },
  
    _initBinds: function _initBinds() {
      this.bind('change:selected', this._onSelectedChange, this);
    },
  
    _onSelectedChange: function _onSelectedChange(changedModel, isSelected) {
      if (isSelected) {
        this.each(function (m) {
          if (m.cid !== changedModel.cid && m.get('selected')) {
            m.set('selected', false);
          }
        });
      }
    },
  
    getSelected: function getSelected() {
      return this.findWhere({ selected: true });
    },
  
    getSelectedValue: function getSelectedValue() {
      var selectedModel = this.getSelected();
      return selectedModel && selectedModel.get('val');
    },
  
    getHighlighted: function getHighlighted() {
      return this.findWhere({ highlighted: true });
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/custom-carousel/custom-carousel-item-model.js":
  /*!*************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/custom-carousel/custom-carousel-item-model.js ***!
    \*************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /*
   *  List item model
   *
   */
  
  module.exports = Backbone.Model.extend({
  
    defaults: {
      selected: false,
      label: '',
      template: function template() {
        return '';
      }
    },
  
    getName: function getName() {
      return this.get('label') || this.getValue();
    },
  
    getValue: function getValue() {
      return this.get('val');
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/custom-carousel/custom-carousel-item-view.js":
  /*!************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/custom-carousel/custom-carousel-item-view.js ***!
    \************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./custom-carousel-item.tpl */ "./lib/assets/javascripts/builder/components/custom-carousel/custom-carousel-item.tpl");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  
  module.exports = CoreView.extend({
  
    className: 'Carousel-item',
    tagName: 'li',
  
    events: {
      'mouseenter': '_onMouseEnter',
      'mouseleave': '_onMouseLeave',
      'click': '_onClick'
    },
  
    initialize: function initialize(opts) {
      this._itemClassName = opts && opts.itemOptions ? opts.itemOptions.className : '';
      this._initBinds();
    },
  
    render: function render() {
      // NOTE: this function calls destroyTipsy for each tooltip, which calls:
      // this.$el.unbind('mouseleave mouseenter');
      // So we need to bind the events again after calling clearSubViews
      this.clearSubViews();
  
      this.$el.bind('mouseenter', this._onMouseEnter.bind(this));
      this.$el.bind('mouseleave', this._onMouseLeave.bind(this));
  
      this.$el.html(template({
        name: this.model.getName(),
        className: this._itemClassName,
        template: this.model.get('template')()
      }));
  
      if (this.model.getValue()) {
        this.$el.addClass('js-' + this.model.getValue());
      }
      this.$el.toggleClass('is-selected', !!this.model.get('selected'));
  
      this._initViews();
  
      return this;
    },
  
    _initViews: function _initViews() {
      if (this.model.get('tooltip')) {
        var tooltip = new TipsyTooltipView({
          el: this.$el,
          gravity: 's',
          title: function () {
            return this.model.get('tooltip');
          }.bind(this)
        });
        this.addView(tooltip);
      }
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change:selected', this.render, this);
    },
  
    _onMouseEnter: function _onMouseEnter() {
      this.model.set('highlighted', true);
    },
  
    _onMouseLeave: function _onMouseLeave() {
      this.model.set('highlighted', false);
    },
  
    _onClick: function _onClick(e) {
      this.killEvent(e);
      this.model.set('selected', true);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/custom-carousel/custom-carousel-view.js":
  /*!*******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/custom-carousel/custom-carousel-view.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var Ps = __webpack_require__(/*! perfect-scrollbar */ "./node_modules/perfect-scrollbar/index.js");
  var template = __webpack_require__(/*! ./custom-carousel.tpl */ "./lib/assets/javascripts/builder/components/custom-carousel/custom-carousel.tpl");
  var CarouselCollection = __webpack_require__(/*! ./custom-carousel-collection */ "./lib/assets/javascripts/builder/components/custom-carousel/custom-carousel-collection.js");
  var CarouselItemView = __webpack_require__(/*! ./custom-carousel-item-view */ "./lib/assets/javascripts/builder/components/custom-carousel/custom-carousel-item-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  /*
   *  A custom carousel selector
   *
   *  It accepts a collection of (val, label) model attributes or a values array
   *  with the same content or only strings.
   *
   *  new CustomCarousel({
   *    options: [
   *      {
   *        val: 'hello',
   *        label: 'hi'
   *      }
   *    ]
   *  });
   */
  
  module.exports = CoreView.extend({
  
    className: 'Carousel',
    tagName: 'div',
  
    initialize: function initialize(opts) {
      if (!opts.collection) {
        if (!opts.options) {
          throw new Error('options array {value, label} is required');
        }
        this.collection = new CarouselCollection(opts.options);
        this.options = opts;
      }
      this._bindedCheckShadows = this._checkShadows.bind(this);
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template());
      this._renderList();
      this._applyCustomScroll();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.collection.bind('change:selected', this._checkScroll, this);
    },
  
    _renderList: function _renderList() {
      this.collection.each(function (model) {
        this._createItem(model);
      }, this);
    },
  
    _createItem: function _createItem(model) {
      var opts = this.options;
      var className = opts && opts.listItemOptions ? opts.listItemOptions.className : 'Carousel-item';
      var view = new CarouselItemView({
        className: className,
        model: model,
        itemOptions: this.options.itemOptions
      });
  
      this._listContainer().append(view.render().el);
      this.addView(view);
    },
  
    _applyCustomScroll: function _applyCustomScroll() {
      Ps.initialize(this._listContainer().get(0), {
        wheelSpeed: 1,
        wheelPropagation: false,
        swipePropagation: true,
        suppressScrollY: true,
        stopPropagationOnClick: false,
        minScrollbarLength: 120,
        useBothWheelAxes: true
      });
      this._checkScroll();
      this._bindScroll();
    },
  
    _destroyCustomScroll: function _destroyCustomScroll() {
      this._unbindScroll();
      Ps.destroy(this._listContainer().get(0));
    },
  
    _bindScroll: function _bindScroll() {
      this._listContainer().on('ps-x-reach-start', this._bindedCheckShadows).on('ps-x-reach-end', this._bindedCheckShadows).on('ps-scroll-x', this._bindedCheckShadows);
    },
  
    _unbindScroll: function _unbindScroll() {
      this._listContainer().off('ps-x-reach-start', this._bindedCheckShadows).off('ps-x-reach-end', this._bindedCheckShadows).off('ps-scroll-x', this._bindedCheckShadows);
    },
  
    _checkScroll: function _checkScroll() {
      var position = this.$('.is-selected').position();
      if (position) {
        this._listContainer().scrollLeft(position.left - 20);
        this._bindedCheckShadows();
      }
    },
  
    _listContainer: function _listContainer() {
      return this.$('.js-list');
    },
  
    _checkShadows: function _checkShadows() {
      var currentPos = this._listContainer().scrollLeft();
      var max = this._listContainer().get(0).scrollWidth;
      var width = this._listContainer().outerWidth();
      var maxPos = max - width;
  
      this.$('.js-leftShadow').toggleClass('is-visible', currentPos > 0);
      this.$('.js-rightShadow').toggleClass('is-visible', currentPos < maxPos);
    },
  
    clean: function clean() {
      this._destroyCustomScroll();
      CoreView.prototype.clean.apply(this);
    },
  
    initScroll: function initScroll() {
      setTimeout(_.bind(function () {
        this._checkShadows();
        this._checkScroll();
        Ps.update(this._listContainer().get(0));
      }, this), 0);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/custom-list/column-list/column-list-view.js":
  /*!***********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/custom-list/column-list/column-list-view.js ***!
    \***********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var CustomListView = __webpack_require__(/*! builder/components/custom-list/custom-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-view.js");
  var CustomListCollection = __webpack_require__(/*! builder/components/custom-list/custom-list-collection */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-collection.js");
  var ColumnListViewTemplate = __webpack_require__(/*! builder/components/custom-list/column-list/column-list-view.tpl */ "./lib/assets/javascripts/builder/components/custom-list/column-list/column-list-view.tpl");
  
  module.exports = CoreView.extend({
    defaults: {
      headerTitle: ''
    },
  
    events: {
      'click .js-back': '_onClickBack'
    },
  
    initialize: function initialize(opts) {
      if (!opts.stackLayoutModel) throw new Error('stackLayoutModel is required');
      if (!opts.columns) throw new Error('columns param is required');
  
      this._stackLayoutModel = opts.stackLayoutModel;
      this._columns = opts.columns;
      this._showSearch = opts.showSearch || false;
      this._typeLabel = opts.typeLabel;
      this._itemTemplate = opts.itemTemplate;
  
      this.collection = new CustomListCollection(this._columns);
      this.listenTo(this.collection, 'change:selected', this._onSelectItem);
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
  
      this.$el.append(ColumnListViewTemplate({
        headerTitle: this.options.headerTitle
      }));
  
      this._initViews();
  
      return this;
    },
  
    _onClickBack: function _onClickBack(e) {
      this.killEvent(e);
      this.trigger('back', this);
    },
  
    _initViews: function _initViews() {
      this._listView = new CustomListView({
        collection: this.collection,
        showSearch: this._showSearch,
        typeLabel: this._typeLabel,
        itemTemplate: this._itemTemplate
      });
      this.$('.js-content').append(this._listView.render().$el);
      this.addView(this._listView);
    },
  
    _onSelectItem: function _onSelectItem(item) {
      this.trigger('selectItem', item, this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/custom-list/custom-list-action-view.js":
  /*!******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/custom-list/custom-list-action-view.js ***!
    \******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./custom-list-action.tpl */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-action.tpl");
  
  module.exports = CoreView.extend({
  
    className: 'CDB-Text CDB-Size-small is-semibold u-upperCase u-actionTextColor u-lSpace--xl',
  
    tagName: 'button',
  
    events: {
      'click': '_onClick'
    },
  
    initialize: function initialize(opts) {
      this.options = opts;
    },
  
    render: function render() {
      this.$el.empty();
      this.clearSubViews();
  
      this.$el.append(template({
        label: this.options.label
      }));
  
      return this;
    },
  
    _onClick: function _onClick() {
      this.options.action && this.options.action();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/custom-list/custom-list-collection.js":
  /*!*****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/custom-list/custom-list-collection.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CustomListItemModel = __webpack_require__(/*! ./custom-list-item-model */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item-model.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  /*
   *  Custom list collection, it parses pairs like:
   *
   *  [{ val, label }]
   *  ["string"]
   */
  
  module.exports = Backbone.Collection.extend({
    sort_key: 'id', // default sort key
  
    initialize: function initialize(models, options) {
      this.options = _.extend({ silent: true }, options);
      this._initBinds();
    },
  
    comparator: function comparator(item) {
      var name = item.get(this.sort_key);
  
      return this._nameToLowerCase(name);
    },
  
    model: function model(attrs, opts) {
      var d = {};
      if (typeof attrs === 'string') {
        d.val = attrs;
      } else {
        d = attrs;
      }
      return new CustomListItemModel(d, opts);
    },
  
    sortByKey: function sortByKey(key) {
      this.sort_key = key;
      this.sort();
    },
  
    _initBinds: function _initBinds() {
      this.bind('change:selected', this._onSelectedChange, this);
    },
  
    _nameToLowerCase: function _nameToLowerCase(name) {
      /*
       *  It could still be evaluated like true if it is a boolean/number
       *  in that case, we convert it to a string
       */
  
      if (_.isUndefined(name) || _.isNull(name)) return name;
  
      return _.isString(name) ? name.toLowerCase() : name.toString().toLowerCase();
    },
  
    search: function search(query) {
      if (!query) return this;
      query = query.toLowerCase();
  
      return _(this.filter(function (model) {
        var name = model.getName();
        var val = this._nameToLowerCase(name);
  
        return val ? ~val.indexOf(query) : -1;
      }, this));
    },
  
    _onSelectedChange: function _onSelectedChange(changedModel, isSelected) {
      if (isSelected) {
        this.each(function (m) {
          if (m.cid !== changedModel.cid) {
            m.set({
              selected: false
            }, {
              silent: this.options.silent
            });
          }
        }, this);
      }
    },
  
    getSelectedItem: function getSelectedItem() {
      return this.findWhere({ selected: true });
    },
  
    containsValue: function containsValue(value) {
      return this.find(function (mdl) {
        return mdl.getValue() === value;
      });
    },
  
    setSelected: function setSelected(value) {
      var selectedModel;
      var silent = { silent: this.options.silent };
  
      this.each(function (mdl) {
        if (mdl.getValue() === value) {
          mdl.set({
            selected: true
          }, silent);
          selectedModel = mdl;
        } else {
          mdl.set({
            selected: false
          }, silent);
        }
      });
      return selectedModel;
    },
  
    removeSelected: function removeSelected() {
      this.each(function (mdl) {
        mdl.set({
          selected: false
        });
      });
    },
  
    isAsync: function isAsync() {
      return false;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item-model.js":
  /*!*****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/custom-list/custom-list-item-model.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /*
   *  List item model
   *
   */
  
  module.exports = Backbone.Model.extend({
  
    defaults: {
      selected: false
    },
  
    getName: function getName() {
      return this.get('label') == null ? this.getValue() : this.get('label'); // eslint-disable-line
    },
  
    getValue: function getValue() {
      return this.get('val');
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item-view.js":
  /*!****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/custom-list/custom-list-item-view.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  module.exports = CoreView.extend({
  
    options: {
      template: __webpack_require__(/*! ./custom-list-item.tpl */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item.tpl")
    },
  
    className: 'CDB-ListDecoration-item CustomList-item js-listItem',
    tagName: 'li',
  
    events: {
      'mouseenter': '_onMouseEnter',
      'mouseleave': '_onMouseLeave',
      'click': '_onClick'
    },
  
    initialize: function initialize(opts) {
      this.options = _.extend({}, this.options, opts);
      this.model.on('change', this.render, this);
    },
  
    render: function render() {
      this.$el.empty();
      this.clearSubViews();
  
      var name = this.model.getName() == null ? 'null' : this.model.getName();
  
      this.$el.append(this.options.template(_.extend({
        typeLabel: this.options.typeLabel,
        isSelected: this.model.get('selected'),
        isDisabled: this.model.get('disabled'),
        isDestructive: this.model.get('destructive'),
        name: name,
        val: this.model.getValue(),
        options: this.model.get('renderOptions')
      })));
  
      this.$el.attr('data-val', this.model.getValue()).toggleClass('is-disabled', !!this.model.get('disabled'));
  
      return this;
    },
  
    _onMouseLeave: function _onMouseLeave() {
      this.$el.removeClass('is-highlighted');
    },
  
    _onMouseEnter: function _onMouseEnter() {
      this.$el.addClass('is-highlighted');
    },
  
    _onClick: function _onClick(ev) {
      this.killEvent(ev);
      this.model.set({
        selectedClass: ev.target.classList,
        selected: true
      });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/custom-list/custom-list-multi-collection.js":
  /*!***********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/custom-list/custom-list-multi-collection.js ***!
    \***********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CustomListCollection = __webpack_require__(/*! ./custom-list-collection */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-collection.js");
  
  module.exports = CustomListCollection.extend({
    _initBinds: function _initBinds() {},
  
    setSelected: function setSelected(value) {
      var selectedModel;
      var silentTrue = { silent: true };
  
      if (_.isArray(value)) {
        this.each(function (mdl) {
          if (_.contains(value, mdl.getValue())) {
            mdl.set({
              selected: true
            }, silentTrue);
            selectedModel = mdl;
          } else {
            mdl.set({
              selected: false
            }, silentTrue);
          }
        });
      } else {
        this.each(function (mdl) {
          if (mdl.getValue() === value) {
            mdl.set({
              selected: true
            }, silentTrue);
            selectedModel = mdl;
          } else {
            mdl.set({
              selected: false
            }, silentTrue);
          }
        });
      }
      return selectedModel;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/custom-list/custom-list-multi-item-view.js":
  /*!**********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/custom-list/custom-list-multi-item-view.js ***!
    \**********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CustomListItemView = __webpack_require__(/*! ./custom-list-item-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item-view.js");
  
  module.exports = CustomListItemView.extend({
    _onClick: function _onClick(ev) {
      this.killEvent(ev);
      this.model.set('selected', !this.model.get('selected'));
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/custom-list/custom-list-search-view.js":
  /*!******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/custom-list/custom-list-search-view.js ***!
    \******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./custom-list-search.tpl */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-search.tpl");
  
  module.exports = CoreView.extend({
  
    className: 'CustomList--full',
    tagName: 'form',
  
    events: {
      'keyup .js-search': '_onSearchType',
      'click .js-clear': '_onClickClear',
      'submit': '_submit'
    },
  
    initialize: function initialize() {
      this.template = this.options.template || template;
      this.searchPlaceholder = this.options.searchPlaceholder || _t('components.custom-list.placeholder', { typeLabel: this.options.typeLabel });
      this._initBinds();
    },
  
    render: function render() {
      this.$el.empty().append(this.template({
        query: this.model.get('query'),
        searchPlaceholder: this.searchPlaceholder
      }));
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.model.on('change:query', this._checkButtons, this);
    },
  
    _checkButtons: function _checkButtons() {
      var query = this.model.get('query');
      this.$('.js-clear').toggleClass('u-transparent', query.length === 0);
    },
  
    _onSearchType: function _onSearchType(e) {
      this._submit();
    },
  
    _onClickClear: function _onClickClear(e) {
      e.stopPropagation();
      this.model.set('query', '');
      this.render();
      this.focus();
    },
  
    focus: function focus() {
      this.$('.js-search').focus();
    },
  
    _submit: function _submit(ev) {
      this.killEvent(ev);
      var query = this.$('.js-search').val();
      this.model.set('query', query);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/custom-list/custom-list-view.js":
  /*!***********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/custom-list/custom-list-view.js ***!
    \***********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Ps = __webpack_require__(/*! perfect-scrollbar */ "./node_modules/perfect-scrollbar/index.js");
  var emptyTemplate = __webpack_require__(/*! ./custom-list-empty.tpl */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-empty.tpl");
  var addTemplate = __webpack_require__(/*! ./custom-list-add.tpl */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-add.tpl");
  var template = __webpack_require__(/*! ./custom-list.tpl */ "./lib/assets/javascripts/builder/components/custom-list/custom-list.tpl");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  
  var ARROW_DOWN_KEY_CODE = 40;
  var ARROW_UP_KEY_CODE = 38;
  var ENTER_KEY_CODE = 13;
  
  module.exports = CoreView.extend({
    module: 'components:custom-list:custom-list-view',
  
    options: {
      size: 3
    },
  
    className: 'CDB-Text CDB-Size-medium CustomList-listWrapper',
  
    tagName: 'div',
  
    events: {
      'click .js-add-custom-value': '_onClickAddCustomValue',
      'mouseover': '_onMouseOver',
      'mouseout': '_onMouseOut'
    },
  
    initialize: function initialize(opts) {
      this.options = _.extend({}, this.options, opts);
  
      this._onKeyDownBinded = this._onKeyDown.bind(this);
      this._needsMaxSize = true;
  
      if (this.options.mouseOverAction) {
        this._mouseOverAction = this.options.mouseOverAction;
      }
  
      if (this.options.mouseOutAction) {
        this._mouseOutAction = this.options.mouseOutAction;
      }
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this._removeArrowBinds();
      this._destroyCustomScroll();
      this.$el.empty();
  
      var query = this.model.get('query');
      var items = this.collection.search(query);
  
      this.$el.append(template());
  
      var allowFreeTextInput = this.options.allowFreeTextInput;
  
      if (allowFreeTextInput && query && !Utils.isBlank(query)) {
        if (!this.collection.containsValue(query)) {
          this.$el.prepend(addTemplate({
            query: query,
            typeLabel: this.options.typeLabel
          }));
        }
      }
  
      if (items.size() > 0) {
        items.each(this._renderItem, this);
        this._applyArrowBinds();
        // Perfect-scroll needs to have the element in the DOM in order to
        // style/positionate the scroll properly, small trick
        setTimeout(this._applyCustomScroll.bind(this), 0);
      } else if (!allowFreeTextInput || Utils.isBlank(query)) {
        this.$el.append(emptyTemplate({
          query: query,
          typeLabel: this.options.typeLabel
        }));
      }
  
      return this;
    },
  
    _renderItem: function _renderItem(model) {
      if (model.get('hidden')) return;
      var ItemViewClass = this.options.itemView;
  
      var itemView = new ItemViewClass({
        model: model,
        typeLabel: this.options.typeLabel,
        template: this.options.itemTemplate
      });
      this.$('.js-list').append(itemView.render().el);
      this.addView(itemView);
  
      itemView.bind('customEvent', function (eventName, item) {
        this.trigger('customEvent', eventName, item, this);
      }, this);
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change:query', this._onQueryChanged, this);
    },
  
    _applyArrowBinds: function _applyArrowBinds() {
      document.addEventListener('keydown', this._onKeyDownBinded);
    },
  
    _removeArrowBinds: function _removeArrowBinds() {
      document.removeEventListener('keydown', this._onKeyDownBinded);
    },
  
    _getSelected: function _getSelected() {
      var selectedModel = this.collection.getSelectedItem();
      var selectedValue;
  
      if (selectedModel) {
        selectedValue = selectedModel.getValue();
        return this.$("[data-val='" + selectedValue + "']");
      }
  
      return null;
    },
  
    _highlightSelected: function _highlightSelected(item) {
      var itemHeight = item.outerHeight();
      item.addClass('is-highlighted');
      this.$('.js-list').scrollTop(item.index() * itemHeight);
    },
  
    _onClickAddCustomValue: function _onClickAddCustomValue(event) {
      this.killEvent(event);
  
      var query = this.model.get('query');
  
      var model = this.collection.add({
        val: query,
        label: '' + query + '',
        dirty: true
      });
  
      this.collection.sortByKey('val');
      model.set('selected', true);
    },
  
    _onKeyDown: function _onKeyDown(event) {
      if (this.model.get('visible') === false) {
        return;
      }
  
      var key = event.which;
      var $listItems = this.$('.js-listItem');
      var $highlighted = $listItems.filter('.is-highlighted');
      var $current;
      var model;
  
      $highlighted.removeClass('is-highlighted');
  
      if (key === ARROW_DOWN_KEY_CODE) {
        if (!$highlighted.length || $highlighted[0] === $listItems.last()[0]) {
          $current = $listItems.eq(0);
        } else {
          $current = $highlighted.next();
        }
      } else if (key === ARROW_UP_KEY_CODE) {
        if (!$highlighted.length || $highlighted[0] === $listItems.first()[0]) {
          $current = $listItems.last();
        } else {
          $current = $highlighted.prev();
        }
      } else if (key === ENTER_KEY_CODE) {
        event.preventDefault();
        if ($highlighted && $highlighted.length) {
          model = _.first(this.collection.where({ val: $highlighted.data('val') }));
          if (model) {
            model.set('selected', true);
          }
          return false;
        }
      }
  
      $current && this._highlightSelected($current);
    },
  
    _onQueryChanged: function _onQueryChanged() {
      var prevQuery = this.collection.findWhere({ val: this.model.previous('query'), dirty: true });
      this.collection.remove(prevQuery);
  
      this.render();
    },
  
    _applyCustomScroll: function _applyCustomScroll() {
      Ps.initialize(this._wrapperContainer().get(0), {
        wheelSpeed: 2,
        wheelPropagation: true,
        stopPropagationOnClick: false,
        minScrollbarLength: 20
      });
    },
  
    _destroyCustomScroll: function _destroyCustomScroll() {
      if (this._wrapperContainer().length > 0) {
        Ps.destroy(this._wrapperContainer().get(0));
      }
    },
  
    _wrapperContainer: function _wrapperContainer() {
      return this.$('.js-list');
    },
  
    clean: function clean() {
      this._removeArrowBinds();
      this._destroyCustomScroll();
      CoreView.prototype.clean.apply(this);
    },
  
    highlight: function highlight() {
      var selected = this._getSelected();
      selected && this._highlightSelected(selected);
    },
  
    _onMouseOver: function _onMouseOver() {
      this._mouseOverAction && this._mouseOverAction();
    },
  
    _onMouseOut: function _onMouseOut() {
      this._mouseOutAction && this._mouseOutAction();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/custom-list/custom-view.js":
  /*!******************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/custom-list/custom-view.js ***!
    \******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var CustomListCollection = __webpack_require__(/*! ./custom-list-collection */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-collection.js");
  var SearchView = __webpack_require__(/*! ./custom-list-search-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-search-view.js");
  var CustomListView = __webpack_require__(/*! ./custom-list-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-view.js");
  var headerTemplate = __webpack_require__(/*! ./custom-list-header.tpl */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-header.tpl");
  var CustomListAction = __webpack_require__(/*! ./custom-list-action-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-action-view.js");
  var itemTemplate = __webpack_require__(/*! ./custom-list-item.tpl */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item.tpl");
  var CustomListItemView = __webpack_require__(/*! ./custom-list-item-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item-view.js");
  
  /*
   *  A custom list with possibility to search within values.
   *
   *  It accepts a collection of (val, label) model attributes or a values array
   *  with the same content or only strings.
   *
   *  new CustomList({
   *    showSearch: false,
   *    itemTemplate: itemTemplate,
   *    values: [
   *      {
   *        val: 'hello',
   *        label: 'hi'
   *      }
   *    ]
   *  });
   */
  
  module.exports = CoreView.extend({
    module: 'components:custom-list:custom-view',
  
    options: {
      showSearch: true,
      allowFreeTextInput: false,
      typeLabel: 'column',
      itemTemplate: itemTemplate,
      itemView: CustomListItemView
    },
  
    className: 'CDB-Box-modal CustomList',
    tagName: 'div',
  
    events: {
      'mouseover': '_onMouseOver',
      'mouseout': '_onMouseOut'
    },
  
    initialize: function initialize(opts) {
      if (!opts.collection) {
        if (!opts.options) {
          throw new Error('options array {value, label} is required');
        }
        this.collection = new CustomListCollection(opts.options);
      }
  
      if (opts.position) {
        this.$el.css(opts.position);
      }
  
      this.options = _.extend({}, this.options, opts);
      this._selectModel = this.options.selectModel;
  
      if (this.options.mouseOverAction) {
        this._mouseOverAction = this.options.mouseOverAction;
      }
  
      if (this.options.mouseOutAction) {
        this._mouseOutAction = this.options.mouseOutAction;
      }
  
      this.model = new Backbone.Model({
        query: '',
        visible: false
      });
      this._initBinds();
    },
  
    render: function render() {
      this.$el.empty();
      this.clearSubViews();
  
      if (this.options.showSearch || this.options.actions) {
        this._renderHeader();
      }
  
      if (this.options.showSearch) {
        this._renderSearch();
      }
  
      if (this.options.actions) {
        this._renderActions();
      }
  
      this._renderList();
  
      if (this.options.showSearch) {
        this._focusSearch();
      }
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change:visible', this._onVisibleChanged, this);
      this.model.bind('change:query', this._setActionsVisibility, this);
    },
  
    _renderHeader: function _renderHeader() {
      this.$el.prepend(headerTemplate());
    },
  
    _renderSearch: function _renderSearch() {
      this._searchView = new SearchView({
        template: this.options.searchTemplate,
        typeLabel: this.options.typeLabel,
        searchPlaceholder: this.options.searchPlaceholder,
        model: this.model
      });
      this.$('.js-header').prepend(this._searchView.render().el);
      this.addView(this._searchView);
    },
  
    _renderActions: function _renderActions() {
      _.each(this.options.actions, function (action) {
        var view = new CustomListAction(action);
        this.$('.js-actions').append(view.render().el);
        this.addView(view);
      }, this);
    },
  
    _setActionsVisibility: function _setActionsVisibility() {
      this.$('.js-actions').toggleClass('u-hide', this.model.get('query') !== '');
    },
  
    _focusSearch: function _focusSearch() {
      setTimeout(function () {
        if (this._searchView) {
          this._searchView.focus();
          var input = this._searchView.$('input');
          var $initialVal = input.val();
          input.val($initialVal + ' ');
          input.val($initialVal);
        }
      }.bind(this), 0);
    },
  
    _renderList: function _renderList() {
      this._listView = new CustomListView({
        model: this.model,
        allowFreeTextInput: this.options.allowFreeTextInput,
        collection: this.collection,
        typeLabel: this.options.typeLabel,
        itemView: this.options.itemView,
        itemTemplate: this.options.itemTemplate,
        size: this.options.size,
        mouseOverAction: this._mouseOverAction,
        mouseOutAction: this._mouseOutAction
      });
      this.$el.append(this._listView.render().el);
  
      this._listView.highlight();
      this.addView(this._listView);
  
      this._listView.bind('customEvent', function (eventName, item) {
        this.trigger(eventName, item, this);
      }, this);
    },
  
    highlight: function highlight() {
      this._listView.highlight();
    },
  
    _onVisibleChanged: function _onVisibleChanged(_model, isVisible) {
      this._resetQuery();
      this._toggleVisibility();
  
      isVisible ? this.render() : this.clearSubViews();
    },
  
    _resetQuery: function _resetQuery() {
      var query = this._selectModel && this._selectModel.get(this.options.typeLabel) || '';
      this.model.set('query', query);
  
      var isInCollection = this.collection.findWhere({ val: query });
      if (query && !isInCollection) {
        this.collection.add({ label: query, val: query });
      }
    },
  
    show: function show() {
      this.model.set('visible', true);
    },
  
    hide: function hide() {
      this.trigger('hidden', this);
      this.model.set('visible', false);
    },
  
    toggle: function toggle() {
      this.model.set('visible', !this.model.get('visible'));
    },
  
    _toggleVisibility: function _toggleVisibility() {
      this.$el.toggleClass('is-visible', !!this.model.get('visible'));
    },
  
    isVisible: function isVisible() {
      return this.model.get('visible');
    },
  
    _onMouseOver: function _onMouseOver() {
      this._mouseOverAction && this._mouseOverAction();
    },
  
    _onMouseOut: function _onMouseOut() {
      this._mouseOutAction && this._mouseOutAction();
    },
  
    remove: function remove() {
      this._listView && this._listView.clean();
      CoreView.prototype.remove.call(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/dataset/dataset-base-view.js":
  /*!********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/dataset/dataset-base-view.js ***!
    \********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var SQLNotifications = __webpack_require__(/*! builder/sql-notifications */ "./lib/assets/javascripts/builder/sql-notifications.js");
  var SQLUtils = __webpack_require__(/*! builder/helpers/sql-utils */ "./lib/assets/javascripts/builder/helpers/sql-utils.js");
  var Notifier = __webpack_require__(/*! builder/components/notifier/notifier */ "./lib/assets/javascripts/builder/components/notifier/notifier.js");
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel', 'editorModel', 'layerDefinitionModel', 'querySchemaModel'];
  
  module.exports = CoreView.extend({
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this._clearSQLModel = new Backbone.Model({
        visible: false
      });
  
      this._sqlModel = this._layerDefinitionModel.sqlModel;
  
      this._SQL = new cdb.SQL({
        user: this._configModel.get('user_name'),
        sql_api_template: this._configModel.get('sql_api_template'),
        api_key: this._configModel.get('api_key')
      });
  
      this._codemirrorModel = new Backbone.Model({
        content: this._querySchemaModel.get('query'),
        readonly: false
      });
  
      this._applyButtonStatusModel = new Backbone.Model({
        loading: false
      });
  
      SQLNotifications.track(this);
    },
  
    _internalParseSQL: function _internalParseSQL(callbackAfterAlterSuccess) {
      var appliedQuery = this._querySchemaModel.get('query');
      var currentQuery = this._codemirrorModel.get('content');
  
      // Remove last character if it has ';'
      if (currentQuery && currentQuery.slice(-1) === ';') {
        currentQuery = currentQuery.slice(0, currentQuery.length - 1);
        this._codemirrorModel.set('content', currentQuery);
      }
  
      var isSameQuery = SQLUtils.isSameQuery(currentQuery, appliedQuery);
      var altersData = SQLUtils.altersData(currentQuery);
  
      if (currentQuery === '' || isSameQuery) {
        SQLNotifications.removeNotification();
        return false;
      }
  
      if (altersData) {
        SQLNotifications.showNotification({
          status: 'loading',
          info: _t('notifications.sql.alter-loading'),
          closable: false
        });
  
        this._applyButtonStatusModel.set('loading', true);
  
        this._sqlModel.set('content', currentQuery);
  
        this._SQL.execute(currentQuery, null, {
          success: function () {
            SQLNotifications.showNotification({
              status: 'success',
              info: _t('notifications.sql.alter-success'),
              closable: true,
              delay: Notifier.DEFAULT_DELAY
            });
  
            this._applyButtonStatusModel.set('loading', false);
  
            this._applyDefaultSQLAfterAlteringData();
  
            if (typeof callbackAfterAlterSuccess === 'function') {
              callbackAfterAlterSuccess.call(this);
            }
          }.bind(this),
          error: function (errors) {
            var parsedErrors = this._parseErrors(errors.responseJSON && errors.responseJSON.error);
  
            this._applyButtonStatusModel.set('loading', false);
  
            this._codemirrorModel.set('errors', parsedErrors);
  
            SQLNotifications.showErrorNotification(parsedErrors);
  
            this._checkClearButton();
          }.bind(this)
        });
      } else {
        this._runQuery(currentQuery, this._saveSQL.bind(this));
      }
    },
  
    _checkClearButton: function _checkClearButton() {
      var customSql = this._codemirrorModel.get('content');
      var isDefaultQuery = SQLUtils.isSameQuery(customSql, this._defaultSQL());
      this._clearSQLModel.set({ visible: !isDefaultQuery });
    },
  
    _applyDefaultSQLAfterAlteringData: function _applyDefaultSQLAfterAlteringData() {
      var originalQuery = this._defaultSQL();
      this._codemirrorModel.set({
        content: originalQuery,
        errors: []
      });
      this._sqlModel.set('content', originalQuery);
      this._querySchemaModel.set('query_errors', []);
      this._clearSQLModel.set({ visible: false });
      this._querySchemaModel.resetDueToAlteredData();
      this._clearSQL();
    },
  
    _clearSQL: function _clearSQL() {
      var originalQuery = this._defaultSQL();
      this._codemirrorModel.set({
        content: originalQuery,
        errors: []
      });
      this._runQuery(originalQuery, this._saveSQL.bind(this));
    },
  
    _showErrors: function _showErrors(model) {
      var errors = this._querySchemaModel.get('query_errors');
      this._forceErrors(errors);
      this._checkClearButton();
    },
  
    _forceErrors: function _forceErrors(errors, options) {
      var hasErrors = errors && errors.length > 0;
      var parsedErrors = hasErrors && this._parseErrors(errors);
      var editorErrors = options && options.showEditorError === false ? [] : parsedErrors;
      this._codemirrorModel.set('errors', editorErrors);
      this._editorModel.set('disabled', hasErrors);
  
      if (hasErrors) {
        SQLNotifications.showErrorNotification(parsedErrors);
      }
    },
  
    _parseErrors: function _parseErrors(errors) {
      if (!errors) {
        return [];
      }
  
      errors = _.isArray(errors) ? errors : [errors];
      return errors.map(function (error) {
        return {
          message: error
        };
      });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/date-picker-range/date-picker-range-view.js":
  /*!***********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/date-picker-range/date-picker-range-view.js ***!
    \***********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  __webpack_require__(/*! builder/components/form-components/index */ "./lib/assets/javascripts/builder/components/form-components/index.js");
  __webpack_require__(/*! datepicker */ "./vendor/assets/javascripts/datepicker.js");
  var datePickerTemplate = __webpack_require__(/*! ./date-picker-range-form.tpl */ "./lib/assets/javascripts/builder/components/date-picker-range/date-picker-range-form.tpl");
  var template = __webpack_require__(/*! ./date-picker-range.tpl */ "./lib/assets/javascripts/builder/components/date-picker-range/date-picker-range.tpl");
  
  var MAX_RANGE = 30;
  var FOUR_HOURS = { amount: 4, unit: 'hours' };
  var ONE_DAY = { amount: 1, unit: 'day' };
  var ONE_WEEK = { amount: 1, unit: 'week' };
  
  /**
   * Custom picer for a dates range.
   */
  module.exports = CoreView.extend({
  
    className: 'DatePicker',
  
    options: {
      flat: true,
      date: ['2008-07-31', '2008-07-31'],
      current: '2008-07-31',
      calendars: 2,
      mode: 'range',
      starts: 1
    },
  
    events: {
      'click .js-dates': '_toggleCalendar',
      'click .js-fourHours': function clickJsFourHours() {
        this._setPreviousTime(FOUR_HOURS);
      },
      'click .js-oneDay': function clickJsOneDay() {
        this._setPreviousTime(ONE_DAY);
      },
      'click .js-oneWeek': function clickJsOneWeek() {
        this._setPreviousTime(ONE_WEEK);
      }
    },
  
    initialize: function initialize(opts) {
      var isDisabled = opts && opts.disabled ? opts.disabled : false;
  
      this.model = new Backbone.Model({
        fromDate: '',
        fromHour: 0,
        fromMin: 0,
        toDate: '',
        toHour: 23,
        toMin: 59,
        user_timezone: 0, // Explained as GMT+0
        disabled: isDisabled
      });
  
      this.template = opts.template || template;
  
      this._initBinds();
      this._setDefaultDate();
    },
  
    render: function render() {
      var self = this;
  
      this.clearSubViews();
      this.$el.empty();
  
      this.$el.append(this.template(_.extend(this.model.attributes, {
        max_days: MAX_RANGE,
        pad: Utils.pad
      })));
  
      setTimeout(function () {
        self._initCalendar();
        self._hideCalendar();
        self._initTimers();
      }, 100);
  
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change', this._setValues, this);
      this.model.bind('change', this._onValuesChange, this);
      $(document).bind('click', this._onDocumentClick.bind(this));
    },
  
    _destroyBinds: function _destroyBinds() {
      $(document).unbind('click', this._onDocumentClick.bind(this));
    },
  
    _formattedDate: function _formattedDate(which) {
      var text = 'components.datepicker.' + which;
      return _t(text) + ' ' + '<strong>' + this.model.get(which + 'Date') + ' ' + (Utils.pad(this.model.get(which + 'Hour'), 2) + ':' + Utils.pad(this.model.get(which + 'Min'), 2)) + '</strong>';
    },
  
    _setValues: function _setValues() {
      var text = _t('components.datepicker.dates-placeholder');
      var data = this.model.attributes;
  
      if (data.fromDate && data.toDate) {
        var calendarIcon = '<i class="CDB-IconFont CDB-IconFont-calendar DatePicker-datesIcon"></i>';
        text = this._formattedDate('from') + ' ' + this._formattedDate('to') + calendarIcon;
      }
  
      this.$('.DatePicker-dates').html(text);
    },
  
    _setDefaultDate: function _setDefaultDate() {
      var datesUTC = this.model.get('user_timezone');
      var today = moment().utc(datesUTC);
      var previous = moment().utc(datesUTC).subtract(MAX_RANGE - 1, 'days');
      this.options.date = [previous.format('YYYY-MM-DD'), today.format('YYYY-MM-DD')];
      this.options.current = today.format('YYYY-MM-DD');
      this._setModelFromPrevious(previous);
    },
  
    _initCalendar: function _initCalendar() {
      var selector = '.DatePicker-calendar';
  
      // Can't initialize calendar if not already present in document... avoid errors being thrown
      if (!document.body.contains(this.$(selector)[0])) return;
  
      this.calendar = this.$(selector).DatePicker(_.extend(this.options, {
        onChange: this._onDatesChange.bind(this),
        onRender: function onRender(d) {
          // Disable future dates and dates < MAX_RANGE days ago
          var date = d.valueOf();
          var now = new Date();
  
          var thirtyDaysAgo = new Date();
          thirtyDaysAgo.setDate(now.getDate() - MAX_RANGE);
  
          return date < thirtyDaysAgo || date > now ? { disabled: true } : '';
        }
      }));
    },
  
    _onDatesChange: function _onDatesChange(formatted, dates) {
      // Check if selected dates have more than MAX_RANGE days
      var start = moment(formatted[0]);
      var end = moment(formatted[1]);
  
      if (Math.abs(start.diff(end, 'days')) > MAX_RANGE) {
        formatted[1] = moment(formatted[0]).add('days', MAX_RANGE).format('YYYY-MM-DD');
        this.$('.DatePicker-calendar').DatePickerSetDate([formatted[0], formatted[1]]);
      }
  
      this.model.set({
        fromDate: formatted[0],
        toDate: formatted[1]
      });
    },
  
    _hideCalendar: function _hideCalendar(e) {
      if (e) this.killEvent(e);
      this.$('.DatePicker-dropdown').hide();
    },
  
    _toggleCalendar: function _toggleCalendar(ev) {
      if (ev) this.killEvent(ev);
      this.$('.DatePicker-dropdown').toggle();
    },
  
    _setPreviousTime: function _setPreviousTime(timeSpan) {
      var previous = moment().utc(0).subtract(timeSpan.amount, timeSpan.unit);
      this._setModelFromPrevious(previous);
      this._setDatepickerFromPrevious(previous);
      this.closeCalendar();
    },
  
    _setModelFromPrevious: function _setModelFromPrevious(previous) {
      var today = moment().utc(0);
  
      this.model.set({
        fromDate: previous.format('YYYY-MM-DD'),
        fromHour: parseInt(previous.format('H'), 10),
        fromMin: parseInt(previous.format('m'), 10),
        toDate: today.format('YYYY-MM-DD'),
        toHour: parseInt(today.format('H'), 10),
        toMin: parseInt(today.format('m'), 10)
      });
    },
  
    _setDatepickerFromPrevious: function _setDatepickerFromPrevious(previous) {
      var today = moment().utc(0);
      this.$('.DatePicker-calendar').DatePickerSetDate([previous.format('YYYY-MM-DD'), today.format('YYYY-MM-DD')]);
    },
  
    _initTimers: function _initTimers() {
      var generateNumberType = function generateNumberType(min, max) {
        var title = max === 23 ? _t('components.datepicker.hour') : _t('components.datepicker.min');
        return {
          type: 'Number',
          title: title,
          validators: ['required', {
            type: 'interval',
            min: min,
            max: max
          }]
        };
      };
  
      this.model.schema = {
        fromHour: generateNumberType(0, 23),
        fromMin: generateNumberType(0, 59),
        toHour: generateNumberType(0, 23),
        toMin: generateNumberType(0, 59)
      };
  
      this._datesForm = new Backbone.Form({
        model: this.model,
        template: datePickerTemplate
      });
  
      this._datesForm.bind('change', function () {
        this.commit();
      });
      this.$('.js-timers').append(this._datesForm.render().el);
    },
  
    _onValuesChange: function _onValuesChange() {
      this.trigger('changeDate', this.model.toJSON(), this);
    },
  
    getDates: function getDates() {
      return this.model.toJSON();
    },
  
    closeCalendar: function closeCalendar() {
      this.$('.DatePicker-dropdown').hide();
    },
  
    _onDocumentClick: function _onDocumentClick(e) {
      var $el = $(e.target);
  
      if ($el.closest('.DatePicker').length === 0) {
        this.closeCalendar();
      }
    },
  
    clean: function clean() {
      this._datesForm && this._datesForm.remove();
      this._destroyBinds();
      this.closeCalendar();
      this.$('.DatePicker-calendar').DatePickerHide();
      CoreView.prototype.clean.call(this);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/dialog/dialog-model.js":
  /*!**************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/dialog/dialog-model.js ***!
    \**************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  /**
   * View model of the dialog-view
   */
  module.exports = Backbone.Model.extend({
    defaults: {
      visible: true,
      createContentView: function createContentView() {
        return new CoreView();
      }
    },
  
    createContentView: function createContentView() {
      return this.get('createContentView')(this);
    },
  
    show: function show() {
      this.set('visible', true);
    },
  
    hide: function hide() {
      this.set('visible', false);
    },
  
    isHidden: function isHidden() {
      return !this.get('visible');
    },
  
    /**
     * @override {Backbone.Model.prototype.destroy}
     */
    destroy: function destroy() {
      var args = Array.prototype.slice.call(arguments);
      this.trigger.apply(this, ['destroy'].concat(args));
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/dialog/dialog-view.js":
  /*!*************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/dialog/dialog-view.js ***!
    \*************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var DropdownOverlayView = __webpack_require__(/*! builder/components/dropdown-overlay/dropdown-overlay-view */ "./lib/assets/javascripts/builder/components/dropdown-overlay/dropdown-overlay-view.js");
  
  module.exports = CoreView.extend({
    className: 'Editor-boxModal Editor-FormDialog js-formDialog is-opening',
  
    initialize: function initialize() {
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this._renderContentView();
      return this;
    },
  
    _renderContentView: function _renderContentView() {
      var view = this.model.createContentView();
      this.addView(view);
      this.$el.append(view.render().$el);
  
      this.dropdownOverlay = new DropdownOverlayView({
        onClickAction: this.hide.bind(this),
        visible: true
      });
      this.addView(this.dropdownOverlay);
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this.model, 'change:show', this._onShowChange);
      this.listenTo(this.model, 'destroy', this._onDestroy);
    },
  
    _onShowChange: function _onShowChange(m, show) {
      if (show) {
        this.$el.show();
        this.$el.removeClass('is-closing').addClass('is-opening');
      } else {
        this.$el.removeClass('is-opening').addClass('is-closing');
        this.$el.hide();
      }
    },
  
    show: function show() {
      this.model.show();
    },
  
    hide: function hide() {
      this.model.hide();
    },
  
    _onDestroy: function _onDestroy() {
      this.hide();
      this.dropdownOverlay && this.dropdownOverlay.clean();
      this.clean();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/dropdown-overlay/dropdown-overlay-view.js":
  /*!*********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/dropdown-overlay/dropdown-overlay-view.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  /*
   *  Dropdown overlay to disable all interactions between elements
   *  beneath the dropdown
   */
  module.exports = CoreView.extend({
  
    className: 'CDB-Box-modalOverlay',
  
    events: {
      'click': '_onOverlayClicked'
    },
  
    initialize: function initialize(opts) {
      this.container = opts && opts.container;
      this.onClickAction = opts && opts.onClickAction;
  
      this.model = new Backbone.Model({
        visible: _.isUndefined(opts && opts.visible) ? false : opts.visible
      });
  
      this._initBinds();
      this.render();
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this.model, 'change:visible', this._onVisibilityChange);
    },
  
    render: function render() {
      (this.container || $(document.body)).append(this.$el);
      this.$el.toggle(this.isVisible());
      return this;
    },
  
    _onOverlayClicked: function _onOverlayClicked() {
      this.onClickAction && this.onClickAction();
      this.hide();
    },
  
    show: function show() {
      this.model.set('visible', true);
    },
  
    hide: function hide() {
      this.model.set('visible', false);
    },
  
    toggle: function toggle() {
      this.model.set('visible', !this.model.get('visible'));
    },
  
    isVisible: function isVisible() {
      return this.model.get('visible');
    },
  
    _onVisibilityChange: function _onVisibilityChange() {
      this.$el.toggle(this.isVisible());
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/error/error-view.js":
  /*!***********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/error/error-view.js ***!
    \***********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var baseTemplate = __webpack_require__(/*! ./error.tpl */ "./lib/assets/javascripts/builder/components/error/error.tpl");
  
  /**
   * A typical error view.
   * @param {Object} options
   * @param {String} options.title If not provided will use a generic text as fallback
   * @param {String} options.desc If not provied will use a generic text as fallback
   */
  module.exports = CoreView.extend({
  
    className: 'IntermediateInfo',
  
    initialize: function initialize(opts) {
      var attrs = _.defaults(_.pick(opts, ['title', 'desc']), {
        title: _t('components.error.default-title'),
        desc: _t('components.error.default-desc')
      });
      this._template = this.options && this.options.template || baseTemplate;
      this.model = new Backbone.Model(attrs);
    },
  
    render: function render() {
      this.$el.html(this._html());
      return this;
    },
  
    _html: function _html() {
      var m = this.model;
      return this._template({
        title: m.get('title'),
        desc: cdb.core.sanitize.html(m.get('desc'))
      });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/_constants/_dialogs.js":
  /*!******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/_constants/_dialogs.js ***!
    \******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  module.exports = {
    Mode: {
      NESTED: 'nested',
      FLOAT: 'float',
      DEFAULT: 'nested'
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/_constants/_fill.js":
  /*!***************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/_constants/_fill.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  module.exports = {
    Size: {
      MARKER_MIN: 7,
      IMAGE_MIN: 20,
      DEFAULT: {
        min: 1,
        max: 45,
        step: 0.5
      },
      DefaultInput100: {
        MIN: 0,
        MAX: 100,
        STEP: 1
      },
      DEFAULT_RANGE: [5, 20]
    },
  
    Panes: {
      FIXED: 'fixed',
      BY_VALUE: 'value',
      FILE: 'file'
    },
  
    Tabs: {
      BINS: 'bins',
      QUANTIFICATION: 'quantification'
    },
  
    Quantification: {
      REFERENCE: {
        'Jenks': 'jenks',
        'Equal Interval': 'equal',
        'Heads/Tails': 'headtails',
        'Quantile': 'quantiles'
      }
    },
  
    Settings: {
      COLOR: {
        quantifications: {
          items: ['jenks', 'equal', 'headtails', 'quantiles', 'category'],
          defaultIndex: 0
        }
      },
  
      COLOR_RAMPS: {
        quantifications: {
          items: ['quantiles', 'jenks', 'equal', 'headtails', 'category'],
          defaultIndex: 0
        },
        bins: {
          items: ['2', '3', '4', '5', '6', '7'],
          defaultIndex: 3
        }
      },
  
      NUMBER: {
        quantifications: {
          items: ['quantiles', 'jenks', 'equal', 'headtails'],
          defaultIndex: 0
        },
        bins: {
          items: ['2', '3', '4', '5', '6', '7'],
          defaultIndex: 3
        }
      }
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/_constants/_style.js":
  /*!****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/_constants/_style.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  module.exports = {
    Type: {
      SIMPLE: 'simple',
      ANIMATION: 'animation',
      HEATMAP: 'heatmap',
      POLYGON: 'polygon',
      REGIONS: 'regions',
      HEXABINS: 'hexabins',
      SQUARES: 'squares',
      NONE: 'none'
    },
    Blending: {
      SIMPLE: ['none', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'xor', 'src-over'],
      ANIMATION: ['lighter', 'multiply', 'source-over', 'xor']
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/base.js":
  /*!***********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/base.js ***!
    \***********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var ESC_KEY_CODE = 27;
  
  Backbone.Form.editors.Base = Backbone.Form.editors.Base.extend({
    applyESCBind: function applyESCBind(callback) {
      this._ESCBindCallback = callback;
      this._onKeyDown = this._onKeyDown.bind(this);
      document.addEventListener('keydown', this._onKeyDown);
    },
  
    _onKeyDown: function _onKeyDown(ev) {
      var anyModalOpen;
      if (ev.which === ESC_KEY_CODE) {
        anyModalOpen = this._anyModalOpen();
        !anyModalOpen && this._ESCBindCallback();
      }
    },
  
    applyClickOutsideBind: function applyClickOutsideBind(callback) {
      this._clickBindCallback = callback;
      this._onDocumentClick = this._onDocumentClick.bind(this);
      this.$el.attr('data-cid', this.cid);
      document.addEventListener('click', this._onDocumentClick);
    },
  
    _onDocumentClick: function _onDocumentClick(e) {
      var $el = $(e.target);
      var anyModalOpen = this._anyModalOpen();
      if ($el.closest('[data-cid="' + this.cid + '"]').length === 0 && !anyModalOpen) {
        this._clickBindCallback();
      }
    },
  
    _anyModalOpen: function _anyModalOpen() {
      var modals = this.options.modals;
      if (!modals) {
        return false;
      }
  
      return modals.isOpen();
    },
  
    _destroyBinds: function _destroyBinds() {
      this._removeESCandClickListeners();
    },
  
    _removeESCandClickListeners: function _removeESCandClickListeners() {
      if (this._ESCBindCallback) {
        document.removeEventListener('keydown', this._onKeyDown);
      }
      if (this._clickBindCallback) {
        document.removeEventListener('click', this._onDocumentClick);
      }
    },
  
    remove: function remove() {
      this._destroyBinds && this._destroyBinds();
      Backbone.View.prototype.remove.call(this);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/code-editor.js":
  /*!******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/code-editor.js ***!
    \******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var FactoryHints = __webpack_require__(/*! builder/editor/editor-hints/factory-hints */ "./lib/assets/javascripts/builder/editor/editor-hints/factory-hints.js");
  var CodeMirrorView = __webpack_require__(/*! builder/components/code-mirror/code-mirror-view */ "./lib/assets/javascripts/builder/components/code-mirror/code-mirror-view.js");
  
  Backbone.Form.editors.CodeEditor = Backbone.Form.editors.TextArea.extend({
    render: function render() {
      this.setValue(this.value);
  
      this._codemirrorModel = new Backbone.Model({
        content: this.value,
        readonly: false,
        lineNumbers: false
      });
  
      FactoryHints.init({
        tokens: this.options.tokens,
        tableName: false,
        columnsName: false
      });
  
      this._initViews();
  
      this._toggleDisableState();
  
      return this;
    },
  
    getValue: function getValue() {
      var val = this.$el.val();
  
      val = this.codeMirrorView.getContent();
  
      return val === '' ? null : val;
    },
  
    _initViews: function _initViews() {
      this._destroyEditor();
  
      var hints = FactoryHints.reset().hints;
      this.codeMirrorView = new CodeMirrorView({
        model: this._codemirrorModel,
        hints: hints,
        mode: 'text/mustache',
        autocompleteChars: 2,
        autocompletePrefix: '{{',
        autocompleteSuffix: '}}',
        placeholder: this.options.placeholder
      });
      this.codeMirrorView.bind('codeChanged', function () {
        this.trigger('change', this.codeMirrorView.getContent());
      }, this);
  
      var $codeMirrorEl = $(this.codeMirrorView.render().el);
      this.$el.replaceWith($codeMirrorEl);
      this.setElement($codeMirrorEl);
      this.$el.addClass('CodeMirror-formInput');
      // The default el is replace it with another dom node
      // we should add tracking class manually again
      this._addTrackingClass();
    },
  
    _addTrackingClass: function _addTrackingClass() {
      if (this.options.trackingClass) {
        var trackClasses = this.options.trackingClass + ' track-' + this.options.key + this.options.editorType;
        this.$el.addClass(trackClasses);
      }
    },
  
    _hasEditor: function _hasEditor() {
      return this.options.editor && !!this.codeMirrorView;
    },
  
    _destroyEditor: function _destroyEditor() {
      if (this._hasEditor()) {
        this.codeMirrorView.remove();
      }
    },
  
    remove: function remove() {
      this._destroyEditor();
      Backbone.Form.editors.Base.prototype.remove.apply(this);
    },
  
    clean: function clean() {
      this.$el.remove();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/data-observatory-dropdown-measurements-view.js":
  /*!********************************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/data-observatory-dropdown-measurements-view.js ***!
    \********************************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var StackLayoutView = __webpack_require__(/*! builder/components/stack-layout/stack-layout-view */ "./lib/assets/javascripts/builder/components/stack-layout/stack-layout-view.js");
  var MeasurementsView = __webpack_require__(/*! ./measurements-list-view */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurements-list-view.js");
  var FiltersView = __webpack_require__(/*! ./filters-list-view */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/filters-list-view.js");
  
  var REQUIRED_OPTS = ['filtersCollection', 'measurementsCollection', 'measurementModel', 'region'];
  
  var braces = function braces(value) {
    var template = _.template("'{<%- value %>}'");
    return template({
      value: value
    });
  };
  
  module.exports = CoreView.extend({
    className: 'CDB-Box-modal CustomList',
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      // For internal state
      this.model = new Backbone.Model({
        visible: false
      });
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this._generateStackLayoutView();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this.model, 'change:visible', function (mdl, isVisible) {
        isVisible ? this.render() : this.clearSubViews();
        this._toggleVisibility();
      });
    },
  
    _generateStackLayoutView: function _generateStackLayoutView() {
      var createListView = function (stackLayoutModel, opts) {
        return this._createListView(stackLayoutModel, opts);
      }.bind(this);
  
      var createFilterView = function (stackLayoutModel, opts) {
        return this._createFilterView(stackLayoutModel, opts);
      }.bind(this);
  
      var stackViewCollection = new Backbone.Collection([{
        createStackView: createListView
      }, {
        createStackView: createFilterView
      }]);
  
      this._stackLayoutView = new StackLayoutView({ collection: stackViewCollection });
      this.addView(this._stackLayoutView);
      this.$el.append(this._stackLayoutView.render().$el);
    },
  
    _buildFilters: function _buildFilters() {
      var selectedFilters = this._filtersCollection.getSelected();
      return _.map(selectedFilters, function (filter) {
        return filter.getValue();
      }).join(', ');
    },
  
    _fetchMeasurements: function _fetchMeasurements() {
      var region = this._region;
      var fetchOptions = {
        region: region && braces(region)
      };
  
      return this._measurementsCollection.fetch(fetchOptions);
    },
  
    _fetchMeasurementsWithFilter: function _fetchMeasurementsWithFilter() {
      var region = this._region;
      var filters = this._buildFilters();
  
      var fetchOptions = {
        filters: filters && braces(filters),
        region: region && braces(region)
      };
  
      return this._measurementsCollection.fetch(fetchOptions);
    },
  
    _searchMeasurements: function _searchMeasurements(keyword) {
      var region = this._region;
      var filters = this._buildFilters();
  
      var fetchOptions = {
        filters: filters && braces(filters),
        region: region && braces(region),
        search: keyword,
        abortable: true
      };
  
      return this._measurementsCollection.fetch(fetchOptions);
    },
  
    _fetchFilters: function _fetchFilters() {
      var region = this._region;
      var fetchOptions = {
        region: region && braces(region)
      };
  
      return this._filtersCollection.fetch(fetchOptions);
    },
  
    _fetchCollections: function _fetchCollections() {
      var selectedFilters = this._filtersCollection.getSelected();
  
      if (selectedFilters.length > 0) {
        this._fetchMeasurementsWithFilter();
      } else {
        this._fetchMeasurements();
      }
    },
  
    _createListView: function _createListView(stackLayoutModel, opts) {
      this._fetchCollections();
  
      var view = new MeasurementsView({
        filtersCollection: this._filtersCollection,
        measurementsCollection: this._measurementsCollection,
        searchMeasurements: this._searchMeasurements.bind(this),
        measurementModel: this._measurementModel
      });
  
      view.bind('filters', function () {
        stackLayoutModel.nextStep();
      }, this);
  
      return view;
    },
  
    _createFilterView: function _createFilterView(stackLayoutModel, opts) {
      // FIXME
      // we could save this request, it only depends on region
      if (this._filtersCollection.size() === 0) {
        this._fetchFilters();
      }
  
      var view = new FiltersView({
        filtersCollection: this._filtersCollection
      });
  
      view.bind('back', function () {
        this._measurementsCollection.trigger('maybeFiltersUpdated');
        stackLayoutModel.prevStep();
      }, this);
  
      return view;
    },
  
    hide: function hide() {
      this.model.set('visible', false);
    },
  
    toggle: function toggle() {
      this.model.set('visible', !this.model.get('visible'));
    },
  
    isVisible: function isVisible() {
      return this.model.get('visible');
    },
  
    _toggleVisibility: function _toggleVisibility() {
      this.$el.toggleClass('is-visible', !!this.isVisible());
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/data-observatory-measurements-view.js":
  /*!***********************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/data-observatory-measurements-view.js ***!
    \***********************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  var template = __webpack_require__(/*! ./data-observatory-measurements.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/data-observatory-measurements.tpl");
  var selectedItemTemplate = __webpack_require__(/*! ./data-observatory-measurement-item.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/data-observatory-measurement-item.tpl");
  var DropdownDialogView = __webpack_require__(/*! ./data-observatory-dropdown-measurements-view */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/data-observatory-dropdown-measurements-view.js");
  var PopupManager = __webpack_require__(/*! builder/components/popup-manager */ "./lib/assets/javascripts/builder/components/popup-manager.js");
  var DialogConstants = __webpack_require__(/*! builder/components/form-components/_constants/_dialogs */ "./lib/assets/javascripts/builder/components/form-components/_constants/_dialogs.js");
  var MeasurementsCollection = __webpack_require__(/*! builder/data/data-observatory/measurements-collection */ "./lib/assets/javascripts/builder/data/data-observatory/measurements-collection.js");
  var FiltersCollection = __webpack_require__(/*! builder/data/data-observatory/filters-collection */ "./lib/assets/javascripts/builder/data/data-observatory/filters-collection.js");
  
  var ENTER_KEY_CODE = 13;
  var STATE = {
    idle: 'idle',
    loading: 'loading',
    fetching: 'fetching',
    fetched: 'fetched',
    error: 'error'
  };
  var MEASUREMENT_ATTRIBUTES = ['aggregate', 'type', 'label', 'val', 'description', 'filter', 'license'];
  
  Backbone.Form.editors.DataObservatoryDropdown = Backbone.Form.editors.Base.extend({
  
    tagName: 'div',
    className: 'u-ellipsis Editor-formSelect',
  
    events: {
      'click .js-button': '_onButtonClick',
      'keydown .js-button': '_onButtonKeyDown',
      'focus .js-button': function focusJsButton() {
        this.trigger('focus', this);
      },
      'blur': function blur() {
        this.trigger('blur', this);
      }
    },
  
    options: {
      selectedItemTemplate: selectedItemTemplate
    },
  
    initialize: function initialize(opts) {
      Backbone.Form.editors.Base.prototype.initialize.call(this, opts);
      EditorHelpers.setOptions(this, opts);
  
      this.template = opts.template || template;
      this.dialogMode = this.options.dialogMode || DialogConstants.Mode.DEFAULT;
  
      this.measurementModel = this.options.measurementModel;
  
      var fetchOptions = {
        configModel: this.options.configModel,
        nodeDefModel: this.options.nodeDefModel
      };
  
      this.measurementsCollection = new MeasurementsCollection([], fetchOptions);
      this.filtersCollection = new FiltersCollection([], fetchOptions);
  
      this._initBinds();
  
      this._dialogView = new DropdownDialogView({
        configModel: this.options.configModel,
        nodeDefModel: this.options.nodeDefModel,
        measurementsCollection: this.measurementsCollection,
        filtersCollection: this.filtersCollection,
        measurementModel: this.measurementModel,
        region: this.options.region
      });
    },
  
    render: function render() {
      var isLoading = this._isLoading();
      var isDisabled = this.options.disabled;
      var item = this.measurementModel;
      var placeholder = this._getPlaceholder();
      var isNull = this._hasValue();
      var label = isNull ? placeholder : item.getName();
      var title = item.getName() || '';
  
      this.$el.html(this.template({
        title: title,
        label: label,
        keyAttr: this.options.keyAttr,
        isDisabled: isDisabled,
        isLoading: isLoading,
        isNull: isNull
      }));
  
      this._popupManager = new PopupManager(this.cid, this.$el, this._dialogView.$el);
      this._popupManager.append(this.dialogMode);
  
      if (item) {
        this._renderLicense(item);
      }
  
      return this;
    },
  
    _initBinds: function _initBinds() {
      var hide = function () {
        this._dialogView.hide();
        this._popupManager && this._popupManager.untrack();
      }.bind(this);
  
      this.applyESCBind(hide);
      this.applyClickOutsideBind(hide);
  
      this.listenTo(this.measurementsCollection, 'change:selected', this._onItemSelected);
    },
  
    _destroyBinds: function _destroyBinds() {
      this.stopListening(this.measurementsCollection);
      Backbone.Form.editors.Base.prototype._destroyBinds.call(this);
    },
  
    _getPlaceholder: function _getPlaceholder(isDisabled) {
      var keyAttr = this.options.keyAttr;
      var placeholder = this.options.placeholder || _t('components.backbone-forms.select.placeholder', { keyAttr: keyAttr });
      return placeholder;
    },
  
    _hasValue: function _hasValue() {
      var name = this.measurementModel.getValue();
      return name == null || name === '';
    },
  
    _isLoading: function _isLoading() {
      var state = this.measurementModel.getState();
      return state === STATE.fetching;
    },
  
    _onItemSelected: function _onItemSelected(mdl) {
      var selected = this.measurementsCollection.getSelectedItem();
  
      if (selected) {
        this.measurementModel.clear({ silent: true });
        this.measurementModel.set(_.pick(selected.attributes, MEASUREMENT_ATTRIBUTES));
      }
  
      this._dialogView.hide();
      this._popupManager.untrack();
      this._renderLicense(selected);
      this._renderButton(selected).focus();
  
      this.trigger('change', this);
    },
  
    _onButtonClick: function _onButtonClick() {
      this._dialogView.toggle();
      this._dialogView.isVisible() ? this._popupManager.track() : this._popupManager.untrack();
    },
  
    _onButtonKeyDown: function _onButtonKeyDown(ev) {
      if (ev.which === ENTER_KEY_CODE) {
        ev.preventDefault();
        if (!this._dialogView.isVisible()) {
          ev.stopPropagation();
          this._onButtonClick();
        } else {
          this._popupManager.track();
        }
      }
    },
  
    validate: function validate() {
      var value = this.getValue();
      var validators = this.schema.validators;
      var getValidator = this.getValidator;
  
      if (!validators) return null;
  
      // Run through validators until an error is found
      var error = null;
      _.every(validators, function (validator) {
        error = getValidator(validator)(value, {});
  
        return !!error;
      });
  
      // Return error to be aggregated by list
      return error ? error : null; // eslint-disable-line
    },
  
    focus: function focus() {
      this.$('.js-button').focus();
    },
  
    blur: function blur() {
      this.$('.js-button').blur();
    },
  
    getValue: function getValue() {
      var item = this.measurementModel;
      if (item) {
        return item.getValue();
      } else if (this.value) {
        return this.value;
      }
    },
  
    setValue: function setValue(value) {
      var selectedModel = this.measurementModel;
      if (selectedModel) {
        this._renderButton(selectedModel);
      }
      this.value = value;
    },
  
    _renderButton: function _renderButton(mdl) {
      var button = this.$('.js-button');
      var label = mdl.getName();
      var $html = this.options.selectedItemTemplate({
        label: label
      });
  
      button.removeClass('is-empty').attr('title', label).html($html);
  
      return button;
    },
  
    _renderLicense: function _renderLicense(mdl) {
      var license = mdl.get('license');
      var $license = this.$('.js-license');
      $license.removeClass('u-isHidden').find('span').text(license);
    },
  
    remove: function remove() {
      this._popupManager && this._popupManager.destroy();
      this._dialogView && this._dialogView.clean();
      this._destroyBinds();
      Backbone.Form.editors.Base.prototype.remove.call(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/filter-list-item-view.js":
  /*!**********************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/filter-list-item-view.js ***!
    \**********************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CustomListMultiItemView = __webpack_require__(/*! builder/components/custom-list/custom-list-multi-item-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-multi-item-view.js");
  
  var NAME = _.template('<%-name %> (<%- items %>)');
  
  module.exports = CustomListMultiItemView.extend({
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
  
      var name = this.model.getName() == null ? 'null' : this.model.getName();
      name = name.replace(/"/g, '');
  
      this.$el.append(this.options.template(_.extend({
        isSelected: this.model.get('selected'),
        isDisabled: this.model.get('disabled'),
        name: NAME({
          name: name,
          items: this.model.get('items')
        }),
        val: this.model.getValue(),
        description: this.model.get('description')
      })));
  
      this.$el.attr('data-val', this.model.getValue()).toggleClass('is-disabled', !!this.model.get('disabled'));
  
      return this;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/filters-list-view.js":
  /*!******************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/filters-list-view.js ***!
    \******************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var CustomListView = __webpack_require__(/*! builder/components/custom-list/custom-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-view.js");
  var CustomListItemView = __webpack_require__(/*! ./filter-list-item-view */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/filter-list-item-view.js");
  var itemListTemplate = __webpack_require__(/*! ./filter-list-item.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/filter-list-item.tpl");
  var template = __webpack_require__(/*! ./filter-list-view.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/filter-list-view.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var statusTemplate = __webpack_require__(/*! ./list-view-states.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/list-view-states.tpl");
  
  var REQUIRED_OPTS = ['filtersCollection'];
  
  module.exports = CoreView.extend({
    events: {
      'click .js-back': '_onClickBack'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this._initBinds();
  
      this._listView = new CustomListView({
        className: 'DO-Filters',
        typeLabel: _t('components.backbone-forms.data-observatory.dropdown.filter.item-label'),
        showSearch: false,
        collection: this._filtersCollection,
        itemTemplate: itemListTemplate,
        itemView: CustomListItemView
      });
  
      this.addView(this._listView);
    },
  
    render: function render() {
      this.$el.append(template({
        headerTitle: _t('components.backbone-forms.data-observatory.dropdown.filter.header')
      }));
  
      this._renderListSection();
      return this;
    },
  
    _renderListSection: function _renderListSection() {
      var status = this._filtersCollection.stateModel.get('state');
      if (status === 'fetched') {
        this.$('.js-content').html(this._listView.render().$el);
      } else {
        this._createStatusView(status);
      }
    },
  
    _createStatusView: function _createStatusView(status) {
      var el = statusTemplate({
        status: status,
        type: _t('components.backbone-forms.data-observatory.dropdown.filter.type')
      });
  
      this.$('.js-content').html(el);
    },
  
    _onClickBack: function _onClickBack(e) {
      this.killEvent(e);
      this.trigger('back', this);
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this._filtersCollection.stateModel, 'change:state', this._renderListSection, this);
      this.listenTo(this._filtersCollection, 'change:selected', this._onSelectItem, this);
    },
  
    _onSelectItem: function _onSelectItem(item) {
      this.trigger('selectItem', item, this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurement-item.js":
  /*!*****************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurement-item.js ***!
    \*****************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var NestedForm = __webpack_require__(/*! builder/components/form-components/nested-form-custom */ "./lib/assets/javascripts/builder/components/form-components/nested-form-custom.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  
  Backbone.Form.editors.List.MeasurementModel = Backbone.Form.editors.NestedModel.extend({
    initialize: function initialize(options) {
      Backbone.Form.editors.Base.prototype.initialize.call(this, options);
      EditorHelpers.setOptions(this, options);
  
      if (!this.form) throw new Error('Missing required option "form"');
      if (!options.schema.model) throw new Error('Missing required "schema.model" option for NestedModel editor');
    },
  
    render: function render() {
      var data = this.value || {};
      var NestedModel = this.schema.model;
  
      // Wrap the data in a model if it isn't already a model instance
      var modelInstance = data.constructor === NestedModel ? data : new NestedModel(data, this.options);
  
      this.nestedForm = new NestedForm({
        className: 'Editor-formInner--nested',
        model: modelInstance,
        idPrefix: this.cid + '_',
        fieldTemplate: 'nestedField',
        template: _.template('<form data-fields="*"></form>'),
        trackingClass: this.options.trackingClass
      });
  
      this._observeFormEvents();
  
      this.listenTo(this.nestedForm, 'change', this._onChangeForm, this);
      // Render form
      this.$el.html(this.nestedForm.render().el);
  
      if (this.hasFocus) {
        this.trigger('blur', this);
      }
  
      return this;
    },
  
    _onChangeForm: function _onChangeForm() {
      // To translate values and validation to parent form
      this.nestedForm.commit();
    },
  
    remove: function remove() {
      this.nestedForm && this.nestedForm.remove();
      Backbone.Form.editors.NestedModel.prototype.remove.call(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurement-list-item-view.js":
  /*!***************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurement-list-item-view.js ***!
    \***************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var BaseView = __webpack_require__(/*! builder/components/custom-list/custom-list-item-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item-view.js");
  
  module.exports = BaseView.extend({
    render: function render() {
      this.$el.empty();
      this.clearSubViews();
  
      var name = this.model.getName() == null ? 'null' : this.model.getName();
      var isSelected = this.model.get('selected');
  
      this.$el.append(this.options.template(_.extend({
        isSelected: isSelected,
        isDisabled: this.model.get('disabled'),
        name: name,
        val: this.model.getValue(),
        description: this.model.get('description')
      })));
  
      this.$el.attr('data-val', this.model.getValue()).attr('data-selected', isSelected).toggleClass('is-disabled', !!this.model.get('disabled'));
  
      return this;
    },
  
    _onMouseLeave: function _onMouseLeave() {
      var selected = this.$el.attr('data-selected');
      if (!selected) {
        this.$el.removeClass('is-highlighted');
      }
    },
  
    _onMouseEnter: function _onMouseEnter() {
      var selected = this.$el.attr('data-selected');
      if (!selected) {
        this.$el.addClass('is-highlighted');
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurements-count-view.js":
  /*!************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurements-count-view.js ***!
    \************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var template = __webpack_require__(/*! ./measurements-count.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurements-count.tpl");
  
  var REQUIRED_OPTS = ['model'];
  
  module.exports = CoreView.extend({
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
      this._initBinds();
    },
  
    render: function render() {
      var query = this.model.get('query');
      var isFiltering = this.model.get('filtering');
      var items = this.model.get('items');
      var count;
  
      if (query === '' && !isFiltering) {
        count = _t('analyses.data-observatory-measure.count.suggested');
      } else {
        count = _t('analyses.data-observatory-measure.count.search', {
          items: items
        });
      }
  
      this.$el.html(template({
        items: count
      }));
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this.model, 'change:items', this.render);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurements-list-view.js":
  /*!***********************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurements-list-view.js ***!
    \***********************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var CustomListView = __webpack_require__(/*! builder/components/custom-list/custom-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-view.js");
  var CustomListItemView = __webpack_require__(/*! ./measurement-list-item-view */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurement-list-item-view.js");
  var itemListTemplate = __webpack_require__(/*! ./measurement-list-item.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurement-list-item.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var template = __webpack_require__(/*! ./measurements-list.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurements-list.tpl");
  var SearchMeasurementView = __webpack_require__(/*! ./measurements-search-view */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurements-search-view.js");
  var CountMeasurementView = __webpack_require__(/*! ./measurements-count-view */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurements-count-view.js");
  var statusTemplate = __webpack_require__(/*! ./list-view-states.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/list-view-states.tpl");
  
  var REQUIRED_OPTS = ['filtersCollection', 'measurementsCollection', 'searchMeasurements', 'measurementModel'];
  
  module.exports = CoreView.extend({
    options: {
      maxItems: 100
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this.model = new Backbone.Model({
        query: '',
        items: this.options.maxItems,
        filtered: false
      });
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this.$el.html(template());
      this._createSearchView();
      this._createCountView();
      this._renderListSection();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this._measurementsCollection.stateModel, 'change:state', this._renderListSection);
      this.listenTo(this.model, 'change:query', this._search);
    },
  
    _createListView: function _createListView() {
      if (this._listView) {
        this._listView.clean();
        this.removeView(this._listView);
      }
  
      if (!this._isSerching()) {
        this._promoteSelected();
      }
  
      this.model.set({
        items: this._measurementsCollection.size(),
        filtering: this._isFiltering()
      });
  
      this._listView = new CustomListView({
        typeLabel: _t('components.backbone-forms.data-observatory.dropdown.measurement.type'),
        showSearch: false,
        itemView: CustomListItemView,
        collection: this._measurementsCollection,
        itemTemplate: itemListTemplate
      });
  
      this.addView(this._listView);
      this._listView.show();
      this.$('.js-list').html(this._listView.$el);
    },
  
    _createStatusView: function _createStatusView(status) {
      var el = statusTemplate({
        status: status,
        type: _t('components.backbone-forms.data-observatory.dropdown.measurement.type')
      });
  
      this.$('.js-list').html(el);
    },
  
    _renderListSection: function _renderListSection() {
      var status = this._measurementsCollection.stateModel.get('state');
  
      if (status === 'fetched') {
        this._createListView();
      } else {
        this._createStatusView(status);
      }
    },
  
    _createSearchView: function _createSearchView() {
      this._searchView = new SearchMeasurementView({
        model: this.model,
        filtersCollection: this._filtersCollection
      });
      this.addView(this._searchView);
      this.$('.js-search').append(this._searchView.render().el);
  
      this.listenTo(this._searchView, 'filters', this._onClickFilters);
    },
  
    _onClickFilters: function _onClickFilters(e) {
      this.killEvent(e);
      this.trigger('filters');
    },
  
    _createCountView: function _createCountView() {
      var view = new CountMeasurementView({
        model: this.model
      });
      this.addView(view);
      this.$('.js-count').append(view.render().el);
    },
  
    _search: function _search() {
      var keyword = this.model.get('query');
  
      // This function is passed from the parent
      this._searchMeasurements(keyword);
    },
  
    _isSerching: function _isSerching() {
      return !!this.model.get('query');
    },
  
    _isFiltering: function _isFiltering() {
      var selectedFilters = this._filtersCollection.getSelected();
      return selectedFilters.length > 0;
    },
  
    _promoteSelected: function _promoteSelected() {
      var selected = this._measurementModel;
      if (!selected.getValue()) {
        return;
      }
  
      var hit = this._measurementsCollection.findWhere({ val: selected.getValue() });
  
      if (hit) {
        this._measurementsCollection.remove(hit);
      }
  
      var promoted = _.clone(selected.attributes);
      promoted.selected = true;
  
      this._measurementsCollection.add(promoted, { at: 0 });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurements-search-view.js":
  /*!*************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurements-search-view.js ***!
    \*************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var template = __webpack_require__(/*! ./measurements-search.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurements-search.tpl");
  
  var REQUIRED_OPTS = ['model', 'filtersCollection'];
  
  module.exports = CoreView.extend({
    className: 'CDB-Box-modalHeader',
  
    events: {
      'input .js-input-search': '_search',
      'click .js-filters': '_onClickFilters'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
    },
  
    render: function render() {
      var label = this._getSearchLabel();
      this.$el.html(template({
        label: label
      }));
  
      // Focus the input when rendered
      setTimeout(function () {
        this._getInput().focus();
      }.bind(this), 100);
  
      return this;
    },
  
    _getSearchLabel: function _getSearchLabel() {
      var selectedFilters = this._filtersCollection.getSelected().length;
      var label = _t('analyses.data-observatory-measure.filters.label');
      if (selectedFilters === 1) {
        label = _t('analyses.data-observatory-measure.filters.applied.single');
      } else if (selectedFilters > 1) {
        label = _t('analyses.data-observatory-measure.filters.applied.multiple', {
          filters: selectedFilters
        });
      }
  
      return label;
    },
  
    _onClickFilters: function _onClickFilters(e) {
      this.killEvent(e);
      this.trigger('filters');
    },
  
    _search: _.debounce(function (e) {
      var query = this._getInput().val();
      query = query.toLowerCase();
      query = utils.sanitizeHtml(query);
      this.model.set('query', query);
    }, 500),
  
    _getInput: function _getInput() {
      return this.$('.js-input-search');
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/datetime/datetime-dialog-model.js":
  /*!*************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/datetime/datetime-dialog-model.js ***!
    \*************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   * View model of the fill dialog
   */
  module.exports = Backbone.Model.extend({
  
    defaults: {
      show: false
    },
  
    show: function show() {
      this.set('show', true);
    },
  
    hide: function hide() {
      this.set('show', false);
    },
  
    isHidden: function isHidden() {
      return !this.get('show');
    },
  
    /**
     * @override {Backbone.Model.prototype.destroy}
     */
    destroy: function destroy() {
      var args = Array.prototype.slice.call(arguments);
      this.trigger.apply(this, ['destroy'].concat(args));
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/datetime/datetime-dialog-view.js":
  /*!************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/datetime/datetime-dialog-view.js ***!
    \************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var DatetimeEditorView = __webpack_require__(/*! ./datetime-editor-view */ "./lib/assets/javascripts/builder/components/form-components/editors/datetime/datetime-editor-view.js");
  
  module.exports = CoreView.extend({
  
    className: 'CDB-Box-modal CustomList CustomList--inputs is-visible has-visibility js-datetimePicker',
  
    initialize: function initialize() {
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
  
      this._datetimeEditorView = new DatetimeEditorView({
        model: this.model
      });
      this.addView(this._datetimeEditorView);
      this.$el.append(this._datetimeEditorView.render().el);
  
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this.model, 'change:show', this._onShowChange);
      this.listenTo(this.model, 'destroy', this._onDestroy);
    },
  
    _onShowChange: function _onShowChange(mdl, show) {
      if (show) {
        this.$el.show();
        this.$el.removeClass('is-closing').addClass('is-opening');
      } else {
        this.$el.removeClass('is-opening').addClass('is-closing');
        this.$el.hide();
      }
    },
  
    show: function show() {
      this.model.show();
    },
  
    hide: function hide() {
      this.model.hide();
    },
  
    _onDestroy: function _onDestroy() {
      this.hide();
      this.clean();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/datetime/datetime-editor-model.js":
  /*!*************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/datetime/datetime-editor-model.js ***!
    \*************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  
  var MONTHS = [{
    val: 0,
    label: _t('months.january')
  }, {
    val: 1,
    label: _t('months.february')
  }, {
    val: 2,
    label: _t('months.march')
  }, {
    val: 3,
    label: _t('months.april')
  }, {
    val: 4,
    label: _t('months.may')
  }, {
    val: 5,
    label: _t('months.june')
  }, {
    val: 6,
    label: _t('months.july')
  }, {
    val: 7,
    label: _t('months.august')
  }, {
    val: 8,
    label: _t('months.september')
  }, {
    val: 9,
    label: _t('months.october')
  }, {
    val: 10,
    label: _t('months.november')
  }, {
    val: 11,
    label: _t('months.december')
  }];
  
  module.exports = Backbone.Model.extend({
  
    initialize: function initialize() {
      this.schema = {
        day: {
          type: 'Text',
          title: '',
          validators: ['required', /^(([0]?[1-9])|([1-2][0-9])|(3[01]))$/, function (value, formValues) {
            var date = moment(Utils.formatDate(formValues));
            if (!date.isValid()) {
              return {
                type: 'date',
                message: _t('components.datepicker.invalid-date')
              };
            }
          }]
        },
        month: {
          type: 'Select',
          title: '',
          position: {
            'left': 0,
            'min-width': '200px'
          },
          options: MONTHS
        },
        year: {
          title: '',
          type: 'Text',
          validators: ['required', /^([0-9]{0,4})$/]
        },
        time: {
          title: '',
          type: 'Text',
          validators: ['required', /^([01]{1}[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/]
        }
      };
    },
  
    getFormattedDate: function getFormattedDate() {
      return Utils.formatDate(this.toJSON());
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/datetime/datetime-editor-view.js":
  /*!************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/datetime/datetime-editor-view.js ***!
    \************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  var DatetimeEditorModel = __webpack_require__(/*! ./datetime-editor-model */ "./lib/assets/javascripts/builder/components/form-components/editors/datetime/datetime-editor-model.js");
  
  module.exports = CoreView.extend({
  
    tagName: 'div',
    className: 'Table-editorDate',
  
    events: {
      'keyup': '_onKeyUp'
    },
  
    initialize: function initialize() {
      var dateAttr = this.model.get('value');
      var date = {};
  
      if (!dateAttr) {
        date = moment().utc();
      } else {
        date = moment(dateAttr).utc();
      }
  
      this._formModel = new DatetimeEditorModel({
        day: date.date(),
        month: date.month(),
        year: date.year(),
        time: date.format('HH:mm:ss'),
        utcOffset: date.utcOffset()
      });
      this._formModel.bind('change', this._setValue, this);
      this.add_related_model(this._formModel);
  
      this._setValue();
    },
  
    render: function render() {
      this._formView = new Backbone.Form({
        model: this._formModel
      });
  
      this._formView.bind('change', function () {
        this.commit();
      });
  
      this.$el.html(this._formView.render().el);
  
      return this;
    },
  
    _setValue: function _setValue() {
      this.model.set('value', this._formModel.getFormattedDate());
    },
  
    _onKeyUp: function _onKeyUp() {
      this._setValue();
    },
  
    clean: function clean() {
      this._formView.remove();
      CoreView.prototype.clean.apply(this);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/datetime/datetime.js":
  /*!************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/datetime/datetime.js ***!
    \************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  
  var DatetimeDialogModel = __webpack_require__(/*! ./datetime-dialog-model */ "./lib/assets/javascripts/builder/components/form-components/editors/datetime/datetime-dialog-model.js");
  var DatetimeDialogView = __webpack_require__(/*! ./datetime-dialog-view */ "./lib/assets/javascripts/builder/components/form-components/editors/datetime/datetime-dialog-view.js");
  var template = __webpack_require__(/*! ./datetime.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/datetime/datetime.tpl");
  
  var DialogConstants = __webpack_require__(/*! builder/components/form-components/_constants/_dialogs */ "./lib/assets/javascripts/builder/components/form-components/_constants/_dialogs.js");
  var PopupManager = __webpack_require__(/*! builder/components/popup-manager */ "./lib/assets/javascripts/builder/components/popup-manager.js");
  
  Backbone.Form.editors.DateTime = Backbone.Form.editors.Base.extend({
    className: 'Editor-formInput u-flex u-alignCenter',
  
    events: {
      'click .js-input': '_onInputClick'
    },
  
    initialize: function initialize(opts) {
      Backbone.Form.editors.Base.prototype.initialize.call(this, opts);
      EditorHelpers.setOptions(this, opts);
  
      this.dialogMode = this.options.dialogMode || DialogConstants.Mode.DEFAULT;
      this._initBinds();
      this.render();
    },
  
    render: function render() {
      Backbone.Form.editors.Base.prototype.render.apply(this, arguments);
  
      this._removeDateTimeDialog();
  
      this.$el.html(template({
        value: this._getFormattedDatetime()
      }));
  
      this._initViews();
  
      return this;
    },
  
    _getFormattedDatetime: function _getFormattedDatetime() {
      if (this.value) {
        var value = new Date(this.value).toUTCString();
        var momentObj = moment(value).utc();
        return momentObj.format('YYYY-MM-DD') + 'T' + momentObj.format('HH:mm:ss') + 'Z';
      }
  
      // for datetime type, empty '' value raises an error on Postgres
      return null;
    },
  
    _initViews: function _initViews() {
      if (this.options.editorAttrs && this.options.editorAttrs.disabled) {
        this.$el.addClass('is-disabled');
      }
  
      this._datetimeDialogModel = new DatetimeDialogModel({
        value: this._getFormattedDatetime()
      });
      this._datetimeDialogModel.bind('change:value', this._onInputChanged, this);
  
      this._datetimeDialogView = new DatetimeDialogView({
        model: this._datetimeDialogModel
      });
  
      this._popupManager = new PopupManager(this.cid, this.$el, this._datetimeDialogView.$el);
    },
  
    _initBinds: function _initBinds() {
      var hide = function () {
        this._removeDateTimeDialog();
      }.bind(this);
      this.applyESCBind(hide);
      this.applyClickOutsideBind(hide);
    },
  
    _onInputClick: function _onInputClick() {
      this._datetimeDialogView.render();
      this._popupManager.append(this.dialogMode);
      this._popupManager.track();
    },
  
    _removeDateTimeDialog: function _removeDateTimeDialog() {
      if (this._datetimeDialogView) {
        this._popupManager.untrack();
        this._datetimeDialogView.remove();
      }
    },
  
    _onInputChanged: function _onInputChanged(mdl) {
      var value = this._datetimeDialogModel.get('value');
      this.setValue(value);
  
      this.trigger('change', this);
    },
  
    _updateInput: function _updateInput(value) {
      this.$('.js-input').toggleClass('is-empty', !value).text(value);
    },
  
    getValue: function getValue() {
      return this._datetimeDialogModel.get('value');
    },
  
    setValue: function setValue(value) {
      this._updateInput(value);
      this.value = value;
    },
  
    remove: function remove() {
      this._removeDateTimeDialog();
      this._popupManager && this._popupManager.destroy();
      Backbone.Form.editors.Base.prototype.remove.apply(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/enabler-editor/enabler-editor-view.js":
  /*!*****************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/enabler-editor/enabler-editor-view.js ***!
    \*****************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  var template = __webpack_require__(/*! ./enabler-editor.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/enabler-editor/enabler-editor.tpl");
  
  /**
   *  Creates an element that enables another component, tested with:
   *
   *  select, number and input so far.
   */
  
  Backbone.Form.editors.EnablerEditor = Backbone.Form.editors.Base.extend({
    tagName: 'div',
    className: 'Editor-checker u-flex u-alignCenter',
  
    events: {
      'click .js-check': '_onCheckClicked'
    },
  
    initialize: function initialize(opts) {
      Backbone.Form.editors.Base.prototype.initialize.call(this, opts);
      EditorHelpers.setOptions(this, opts);
  
      // Disable validators unless it's enabled
      this.validators = null;
  
      if (!this.options.editor) {
        throw new Error('editor options is required');
      }
  
      this._editorOptions = this.options.editor;
      this.value = this.model.get(opts.key);
      this._checkModel = new Backbone.Model({
        enabled: !!this.value
      });
      this.template = template;
  
      this._initBinds();
    },
  
    render: function render() {
      this.$el.html(this.template({
        label: this.options.label,
        isChecked: this._isChecked(),
        help: this.options.help || '',
        isDisabled: !!this.options.isDisabled,
        id: this.cid
      }));
  
      if (this.options.help) {
        this._helpTooltip = new TipsyTooltipView({
          el: this.$('.js-help'),
          gravity: 's',
          offset: 0,
          title: function title() {
            return $(this).data('tooltip');
          }
        });
      }
  
      this._renderComponent();
  
      return this;
    },
  
    _initBinds: function _initBinds() {
      this._checkModel.bind('change:enabled', function (mdl, isEnabled) {
        this._manageValue(isEnabled);
        this._renderComponent();
        this._triggerChange();
      }, this);
    },
  
    _manageValue: function _manageValue(isEnabled) {
      if (isEnabled) {
        this.validators = this.options.validators;
        this.value = this.options.defaultValue || '';
        this._editorComponent.setValue(this.options.defaultValue || '');
      } else {
        this.validators = null;
        this.value = '';
        this._editorComponent.setValue('');
      }
      this.model.set(this.options.keyAttr, this.value);
      this.validate();
    },
  
    _isChecked: function _isChecked() {
      return this._checkModel.get('enabled');
    },
  
    _renderComponent: function _renderComponent() {
      if (this._editorComponent) {
        this._removeComponent();
      }
  
      var isDisabled = !this._isChecked() || this.options.isDisabled;
      var EditorClass = Backbone.Form.editors[this._editorOptions.type];
      var editorAttrs = _.extend(this._editorOptions.editorAttrs || {}, {
        disabled: isDisabled
      });
  
      this._editorComponent = new EditorClass(_.extend({
        model: this.model,
        key: this.options.keyAttr,
        editorAttrs: editorAttrs,
        trackingClass: this.options.trackingClass,
        editorType: this._editorOptions.type
      }, _.omit(this._editorOptions, 'editorAttrs', 'type')));
      this._editorComponent.bind('change', this._setEditorComponentValue, this);
      this.$('.js-editor').html(this._editorComponent.render().el);
  
      // Not all editor implement the focus method
      try {
        this._editorComponent.focus();
      } catch (e) {}
    },
  
    _removeComponent: function _removeComponent() {
      this._editorComponent.remove();
      this._editorComponent.unbind('change', this._setEditorComponentValue, this);
    },
  
    _setEditorComponentValue: function _setEditorComponentValue() {
      this.value = this._editorComponent.getValue();
      this._triggerChange();
    },
  
    _triggerChange: function _triggerChange() {
      this.trigger('change', this);
    },
  
    getValue: function getValue() {
      if (this._checkModel.get('enabled')) {
        return this._editorComponent && this._editorComponent.getValue() || '';
      } else {
        return '';
      }
    },
  
    setValue: function setValue(value) {
      this._checkModel.set('enabled', !!value);
      if (this._editorComponent) {
        this._editorComponent.setValue(value);
      }
      this.value = value;
    },
  
    _onCheckClicked: function _onCheckClicked(ev) {
      this._checkModel.set('enabled', $(ev.target).is(':checked'));
    },
  
    remove: function remove() {
      if (this._editorComponent) {
        this._removeComponent();
      }
      if (this._helpTooltip) {
        this._helpTooltip.clean();
      }
      Backbone.Form.editors.Base.prototype.remove.call(this);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/enabler/enabler-view.js":
  /*!***************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/enabler/enabler-view.js ***!
    \***************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  var template = __webpack_require__(/*! ./enabler.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/enabler/enabler.tpl");
  var templateReversed = __webpack_require__(/*! ./enabler-reversed.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/enabler/enabler-reversed.tpl");
  
  Backbone.Form.editors.Enabler = Backbone.Form.editors.Base.extend({
    tagName: 'div',
  
    events: {
      'change .js-input': '_onCheckChange',
      'focus .js-input': function focusJsInput() {
        this.trigger('focus', this);
      },
      'blur .js-input': function blurJsInput() {
        this.trigger('blur', this);
      }
    },
  
    initialize: function initialize(opts) {
      Backbone.Form.editors.Base.prototype.initialize.call(this, opts);
      EditorHelpers.setOptions(this, opts);
  
      this.template = opts.schema && opts.schema.editorAttrs && opts.schema.editorAttrs.reversed ? templateReversed : opts.template || template;
      this._initViews();
    },
  
    _initViews: function _initViews() {
      this.$el.html(this.template({
        checked: this.options.disabled ? false : this.model.get(this.options.key),
        label: this.options.label,
        id: this.options.inputId,
        title: this.options.title,
        help: this.options.help || '',
        disabled: this.options.disabled
      }));
  
      if (this.options.help) {
        this._removeTooltip();
  
        this._helpTooltip = new TipsyTooltipView({
          el: this.$('.js-help'),
          gravity: 's',
          title: function title() {
            return $(this).data('tooltip');
          }
        });
      }
  
      if (this.options.disabled) {
        this.undelegateEvents();
      }
    },
  
    _onCheckChange: function _onCheckChange() {
      var isEnabled = this.$('.js-input').is(':checked');
      this.model.set('enabler', isEnabled);
      this.trigger('change', this);
    },
  
    getValue: function getValue() {
      return this.$('.js-input').is(':checked');
    },
  
    setValue: function setValue(value) {
      this.$('.js-input')[value ? 'attr' : 'removeAttr']('checked', '');
      this.model.set(this.key, value);
    },
  
    _removeTooltip: function _removeTooltip() {
      if (this._helpTooltip) {
        this._helpTooltip.clean();
      }
    },
  
    remove: function remove() {
      this._removeTooltip();
      Backbone.Form.editors.Base.prototype.remove.apply(this);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/fill-color/fill-color-by-value-view.js":
  /*!******************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/fill-color/fill-color-by-value-view.js ***!
    \******************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var InputFillView = __webpack_require__(/*! builder/components/input-fill/input-fill-view */ "./lib/assets/javascripts/builder/components/input-fill/input-fill-view.js");
  var InputColorByValueView = __webpack_require__(/*! builder/components/form-components/editors/fill-color/inputs/input-color-by-value */ "./lib/assets/javascripts/builder/components/form-components/editors/fill-color/inputs/input-color-by-value.js");
  var FillConstants = __webpack_require__(/*! builder/components/form-components/_constants/_fill */ "./lib/assets/javascripts/builder/components/form-components/_constants/_fill.js");
  
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['columns', 'query', 'configModel', 'userModel', 'editorAttrs', 'modals', 'dialogMode', 'valueColorInputModel', 'popupConfig'];
  
  module.exports = InputFillView.extend({
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      this._initViews();
    },
  
    _initInputFields: function _initInputFields() {
      InputFillView.prototype._initInputFields.call(this);
  
      this._initColorByValueInput();
    },
  
    _initColorByValueInput: function _initColorByValueInput() {
      var quantification = this._valueColorInputModel.get('quantification');
  
      if (quantification && FillConstants.Quantification.REFERENCE[quantification]) {
        this._valueColorInputModel.set('quantification', FillConstants.Quantification.REFERENCE[quantification], {
          silent: true
        });
      }
  
      this._valueColorInputView = new InputColorByValueView({
        model: this._valueColorInputModel,
        columns: this.options.columns,
        hideNumericColumns: this.options.hideNumericColumns,
        removeByValueCategory: this.options.removeByValueCategory,
        query: this.options.query,
        configModel: this.options.configModel,
        userModel: this.options.userModel,
        modals: this.options.modals,
        imageEnabled: this.options.imageEnabled,
        editorAttrs: this.options.editorAttrs ? this.options.editorAttrs : {},
        disabled: this.options.editorAttrs && this.options.editorAttrs.disabled
      });
  
      this._valueColorInputView.bind('click', this._onInputClick, this);
      this.$('.js-content').append(this._valueColorInputView.render().$el);
  
      this._inputCollection && this._inputCollection.push(this._valueColorInputModel);
    },
  
    afterRender: function afterRender() {
      this._valueColorInputView && this._valueColorInputView.afterRender();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/fill-color/fill-color-fixed-view.js":
  /*!***************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/fill-color/fill-color-fixed-view.js ***!
    \***************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var InputFillView = __webpack_require__(/*! builder/components/input-fill/input-fill-view */ "./lib/assets/javascripts/builder/components/input-fill/input-fill-view.js");
  var InputColorFixedView = __webpack_require__(/*! builder/components/form-components/editors/fill-color/inputs/input-color-fixed */ "./lib/assets/javascripts/builder/components/form-components/editors/fill-color/inputs/input-color-fixed.js");
  var InputImageView = __webpack_require__(/*! builder/components/form-components/editors/fill-color/inputs/input-image */ "./lib/assets/javascripts/builder/components/form-components/editors/fill-color/inputs/input-image.js");
  
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['columns', 'editorAttrs', 'dialogMode', 'popupConfig', 'fixedColorInputModel', 'imageInputModel'];
  
  module.exports = InputFillView.extend({
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      if (this._editorAttrs.imageEnabled) {
        this._configModel = this.options.configModel;
        this._userModel = this.options.userModel;
        this._modals = this.options.modals;
      }
  
      this._initViews();
    },
  
    _initInputFields: function _initInputFields() {
      InputFillView.prototype._initInputFields.call(this);
  
      this._initFillColorInput();
      this._initFillImageInput();
    },
  
    _initFillColorInput: function _initFillColorInput() {
      this._fillInputColorView = new InputColorFixedView({
        model: this._fixedColorInputModel,
        columns: this._columns,
        configModel: this._configModel,
        userModel: this._userModel,
        modals: this._modals,
        editorAttrs: this._editorAttrs || {},
        disabled: this._editorAttrs && this._editorAttrs.disabled
      });
  
      this._fillInputColorView.bind('click', this._onInputClick, this);
      this.$('.js-content').append(this._fillInputColorView.render().$el);
  
      this._inputCollection && this._inputCollection.push(this._fixedColorInputModel);
    },
  
    _initFillImageInput: function _initFillImageInput() {
      if (this._editorAttrs.imageEnabled) {
        this._fillInputImageView = new InputImageView({
          model: this._imageInputModel,
          columns: this._columns,
          configModel: this._configModel,
          userModel: this._userModel,
          modals: this._modals,
          query: this._query,
          editorAttrs: this._editorAttrs || {},
          disabled: this._editorAttrs && this._editorAttrs.disabled
        });
  
        this._fillInputImageView.bind('click', this._onInputClick, this);
        this.$('.js-content').append(this._fillInputImageView.render().$el);
  
        this._inputCollection && this._inputCollection.push(this._imageInputModel);
      }
    },
  
    _unbindFormInputs: function _unbindFormInputs() {
      this._fillInputColorView.unbind('click', this._onInputClick, this);
      if (this._fillInputImageView) {
        this._fillInputImageView.unbind('click', this._onInputClick, this);
      }
      this._inputCollection.unbind('onInputChanged', this._onInputChanged, this);
    },
  
    clean: function clean() {
      this._unbindFormInputs();
      InputFillView.prototype.clean.call(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/fill-color/fill-color.js":
  /*!****************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/fill-color/fill-color.js ***!
    \****************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  
  var FillColorFixedView = __webpack_require__(/*! builder/components/form-components/editors/fill-color/fill-color-fixed-view */ "./lib/assets/javascripts/builder/components/form-components/editors/fill-color/fill-color-fixed-view.js");
  var FillColorByValueView = __webpack_require__(/*! builder/components/form-components/editors/fill-color/fill-color-by-value-view */ "./lib/assets/javascripts/builder/components/form-components/editors/fill-color/fill-color-by-value-view.js");
  
  var DialogConstants = __webpack_require__(/*! builder/components/form-components/_constants/_dialogs */ "./lib/assets/javascripts/builder/components/form-components/_constants/_dialogs.js");
  var FillConstants = __webpack_require__(/*! builder/components/form-components/_constants/_fill */ "./lib/assets/javascripts/builder/components/form-components/_constants/_fill.js");
  var tabPaneTemplate = __webpack_require__(/*! builder/components/tab-pane/tab-pane.tpl */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane.tpl");
  var createRadioLabelsTabPane = __webpack_require__(/*! builder/components/tab-pane/create-radio-labels-tab-pane */ "./lib/assets/javascripts/builder/components/tab-pane/create-radio-labels-tab-pane.js");
  
  Backbone.Form.editors.FillColor = Backbone.Form.editors.Base.extend({
    className: 'Form-InputFill Editor-formInput--FillColor',
  
    initialize: function initialize(options) {
      Backbone.Form.editors.Base.prototype.initialize.call(this, options);
      EditorHelpers.setOptions(this, options);
  
      if (this.options.editorAttrs) {
        this.options = _.extend(this.options, {
          columns: this.options.options,
          query: this.options.query,
          configModel: this.options.configModel,
          userModel: this.options.userModel,
          editorAttrs: this.options.editorAttrs,
          modals: this.options.modals
        });
  
        this._colorKeyAttribute = options.key;
        this._colorAttributes = this.model.get(this._colorKeyAttribute);
        this._sizeAttributes = this.model.get('fillSize');
  
        this._imageInputModel = new Backbone.Model(_.extend({ type: 'image' }, this._colorAttributes));
  
        this._fixedColorInputModel = new Backbone.Model(_.extend({ type: 'color' }, this._colorAttributes));
  
        this._valueColorInputModel = new Backbone.Model(_.extend({ type: 'color' }, this._colorAttributes));
      }
  
      this._initViews();
    },
  
    _initViews: function _initViews() {
      var self = this;
      var geometryName = this.options.editorAttrs.geometryName;
  
      var fixedPane = {
        name: FillConstants.Panes.FIXED,
        label: _t('form-components.editors.fill.input-number.solid'),
        tooltip: _t('editor.style.tooltips.fill.fixed-tab', { type: geometryName }),
        tooltipGravity: 's',
        createContentView: function createContentView() {
          return self._generateFixedContentView();
        }
      };
  
      var valuePane = {
        name: FillConstants.Panes.BY_VALUE,
        label: _t('form-components.editors.fill.input-number.by-value'),
        tooltip: _t('editor.style.tooltips.fill.by-value-tab', { type: geometryName }),
        tooltipGravity: 's',
        createContentView: function createContentView() {
          return self._generateValueContentView();
        }
      };
  
      this._tabPaneTabs = [];
  
      if (this.options.editorAttrs && this.options.editorAttrs.hidePanes) {
        var hidePanes = this.options.editorAttrs.hidePanes;
  
        if (!_.contains(hidePanes, FillConstants.Panes.FIXED)) {
          this._tabPaneTabs.push(fixedPane);
        }
  
        if (!_.contains(hidePanes, FillConstants.Panes.BY_VALUE)) {
          this._tabPaneTabs.push(valuePane);
        }
      } else {
        this._tabPaneTabs = [fixedPane, valuePane];
      }
  
      var tabPaneOptions = {
        tabPaneOptions: {
          template: tabPaneTemplate,
          tabPaneItemOptions: {
            tagName: 'li',
            klassName: 'CDB-NavMenu-item'
          }
        },
        tabPaneItemLabelOptions: {
          tagName: 'div',
          className: 'CDB-Text CDB-Size-medium'
        }
      };
  
      var selectedTabPaneIndex = this._getSelectedTabPaneIndex();
      this._tabPaneTabs[selectedTabPaneIndex].selected = true;
  
      this._tabPaneView = createRadioLabelsTabPane(this._tabPaneTabs, tabPaneOptions);
      this.$el.append(this._tabPaneView.render().$el);
    },
  
    _getSelectedTabPaneIndex: function _getSelectedTabPaneIndex() {
      var FIXED_TAB_PANE_INDEX = 0;
      var VALUE_TAB_PANE_INDEX = 1;
  
      return this._colorAttributes && this._colorAttributes.range && this._tabPaneTabs.length > 1 ? VALUE_TAB_PANE_INDEX : FIXED_TAB_PANE_INDEX;
    },
  
    _removeDialogs: function _removeDialogs() {
      this._removeFillColorFixedDialog();
      this._removeFillColorByValueDialog();
    },
  
    _removeFillColorFixedDialog: function _removeFillColorFixedDialog() {
      this._fillColorFixedView && this._fillColorFixedView.removeDialog();
    },
  
    _removeFillColorByValueDialog: function _removeFillColorByValueDialog() {
      this._fillColorByValueView && this._fillColorByValueView.removeDialog();
    },
  
    _generateFixedContentView: function _generateFixedContentView() {
      this._fillColorFixedView = new FillColorFixedView({
        model: this.model,
        columns: this.options.columns,
        configModel: this.options.configModel,
        userModel: this.options.userModel,
        modals: this.options.modals,
        query: this.options.query,
        editorAttrs: this.options.editorAttrs,
        dialogMode: DialogConstants.Mode.FLOAT,
        hideTabs: this.options.hideTabs,
        fixedColorInputModel: this._fixedColorInputModel,
        imageInputModel: this._imageInputModel,
        popupConfig: {
          cid: this.cid,
          $el: this.$el
        }
      });
  
      this.applyESCBind(this._removeFillColorFixedDialog);
      this.applyClickOutsideBind(this._removeFillColorFixedDialog);
  
      this._fillColorFixedView.on('onInputChanged', function (input) {
        this.trigger('change', input);
      }, this);
  
      return this._fillColorFixedView;
    },
  
    _generateValueContentView: function _generateValueContentView() {
      this._fillColorByValueView = new FillColorByValueView({
        columns: this.options.columns,
        query: this.options.query,
        configModel: this.options.configModel,
        userModel: this.options.userModel,
        editorAttrs: this.options.editorAttrs,
        model: this.model,
        dialogMode: DialogConstants.Mode.FLOAT,
        categorizeColumns: this.options.categorizeColumns,
        hideNumericColumns: this.options.hideNumericColumns,
        removeByValueCategory: this.options.removeByValueCategory,
        modals: this.options.modals,
        hideTabs: this.options.hideTabs,
        valueColorInputModel: this._valueColorInputModel,
        popupConfig: {
          cid: this.cid,
          $el: this.$el
        }
      });
  
      this.applyESCBind(this._removeFillColorByValueDialog);
      this.applyClickOutsideBind(this._removeFillColorByValueDialog);
  
      this._fillColorByValueView.on('onInputChanged', function (input) {
        this.trigger('change', input);
      }, this);
  
      return this._fillColorByValueView;
    },
  
    getValue: function getValue(param) {
      var selectedTabPaneName = this._tabPaneView.getSelectedTabPaneName();
  
      return selectedTabPaneName === FillConstants.Panes.FIXED ? this._getFillFixedValues() : this._getFillByValueValues();
    },
  
    _getFillFixedValues: function _getFillFixedValues() {
      var color = this._fixedColorInputModel.toJSON();
      var image = this._imageInputModel.toJSON();
  
      if (color.range) {
        color.fixed = color.range[0];
        color.opacity = 1;
      }
  
      var colorOmitAttributes = ['createContentView', 'selected', 'type', 'image', 'marker', 'range'];
  
      var imageOmitAttributes = ['createContentView', 'selected', 'type', 'fixed', 'range'];
  
      var colorAttributes = _.omit(color, colorOmitAttributes);
      var imageAttributes = _.omit(image, imageOmitAttributes);
      var values = _.extend({}, imageAttributes, colorAttributes);
  
      this._fixedColorInputModel.set(values);
      this._imageInputModel.set(values);
  
      return values;
    },
  
    _getFillByValueValues: function _getFillByValueValues() {
      var colorOmitAttributes = ['createContentView', 'selected', 'type'];
  
      var values = _.omit(this._valueColorInputModel.toJSON(), colorOmitAttributes);
  
      this._valueColorInputModel.set(values);
  
      return values;
    },
  
    remove: function remove() {
      this._removeDialogs();
      this._tabPaneView.clean();
      this._fillColorByValueView && this._fillColorByValueView.clean();
      this._fillColorFixedView && this._fillColorFixedView.clean();
      Backbone.Form.editors.Base.prototype.remove.apply(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/fill-color/inputs/input-color-by-value.js":
  /*!*********************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/fill-color/inputs/input-color-by-value.js ***!
    \*********************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  var InputColorValueContentView = __webpack_require__(/*! builder/components/input-color/input-color-value-content-view */ "./lib/assets/javascripts/builder/components/input-color/input-color-value-content-view.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  var InputColorTemplate = __webpack_require__(/*! builder/components/form-components/editors/fill-color/inputs/input-color-by-value.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/fill-color/inputs/input-color-by-value.tpl");
  var FillConstants = __webpack_require__(/*! builder/components/form-components/_constants/_fill */ "./lib/assets/javascripts/builder/components/form-components/_constants/_fill.js");
  
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['columns', 'query', 'configModel', 'userModel', 'modals'];
  
  module.exports = CoreView.extend({
    tagName: 'li',
    className: 'CDB-OptionInput-item',
  
    events: {
      'click': '_onClick'
    },
  
    initialize: function initialize(options) {
      if (this.options.editorAttrs) {
        this._editorAttrs = this.options.editorAttrs;
        this._help = this._editorAttrs.help;
        this._imageEnabled = this._editorAttrs.imageEnabled;
        this._hideNumericColumns = this.options.hideNumericColumns;
        this._removeByValueCategory = this.options.removeByValueCategory;
  
        if (this._editorAttrs.hidePanes && !_.contains(this._editorAttrs.hidePanes, FillConstants.Panes.BY_VALUE)) {
          if (!options.configModel) throw new Error('configModel param is required');
          if (!options.userModel) throw new Error('userModel param is required');
          if (!options.modals) throw new Error('modals param is required');
          if (!options.query) throw new Error('query param is required');
        }
      }
  
      if (!options.columns) throw new Error('columns is required');
  
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this.$el.toggleClass('is-disabled', this.options.disabled);
  
      this.$el.html(InputColorTemplate({
        value: this._getValue(),
        attribute: this.model.get('attribute'),
        opacity: this._getOpacity(),
        colorBar: this._getColorbar(),
        help: this._help.color || ''
      }));
  
      this._initViews();
  
      return this;
    },
  
    afterRender: function afterRender() {
      this._openPopupForColumn();
    },
  
    _openPopupForColumn: function _openPopupForColumn() {
      var columnSelected = this.model.get('attribute');
      if (_.isUndefined(columnSelected)) {
        var self = this;
        setTimeout(function () {
          self.$el.click();
        }, 200);
      }
    },
  
    _getColorbar: function _getColorbar() {
      var colors = this._getValue();
      if (!_.isArray(colors)) return '';
  
      var deltaPercent = 100.0 / colors.length;
      var previousPercent = 0;
      var self = this;
      var colorsForBar = colors.map(function (color) {
        var min = previousPercent;
        var max = previousPercent + deltaPercent;
        var entry = self._getColorStep(color, [min, max]);
        previousPercent = max;
        return entry;
      });
  
      var colorBar = 'background: linear-gradient(90deg, ' + colorsForBar.join(', ') + ')';
      return colorBar;
    },
  
    _getColorStep: function _getColorStep(color, minMax) {
      return color + ' ' + minMax[0] + '%, ' + color + ' ' + minMax[1] + '%';
    },
  
    _initViews: function _initViews() {
      if (this._help.color) {
        var tooltip = new TipsyTooltipView({
          el: this.$('.js-help'),
          gravity: 'w',
          title: function title() {
            return $(this).data('tooltip');
          },
          offset: 8
        });
  
        this.addView(tooltip);
      }
    },
  
    _initBinds: function _initBinds() {
      var self = this;
  
      this.model.set('createContentView', function () {
        return self._createContentView();
      }).bind(this);
  
      this.model.on('change:selected', this._onToggleSelected, this);
      this.model.on('change:opacity change:range change:attribute', this.render, this);
    },
  
    _getColumn: function _getColumn() {
      return _.find(this._columns, function (column) {
        return column.label === this.model.get('attribute');
      }, this);
    },
  
    _iconStylingEnabled: function _iconStylingEnabled() {
      return this._imageEnabled;
    },
  
    _createContentView: function _createContentView() {
      this._inputColorValueContentView = new InputColorValueContentView({
        model: this.model,
        columns: this._columns,
        hideNumericColumns: this._hideNumericColumns,
        removeByValueCategory: this._removeByValueCategory,
        configModel: this._configModel,
        categorizeColumns: this._categorizeColumns,
        imageEnabled: this._imageEnabled,
        userModel: this._userModel,
        modals: this._modals,
        hideTabs: this._hideTabs,
        query: this._query
      });
  
      this.model.on('change', this._onChangeValue, this);
  
      return this._inputColorValueContentView;
    },
  
    _onClick: function _onClick() {
      if (this.options.disabled) {
        return;
      }
  
      this.trigger('click', this.model);
    },
  
    _getValue: function _getValue() {
      return this.model.get('range') && this.model.get('range').length ? this._getRangeColorValues() : null;
    },
  
    _getRangeColorValues: function _getRangeColorValues() {
      return _.map(this.model.get('range'), function (color) {
        return Utils.hexToRGBA(color, this._getOpacity());
      }, this);
    },
  
    _getOpacity: function _getOpacity() {
      return this.model.get('opacity') != null ? this.model.get('opacity') : 1;
    },
  
    _onToggleSelected: function _onToggleSelected() {
      this.$el.toggleClass('is-active', this.model.get('selected'));
    },
  
    _onChangeValue: function _onChangeValue(color) {
      this.model.set({ quantification: color.get('quantification'), range: color.get('range') });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/fill-color/inputs/input-color-fixed.js":
  /*!******************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/fill-color/inputs/input-color-fixed.js ***!
    \******************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  var ColorPickerView = __webpack_require__(/*! builder/components/color-picker/color-picker */ "./lib/assets/javascripts/builder/components/color-picker/color-picker.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  var InputColorTemplate = __webpack_require__(/*! builder/components/form-components/editors/fill-color/inputs/input-color-fixed.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/fill-color/inputs/input-color-fixed.tpl");
  
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  
  module.exports = CoreView.extend({
    tagName: 'li',
    className: 'CDB-OptionInput-item',
  
    events: {
      'click': '_onClick'
    },
  
    initialize: function initialize(options) {
      if (this.options.editorAttrs) {
        this._editorAttrs = this.options.editorAttrs;
        this._help = this._editorAttrs.help;
      }
  
      if (!options.columns) throw new Error('columns is required');
  
      this._columns = options.columns;
      this._configModel = options.configModel;
      this._userModel = options.userModel;
      this._modals = options.modals;
      this._query = options.query;
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this.$el.toggleClass('is-disabled', this.options.disabled);
  
      this.$el.html(InputColorTemplate({
        value: this._getValue(),
        opacity: this._getOpacity(),
        help: this._help && this._help.color || null
      }));
  
      this._initViews();
  
      return this;
    },
  
    _initViews: function _initViews() {
      if (this._help && this._help.color) {
        var tooltip = new TipsyTooltipView({
          el: this.$('.js-help'),
          gravity: 'w',
          title: function title() {
            return $(this).data('tooltip');
          },
          offset: 8
        });
  
        this.addView(tooltip);
      }
    },
  
    _initBinds: function _initBinds() {
      var self = this;
  
      this.model.set('createContentView', function () {
        return self._createContentView();
      }).bind(this);
  
      this.model.on('change:selected', this._onToggleSelected, this);
      this.model.on('change:opacity change:fixed', this.render, this);
    },
  
    _getColumn: function _getColumn() {
      return _.find(this._columns, function (column) {
        return column.label === this.model.get('attribute');
      }, this);
    },
  
    _createContentView: function _createContentView() {
      this._colorPickerView = new ColorPickerView({
        value: this.model.get('fixed'),
        opacity: this.model.get('opacity'),
        disableOpacity: this._disableOpacity || false
      });
  
      this._initColorPickerViewBindings();
  
      return this._colorPickerView;
    },
  
    _initColorPickerViewBindings: function _initColorPickerViewBindings() {
      if (this._colorPickerView) {
        this._colorPickerView.bind('change', this._onChangeValue, this);
        this._colorPickerView.on('onClean', function () {
          this._colorPickerView.unbind('change', this._onChangeValue, this);
        }, this);
      }
    },
  
    _onClick: function _onClick() {
      if (this.options.disabled) {
        return;
      }
  
      this.trigger('click', this.model);
    },
  
    _getValue: function _getValue() {
      var value = this.model.get('fixed');
  
      return value ? Utils.hexToRGBA(value, this._getOpacity()) : value;
    },
  
    _getOpacity: function _getOpacity() {
      return this.model.get('opacity') != null ? this.model.get('opacity') : 1;
    },
  
    _onToggleSelected: function _onToggleSelected() {
      this.$el.toggleClass('is-active', this.model.get('selected'));
    },
  
    _onChangeValue: function _onChangeValue(color) {
      this.model.set({ fixed: color.hex, opacity: color.opacity });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/fill-color/inputs/input-image.js":
  /*!************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/fill-color/inputs/input-image.js ***!
    \************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  var InputImageTemplate = __webpack_require__(/*! ./input-image.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/fill-color/inputs/input-image.tpl");
  var ImageLoaderView = __webpack_require__(/*! builder/components/img-loader-view */ "./lib/assets/javascripts/builder/components/img-loader-view.js");
  var InputColorFileView = __webpack_require__(/*! builder/components/input-color/input-color-file-view */ "./lib/assets/javascripts/builder/components/input-color/input-color-file-view.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  
  module.exports = CoreView.extend({
    tagName: 'li',
    className: 'CDB-OptionInput-item',
  
    events: {
      'click': '_onClick'
    },
  
    initialize: function initialize(options) {
      if (this.options.editorAttrs) {
        this._editorAttrs = this.options.editorAttrs;
        this._help = this._editorAttrs.help;
      }
  
      this._imageEnabled = true;
      this._columns = options.columns;
      this._configModel = options.configModel;
      this._userModel = options.userModel;
      this._modals = options.modals;
      this._query = options.query;
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
  
      this.$el.html(InputImageTemplate({
        help: this._help.image || '',
        image: this.model.get('image'),
        isCustomMarker: this.model.get('kind') === 'custom-marker'
      }));
  
      this._initViews();
  
      return this;
    },
  
    _initViews: function _initViews() {
      this.iconView = new ImageLoaderView({
        imageClass: 'Editor-fillImageAsset',
        imageUrl: this._getImageURL(),
        color: this._getColor()
      });
  
      this.addView(this.iconView);
      this.$('.js-image-container').append(this.iconView.render().el);
  
      if (this._help.image) {
        var tooltip = new TipsyTooltipView({
          el: this.$('.js-help'),
          gravity: 'w',
          title: function title() {
            return $(this).data('tooltip');
          },
          offset: 8
        });
  
        this.addView(tooltip);
      }
    },
  
    _initBinds: function _initBinds() {
      var self = this;
      this.model.set('createContentView', function () {
        return self._createContentView();
      }).bind(this);
  
      this.model.on('change:images change:image', this.render, this);
      this.model.on('change:opacity change:fixed', this._updateImageColor, this);
    },
  
    _categoryImagesPresent: function _categoryImagesPresent() {
      var images = this.model.get('images');
  
      images.forEach(function (image) {
        if (!_.isEmpty(image)) return true;
      });
  
      return false;
    },
  
    _updateImageColor: function _updateImageColor() {
      if (this.iconView) {
        this.iconView.updateImageColor(this._getColor());
      }
    },
  
    _getColor: function _getColor() {
      var color = this.model.get('fixed');
  
      return color ? Utils.hexToRGBA(color, this._getOpacity()) : color;
    },
  
    _getOpacity: function _getOpacity() {
      return this.model.get('opacity') != null ? this.model.get('opacity') : 1;
    },
  
    _onClick: function _onClick() {
      if (this.options.disabled) {
        return;
      }
  
      this.trigger('click', this.model);
    },
  
    _onChangeFile: function _onChangeFile(marker) {
      var kind, image;
  
      if (marker) {
        kind = marker.kind;
        image = marker.url;
      } else {
        kind = null;
        image = null;
      }
  
      this.model.set({ kind: kind, image: image });
    },
  
    _createContentView: function _createContentView() {
      this._inputColorFileView = new InputColorFileView({
        model: this.model,
        userModel: this._userModel,
        configModel: this._configModel,
        modals: this._modals
      });
  
      this._initInputColorFileViewBindings();
  
      return this._inputColorFileView;
    },
  
    _initInputColorFileViewBindings: function _initInputColorFileViewBindings() {
      if (this._inputColorFileView) {
        this._inputColorFileView.bind('change', this._onChangeFile, this);
        this._inputColorFileView.on('onClean', function () {
          this._inputColorFileView.unbind('change', this._onChangeFile, this);
        }, this);
      }
    },
  
    _getImageURL: function _getImageURL() {
      return this.model.get('image') && this._isIconStylingEnabled() ? this.model.get('image') : '';
    },
  
    _getKind: function _getKind() {
      return this.model.get('kind') && this._isIconStylingEnabled() ? this.model.get('kind') : '';
    },
  
    _isIconStylingEnabled: function _isIconStylingEnabled() {
      return this._imageEnabled;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/fill/fill.js":
  /*!****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/fill/fill.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  
  var DialogModel = __webpack_require__(/*! builder/components/dialog/dialog-model */ "./lib/assets/javascripts/builder/components/dialog/dialog-model.js");
  var DialogView = __webpack_require__(/*! builder/components/dialog/dialog-view */ "./lib/assets/javascripts/builder/components/dialog/dialog-view.js");
  var DialogConstants = __webpack_require__(/*! builder/components/form-components/_constants/_dialogs */ "./lib/assets/javascripts/builder/components/form-components/_constants/_dialogs.js");
  
  var InputCollection = __webpack_require__(/*! ./input-collection */ "./lib/assets/javascripts/builder/components/form-components/editors/fill/input-collection.js");
  var InputNumber = __webpack_require__(/*! builder/components/input-number/input-number */ "./lib/assets/javascripts/builder/components/input-number/input-number.js");
  var InputColor = __webpack_require__(/*! builder/components/input-color/input-color */ "./lib/assets/javascripts/builder/components/input-color/input-color.js");
  
  var template = __webpack_require__(/*! builder/components/input-fill/input-fill.tpl */ "./lib/assets/javascripts/builder/components/input-fill/input-fill.tpl");
  
  var PopupManager = __webpack_require__(/*! builder/components/popup-manager */ "./lib/assets/javascripts/builder/components/popup-manager.js");
  
  var INPUT_TYPE_MAP = {
    'size': InputNumber,
    'color': InputColor,
    'image': InputColor
  };
  
  var QUANTIFICATION_REF = {
    'Jenks': 'jenks',
    'Equal Interval': 'equal',
    'Heads/Tails': 'headtails',
    'Quantile': 'quantiles'
  };
  
  var MIN_IMAGE_SIZE = 20;
  var MIN_MARKER_SIZE = 7;
  
  Backbone.Form.editors.Fill = Backbone.Form.editors.Base.extend({
    className: 'Form-InputFill CDB-OptionInput CDB-Text js-input',
  
    events: {
      focus: function focus() {
        this.trigger('focus', this);
      },
      blur: function blur() {
        this.trigger('blur', this);
      }
    },
  
    initialize: function initialize(opts) {
      Backbone.Form.editors.Base.prototype.initialize.call(this, opts);
      EditorHelpers.setOptions(this, opts); // Options
  
      this.options = _.extend(this.options, {
        columns: this.options.options,
        query: this.options.query,
        configModel: this.options.configModel,
        userModel: this.options.userModel,
        editorAttrs: this.options.editorAttrs,
        modals: this.options.modals
      });
  
      this._keyAttr = opts.key;
      this.dialogMode = this.options.dialogMode || DialogConstants.Mode.DEFAULT;
  
      this._initBinds();
      this._initViews();
    },
  
    _initViews: function _initViews() {
      this.$el.append(template());
  
      if (this.options.editorAttrs && this.options.editorAttrs.disabled) {
        this.$el.addClass('is-disabled');
      }
  
      this._initFillDialog();
      this._initInputFields();
  
      this._popupManager = new PopupManager(this.cid, this.$el, this._dialogView.$el);
    },
  
    _initInputFields: function _initInputFields() {
      var inputKlass;
  
      this._inputCollection = new InputCollection();
  
      _.each(this.model.get(this._keyAttr), function (value, key) {
        this._inputCollection.add(_.extend({ type: key }, value));
      }, this);
  
      this._inputCollection.each(function (inputModel) {
        var type = inputModel.get('type');
  
        var Klass = INPUT_TYPE_MAP[type];
  
        if (!Klass) {
          throw new Error(type + ' is not a valid type of constructor');
        }
  
        if (inputModel.get('quantification') && QUANTIFICATION_REF[inputModel.get('quantification')]) {
          inputModel.set('quantification', QUANTIFICATION_REF[inputModel.get('quantification')], { silent: true });
        }
  
        inputKlass = new Klass({
          model: inputModel,
          columns: this.options.columns,
          query: this.options.query,
          configModel: this.options.configModel,
          userModel: this.options.userModel,
          modals: this.options.modals,
          editorAttrs: this.options.editorAttrs ? this.options.editorAttrs[type] : {},
          disabled: this.options.editorAttrs && this.options.editorAttrs.disabled
        });
  
        inputKlass.bind('click', this._onInputClick, this);
  
        this.$('.js-content').append(inputKlass.render().$el);
      }, this);
  
      this._inputCollection.bind('inputChanged', this._onInputChanged, this);
    },
  
    _initBinds: function _initBinds() {
      this.applyESCBind(function () {
        this._removeDialog();
      });
      this.applyClickOutsideBind(function () {
        this._removeDialog();
      });
    },
  
    _onInputClick: function _onInputClick(inputModel) {
      if (inputModel.get('selected')) {
        this._removeDialog();
        return;
      }
  
      inputModel.set('selected', true);
      this._dialogView.model.set('createContentView', inputModel.get('createContentView'));
      this._dialogView.render();
      this._dialogView.show();
  
      this._popupManager.append(this.dialogMode);
      this._popupManager.track();
    },
  
    _onInputChanged: function _onInputChanged(model) {
      this._adjustImageSize(model);
      this.trigger('change', this);
    },
  
    _adjustImageSize: function _adjustImageSize(model) {
      if (model.get('type') !== 'color' && model.get('kind') !== 'marker') {
        return;
      }
  
      var size = this._inputCollection.findWhere({ type: 'size' });
  
      if (!model.get('image') && model.hasChanged('image') && model.previous('image')) {
        size.set('fixed', MIN_MARKER_SIZE);
        return;
      }
  
      if (!model.get('images') && model.hasChanged('images')) {
        size.set('fixed', MIN_MARKER_SIZE);
        return;
      }
  
      var changedImage = model.get('image') && model.hasChanged('image') && !model.previous('image');
      var hasImages = _.isEmpty(_.compact(model.get('images')));
      var hadImages = _.isEmpty(_.compact(model.previous('images')));
      var changedImages = !hasImages && model.hasChanged('images') && hadImages;
  
      if (changedImage || changedImages) {
        if (size && size.get('fixed') < MIN_IMAGE_SIZE) {
          size.set('fixed', MIN_IMAGE_SIZE);
        }
      }
    },
  
    _initFillDialog: function _initFillDialog() {
      var dialogModel = new DialogModel();
  
      this.listenToOnce(dialogModel, 'destroy', function () {
        this._dialogView = null;
        this.stopListening(dialogModel);
      });
  
      this._dialogView = new DialogView({
        model: dialogModel
      });
    },
  
    _removeDialog: function _removeDialog(dialog) {
      this._inputCollection.unselect();
      this._dialogView.clean();
      this._popupManager.untrack();
    },
  
    focus: function focus() {
      if (this.hasFocus) return;
      this.$('.js-fillInput').focus();
    },
  
    blur: function blur() {
      if (!this.hasFocus) return;
      this.$('.js-fillInput').blur();
    },
  
    getValue: function getValue() {
      return this._inputCollection.getValues();
    },
  
    setValue: function setValue(value) {
      // TODO: add setter
    },
  
    remove: function remove() {
      this._removeDialog();
      this._popupManager.destroy();
      this._inputCollection.unbind('inputChanged', this._onInputChanged, this);
      Backbone.Form.editors.Base.prototype.remove.apply(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/fill/input-collection.js":
  /*!****************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/fill/input-collection.js ***!
    \****************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  var INPUT_TYPE_ORDER = ['size', 'color'];
  
  module.exports = Backbone.Collection.extend({
    constructor: function constructor(models, options) {
      options = _.extend(options || {}, { silent: false });
      Backbone.Collection.prototype.constructor.call(this, models, options);
    },
  
    comparator: function comparator(m) {
      return INPUT_TYPE_ORDER.indexOf(m.get('type'));
    },
  
    initialize: function initialize() {
      this.bind('change:selected', this._onSelectedChange, this);
      this.bind('change', this._onModelsChanged, this);
    },
  
    getSelected: function getSelected() {
      return this.find(function (model) {
        return model.get('selected');
      });
    },
  
    unselect: function unselect() {
      this.each(function (model) {
        model.set('selected', false);
      }, this);
    },
  
    _onSelectedChange: function _onSelectedChange(itemModel, isSelected) {
      if (!isSelected) {
        return;
      }
  
      this.each(function (model) {
        if (model !== itemModel) {
          model.set('selected', false);
        }
      }, this);
    },
  
    _onModelsChanged: function _onModelsChanged(mdl) {
      var mdlChanges = mdl.changed;
  
      // If there is any change about selected, don't propagate it
      if (_.isEmpty(mdlChanges) || _.size(mdlChanges) === 1 && mdl.changed.hasOwnProperty('selected')) {
        return;
      }
  
      this.trigger('inputChanged', mdl, this);
    },
  
    getValues: function getValues() {
      return this.reduce(function (memo, mdl) {
        var data = {};
        var typeValues = mdl.toJSON();
  
        if (typeValues.fixed) {
          data.fixed = typeValues.fixed;
  
          if (typeValues.type === 'color') {
            if (typeValues.image) {
              data.image = typeValues.image;
            }
            if (typeValues.kind) {
              data.kind = typeValues.kind;
            }
            data.opacity = typeValues.opacity;
          }
        } else {
          data = _.omit(typeValues, ['createContentView', 'selected', 'type']);
        }
  
        memo[typeValues.type] = data;
  
        return memo;
      }, {});
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/lazy-select/lazy-list-view.js":
  /*!*********************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/lazy-select/lazy-list-view.js ***!
    \*********************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var CustomListView = __webpack_require__(/*! builder/components/custom-list/custom-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var template = __webpack_require__(/*! ./lazy-list.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/lazy-select/lazy-list.tpl");
  var SearchView = __webpack_require__(/*! ./lazy-search-view */ "./lib/assets/javascripts/builder/components/form-components/editors/lazy-select/lazy-search-view.js");
  var statusTemplate = __webpack_require__(/*! ./lazy-list-view-states.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/lazy-select/lazy-list-view-states.tpl");
  
  var REQUIRED_OPTS = ['searchCollection', 'lazySearch'];
  
  module.exports = CoreView.extend({
    className: 'CDB-Box-modal CustomList',
    module: 'components:lazy-load:lazy-list-view',
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
      this._type = opts.type || _t('components.backbone-forms.lazy-select.type');
      this.model = new Backbone.Model({
        query: '',
        visible: false
      });
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this.$el.html(template());
      this._createSearchView();
      this._renderListSection();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this._searchCollection.stateModel, 'change:state', this._renderListSection);
      this.listenTo(this.model, 'change:query', this._search);
  
      this.listenTo(this.model, 'change:visible', function (mdl, isVisible) {
        isVisible ? this.render() : this.clearSubViews();
        this._toggleVisibility();
      });
    },
  
    _createListView: function _createListView() {
      if (this._listView) {
        this._listView.clean();
        this.removeView(this._listView);
      }
  
      this._listView = new CustomListView({
        className: '',
        typeLabel: this._type,
        showSearch: false,
        collection: this._searchCollection,
        searchPlaceholder: this.options.searchPlaceholder
      });
  
      this.addView(this._listView);
      this._listView.show();
      this.$('.js-list').html(this._listView.$el);
    },
  
    _createStatusView: function _createStatusView(status) {
      var el = statusTemplate({
        status: status,
        type: this._type
      });
  
      this.$('.js-list').html(el);
    },
  
    _renderListSection: function _renderListSection() {
      var status = this._searchCollection.stateModel.get('state');
  
      if (status === 'fetched') {
        this._createListView();
      } else {
        this._createStatusView(status);
      }
    },
  
    _createSearchView: function _createSearchView() {
      this._searchView = new SearchView({
        model: this.model
      });
      this.addView(this._searchView);
      this.$('.js-search').append(this._searchView.render().el);
    },
  
    _search: function _search() {
      var keyword = this.model.get('query');
  
      // This function is passed from the parent
      this._lazySearch(keyword);
    },
  
    _isSerching: function _isSerching() {
      return !!this.model.get('query');
    },
  
    show: function show() {
      this.model.set('visible', true);
    },
  
    hide: function hide() {
      this.model.set('visible', false);
    },
  
    toggle: function toggle() {
      this.model.set('visible', !this.model.get('visible'));
    },
  
    isVisible: function isVisible() {
      return this.model.get('visible');
    },
  
    _toggleVisibility: function _toggleVisibility() {
      this.$el.toggleClass('is-visible', !!this.isVisible());
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/lazy-select/lazy-search-collection.js":
  /*!*****************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/lazy-select/lazy-search-collection.js ***!
    \*****************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var CustomListCollection = __webpack_require__(/*! builder/components/custom-list/custom-list-collection */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-collection.js");
  var BaseModel = __webpack_require__(/*! builder/components/custom-list/custom-list-item-model */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item-model.js");
  
  var queryTemplate = _.template("SELECT DISTINCT <%= column %> FROM (<%= sql %>) _table_sql WHERE <%= column %> ilike '%<%= search %>%' ORDER BY <%= column %> ASC");
  
  var REQUIRED_OPTS = ['configModel', 'rowModel', 'column'];
  
  module.exports = CustomListCollection.extend({
    initialize: function initialize(models, options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      this._query = options.nodeDefModel.querySchemaModel.get('query');
  
      var configModel = options.configModel;
      this.SQL = new cdb.SQL({
        user: configModel.get('user_name'),
        sql_api_template: configModel.get('sql_api_template'),
        api_key: configModel.get('api_key')
      });
  
      this.stateModel = new Backbone.Model({
        state: _.isEmpty(models) ? 'empty' : 'fetched'
      });
  
      CustomListCollection.prototype.initialize.call(this, models, options);
    },
  
    model: function model(attrs, opts) {
      // label and val to custom list compatibility
      var key = Object.keys(attrs)[0];
      var o = {};
      o.val = attrs[key];
      o.label = attrs[key];
  
      return new BaseModel(o);
    },
  
    _onSelectedChange: function _onSelectedChange(changedModel, isSelected) {
      if (this.type === 'multiple') {
        return;
      }
  
      if (isSelected) {
        this.each(function (m) {
          if (m.cid !== changedModel.cid) {
            m.set({ selected: false }, { silent: true });
          }
        }, this);
      }
    },
  
    buildQuery: function buildQuery(search) {
      var column = this.options.column;
      return queryTemplate({
        sql: this._query,
        search: search,
        column: this._rowModel.get(column)
      });
    },
  
    fetch: function fetch(search) {
      this.deferred = $.Deferred();
      var sqlQuery = this.buildQuery(search);
      this.stateModel.set('state', 'fetching');
  
      this.SQL.execute(sqlQuery, null, {
        extra_params: ['page', 'rows_per_page'],
        page: 0,
        rows_per_page: 40,
        success: function (data) {
          this._onFetchSuccess(data);
          this.stateModel.set('state', 'fetched');
          this.deferred.resolve();
        }.bind(this),
        error: function () {
          this.stateModel.set('state', 'error');
          this.deferred.reject();
        }.bind(this)
      });
  
      return this.deferred.promise();
    },
  
    _onFetchSuccess: function _onFetchSuccess(data) {
      this.reset(data.rows);
      if (_.isEmpty(this.models)) {
        this.stateModel.set('state', 'empty');
      }
    },
  
    isFetching: function isFetching() {
      return this.getState() === 'fetching';
    },
  
    getState: function getState() {
      return this.stateModel.get('state');
    },
  
    getItem: function getItem(value) {
      return this.findWhere({ val: value });
    },
  
    isAsync: function isAsync() {
      return true;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/lazy-select/lazy-search-view.js":
  /*!***********************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/lazy-select/lazy-search-view.js ***!
    \***********************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var template = __webpack_require__(/*! ./lazy-search.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/lazy-select/lazy-search.tpl");
  
  var REQUIRED_OPTS = ['model'];
  
  module.exports = CoreView.extend({
    className: 'CDB-Box-modalHeader',
  
    events: {
      'input .js-input-search': '_search'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
    },
  
    render: function render() {
      this.$el.html(template());
  
      // Focus the input when rendered
      setTimeout(function () {
        this._getInput().focus();
      }.bind(this), 100);
  
      return this;
    },
  
    _onClickFilters: function _onClickFilters(e) {
      this.killEvent(e);
      this.trigger('filters');
    },
  
    _search: _.debounce(function (e) {
      var query = this._getInput().val();
      query = query.toLowerCase();
      query = utils.sanitizeHtml(query);
      this.model.set('query', query);
    }, 500),
  
    _getInput: function _getInput() {
      return this.$('.js-input-search');
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/lazy-select/lazy-select-view.js":
  /*!***********************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/lazy-select/lazy-select-view.js ***!
    \***********************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  var template = __webpack_require__(/*! ./lazy-select.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/lazy-select/lazy-select.tpl");
  var selectedItemTemplate = __webpack_require__(/*! ./lazy-select-item.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/lazy-select/lazy-select-item.tpl");
  var ListView = __webpack_require__(/*! ./lazy-list-view */ "./lib/assets/javascripts/builder/components/form-components/editors/lazy-select/lazy-list-view.js");
  var PopupManager = __webpack_require__(/*! builder/components/popup-manager */ "./lib/assets/javascripts/builder/components/popup-manager.js");
  var DialogConstants = __webpack_require__(/*! builder/components/form-components/_constants/_dialogs */ "./lib/assets/javascripts/builder/components/form-components/_constants/_dialogs.js");
  var SearchCollection = __webpack_require__(/*! ./lazy-search-collection */ "./lib/assets/javascripts/builder/components/form-components/editors/lazy-select/lazy-search-collection.js");
  
  var ENTER_KEY_CODE = 13;
  
  Backbone.Form.editors.LazySelect = Backbone.Form.editors.Base.extend({
  
    tagName: 'div',
    className: 'u-ellipsis Editor-formSelect',
  
    events: {
      'click .js-button': '_onButtonClick',
      'keydown .js-button': '_onButtonKeyDown',
      'focus .js-button': function focusJsButton() {
        this.trigger('focus', this);
      },
      'blur': function blur() {
        this.trigger('blur', this);
      }
    },
  
    options: {
      selectedItemTemplate: selectedItemTemplate
    },
  
    initialize: function initialize(options) {
      Backbone.Form.editors.Base.prototype.initialize.call(this, options);
      EditorHelpers.setOptions(this, options);
  
      this.template = options.template || template;
      this.dialogMode = this.options.dialogMode || DialogConstants.Mode.DEFAULT;
  
      var fetchOptions = {
        configModel: this.options.configModel,
        nodeDefModel: this.options.nodeDefModel,
        rowModel: this.model,
        column: this.options.column
      };
  
      if (this.options.options != null) {
        this.searchCollection = new SearchCollection(this.options.options, fetchOptions);
      } else {
        this.searchCollection = this.options.collection;
      }
  
      this._initBinds();
  
      var value = this.model.get(this.options.keyAttr);
      if (value != null) {
        this.setValue(value);
      }
  
      var lazySearch = function (search) {
        this.searchCollection.fetch(search);
      }.bind(this);
      var type = this.model.get(this.options.column);
  
      this._listView = new ListView({
        configModel: this.options.configModel,
        searchCollection: this.searchCollection,
        lazySearch: lazySearch,
        type: type,
        searchPlaceholder: this.options.searchPlaceholder
      });
    },
  
    render: function render() {
      var isEmpty = !this.searchCollection.length;
      var isDisabled = this.options.disabled;
      var name = this.model.get(this.options.keyAttr);
      var placeholder = this._getPlaceholder();
      var isNull = this._hasValue();
      var label = isNull ? placeholder : name;
      var title = name || '';
  
      this.$el.html(this.template({
        title: title,
        label: label,
        keyAttr: this.options.keyAttr,
        isEmpty: isEmpty,
        isDisabled: isDisabled,
        isNull: isNull
      }));
  
      this._popupManager = new PopupManager(this.cid, this.$el, this._listView.$el);
      this._popupManager.append(this.dialogMode);
  
      return this;
    },
  
    _initBinds: function _initBinds() {
      var hide = function () {
        this._listView.hide();
        this._popupManager && this._popupManager.untrack();
      }.bind(this);
  
      this.applyESCBind(hide);
      this.applyClickOutsideBind(hide);
  
      this.listenTo(this.searchCollection, 'change:selected', this._onItemSelected);
    },
  
    _destroyBinds: function _destroyBinds() {
      this.stopListening(this.searchCollection);
      Backbone.Form.editors.Base.prototype._destroyBinds.call(this);
    },
  
    _getPlaceholder: function _getPlaceholder(isDisabled) {
      var keyAttr = this.options.keyAttr;
      var placeholder = this.options.placeholder || _t('components.backbone-forms.select.placeholder', { keyAttr: keyAttr });
      return placeholder;
    },
  
    _hasValue: function _hasValue() {
      var name = this.model.get(this.options.keyAttr);
      return name == null || name === '';
    },
  
    _onItemSelected: function _onItemSelected(model) {
      this._listView.hide();
      this._popupManager.untrack();
      this._renderButton(model).focus();
  
      this.trigger('change', this);
    },
  
    _onButtonClick: function _onButtonClick() {
      this._listView.toggle();
      this._listView.isVisible() ? this._popupManager.track() : this._popupManager.untrack();
    },
  
    _onButtonKeyDown: function _onButtonKeyDown(ev) {
      if (ev.which === ENTER_KEY_CODE) {
        ev.preventDefault();
        if (!this._listView.isVisible()) {
          ev.stopPropagation();
          this._onButtonClick();
        } else {
          this._popupManager.track();
        }
      }
    },
  
    focus: function focus() {
      this.$('.js-button').focus();
    },
  
    blur: function blur() {
      this.$('.js-button').blur();
    },
  
    getValue: function getValue() {
      var item = this.searchCollection.getSelectedItem();
      if (item) {
        return item.getValue();
      } else {
        return this.value;
      }
    },
  
    setValue: function setValue(value) {
      var selectedModel = this.searchCollection.getSelectedItem();
      if (selectedModel) {
        this._renderButton(selectedModel);
      } else {
        this._renderButton(value);
      }
      this.value = value;
    },
  
    _renderButton: function _renderButton(model) {
      var button = this.$('.js-button');
      var label = model.getName && model.getName() || model;
      var $html = this.options.selectedItemTemplate({
        label: label
      });
  
      button.toggleClass('is-empty', label === '').attr('title', label).html($html);
  
      return button;
    },
  
    remove: function remove() {
      this._popupManager && this._popupManager.destroy();
      this._listView && this._listView.clean();
      this._destroyBinds();
      Backbone.Form.editors.Base.prototype.remove.call(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/legend/category-item.js":
  /*!***************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/legend/category-item.js ***!
    \***************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  
  Backbone.Form.editors.List.CategoryModel = Backbone.Form.editors.NestedModel.extend({
  
    initialize: function initialize(options) {
      Backbone.Form.editors.Base.prototype.initialize.call(this, options);
      EditorHelpers.setOptions(this, options);
  
      if (!this.form) throw new Error('Missing required option "form"');
      if (!options.schema.model) throw new Error('Missing required "schema.model" option for NestedModel editor');
    },
  
    render: function render() {
      // Get the constructor for creating the nested form; i.e. the same constructor as used by the parent form
      var NestedForm = this.form.constructor;
  
      var data = this.value || {};
      var NestedModel = this.schema.model;
  
      // Wrap the data in a model if it isn't already a model instance
      var modelInstance = data.constructor === NestedModel ? data : new NestedModel(data, this.options);
  
      this.nestedForm = new NestedForm({
        model: modelInstance,
        idPrefix: this.cid + '_',
        fieldTemplate: 'nestedField'
      });
  
      this._observeFormEvents();
  
      // Render form
      this.$el.html(this.nestedForm.render().el);
  
      if (this.hasFocus) this.trigger('blur', this);
  
      return this;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/list/list-item.js":
  /*!*********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/list/list-item.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  
  var ENTER_KEY_CODE = 13;
  
  /**
   * A single item in the list
   *
   * @param {editors.List} options.list The List editor instance this item belongs to
   * @param {Function} options.Editor   Editor constructor function
   * @param {String} options.key        Model key
   * @param {Mixed} options.value       Value
   * @param {Object} options.schema     Field schema
   */
  Backbone.Form.editors.List.Item = Backbone.Form.editors.Base.extend({
  
    events: {
      'click [data-action="remove"]': function clickDataActionRemove(event) {
        event.preventDefault();
        this.list.removeItem(this);
      },
      'keydown input[type=text]': function keydownInputTypeText(event) {
        if (event.keyCode !== ENTER_KEY_CODE) return;
        event.preventDefault();
        this.list.addItem(null, true);
        this.list.$list.find('input:last').focus();
      }
    },
  
    initialize: function initialize(options) {
      EditorHelpers.setOptions(this, options);
      this.list = options.list;
      this.schema = options.schema || this.list.schema;
      this.Editor = options.Editor || Backbone.Form.editors.Text;
      this.template = options.template || this.schema.itemTemplate || this.constructor.template;
      this.errorClassName = options.errorClassName || this.constructor.errorClassName;
    },
  
    render: function render() {
      // Create editor
      this.editor = new this.Editor({
        key: this.options.key,
        schema: this.schema,
        value: this.options.value,
        list: this.options.list,
        item: this,
        form: this.options.form,
        trackingClass: this.options.trackingClass
      }, {
        userModel: this.options.userModel,
        configModel: this.options.configModel,
        modals: this.options.modals
      }).render();
  
      // Create main element
      var $el = $($.trim(this.template()));
  
      $el.find('[data-editor]').append(this.editor.el);
  
      var $tooltip = $el.find('.js-remove-help');
  
      if ($tooltip.length) {
        this._removeTooltip();
  
        this._tooltip = new TipsyTooltipView({
          el: $tooltip,
          gravity: 'w',
          title: function title() {
            return _t('editor.legend.tooltips.item.remove');
          }
        });
      }
  
      // Replace the entire element so there isn't a wrapper tag
      this.setElement($el);
  
      return this;
    },
  
    getValue: function getValue() {
      return this.editor.getValue();
    },
  
    setValue: function setValue(value) {
      this.editor.setValue(value);
    },
  
    focus: function focus() {
      this.editor.focus();
    },
  
    blur: function blur() {
      this.editor.blur();
    },
  
    validate: function validate() {
      var value = this.getValue();
      var formValues = this.list.form ? this.list.form.getValue() : {};
      var validators = this.schema.validators;
      var getValidator = this.getValidator;
  
      if (!validators) return null;
  
      // Run through validators until an error is found
      var error = null;
      _.every(validators, function (validator) {
        error = getValidator(validator)(value, formValues);
  
        return !!error;
      });
  
      // Show/hide error
      if (error) {
        this.setError(error);
      } else {
        this.clearError();
      }
  
      // Return error to be aggregated by list
      return error ? error : null; // eslint-disable-line
    },
  
    /**
     * Show a validation error
     */
    setError: function setError(err) {
      this.$el.addClass(this.errorClassName);
      this.$el.attr('title', err.message);
    },
  
    /**
     * Hide validation errors
     */
    clearError: function clearError() {
      this.$el.removeClass(this.errorClassName);
      this.$el.attr('title', null);
    },
  
    _removeTooltip: function _removeTooltip() {
      if (this._tooltip) {
        this._tooltip.clean();
      }
    },
  
    remove: function remove() {
      this._removeTooltip();
      this.editor.remove();
  
      Backbone.Form.editors.Base.prototype.remove.apply(this);
    },
  
    clean: function clean() {
      this.$el.remove();
    }
  }, {
  
    /* eslint-disable */
    template: _.template('\
        <div>\
          <span data-editor></span>\
          <button type="button" data-action="remove">&times;</button>\
        </div>\
      ', null, Backbone.Form.templateSettings),
    errorClassName: 'error'
    /* eslint-enable */
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/list/list.js":
  /*!****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/list/list.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  
  var OPTIONS = ['userModel', 'configModel', 'modals', 'layerDefinitionModel', 'trackingClass'];
  
  Backbone.Form.editors.List = Backbone.Form.editors.Base.extend({
  
    events: {
      'click [data-action="add"]': function clickDataActionAdd(event) {
        event.preventDefault();
        if (this._canAddNewItems()) {
          this.addItem(null, true);
        }
      }
    },
  
    initialize: function initialize(options) {
      options = options || {};
  
      var editors = Backbone.Form.editors;
  
      editors.Base.prototype.initialize.call(this, options);
      EditorHelpers.setOptions(this, options);
  
      var schema = this.schema;
      if (!schema) throw new Error("Missing required option 'schema'");
  
      this.template = options.template || schema.listTemplate || this.constructor.template;
  
      // Determine the editor to use
      this.Editor = function () {
        var type = schema.itemType;
  
        // Default to Text
        if (!type) return editors.Text;
  
        // Use List-specific version if available
        if (editors.List[type]) return editors.List[type];
  
        // Or whichever was passed
        return editors[type];
      }();
  
      _.each(OPTIONS, function (item) {
        if (this.options[item]) {
          this['_' + item] = this.options[item];
        }
      }, this);
  
      this.items = [];
      this.errors = [];
  
      this._initBinds();
    },
  
    render: function render() {
      var self = this;
      var value = this.value || [];
  
      // Create main element
      var $el = $($.trim(this.template()));
  
      // Store a reference to the list (item container)
      this.$list = $el.is('[data-items]') ? $el : $el.find('[data-items]');
  
      this.setElement($el);
      this.$el.attr('id', this.id);
      this.$el.attr('name', this.key);
  
      // Add existing items
      if (value.length) {
        _.each(value, function (itemValue) {
          self.addItem(itemValue);
        });
      } else {
        // If no existing items create an empty one, unless the editor specifies otherwise
        if (!this.Editor.isAsync) this.addItem(null, true);
      }
  
      if (this.hasFocus) this.trigger('blur', this);
  
      this.validate();
      return this;
    },
  
    _initBinds: function _initBinds() {
      if (this.options.maxItems) {
        this.listenTo(this, 'add remove', this._setAddButtonState);
      }
    },
  
    /**
     * Add a new item to the list
     * @param {Mixed} [value]           Value for the new item editor
     * @param {Boolean} [userInitiated] If the item was added by the user clicking 'add' or pressing `Enter`
     */
    addItem: function addItem(value, userInitiated) {
      var self = this;
      var editors = Backbone.Form.editors;
  
      var defaultOptions = {
        list: this,
        form: this.form,
        schema: this.schema,
        value: value,
        Editor: this.Editor,
        key: this.key
      };
  
      var customOptions = _.reduce(OPTIONS, function (memo, item) {
        if (this.options[item]) {
          memo[item] = this['_' + item];
        }
        return memo;
      }, {}, this);
  
      var options = _.extend({}, defaultOptions, customOptions);
  
      // Create the item
      var item = new editors.List.Item(options).render();
  
      var _addItem = function _addItem() {
        self.items.push(item);
        self.$list.append(item.el);
  
        item.editor.on('all', function (event) {
          if (event === 'change') return;
  
          // args = ["key:change", itemEditor, fieldEditor]
          var args = _.toArray(arguments);
          args[0] = 'item:' + event;
          args.splice(1, 0, self);
          // args = ["item:key:change", this=listEditor, itemEditor, fieldEditor]
  
          editors.List.prototype.trigger.apply(this, args);
        }, self);
  
        item.editor.on('change', function () {
          if (!item.addEventTriggered) {
            item.addEventTriggered = true;
            this.trigger('add', this, item.editor);
          }
          this.trigger('item:change', this, item.editor);
          this.trigger('change', this);
        }, self);
  
        item.editor.on('focus', function () {
          if (this.hasFocus) return;
          this.trigger('focus', this);
        }, self);
        item.editor.on('blur', function () {
          if (!this.hasFocus) return;
          var self = this;
          setTimeout(function () {
            if (_.find(self.items, function (item) {
              return item.editor.hasFocus;
            })) return;
            self.trigger('blur', self);
          }, 0);
        }, self);
  
        if (userInitiated || value) {
          item.addEventTriggered = true;
        }
  
        if (userInitiated) {
          self.trigger('add', self, item.editor);
          self.trigger('change', self);
        }
      };
  
      // Check if we need to wait for the item to complete before adding to the list
      if (this.Editor.isAsync) {
        item.editor.on('readyToAdd', _addItem, this);
      } else {
        // Most editors can be added automatically
        _addItem();
        item.editor.focus();
      }
  
      return item;
    },
  
    /**
     * Remove an item from the list
     * @param {List.Item} item
     */
    removeItem: function removeItem(item) {
      // Confirm delete
      var confirmMsg = this.schema.confirmDelete;
      if (confirmMsg && !confirm(confirmMsg)) return; // eslint-disable-line
  
      var index = _.indexOf(this.items, item);
  
      this.items[index].remove();
      this.items.splice(index, 1);
  
      if (item.addEventTriggered) {
        this.trigger('remove', this, item.editor);
        this.trigger('change', this);
      }
  
      if (!this.items.length && !this.Editor.isAsync) this.addItem();
    },
  
    getValue: function getValue() {
      var values = _.map(this.items, function (item) {
        return item.getValue();
      });
  
      // Filter empty items
      return _.without(values, undefined, '');
    },
  
    setValue: function setValue(value) {
      this.value = value;
      this.render();
    },
  
    focus: function focus() {
      if (this.hasFocus) return;
  
      if (this.items[0]) this.items[0].editor.focus();
    },
  
    blur: function blur() {
      if (!this.hasFocus) return;
  
      var focusedItem = _.find(this.items, function (item) {
        return item.editor.hasFocus;
      });
  
      if (focusedItem) focusedItem.editor.blur();
    },
  
    /**
     * Override default remove function in order to remove item views
     */
    remove: function remove() {
      _.invoke(this.items, 'remove');
  
      Backbone.Form.editors.Base.prototype.remove.call(this);
    },
  
    /**
     * Run validation
     *
     * @return {Object|Null}
     */
    validate: function validate() {
      if (!this.validators) return null;
  
      // Collect errors
      var errors = _.map(this.items, function (item) {
        return item.validate();
      });
  
      // Max items Check
      if (this.options.maxItems && this.options.maxItems < this.items.length) {
        errors.push(_t('form-components.editors.list.max-items'));
      }
  
      this.errors = _.compact(errors);
      // Check if any item has errors
      var hasErrors = !!this.errors.length;
      this._setAddButtonState();
  
      if (!hasErrors) return null;
    },
  
    _errorPresenter: function _errorPresenter(errors) {
      return _.unique(this.errors.map(function (error) {
        return error.message;
      })).join('\n');
    },
  
    _setAddButtonState: function _setAddButtonState() {
      var $button = this._getAddButtonElement();
      var hasErrors = !!this.errors.length;
  
      $button.toggleClass('is-disabled', hasErrors);
  
      if (hasErrors) {
        this._errorTooltip = new TipsyTooltipView({
          el: $button,
          gravity: 's',
          offset: 0,
          title: this._errorPresenter.bind(this)
        });
      } else {
        if (this._errorTooltip) {
          this._errorTooltip.clean();
          this._errorTooltip = null;
        }
      }
  
      if (this.options.maxItems) {
        $button.toggle(this.items.length < this.options.maxItems);
      }
    },
  
    _getAddButtonElement: function _getAddButtonElement() {
      return this.$('[data-action="add"]');
    },
  
    _canAddNewItems: function _canAddNewItems() {
      var opts = this.options;
      var maxItemsReached = opts.maxItems && opts.maxItems <= this.items.length || false;
      return !this.errors.length && !maxItemsReached;
    }
  }, {
  
    /* eslint-disable */
    template: _.template('\
        <div>\
          <div data-items></div>\
          <button type="button" data-action="add">Add</button>\
        </div>\
      ', null, Backbone.Form.templateSettings)
    /* eslint-enable */
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/node-dataset/node-dataset-item-view.js":
  /*!******************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/node-dataset/node-dataset-item-view.js ***!
    \******************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CustomListItemView = __webpack_require__(/*! builder/components/custom-list/custom-list-item-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  module.exports = CustomListItemView.extend({
  
    render: function render() {
      this.$el.empty();
      this.clearSubViews();
  
      this.$el.append(this.options.template(_.extend({
        typeLabel: this.options.typeLabel,
        isSelected: this.model.get('selected'),
        isSourceType: this.model.get('isSourceType'),
        name: this.model.getName(),
        val: this.model.getValue()
      }, this.model.attributes)));
  
      this.$el.attr('data-val', this.model.getValue()).toggleClass('is-disabled', !!this.model.get('disabled'));
  
      return this;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/node-dataset/node-dataset-view.js":
  /*!*************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/node-dataset/node-dataset-view.js ***!
    \*************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var NodeDatasetItemView = __webpack_require__(/*! ./node-dataset-item-view */ "./lib/assets/javascripts/builder/components/form-components/editors/node-dataset/node-dataset-item-view.js");
  var nodeDatasetSelectedTemplate = __webpack_require__(/*! ./node-dataset-selected.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/node-dataset/node-dataset-selected.tpl");
  var nodeDatasetItemTemplate = __webpack_require__(/*! ./node-dataset-item.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/node-dataset/node-dataset-item.tpl");
  
  Backbone.Form.editors.NodeDataset = Backbone.Form.editors.Select.extend({
  
    options: {
      selectedItemTemplate: nodeDatasetSelectedTemplate,
      itemListTemplate: nodeDatasetItemTemplate,
      customListItemView: NodeDatasetItemView
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/number/number.js":
  /*!********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/number/number.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var template = __webpack_require__(/*! ./number.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/number/number.tpl");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  __webpack_require__(/*! jquery-ui */ "./lib/assets/javascripts/vendor/jquery-ui.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  
  var UP_ARROW_KEY_CODE = 38;
  var BOTTOM_ARROW_KEY_CODE = 40;
  var SPACE_KEY_CODE = 32;
  var ENTER_KEY_CODE = 13;
  
  var SMALL_INCREMENT = 1;
  var BIG_INCREMENT = 10;
  
  Backbone.Form.editors.Number = Backbone.Form.editors.Base.extend({
  
    tagName: 'ul',
    className: 'CDB-OptionInput-container CDB-OptionInput-container--noMargin u-grow',
  
    // backbone-forms 0.14.1 has a 'number' validator:
    // https://github.com/powmedia/backbone-forms/blob/v0.14.1/src/validators.js#L64
    // We're on 0.14.0 so we have to use a 'regexp' validator
    options: {
      min: 0,
      max: 10,
      step: 1,
      showSlider: true,
      validators: [{
        type: 'regexp',
        regexp: /^[+-]?((\.\d+)|(\d+(\.\d+)?))$/,
        message: _t('editor.edit-feature.valid')
      }]
    },
  
    events: {
      'keydown .js-input': '_onInputKeyDown',
      'keyup .js-input': '_onInputKeyUp',
      focus: function focus() {
        this.trigger('focus', this);
      },
      blur: function blur() {
        this.trigger('blur', this);
      }
    },
  
    initialize: function initialize(opts) {
      Backbone.Form.editors.Base.prototype.initialize.call(this, opts);
      EditorHelpers.setOptions(this, opts);
  
      // Setting min, max and step from validators, if exists.
      this._validators = opts.validators || opts.schema && opts.schema.validators;
      if (this._validators && this._validators[1]) {
        this.options.min = this._validators[1].min;
        this.options.max = this._validators[1].max;
        this.options.step = this._validators[1].step;
      }
  
      if (this.options.editorAttrs && this.options.editorAttrs.help) {
        this._help = this.options.editorAttrs.help;
      }
  
      this._debouncedTriggerChange = _.debounce(this._triggerChange, 333).bind(this);
  
      this._initViews();
    },
  
    _initViews: function _initViews() {
      var placeholder = this.value === null ? 'null' : '';
  
      this.$el.html(template({
        value: this.value,
        isDisabled: this.options.disabled,
        hasSlider: this.options.showSlider,
        isFormatted: this.options.isFormatted,
        placeholder: placeholder,
        help: this._help || ''
      }));
  
      if (this.options.showSlider) {
        this.$('.js-slider').slider({
          range: 'min',
          value: this.value,
          min: this.options.min,
          max: this.options.max,
          step: this.options.step,
          orientation: 'horizontal',
          disabled: this.options.disabled,
          slide: this._onSlideChange.bind(this),
          stop: this._onSlideStop.bind(this)
        });
      }
  
      if (this._help) {
        this._removeTooltip();
  
        this._helpTooltip = new TipsyTooltipView({
          el: this.$('.js-help'),
          gravity: 'w',
          title: function title() {
            return $(this).data('tooltip');
          }
        });
      }
  
      this.$el.toggleClass('CDB-OptionInput-container--noSlider', !!this.options.showSlider);
    },
  
    _onSlideChange: function _onSlideChange(ev, ui) {
      this.value = ui.value;
      this.$('.js-input').val(this.value);
    },
  
    _onSlideStop: function _onSlideStop(ev, ui) {
      this._debouncedTriggerChange();
    },
  
    _onInputKeyDown: function _onInputKeyDown(event) {
      var $input = this.$('.js-input');
      var value = +this.getValue();
      var increment = event.shiftKey === true ? BIG_INCREMENT : SMALL_INCREMENT;
  
      switch (event.which) {
        case SPACE_KEY_CODE:
        case ENTER_KEY_CODE:
          return false;
        case UP_ARROW_KEY_CODE:
          value = this._nextValue(value, increment);
          $input.val(value);
          break;
        case BOTTOM_ARROW_KEY_CODE:
          value = this._nextValue(value, increment * -1);
          $input.val(value);
          break;
        default:
        // Any other case!
      }
    },
  
    _nextValue: function _nextValue(value, increment) {
      var nextValue = value += increment;
  
      if (nextValue < this.options.min) return this.options.min;
      if (nextValue > this.options.max) return this.options.max;
  
      return nextValue;
    },
  
    _hasSlider: function _hasSlider() {
      return this.options.showSlider && this.$('.js-slider').data('ui-slider');
    },
  
    _onInputKeyUp: function _onInputKeyUp() {
      var value = this.$('.js-input').val();
      if (this._hasSlider()) {
        this.$('.js-slider').slider('value', value);
      }
  
      this.value = value;
      this._debouncedTriggerChange();
    },
  
    _triggerChange: function _triggerChange() {
      this.trigger('change', this);
    },
  
    focus: function focus() {
      if (this.hasFocus) return;
      this.$('.js-input').focus();
    },
  
    blur: function blur() {
      if (!this.hasFocus) return;
      this.$('.js-input').blur();
    },
  
    getValue: function getValue() {
      var val = this.$('.js-input').val();
  
      return val === '' ? null : +val;
    },
  
    setValue: function setValue(value) {
      if (this._hasSlider()) {
        this.$('.js-slider').slider('value', value);
      }
  
      this.$('.js-input').val(value);
      this.value = value;
    },
  
    _destroySlider: function _destroySlider() {
      if (this._hasSlider()) {
        this.$('.js-slider').slider('destroy');
      }
    },
  
    _removeTooltip: function _removeTooltip() {
      if (this._helpTooltip) {
        this._helpTooltip.clean();
      }
    },
  
    remove: function remove() {
      this._destroySlider();
      this._removeTooltip();
  
      Backbone.Form.editors.Base.prototype.remove.apply(this);
    },
  
    clean: function clean() {
      this.$el.remove();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/operators/operators-list-collection.js":
  /*!******************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/operators/operators-list-collection.js ***!
    \******************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CustomListCollection = __webpack_require__(/*! builder/components/custom-list/custom-list-collection */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-collection.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  /*
   *  Custom list collection, it parses pairs like:
   *
   *  [{ val, label }]
   *  ["string"]
   */
  
  module.exports = CustomListCollection.extend({
  
    search: function search(query) {
      query = query.toLowerCase();
  
      return _(this.filter(function (model) {
        var val = model.getName().toLowerCase();
        var type = model.get('type').toLowerCase();
        return ~val.indexOf(query) && type === 'number';
      }));
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/operators/operators-list-model.js":
  /*!*************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/operators/operators-list-model.js ***!
    \*************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  module.exports = Backbone.Model.extend({
  
    defaults: {
      visible: false,
      operator: 'count',
      attribute: ''
    },
  
    isValidOperator: function isValidOperator() {
      var operator = this.get('operator');
      var attribute = this.get('attribute');
  
      if (operator === 'count') {
        return true;
      } else {
        if (operator && attribute) {
          return true;
        }
        return false;
      }
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/operators/operators-list-view.js":
  /*!************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/operators/operators-list-view.js ***!
    \************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var CustomListView = __webpack_require__(/*! builder/components/custom-list/custom-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-view.js");
  var DropdownOverlayView = __webpack_require__(/*! builder/components/dropdown-overlay/dropdown-overlay-view */ "./lib/assets/javascripts/builder/components/dropdown-overlay/dropdown-overlay-view.js");
  var OperatorsListModel = __webpack_require__(/*! ./operators-list-model */ "./lib/assets/javascripts/builder/components/form-components/editors/operators/operators-list-model.js");
  var emptyTemplate = __webpack_require__(/*! ./operators-list-count.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/operators/operators-list-count.tpl");
  var template = __webpack_require__(/*! ./operators-list.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/operators/operators-list.tpl");
  
  module.exports = CoreView.extend({
  
    className: 'Editor-dropdown Editor-boxModal Editor-dropdownOperators',
    tagName: 'div',
  
    events: {
      'change input[name="operator"]': '_onOperationChange'
    },
  
    initialize: function initialize(opts) {
      this.model = new OperatorsListModel({
        operator: opts.operator,
        attribute: opts.attribute,
        visible: false
      });
  
      if (opts.attribute) {
        this.collection.setSelected(opts.attribute);
      }
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this.$el.append(template({
        operator: this.model.get('operator')
      }));
      this._renderList();
  
      this._dropdownOverlay = new DropdownOverlayView({
        onClickAction: this.hide.bind(this),
        visible: this.model.get('visible')
      });
      this.addView(this._dropdownOverlay);
  
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change:operator change:attribute', _.debounce(this._onModelChange.bind(this), 10));
      this.model.bind('change:visible', function (mdl, isVisible) {
        this._toggleVisibility();
  
        if (!isVisible) {
          this._destroyList();
          this.$('.js-list').html(emptyTemplate());
        } else {
          this.render();
        }
      }, this);
      this.collection.bind('change:selected', this._onAttributeSelected, this);
      this.add_related_model(this.collection);
    },
  
    _hasList: function _hasList() {
      return !!this._listView;
    },
  
    _renderList: function _renderList() {
      if (this.model.get('operator') !== 'count') {
        if (this._hasList()) {
          return;
        }
  
        this._listView = new CustomListView({
          className: 'CDB-Dropdown-options CDB-Text CDB-Size-medium',
          collection: this.collection,
          showSearch: true,
          typeLabel: this.options.keyAttr
        });
        this.$('.js-list').html(this._listView.render().el);
      } else {
        this._destroyList();
        this.$('.js-list').html(emptyTemplate());
      }
    },
  
    _destroyList: function _destroyList() {
      if (this._hasList()) {
        this.removeView(this._listView);
        this._listView.clean();
        delete this._listView;
      }
    },
  
    _onModelChange: function _onModelChange() {
      if (this.model.isValidOperator()) {
        this.trigger('change', this.model.toJSON(), this);
      }
    },
  
    _onOperationChange: function _onOperationChange(ev) {
      var $input = $(ev.target);
      var operator = $input.val();
  
      if (operator === 'count') {
        this.model.set('attribute', '');
        this.collection.removeSelected();
      }
  
      this.model.set('operator', operator);
  
      this._renderList();
    },
  
    _onAttributeSelected: function _onAttributeSelected(mdl) {
      if (mdl.get('selected')) {
        this.model.set('attribute', mdl.getValue());
      }
    },
  
    _toggleVisibility: function _toggleVisibility() {
      this.$el.toggleClass('is-visible', !!this.model.get('visible'));
    },
  
    show: function show() {
      this.model.set('visible', true);
    },
  
    hide: function hide() {
      this.model.set('visible', false);
    },
  
    toggle: function toggle() {
      this.model.set('visible', !this.model.get('visible'));
    },
  
    isVisible: function isVisible() {
      return this.model.get('visible');
    },
  
    remove: function remove() {
      this._destroyList();
      this.$el.empty();
      CoreView.prototype.remove.call(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/operators/operators-view.js":
  /*!*******************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/operators/operators-view.js ***!
    \*******************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var OperatorListView = __webpack_require__(/*! ./operators-list-view */ "./lib/assets/javascripts/builder/components/form-components/editors/operators/operators-list-view.js");
  var OperatorListCollection = __webpack_require__(/*! ./operators-list-collection */ "./lib/assets/javascripts/builder/components/form-components/editors/operators/operators-list-collection.js");
  var template = __webpack_require__(/*! ./operators.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/operators/operators.tpl");
  var PopupManager = __webpack_require__(/*! builder/components/popup-manager */ "./lib/assets/javascripts/builder/components/popup-manager.js");
  var DialogConstants = __webpack_require__(/*! builder/components/form-components/_constants/_dialogs */ "./lib/assets/javascripts/builder/components/form-components/_constants/_dialogs.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  
  var ENTER_KEY_CODE = 13;
  
  Backbone.Form.editors.Operators = Backbone.Form.editors.Base.extend({
  
    tagName: 'div',
    className: 'Editor-formSelect u-ellipsis',
  
    events: {
      'click .js-button': '_onButtonClick',
      'keydown .js-button': '_onButtonKeyDown',
      'focus .js-button': function focusJsButton() {
        this.trigger('focus', this);
      },
      'blur': function blur() {
        this.trigger('blur', this);
      }
    },
  
    initialize: function initialize(opts) {
      Backbone.Form.editors.Base.prototype.initialize.call(this, opts);
      EditorHelpers.setOptions(this, opts);
  
      this.collection = new OperatorListCollection(this.options.options);
      this.dialogMode = this.options.dialogMode || DialogConstants.Mode.DEFAULT;
  
      if (this.options.editorAttrs && this.options.editorAttrs.help) {
        this._help = this.options.editorAttrs.help;
      }
  
      this._initViews();
      this.setValue(this.model.get(this.options.keyAttr));
      this._initBinds();
    },
  
    _initViews: function _initViews() {
      var value = this.model.get(this.options.keyAttr);
  
      this.$el.append($('<div>').addClass('js-operator'));
  
      this._setOperatorTemplate();
  
      this._operatorsListView = new OperatorListView({
        operator: value.operator,
        attribute: value.attribute,
        collection: this.collection
      });
      this._operatorsListView.bind('change', this._onOperatorsChange, this);
  
      this._popupManager = new PopupManager(this.cid, this.$el, this._operatorsListView.$el);
      this._popupManager.append(this.dialogMode);
  
      if (this.options.disabled) {
        this.undelegateEvents();
      }
    },
  
    _setOperatorTemplate: function _setOperatorTemplate() {
      this.$('.js-operator').html(template({
        name: this._getOperatorsTextValue(),
        disabled: this.options.disabled,
        keyAttr: this.options.keyAttr,
        help: this._help || ''
      }));
  
      if (this._help) {
        this._removeTooltip();
  
        this._helpTooltip = new TipsyTooltipView({
          el: this.$('.js-help'),
          gravity: 'w',
          title: function title() {
            return $(this).data('tooltip');
          }
        });
      }
    },
  
    _initBinds: function _initBinds() {
      var hide = function () {
        this._operatorsListView.hide();
        this._popupManager.untrack();
      }.bind(this);
  
      this.applyESCBind(hide);
      this.applyClickOutsideBind(hide);
    },
  
    _onOperatorsChange: function _onOperatorsChange(data) {
      this.model.set(this.options.keyAttr, data);
      this._setOperatorTemplate();
      this.$('.js-button').focus();
      this.trigger('change', this);
    },
  
    _getOperatorsTextValue: function _getOperatorsTextValue() {
      var value = this.model.get(this.options.keyAttr);
      if (value && value.operator) {
        return value.operator.toUpperCase() + (value.attribute ? '(' + value.attribute + ')' : '');
      } else {
        return '';
      }
    },
  
    _onButtonClick: function _onButtonClick(ev) {
      this._operatorsListView.toggle();
      this._operatorsListView.isVisible() ? this._popupManager.track() : this._popupManager.untrack();
    },
  
    _onButtonKeyDown: function _onButtonKeyDown(ev) {
      if (ev.which === ENTER_KEY_CODE) {
        ev.preventDefault();
        if (!this._operatorsListView.isVisible()) {
          ev.stopPropagation();
          this._operatorsListView.toggle();
          this._popupManager.track();
        } else {
          this._popupManager.untrack();
        }
      }
    },
  
    getValue: function getValue() {
      var data = this.model.get(this.options.keyAttr);
      return _.omit(data, 'visible');
    },
  
    setValue: function setValue(value) {
      var textValue = this._getOperatorsTextValue();
      this.value = textValue;
      this._setOperatorTemplate();
    },
  
    _removeTooltip: function _removeTooltip() {
      if (this._helpTooltip) {
        this._helpTooltip.clean();
      }
    },
  
    remove: function remove() {
      this._removeTooltip();
  
      this._popupManager && this._popupManager.destroy();
      this._operatorsListView && this._operatorsListView.clean();
      Backbone.Form.editors.Base.prototype.remove.call(this);
    },
  
    clean: function clean() {
      this.$el.remove();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/radio/radio.js":
  /*!******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/radio/radio.js ***!
    \******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  var template = __webpack_require__(/*! ./radio.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/radio/radio.tpl");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  
  Backbone.Form.editors.Radio = Backbone.Form.editors.Radio.extend({
  
    className: 'CDB-Text CDB-Size-medium u-flex u-alignCenter',
  
    initialize: function initialize(opts) {
      Backbone.Form.editors.Base.prototype.initialize.apply(this, arguments);
      EditorHelpers.setOptions(this, opts);
    },
  
    render: function render() {
      this.setOptions(this.schema.options); // It comes from the default Select editor (not ours)
      this._setHelp();
      return this;
    },
  
    _setHelp: function _setHelp() {
      var containsHelp = _.find(this.schema.options, function (option) {
        return option.help;
      });
  
      if (containsHelp) {
        this._helpTooltip = this._createTooltip({
          $el: this.$('.js-help')
        });
      }
    },
  
    _createTooltip: function _createTooltip(opts) {
      return new TipsyTooltipView({
        el: opts.$el || this.$el,
        gravity: opts.gravity || 's',
        className: opts.className || '',
        offset: opts.offset || 0,
        title: function title() {
          return opts.msg || $(this).data('tooltip');
        }
      });
    },
  
    getValue: function getValue() {
      var value = this.$('input[type=radio]:checked').val();
  
      return value === '' ? null : value;
    },
  
    _arrayToHtml: function _arrayToHtml(array) {
      var selectedVal = this.form.model.get(this.key);
  
      var items = _.map(array, function (option, index) {
        var val = option.val;
  
        var item = {
          name: this.getName(),
          value: val === null ? '' : val.toString(),
          help: option.help,
          id: this.id,
          label: option.label,
          className: option.className
        };
  
        // Can't be selected and disabled simultaneously
        if (selectedVal === val) {
          item.selected = true;
        } else {
          item.disabled = option.disabled;
        }
  
        return item;
      }, this);
  
      return template({
        items: items
      });
    },
  
    _destroyBinds: function _destroyBinds() {},
  
    remove: function remove() {
      if (this._helpTooltip) {
        this._helpTooltip.clean();
      }
      Backbone.Form.editors.Base.prototype.remove.call(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/select/multi-select-view.js":
  /*!*******************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/select/multi-select-view.js ***!
    \*******************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CustomListView = __webpack_require__(/*! builder/components/custom-list/custom-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-view.js");
  var CustomListCollection = __webpack_require__(/*! builder/components/custom-list/custom-list-multi-collection */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-multi-collection.js");
  var selectedItemTemplate = __webpack_require__(/*! ./select-item.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/select/select-item.tpl");
  var CustomListItemView = __webpack_require__(/*! builder/components/custom-list/custom-list-multi-item-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-multi-item-view.js");
  var itemListTemplate = __webpack_require__(/*! builder/components/custom-list/custom-list-item-with-checkbox.tpl */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item-with-checkbox.tpl");
  var template = __webpack_require__(/*! ./select.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/select/select.tpl");
  var PopupManager = __webpack_require__(/*! builder/components/popup-manager */ "./lib/assets/javascripts/builder/components/popup-manager.js");
  var DialogConstants = __webpack_require__(/*! builder/components/form-components/_constants/_dialogs */ "./lib/assets/javascripts/builder/components/form-components/_constants/_dialogs.js");
  
  var ENTER_KEY_CODE = 13;
  
  Backbone.Form.editors.MultiSelect = Backbone.Form.editors.Base.extend({
  
    tagName: 'div',
    className: 'u-ellipsis Editor-formSelect',
  
    events: {
      'click .js-button': '_onButtonClick',
      'keydown .js-button': '_onButtonKeyDown',
      'focus .js-button': function focusJsButton() {
        this.trigger('focus', this);
      },
      'blur': function blur() {
        this.trigger('blur', this);
      }
    },
  
    options: {
      selectedItemTemplate: selectedItemTemplate,
      itemListTemplate: itemListTemplate,
      customListItemView: CustomListItemView
    },
  
    initialize: function initialize(opts) {
      EditorHelpers.setOptions(this, opts);
  
      this.collection = new CustomListCollection(opts.schema.options);
      this.dialogMode = this.options.dialogMode || DialogConstants.Mode.DEFAULT;
  
      this._initViews();
      this.setValue(this.model.get(opts.key));
      Backbone.Form.editors.Base.prototype.initialize.call(this, opts);
  
      this._initBinds();
    },
  
    _getLabel: function _getLabel() {
      var itemCount = _.compact(this.collection.pluck('selected')).length;
      return _t('components.backbone-forms.select.selected', { count: itemCount });
    },
  
    _initViews: function _initViews() {
      var isLoading = this.options.loading;
      var isEmpty = !this.collection.length;
      var isDisabled = !isEmpty ? this.options.disabled : true;
      var name = this._getLabel();
      var isNull = name === null;
      var label = isNull ? 'null' : name;
  
      this.$el.html(template({
        label: label,
        keyAttr: this.options.keyAttr,
        isDisabled: isDisabled,
        isLoading: isLoading,
        isEmpty: isEmpty,
        isNull: isNull,
        placeholder: null,
        help: this.options.help
      }));
  
      if (isDisabled) {
        this.undelegateEvents();
      }
  
      this._listView = new CustomListView({
        collection: this.collection,
        showSearch: this.options.showSearch,
        typeLabel: this.options.keyAttr,
        itemTemplate: this.options.itemListTemplate,
        itemView: this.options.customListItemView,
        actions: [{
          label: _t('components.backbone-forms.select.none'),
          action: this._deselectAll.bind(this)
        }, {
          label: _t('components.backbone-forms.select.all'),
          action: this._selectAll.bind(this)
        }],
        searchPlaceholder: 'Search'
      });
  
      this._listView.bind('hidden', this._onHide, this);
  
      this._popupManager = new PopupManager(this.cid, this.$el, this._listView.$el);
      this._popupManager.append(this.dialogMode);
    },
  
    _initBinds: function _initBinds() {
      var hide = function () {
        this._listView.hide();
        this._popupManager.untrack();
      }.bind(this);
  
      this.collection.bind('change:selected', _.debounce(this._onItemSelected, 50), this);
      this.applyESCBind(hide);
      this.applyClickOutsideBind(hide);
    },
  
    _selectAll: function _selectAll() {
      this.collection.each(function (model) {
        model.set('selected', true);
      });
    },
  
    _deselectAll: function _deselectAll() {
      this.collection.each(function (model) {
        model.set('selected', false);
      });
    },
  
    _onItemSelected: function _onItemSelected(mdl) {
      this._renderButton(mdl).focus();
      this.trigger('change', this);
    },
  
    _onButtonClick: function _onButtonClick(ev) {
      this._listView.toggle();
      this._listView.isVisible() ? this._popupManager.track() : this._popupManager.untrack();
    },
  
    _onButtonKeyDown: function _onButtonKeyDown(ev) {
      if (ev.which === ENTER_KEY_CODE) {
        ev.preventDefault();
        if (!this._listView.isVisible()) {
          ev.stopPropagation();
          this._listView.toggle();
          this._popupManager.track();
        } else {
          this._popupManager.untrack();
        }
      }
    },
  
    _getSelectedValues: function _getSelectedValues() {
      return this.collection.chain().map(function (m) {
        return m.get('selected') ? m.get('val') : null;
      }).compact().value();
    },
  
    getValue: function getValue() {
      var values = this._getSelectedValues();
      if (values.length > 0) {
        return values;
      }
    },
  
    setValue: function setValue(value) {
      if (value) {
        var selectedModel = this.collection.setSelected(value);
  
        if (selectedModel) {
          this._renderButton(selectedModel);
        }
      }
    },
  
    _renderButton: function _renderButton(mdl) {
      var button = this.$('.js-button');
      var data = _.extend({}, mdl.attributes, { label: this._getLabel() });
      var $html = this.options.selectedItemTemplate(data);
  
      button.removeClass('is-empty').html($html);
  
      return button;
    },
  
    _onHide: function _onHide() {
      if (this._getSelectedValues().length > 0) {
        this.trigger('change', this);
      }
    },
  
    remove: function remove() {
      this._popupManager && this._popupManager.destroy();
      this._listView && this._listView.clean();
      Backbone.Form.editors.Base.prototype.remove.call(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/select/select-list-view.js":
  /*!******************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/select/select-list-view.js ***!
    \******************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var CustomView = __webpack_require__(/*! builder/components/custom-list/custom-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-view.js");
  var DropdownOverlayView = __webpack_require__(/*! builder/components/dropdown-overlay/dropdown-overlay-view */ "./lib/assets/javascripts/builder/components/dropdown-overlay/dropdown-overlay-view.js");
  var statusTemplate = __webpack_require__(/*! ./select-list-view-states.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/select/select-list-view-states.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['collection', 'itemTemplate', 'itemView'];
  
  module.exports = CoreView.extend({
    module: 'components:form-components:editors:select:select-list-view',
  
    className: 'CustomList',
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this._selectModel = this.options.selectModel;
      this.model = new Backbone.Model({
        visible: false
      });
  
      if (this.options.mouseOverAction) {
        this._mouseOverAction = this.options.mouseOverAction;
      }
  
      if (this.options.mouseOutAction) {
        this._mouseOutAction = this.options.mouseOutAction;
      }
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this._renderListSection();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this.model, 'change:visible', function (mdl, isVisible) {
        isVisible ? this.render() : this.clearSubViews();
        this._toggleVisibility();
        this.trigger('change:visible');
      });
  
      if (this.collection.isAsync()) {
        this.listenTo(this.collection.stateModel, 'change:state', this._renderListSection);
      }
    },
  
    _createListView: function _createListView() {
      if (this._listView) {
        this._listView.clean();
        this.removeView(this._listView);
      }
      this._listView = new CustomView({
        className: 'CDB-Box-modal CustomList--inner',
        collection: this.collection,
        showSearch: this.options.showSearch,
        allowFreeTextInput: this.options.allowFreeTextInput,
        typeLabel: this.options.typeLabel,
        itemTemplate: this._itemTemplate,
        itemView: this._itemView,
        position: this.options.position,
        searchPlaceholder: this.options.searchPlaceholder,
        selectModel: this._selectModel,
        mouseOverAction: this._mouseOverAction,
        mouseOutAction: this._mouseOutAction
      });
  
      this.addView(this._listView);
      this._listView.show();
      this.el.appendChild(this._listView.render().el);
    },
  
    _createStatusView: function _createStatusView(status) {
      var el = statusTemplate({
        status: status,
        type: this.options.typeLabel
      });
  
      this.$el.html(el);
    },
  
    _renderListSection: function _renderListSection() {
      var status = this._getStatus();
  
      if (status === 'fetched') {
        this._createListView();
      } else {
        this._createStatusView(status);
      }
    },
  
    show: function show() {
      this.model.set('visible', true);
    },
  
    hide: function hide() {
      this.model.set('visible', false);
    },
  
    toggle: function toggle() {
      this.model.set('visible', !this.model.get('visible'));
    },
  
    _renderOverlay: function _renderOverlay() {
      var closestModalDialog = this.$el.closest('.Dialog');
  
      this._dropdownOverlay = new DropdownOverlayView({
        container: closestModalDialog.length ? closestModalDialog : undefined,
        onClickAction: this.hide.bind(this),
        visible: true
      });
  
      this.addView(this._dropdownOverlay);
    },
  
    _destroyOverlay: function _destroyOverlay() {
      this._dropdownOverlay && this._dropdownOverlay.clean() && this.removeView(this._dropdownOverlay);
    },
  
    isVisible: function isVisible() {
      return this.model.get('visible');
    },
  
    _toggleVisibility: function _toggleVisibility() {
      this.$el.toggleClass('is-visible', !!this.isVisible());
  
      if (this.isVisible()) {
        this._renderOverlay();
      } else {
        this._destroyOverlay();
      }
    },
  
    _getStatus: function _getStatus() {
      if (this.collection.isAsync()) {
        return this.collection.stateModel.get('state');
      } else {
        return 'fetched';
      }
    },
  
    _destroyBinds: function _destroyBinds() {
      this.stopListening(this.collection);
    },
  
    _onMouseOver: function _onMouseOver() {
      this._mouseOverAction && this._mouseOverAction();
    },
  
    _onMouseOut: function _onMouseOut() {
      this._mouseOutAction && this._mouseOutAction();
    },
  
    remove: function remove() {
      this._listView && this._listView.clean();
      this._dropdownOverlay && this._dropdownOverlay.clean();
      this._destroyBinds();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/select/select-placeholder.js":
  /*!********************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/select/select-placeholder.js ***!
    \********************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  Backbone.Form.editors.SelectPlaceholder = Backbone.Form.editors.Select.extend({
    initialize: function initialize(opts) {
      Backbone.Form.editors.Select.prototype.initialize.call(this, opts);
    },
  
    _renderButton: function _renderButton(model) {
      Backbone.Form.editors.Select.prototype._renderButton.call(this, model);
  
      if (this.options.forcePlaceholder) {
        this._getButton().addClass('is-empty');
      }
    },
  
    _getLabel: function _getLabel() {
      if (this.options.forcePlaceholder) {
        return this.options.placeholder;
      }
  
      return Backbone.Form.editors.Select.prototype._getLabel.call(this);
    },
  
    _hasValue: function _hasValue() {
      if (this.options.forcePlaceholder) {
        return false;
      }
  
      return Backbone.Form.editors.Select.prototype._hasValue.call(this);
    },
  
    _getButtonTemplateData: function _getButtonTemplateData(model) {
      var data = Backbone.Form.editors.Select.prototype._getButtonTemplateData.call(this, model);
  
      if (this.options.forcePlaceholder) {
        data.label = this.options.placeholder;
      }
  
      return data;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/select/select-view.js":
  /*!*************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/select/select-view.js ***!
    \*************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CustomListCollection = __webpack_require__(/*! builder/components/custom-list/custom-list-collection */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-collection.js");
  var selectedItemTemplate = __webpack_require__(/*! ./select-item.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/select/select-item.tpl");
  var CustomListItemView = __webpack_require__(/*! builder/components/custom-list/custom-list-item-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item-view.js");
  var itemListTemplate = __webpack_require__(/*! builder/components/custom-list/custom-list-item.tpl */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item.tpl");
  var template = __webpack_require__(/*! ./select.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/select/select.tpl");
  var PopupManager = __webpack_require__(/*! builder/components/popup-manager */ "./lib/assets/javascripts/builder/components/popup-manager.js");
  var DialogConstants = __webpack_require__(/*! builder/components/form-components/_constants/_dialogs */ "./lib/assets/javascripts/builder/components/form-components/_constants/_dialogs.js");
  var SelectListView = __webpack_require__(/*! ./select-list-view */ "./lib/assets/javascripts/builder/components/form-components/editors/select/select-list-view.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  
  var ENTER_KEY_CODE = 13;
  
  Backbone.Form.editors.Select = Backbone.Form.editors.Base.extend({
  
    tagName: 'div',
    className: 'u-ellipsis Editor-formSelect',
  
    events: {
      'click .js-button': '_onButtonClick',
      'keydown .js-button': '_onButtonKeyDown',
      'focus .js-button': function focusJsButton() {
        this.trigger('focus', this);
      },
      'blur': function blur() {
        this.trigger('blur', this);
      }
    },
  
    options: {
      selectedItemTemplate: selectedItemTemplate,
      itemListTemplate: itemListTemplate,
      customListItemView: CustomListItemView
    },
  
    initialize: function initialize(opts) {
      Backbone.Form.editors.Base.prototype.initialize.call(this, opts);
      EditorHelpers.setOptions(this, opts);
  
      this.template = opts.template || template;
      this.dialogMode = this.options.dialogMode || DialogConstants.Mode.DEFAULT;
  
      if (this.options.mouseOverAction) {
        this._mouseOverAction = this.options.mouseOverAction;
      }
  
      if (this.options.mouseOutAction) {
        this._mouseOutAction = this.options.mouseOutAction;
      }
  
      if (this.options.editorAttrs && this.options.editorAttrs.help) {
        this._help = this.options.editorAttrs.help;
      }
  
      if (this.options.options != null) {
        this.collection = new CustomListCollection(this.options.options);
      } else {
        this.collection = this.options.collection;
      }
  
      if (this.collection.isAsync === undefined) {
        throw new Error('collection must implement isAsync method.');
      }
  
      this._initViews();
  
      this.setValue(this.model.get(this.options.keyAttr));
  
      this._initBinds();
    },
  
    render: function render() {
      var isEmpty = !this.collection.length;
      var isNull = !this._hasValue();
      this._isDisabled = !isEmpty ? this.options.disabled : true;
      var placeholder = this._getPlaceholder(this._isDisabled);
      var label = isNull ? placeholder : this._getLabel();
      var isLoading = this._isLoading();
  
      this.$el.html(this.template({
        keyAttr: this.options.keyAttr,
        isEmpty: isEmpty,
        label: label,
        isDisabled: this._isDisabled,
        isNull: isNull,
        isLoading: isLoading,
        help: this._help || ''
      }));
  
      // we are replacing the html, so we need to re append if nested mode
      if (this.dialogMode === DialogConstants.Mode.NESTED) {
        this._popupManager.append(this.dialogMode);
      }
  
      if (!isLoading) {
        this._renderSelected();
      }
  
      return this;
    },
  
    _initBinds: function _initBinds() {
      var hide = function () {
        this._listView.hide();
        this._popupManager.untrack();
        this._onToggleSelected();
      }.bind(this);
  
      this.applyESCBind(hide);
  
      this.listenTo(this.collection, 'change:selected', this._onItemSelected);
      this.listenTo(this._listView, 'change:visible', this._onToggleSelected);
  
      if (this.collection.isAsync()) {
        this.listenTo(this.collection.stateModel, 'change:state', this.render);
      }
    },
  
    _initViews: function _initViews() {
      this._listView = new SelectListView({
        collection: this.collection,
        showSearch: this.options.showSearch,
        allowFreeTextInput: this.options.allowFreeTextInput,
        typeLabel: this.options.keyAttr,
        itemTemplate: this.options.itemListTemplate,
        itemView: this.options.customListItemView,
        position: this.options.position,
        searchPlaceholder: this.options.searchPlaceholder,
        selectModel: this.options.defaultValue && this.model,
        mouseOverAction: this._mouseOverAction,
        mouseOutAction: this._mouseOutAction
      });
  
      this._popupManager = new PopupManager(this.cid, this.$el, this._listView.$el);
      this._popupManager.append(this.dialogMode);
    },
  
    _getPlaceholder: function _getPlaceholder(isDisabled) {
      var keyAttr = this.options.keyAttr;
      var placeholder;
  
      if (isDisabled) {
        placeholder = this.options.disabledPlaceholder || _t('components.backbone-forms.select.disabled-placeholder', { keyAttr: keyAttr });
      } else {
        placeholder = this.options.placeholder || _t('components.backbone-forms.select.placeholder', { keyAttr: keyAttr });
      }
  
      return placeholder;
    },
  
    _hasValue: function _hasValue() {
      var name = this.model.get(this.options.keyAttr);
      return name != null && name !== '';
    },
  
    _getLabel: function _getLabel() {
      var name = this.model.get(this.options.keyAttr);
      var mdl = this.collection.findWhere({ val: name });
      return mdl && mdl.getName() || name || '';
    },
  
    _isLoading: function _isLoading() {
      var isLoading = this.options.loading;
  
      if (this.collection.isAsync()) {
        isLoading = this.collection.stateModel.get('state') === 'fetching';
      }
  
      return isLoading;
    },
  
    _destroyBinds: function _destroyBinds() {
      this.stopListening(this.collection);
      Backbone.Form.editors.Base.prototype._destroyBinds.call(this);
    },
  
    _onItemSelected: function _onItemSelected(model) {
      this._listView.hide();
      this._popupManager.untrack();
      this._renderButton(model);
      this.trigger('change', this);
    },
  
    _onButtonClick: function _onButtonClick() {
      if (this._isDisabled) {
        return;
      }
  
      this._listView.toggle();
      this._listView.isVisible() ? this._popupManager.track() : this._popupManager.untrack();
      this._onToggleSelected();
    },
  
    _onButtonKeyDown: function _onButtonKeyDown(event) {
      if (this._isDisabled) {
        return;
      }
  
      if (event.which === ENTER_KEY_CODE) {
        event.preventDefault();
  
        if (!this._listView.isVisible()) {
          event.stopPropagation();
          this._listView.toggle();
        } else {
          this._popupManager.track();
        }
      }
    },
  
    getValue: function getValue() {
      var item = this.collection.getSelectedItem();
      if (item) {
        return item.getValue();
      } else {
        return this.value;
      }
    },
  
    setValue: function setValue(value) {
      var selectedModel = this.collection.setSelected(value);
      if (selectedModel) {
        this._renderButton(selectedModel);
      } else {
        this.render();
      }
      this.value = value;
    },
  
    _renderSelected: function _renderSelected() {
      var selectedModel = this.collection.getSelectedItem();
      if (selectedModel) {
        this._renderButton(selectedModel);
      }
    },
  
    _getButton: function _getButton() {
      return this.$('.js-button');
    },
  
    _getButtonTemplateData: function _getButtonTemplateData(model) {
      return _.extend({ isSourceType: false }, model.attributes, { label: model.getName() });
    },
  
    _renderButton: function _renderButton(model) {
      var button = this._getButton();
      var data = this._getButtonTemplateData(model);
      var $html = this.options.selectedItemTemplate(data);
  
      button.removeClass('is-empty').html($html);
  
      this._initButtonBinds();
  
      if (this._help) {
        this._removeTooltip();
  
        this._helpTooltip = new TipsyTooltipView({
          el: this.$('.js-help'),
          gravity: 'w',
          title: function title() {
            return $(this).data('tooltip');
          }
        });
      }
  
      return button;
    },
  
    _removeTooltip: function _removeTooltip() {
      if (this._helpTooltip) {
        this._helpTooltip.clean();
      }
    },
  
    _initButtonBinds: function _initButtonBinds() {
      var button = this._getButton();
  
      button.on('mouseover', this._onMouseOver.bind(this)).on('mouseout', this._onMouseOut.bind(this));
    },
  
    _destroyButtonBinds: function _destroyButtonBinds() {
      var button = this._getButton();
  
      button.off('mouseover', this._onMouseOver.bind(this)).off('mouseout', this._onMouseOut.bind(this));
    },
  
    remove: function remove() {
      this._removeTooltip();
      this._popupManager && this._popupManager.destroy();
      this._listView && this._listView.clean();
      this._destroyButtonBinds();
      this._destroyBinds();
      Backbone.Form.editors.Base.prototype.remove.call(this);
    },
  
    _onToggleSelected: function _onToggleSelected() {
      var visible = this._listView.isVisible();
  
      this.$el.toggleClass('is-active', visible);
  
      if (!visible) {
        this._getButton().blur();
      }
    },
  
    _onMouseOver: function _onMouseOver() {
      this._mouseOverAction && this._mouseOverAction();
    },
  
    _onMouseOut: function _onMouseOut() {
      this._mouseOutAction && this._mouseOutAction();
    },
  
    clean: function clean() {
      this.$el.remove();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/select/suggest-view.js":
  /*!**************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/select/suggest-view.js ***!
    \**************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  var CustomListCollection = __webpack_require__(/*! builder/components/custom-list/custom-list-collection */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-collection.js");
  var DialogConstants = __webpack_require__(/*! builder/components/form-components/_constants/_dialogs */ "./lib/assets/javascripts/builder/components/form-components/_constants/_dialogs.js");
  var template = __webpack_require__(/*! ./select.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/select/select.tpl");
  
  Backbone.Form.editors.Suggest = Backbone.Form.editors.Select.extend({
  
    initialize: function initialize(opts) {
      Backbone.Form.editors.Base.prototype.initialize.call(this, opts);
      EditorHelpers.setOptions(this, opts);
  
      this.template = opts.template || template;
      this.dialogMode = this.options.dialogMode || DialogConstants.Mode.DEFAULT;
      this._setupCollection();
      this._initViews();
  
      this.setValue(this.model.get(this.options.keyAttr));
  
      this._initBinds();
    },
  
    _setupCollection: function _setupCollection() {
      var item = { label: this.value, val: this.value };
      this.collection = new CustomListCollection(this.options.options);
  
      if (this.options.editorAttrs && this.options.editorAttrs.collectionData) {
        var categories = _.map(this.options.editorAttrs.collectionData, function (data) {
          return { label: data, val: data };
        });
  
        this.collection.reset(categories);
      }
  
      if (this.value && !this.collection.findWhere(item)) {
        this.collection.add(item);
      }
    },
  
    _initBinds: function _initBinds() {
      var hide = function () {
        this._listView.hide();
        this._popupManager.untrack();
      }.bind(this);
  
      this.collection.bind('change:selected', this._onItemSelected, this);
      this.collection.bind('reset', this.render, this);
      this.applyESCBind(hide);
      this.applyClickOutsideBind(hide);
    },
  
    _renderButton: function _renderButton(model) {
      var button = this.$('.js-button');
      var name = model.getName();
      var isNull = name === null || name === 'null';
      var label = isNull ? 'null' : name;
  
      var data = _.extend({}, model.attributes, { label: label });
      var $html = this.options.selectedItemTemplate(data);
  
      button.html($html).toggleClass('is-empty', isNull);
  
      return button;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/size/size-by-value-content-view.js":
  /*!**************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/size/size-by-value-content-view.js ***!
    \**************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./size-by-value-content-view.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/size/size-by-value-content-view.tpl");
  
  var DEFAULT_RANGE = [1, 5];
  
  module.exports = CoreView.extend({
    events: {
      'click .js-back': '_onClickBack',
      'click .js-bins': '_onClickBins',
      'click .js-quantification': '_onClickQuantification'
    },
  
    render: function render() {
      this.clearSubViews();
      this._removeForm();
      this.$el.empty();
  
      this.$el.append(template({
        bins: this.model.get('bins'),
        attribute: this.model.get('attribute'),
        quantification: this.model.get('quantification')
      }));
  
      this._initForm();
  
      return this;
    },
  
    _initForm: function _initForm() {
      if (this._formView) this._formView.remove();
  
      var range = this._getRangeOrCalculateItIfNeeded();
      this._formView = this._createFormView(range);
  
      this._renderFormView();
    },
  
    _renderFormView: function _renderFormView() {
      this.$('.js-content').append(this._formView.render().$el);
    },
  
    _getRangeOrCalculateItIfNeeded: function _getRangeOrCalculateItIfNeeded() {
      var min, max;
      var fixedValue = this.model.get('fixed');
  
      var rangeValues = this.model.get('range');
      if (rangeValues) {
        min = +rangeValues[0];
        max = +rangeValues[1];
      }
  
      /* if we come from a fixed value, we need to
       calculate the range values based on this */
      if (fixedValue) {
        var rangeFromFixedValue = this._calculateRangeFromFixed(fixedValue);
        min = rangeFromFixedValue[0];
        max = rangeFromFixedValue[1];
        this.model.set('range', rangeFromFixedValue); // changes are propagated!
        this.model.unset('fixed'); // once we have a range, everything is ready to map by value
      }
  
      return [min, max];
    },
  
    _createFormView: function _createFormView(range) {
      var min = range[0];
      var max = range[1];
  
      var formModel = new Backbone.Model({ min: min, max: max });
  
      var getNumberType = this._getNumberType.bind(this);
      formModel.schema = { min: getNumberType(), max: getNumberType() };
      formModel.bind('change', function (input) {
        this.model.set('range', [+input.get('min'), +input.get('max')]);
      }, this);
  
      var formView = new Backbone.Form({
        className: 'Editor-boxList',
        model: formModel
      });
      formView.bind('change', function () {
        this.commit();
      });
  
      return formView;
    },
  
    _calculateRangeFromFixed: function _calculateRangeFromFixed(fixed, percent) {
      percent = percent || 30;
  
      var span = this.options.max - this.options.min;
      var delta = fixed / span;
      var min = Math.floor(Math.max(this.options.min, fixed - percent * delta));
      var max = Math.floor(Math.min(this.options.max, fixed + percent * delta));
  
      min = Math.max(min, DEFAULT_RANGE[0]);
      max = Math.max(max, DEFAULT_RANGE[1]);
  
      return [min, max];
    },
  
    _getNumberType: function _getNumberType() {
      return {
        type: 'Number',
        validators: ['required', {
          type: 'interval',
          min: this.options.min,
          max: this.options.max
        }]
      };
    },
  
    _removeForm: function _removeForm() {
      this._formView && this._formView.remove();
    },
  
    _onClickBack: function _onClickBack(e) {
      this.killEvent(e);
      this.trigger('back', this);
    },
  
    _onClickQuantification: function _onClickQuantification(e) {
      this.killEvent(e);
      this.trigger('selectQuantification', this);
    },
  
    _onClickBins: function _onClickBins(e) {
      this.killEvent(e);
      this.trigger('selectBins', this);
    },
  
    clean: function clean() {
      this._removeForm();
      CoreView.prototype.clean.call(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/size/size-by-value-view.js":
  /*!******************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/size/size-by-value-view.js ***!
    \******************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  var template = __webpack_require__(/*! ./size-by-value-view.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/size/size-by-value-view.tpl");
  var DialogModel = __webpack_require__(/*! builder/components/dialog/dialog-model */ "./lib/assets/javascripts/builder/components/dialog/dialog-model.js");
  var DialogView = __webpack_require__(/*! builder/components/dialog/dialog-view */ "./lib/assets/javascripts/builder/components/dialog/dialog-view.js");
  
  var StackLayoutView = __webpack_require__(/*! builder/components/stack-layout/stack-layout-view */ "./lib/assets/javascripts/builder/components/stack-layout/stack-layout-view.js");
  var ColumnListView = __webpack_require__(/*! builder/components/custom-list/column-list/column-list-view */ "./lib/assets/javascripts/builder/components/custom-list/column-list/column-list-view.js");
  var columnListQuantificationMethodItemTemplate = __webpack_require__(/*! builder/components/custom-list/column-list/column-list-quantification-method-item.tpl */ "./lib/assets/javascripts/builder/components/custom-list/column-list/column-list-quantification-method-item.tpl");
  var SizeByValueContentView = __webpack_require__(/*! ./size-by-value-content-view */ "./lib/assets/javascripts/builder/components/form-components/editors/size/size-by-value-content-view.js");
  
  var PopupManager = __webpack_require__(/*! builder/components/popup-manager */ "./lib/assets/javascripts/builder/components/popup-manager.js");
  
  var FillConstants = __webpack_require__(/*! builder/components/form-components/_constants/_fill */ "./lib/assets/javascripts/builder/components/form-components/_constants/_fill.js");
  
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['columns', 'popupConfig'];
  
  var COLUMN_PANE_INDEX = 0;
  var MAIN_PANE_INDEX = 1;
  var QUANTIFICATION_PANE_INDEX = 2;
  var BINS_PANE_INDEX = 3;
  
  module.exports = CoreView.extend({
    className: 'Form-StyleByValue u-ellipsis',
  
    events: {
      'click .js-button': '_showByValueDialog',
      'click .js-back': '_onClickBack'
    },
  
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      this._settings = FillConstants.Settings.NUMBER;
      this._setupModel();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this._initViews();
      return this;
    },
  
    afterRender: function afterRender() {
      this._openPopupForColumn();
    },
  
    _openPopupForColumn: function _openPopupForColumn() {
      var columnSelected = this.model.get('attribute');
      if (_.isUndefined(columnSelected)) {
        var self = this;
        this.timeoutId = setTimeout(function () {
          self.timeoutId = null;
          self._showByValueDialog();
        }, 200);
      }
    },
  
    _setupModel: function _setupModel() {
      var options = {};
  
      if (!this.model.get('quantification')) {
        var quantifications = this._settings.quantifications;
        options.quantification = quantifications.items[quantifications.defaultIndex];
      }
  
      var modelBins = this.model.get('bins');
      var defaultBins = this._settings.bins;
  
      if (!modelBins) {
        options.bins = defaultBins.items[defaultBins.defaultIndex];
      }
  
      if (+modelBins > +_.last(defaultBins.items)) {
        options.bins = _.last(defaultBins.items);
      }
  
      this.model.set(options);
      this.listenTo(this.model, 'change:attribute change:range', this.render);
    },
  
    _initViews: function _initViews() {
      this._initDialog();
      this._initPopup();
      this._initInputColumn();
    },
  
    _initDialog: function _initDialog() {
      if (this._dialogView) return;
  
      var dialogModel = new DialogModel();
  
      this.listenToOnce(dialogModel, 'destroy', function () {
        this._dialogView = null;
        this.stopListening(dialogModel);
      });
  
      this._dialogView = new DialogView({
        model: dialogModel
      });
    },
  
    _initPopup: function _initPopup() {
      this._popupManager = new PopupManager(this._popupConfig.cid, this._popupConfig.$el, this._dialogView.$el);
    },
  
    _initInputColumn: function _initInputColumn() {
      var columnSelected = this.model.get('attribute');
      var rangeSelected = this.model.get('range');
  
      var labelColumn = columnSelected || _t('form-components.editors.style.select-by-column');
      var labelRange = rangeSelected ? rangeSelected[0] + ' - ' + rangeSelected[1] : '';
  
      this.$el.append(template({
        columnSelected: !!columnSelected,
        label: labelColumn,
        rangeSelected: !!rangeSelected,
        range: labelRange
      }));
    },
  
    removeDialog: function removeDialog() {
      this._dialogView.clean();
      this._popupManager.untrack();
    },
  
    removePopupManager: function removePopupManager() {
      this._popupManager.destroy();
    },
  
    _createStackView: function _createStackView() {
      var stackLayoutView = new StackLayoutView({
        collection: new Backbone.Collection([{ createStackView: this._createColumnsView.bind(this) }, { createStackView: this._createSizeValueContentView.bind(this) }, { createStackView: this._createQuantificationView.bind(this) }, { createStackView: this._createBinsView.bind(this) }])
      });
      stackLayoutView.model.set('position', this._getDialogStepPosition());
      return stackLayoutView;
    },
  
    _showByValueDialog: function _showByValueDialog() {
      this._dialogView.model.set('createContentView', this._createStackView.bind(this));
      this._dialogView.render();
      this._dialogView.show();
  
      this._popupManager.append(this._popupConfig.mode);
      this._popupManager.track();
    },
  
    _getDialogStepPosition: function _getDialogStepPosition() {
      var position = MAIN_PANE_INDEX;
      if (!this.model.get('attribute')) {
        position = COLUMN_PANE_INDEX;
      } else if (!this.model.get('quantification')) {
        position = QUANTIFICATION_PANE_INDEX;
      }
      return position;
    },
  
    _createColumnsView: function _createColumnsView(stackLayoutModel, opts) {
      var view = new ColumnListView({
        stackLayoutModel: stackLayoutModel,
        columns: this._columns.filter(function (column) {
          return column.type === 'number';
        }),
        showSearch: true,
        typeLabel: 'column'
      });
  
      view.bind('selectItem', function (item) {
        this.model.set('attribute', item.get('val'));
        var step = MAIN_PANE_INDEX;
        if (!this.model.get('quantification')) {
          step = QUANTIFICATION_PANE_INDEX;
        }
        stackLayoutModel.goToStep(step);
      }, this);
  
      return view;
    },
  
    _createSizeValueContentView: function _createSizeValueContentView(stackLayoutModel, opts) {
      var view = new SizeByValueContentView({
        stackLayoutModel: stackLayoutModel,
        model: this.model,
        min: this.options.min,
        max: this.options.max
      });
  
      view.bind('back', function (value) {
        stackLayoutModel.prevStep();
      }, this);
  
      view.bind('selectQuantification', function (value) {
        stackLayoutModel.goToStep(QUANTIFICATION_PANE_INDEX);
      }, this);
  
      view.bind('selectBins', function (value) {
        stackLayoutModel.goToStep(BINS_PANE_INDEX);
      }, this);
  
      return view;
    },
  
    _createQuantificationView: function _createQuantificationView(stackLayoutModel, opts) {
      var view = new ColumnListView({
        headerTitle: _t('form-components.editors.fill.quantification.title'),
        stackLayoutModel: stackLayoutModel,
        columns: this._settings.quantifications.items,
        itemTemplate: columnListQuantificationMethodItemTemplate,
        showSearch: false
      });
  
      view.bind('selectItem', function (item) {
        this.model.set('quantification', item.get('val'));
        stackLayoutModel.prevStep();
      }, this);
  
      view.bind('back', function (value) {
        stackLayoutModel.prevStep();
      }, this);
  
      return view;
    },
  
    _createBinsView: function _createBinsView(stackLayoutModel, opts) {
      var view = new ColumnListView({
        headerTitle: _t('form-components.editors.fill.bins'),
        stackLayoutModel: stackLayoutModel,
        columns: this._settings.bins.items
      });
  
      view.bind('selectItem', function (item) {
        this.model.set('bins', item.get('val'));
        stackLayoutModel.goToStep(MAIN_PANE_INDEX);
      }, this);
  
      view.bind('back', function (value) {
        stackLayoutModel.goToStep(MAIN_PANE_INDEX);
      }, this);
  
      return view;
    },
  
    _onClickBack: function _onClickBack(e) {
      this.killEvent(e);
    },
  
    clean: function clean() {
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
      }
  
      CoreView.prototype.clean.apply(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/size/size-fixed-view.js":
  /*!***************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/size/size-fixed-view.js ***!
    \***************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  module.exports = CoreView.extend({
    render: function render() {
      this.clearSubViews();
      this._removeForm();
      this.$el.empty();
      this._initForm();
      return this;
    },
  
    _initForm: function _initForm() {
      this._formModel = new Backbone.Model({
        value: this.model.get('fixed')
      });
  
      this._formModel.schema = {
        value: {
          type: 'Number',
          title: '',
          validators: ['required', {
            type: 'interval',
            min: this.options.min,
            max: this.options.max,
            step: this.options.step
          }]
        }
      };
  
      this._formModel.bind('change', function (input) {
        this.model.set('fixed', input.get('value'));
      }, this);
  
      this._formView = new Backbone.Form({
        model: this._formModel
      });
  
      this._formView.bind('change', function () {
        this.commit();
      });
  
      this.$el.append(this._formView.render().$el);
    },
  
    _removeForm: function _removeForm() {
      this._formView && this._formView.remove();
    },
  
    clean: function clean() {
      this._removeForm();
      CoreView.prototype.clean.call(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/size/size.js":
  /*!****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/size/size.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  var tabPaneTemplate = __webpack_require__(/*! builder/components/tab-pane/tab-pane.tpl */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane.tpl");
  var createRadioLabelsTabPane = __webpack_require__(/*! builder/components/tab-pane/create-radio-labels-tab-pane */ "./lib/assets/javascripts/builder/components/tab-pane/create-radio-labels-tab-pane.js");
  
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  
  var SizeFixedView = __webpack_require__(/*! ./size-fixed-view */ "./lib/assets/javascripts/builder/components/form-components/editors/size/size-fixed-view.js");
  var SizeByValueView = __webpack_require__(/*! ./size-by-value-view */ "./lib/assets/javascripts/builder/components/form-components/editors/size/size-by-value-view.js");
  
  var FillConstants = __webpack_require__(/*! builder/components/form-components/_constants/_fill */ "./lib/assets/javascripts/builder/components/form-components/_constants/_fill.js");
  
  Backbone.Form.editors.Size = Backbone.Form.editors.Base.extend({
    className: 'Form-InputSize CDB-Text',
  
    events: {
      focus: function focus() {
        this.trigger('focus', this);
      },
      blur: function blur() {
        this.trigger('blur', this);
      }
    },
  
    initialize: function initialize(opts) {
      Backbone.Form.editors.Base.prototype.initialize.call(this, opts);
      EditorHelpers.setOptions(this, opts);
  
      this._sizeModel = new Backbone.Model(this.model.get(opts.key));
  
      this._initBinds();
      this._initViews();
    },
  
    _initBinds: function _initBinds() {
      this._updateSizeModelOnChangeBind();
      this.applyESCBind(this._removeDialogs);
      this.applyClickOutsideBind(this._removeDialogs);
    },
  
    _updateSizeModelOnChangeBind: function _updateSizeModelOnChangeBind() {
      var self = this;
      this._sizeModel.bind('change', function () {
        self.model.set(self.key, self._sizeModel.toJSON());
      }, this);
    },
  
    _removeDialogs: function _removeDialogs() {
      this._valueView && this._valueView.removeDialog();
    },
  
    _removePopupManagers: function _removePopupManagers() {
      this._valueView && this._valueView.removePopupManager();
    },
  
    _initViews: function _initViews() {
      this._tabPaneTabs = this._getTabPanes();
  
      this._setSelectedTab();
  
      this._tabPaneView = createRadioLabelsTabPane(this._tabPaneTabs, this._getTabPaneOptions());
  
      this.listenTo(this._tabPaneView.collection, 'change:selected', this._onChangeTabPaneViewTab);
  
      this.$el.append(this._tabPaneView.render().$el);
    },
  
    _getTabPanes: function _getTabPanes() {
      var tabPaneTabs = [];
      var attrs = this.options.editorAttrs;
      if (attrs && attrs.hidePanes) {
        if (!_.contains(attrs.hidePanes, FillConstants.Panes.FIXED)) tabPaneTabs.push(this._buildFixedPane());
        if (!_.contains(attrs.hidePanes, FillConstants.Panes.BY_VALUE)) tabPaneTabs.push(this._buildByValuePane());
      } else {
        tabPaneTabs = [this._buildFixedPane(), this._buildByValuePane()];
      }
      return tabPaneTabs;
    },
  
    _setSelectedTab: function _setSelectedTab() {
      var selectedIndex = this._getSelectedTabPaneIndex();
      this._tabPaneTabs[selectedIndex].selected = true;
    },
  
    _getTabPaneOptions: function _getTabPaneOptions() {
      var options = {
        tabPaneOptions: {
          template: tabPaneTemplate,
          tabPaneItemOptions: {
            tagName: 'li',
            klassName: 'CDB-NavMenu-item'
          }
        },
        tabPaneItemLabelOptions: {
          tagName: 'div',
          className: 'CDB-Text CDB-Size-medium'
        }
      };
      return options;
    },
  
    _buildFixedPane: function _buildFixedPane() {
      var self = this;
      var geometryName = this.options.editorAttrs.geometryName;
      var fixedPane = {
        name: FillConstants.Panes.FIXED,
        label: _t('form-components.editors.fill.input-number.fixed'),
        tooltip: _t('editor.style.tooltips.size.fixed-tab', { type: geometryName }),
        tooltipGravity: 's',
        createContentView: function createContentView() {
          return self._generateFixedContentView();
        }
      };
      return fixedPane;
    },
  
    _buildByValuePane: function _buildByValuePane() {
      var self = this;
      var geometryName = this.options.editorAttrs.geometryName;
      var valuePane = {
        name: FillConstants.Panes.BY_VALUE,
        label: _t('form-components.editors.fill.input-number.by-value'),
        tooltip: _t('editor.style.tooltips.size.by-value-tab', { type: geometryName }),
        tooltipGravity: 's',
        createContentView: function createContentView() {
          return self._generateByValueContentView();
        }
      };
      return valuePane;
    },
  
    _getSelectedTabPaneIndex: function _getSelectedTabPaneIndex() {
      var FIXED_TAB_PANE = 0;
      var BY_VALUE_PANE = 1;
  
      var hasRange = this._sizeModel.get('range');
      var thereIsByValuePane = this._tabPaneTabs.length > 1;
  
      return hasRange && thereIsByValuePane ? BY_VALUE_PANE : FIXED_TAB_PANE;
    },
  
    _onChangeTabPaneViewTab: function _onChangeTabPaneViewTab() {
      var selectedTabPaneName = this._tabPaneView.getSelectedTabPaneName();
  
      if (selectedTabPaneName === FillConstants.Panes.FIXED) {
        this._updateFixedValue();
      } else {
        this._updateRangeValue();
      }
  
      this.trigger('change', selectedTabPaneName, this);
    },
  
    _updateFixedValue: function _updateFixedValue() {
      var range = this._sizeModel.get('range');
      if (range) {
        // when coming from range calculate the average...
        var avg = 0.5 * (+range[0] + +range[1]);
        this._sizeModel.set('fixed', avg);
        this._sizeModel.unset('range');
      }
    },
  
    _updateRangeValue: function _updateRangeValue() {
      var fixed = this._sizeModel.get('fixed');
      if (fixed !== null && !_.isUndefined(fixed) && this._sizeModel.get('attribute')) {
        var editorAttrs = this.options.editorAttrs;
        var range = editorAttrs && editorAttrs.defaultRange || [fixed, fixed];
        this._sizeModel.set('range', range);
        this._sizeModel.unset('fixed');
      }
    },
  
    _generateFixedContentView: function _generateFixedContentView() {
      var editorAttrs = this.options.editorAttrs;
      this._fixedView = new SizeFixedView({
        model: this._sizeModel,
        min: editorAttrs && editorAttrs.min || FillConstants.Size.DefaultInput100.MIN,
        max: editorAttrs && editorAttrs.max || FillConstants.Size.DefaultInput100.MAX,
        step: editorAttrs && editorAttrs.step || FillConstants.Size.DefaultInput100.STEP
      });
      return this._fixedView;
    },
  
    _generateByValueContentView: function _generateByValueContentView() {
      var editorAttrs = this.options.editorAttrs;
      this._valueView = new SizeByValueView({
        model: this._sizeModel,
        columns: this.schema.options,
        min: editorAttrs && editorAttrs.min || FillConstants.Size.DefaultInput100.MIN,
        max: editorAttrs && editorAttrs.max || FillConstants.Size.DefaultInput100.MAX,
        popupConfig: {
          cid: this.cid,
          $el: this.$el,
          mode: this.options.dialogMode
        }
      });
      return this._valueView;
    },
  
    focus: function focus() {
      if (this.hasFocus) return;
      this.$('.js-menu').focus();
    },
  
    blur: function blur() {
      if (!this.hasFocus) return;
      this.$('.js-menu').blur();
    },
  
    getValue: function getValue() {
      return this._sizeModel.toJSON();
    },
  
    remove: function remove() {
      this._removeDialogs();
      this._removePopupManagers();
      this._tabPaneView.clean();
      this._valueView && this._valueView.clean();
      this._fixedView && this._fixedView.clean();
      Backbone.Form.editors.Base.prototype.remove.apply(this);
    },
  
    clean: function clean() {
      this.$el.remove();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/slider/slider.js":
  /*!********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/slider/slider.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  var template = __webpack_require__(/*! ./slider.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/slider/slider.tpl");
  var MutationObserver = window.MutationObserver;
  
  var TICKS_PLACEHOLDER = 5;
  var HANDLE_WIDTH = 12;
  var DIMENSION = 160;
  var INITIAL = {
    HIGHEST: 'highest',
    LOWEST: 'lowest'
  };
  
  Backbone.Form.editors.Slider = Backbone.Form.editors.Base.extend({
  
    className: 'rangeslider--no-fill',
  
    options: {
      direction: 'horizontal',
      initial: INITIAL.LOWEST
    },
  
    events: {
      'change .js-slider': '_onValueChange',
      focus: function focus() {
        this.trigger('focus', this);
      },
      blur: function blur() {
        this.trigger('blur', this);
      }
    },
  
    initialize: function initialize(opts) {
      Backbone.Form.editors.Base.prototype.initialize.call(this, opts);
      EditorHelpers.setOptions(this, opts);
  
      if (!this.options.labels) {
        throw new Error('labels is required');
      }
  
      if (this.options.values && this.options.labels.length !== this.options.values.length) {
        throw new Error('values and labels should have the same length');
      }
  
      if (this.options.value !== undefined) {
        this.value = this.options.value;
      }
  
      this._onValueChange = this._onValueChange.bind(this);
      this._onSlideChange = this._onSlideChange.bind(this);
  
      this._values = this.options.values;
      this._labels = this.options.labels;
      this._getInitialTickID();
      this._updateUI();
    },
  
    render: function render() {
      var isDisabled = this.options.disabled || this._labels.length <= 0;
      var max = this._labels.length === 0 ? TICKS_PLACEHOLDER - 1 : this._labels.length - 1;
      var step = this._getStepPercentage();
  
      this.$el.html(template({
        orientation: this.options.direction,
        disabled: isDisabled,
        min: 0,
        max: max,
        value: this.rangeIndex
      }));
  
      this._renderSlider();
      this._addTicks(step);
      this._updateUI();
  
      return this;
    },
  
    _getInitialTickID: function _getInitialTickID() {
      var value = this.value;
  
      if (this._values && this._values.length > 0) {
        value = this._values.indexOf(this.value);
  
        if (value === -1) {
          value = this.options.initial === INITIAL.LOWEST ? 0 : this._values.length - 1;
        }
      } else if (!this.value) {
        value = 0;
      }
  
      this.rangeIndex = value;
    },
  
    _getNumberOfValues: function _getNumberOfValues() {
      return this._values && this._values.length || 0;
    },
  
    _renderSlider: function _renderSlider() {
      var element;
      var field;
      var onMutationObserver;
      var observer;
      var config = { subtree: true, childList: true };
  
      if (!MutationObserver) {
        this._initializeSlider();
      } else {
        element = document.body;
        field = this.$('.js-slider').get(0);
        onMutationObserver = function () {
          if (element.contains(field)) {
            this._initializeSlider();
            observer.disconnect();
          }
        }.bind(this);
  
        observer = new MutationObserver(onMutationObserver);
        onMutationObserver();
  
        observer.observe(element, config);
      }
    },
  
    _initializeSlider: function _initializeSlider() {
      var numberOfValues = this._getNumberOfValues();
      var init = function () {
        this.$('.js-slider').rangeslider({
          polyfill: false,
          fillClass: 'rangesliderFill',
          handleClass: 'rangesliderHandle',
          onSlideEnd: this._onSlideChange
        });
      }.bind(this);
  
      if (numberOfValues !== 1) {
        !MutationObserver ? setTimeout(init, 0) : init();
      }
  
      this.$('.js-slider').toggle(numberOfValues !== 1);
    },
  
    _updateUI: function _updateUI() {
      this._updateLabel(this.rangeIndex);
      this._highlightTick(this.rangeIndex);
    },
  
    _addTicks: function _addTicks(step) {
      var offset = HANDLE_WIDTH / 2;
      var numberOfValues = this._getNumberOfValues();
      var ticks = this._labels.length > 0 ? this._labels.length : TICKS_PLACEHOLDER;
      _.each(_.range(ticks), function (tick, index) {
        $('<div class="rangeslider-tick js-tick"></div>').css('left', step * index + offset + 'px').appendTo(this.$('.js-ticks'));
      }, this);
  
      this.$('.js-ticks').toggle(numberOfValues !== 1);
    },
  
    _highlightTick: function _highlightTick(tickID) {
      this.$('.js-tick').removeClass('is-highlighted');
      $(this.$('.js-tick').get(tickID)).addClass('is-highlighted');
    },
  
    _updateLabel: function _updateLabel(tickID) {
      var label = this._labels[tickID];
      if (this._labels.length <= 0) {
        label = _t('form-components.editors.slide.no-values');
      }
      this.$('.js-label').text(label);
    },
  
    _getStepPercentage: function _getStepPercentage() {
      var steps = this._getSteps();
      var rangeWidth = DIMENSION - HANDLE_WIDTH;
  
      return rangeWidth / steps;
    },
  
    _getSteps: function _getSteps() {
      var steps = this._labels.length - 1;
      if (steps < 0) {
        steps = TICKS_PLACEHOLDER - 1;
      }
  
      return steps;
    },
  
    _onValueChange: function _onValueChange(e) {
      var value = this.$('.js-slider').val();
      this._onSlideChange(null, value);
    },
  
    _onSlideChange: function _onSlideChange(position, value) {
      this.rangeIndex = +value;
      this.value = this._values && this._values.length > 0 ? this._values[this.rangeIndex] : this.rangeIndex;
      this._updateUI(this.rangeIndex);
      this.trigger('change', this);
    },
  
    getValue: function getValue() {
      var value = this._values && this._values.length > 0 ? this._values[this.rangeIndex] : null;
      return this.value || value;
    },
  
    setValue: function setValue(value) {
      var index = this._values ? this._values.indexOf(value) : value;
      this.$('.js-slider').val(index).change();
      this.value = value;
    },
  
    _destroySlider: function _destroySlider() {
      this.$('.js-slider').off('change', this._onValueChange);
      this.$('.js-slider').rangeslider('destroy');
    },
  
    remove: function remove() {
      this._destroySlider();
      Backbone.Form.editors.Base.prototype.remove.apply(this);
    },
  
    clean: function clean() {
      this.$el.remove();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/sortable-list.js":
  /*!********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/sortable-list.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  __webpack_require__(/*! jquery-ui */ "./lib/assets/javascripts/vendor/jquery-ui.js");
  
  Backbone.Form.editors.SortableList = Backbone.Form.editors.List.extend({
    initialize: function initialize() {
      Backbone.Form.editors.List.prototype.initialize.apply(this, arguments);
    },
  
    render: function render() {
      Backbone.Form.editors.List.prototype.render.apply(this, arguments);
      this._initSortable();
      return this;
    },
  
    addItem: function addItem() {
      Backbone.Form.editors.List.prototype.addItem.apply(this, arguments);
      this._updateEditability();
      return this;
    },
  
    removeItem: function removeItem() {
      Backbone.Form.editors.List.prototype.removeItem.apply(this, arguments);
      this._updateEditability();
      return this;
    },
  
    _initSortable: function _initSortable() {
      this.$list.sortable({
        axis: 'y',
        items: '.js-sortable',
        tolerance: 'pointer',
        containment: this.$list,
        forceHelperSize: true,
        forcePlaceholderSize: true,
        update: this._onSortableUpdate.bind(this)
      });
    },
  
    _onSortableUpdate: function _onSortableUpdate(event, ui) {
      var sorted = [];
      var list = this.$list;
      var items = this.items;
  
      _.each(items, function (item) {
        var index = item.$el.index(list.$el);
        sorted[index] = item;
      });
  
      this.items = sorted;
      this.commit();
    },
  
    _updateEditability: function _updateEditability() {
      if (this.items.length > 1) {
        this.$('.js-sortable').addClass('is-movable');
        this.$('.js-editable').removeClass('is-hidden');
      } else {
        this.$('.js-sortable').removeClass('is-movable');
        this.$('.js-editable').addClass('is-hidden');
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/taglist/taglist-collection.js":
  /*!*********************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/taglist/taglist-collection.js ***!
    \*********************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  module.exports = Backbone.Collection.extend({
    removeTag: function removeTag(label) {
      var m = this.findWhere({ label: label });
      m && this.remove(m);
    },
  
    addTag: function addTag(label) {
      var m = this.findWhere({ label: label });
      !m && this.add({ label: label });
    },
  
    getValue: function getValue() {
      return this.map(function (mdl) {
        return mdl.get('label');
      });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/taglist/taglist-item-view.js":
  /*!********************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/taglist/taglist-item-view.js ***!
    \********************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  module.exports = CoreView.extend({
    tagName: 'li',
  
    initialize: function initialize(opts) {
      if (!opts.label) throw new Error('label is required');
      this._label = opts.label;
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(this._label);
      return this;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/taglist/taglist.js":
  /*!**********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/taglist/taglist.js ***!
    \**********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var template = __webpack_require__(/*! ./taglist.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/taglist/taglist.tpl");
  var TagView = __webpack_require__(/*! ./taglist-item-view */ "./lib/assets/javascripts/builder/components/form-components/editors/taglist/taglist-item-view.js");
  var TagCollection = __webpack_require__(/*! ./taglist-collection */ "./lib/assets/javascripts/builder/components/form-components/editors/taglist/taglist-collection.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  
  __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  __webpack_require__(/*! jquery-ui */ "./lib/assets/javascripts/vendor/jquery-ui.js");
  __webpack_require__(/*! tagit */ "./vendor/assets/javascripts/tag-it.js");
  
  Backbone.Form.editors.Taglist = Backbone.Form.editors.Base.extend({
    className: 'Form-tags CDB-Text',
    events: {
      'mouseover': '_onMouseOver',
      'mouseout': '_onMouseOut'
    },
    initialize: function initialize(opts) {
      Backbone.Form.editors.Base.prototype.initialize.call(this, opts);
      EditorHelpers.setOptions(this, opts);
  
      this._tagCollection = new TagCollection(this._normalize(opts.schema.options.tags));
  
      this.isEditable = opts.schema.options.isEditable || opts.schema.options.isEditable === undefined;
    },
  
    render: function render() {
      this._initViews();
      return this;
    },
  
    _initViews: function _initViews() {
      var self = this;
      var tagsPlaceholder = !this.isEditable && this._tagCollection.length === 0 ? _t('components.taglist.none') : _t('components.taglist.placeholder');
  
      this.$el.html(template());
  
      this._tagCollection.each(this._renderTag, this);
  
      this.$('.js-tagsList').tagit({
        allowSpaces: true,
        caseSensitive: false,
        placeholderText: tagsPlaceholder,
        readOnly: !this.isEditable,
        onBlur: function onBlur() {
          self.isEditable && self.$el.removeClass('is-focus');
          self.trigger('blur', self);
        },
        onFocus: function onFocus() {
          self.isEditable && self.$el.removeClass('is-hover').addClass('is-focus');
          self.trigger('focus', self);
        },
        preprocessTag: function preprocessTag(tag) {
          return tag.toLowerCase();
        },
        afterTagAdded: self._onTagAdded.bind(self),
        afterTagRemoved: self._onTagRemoved.bind(self)
      });
    },
  
    _renderTag: function _renderTag(model) {
      var view = new TagView({
        label: model.get('label')
      });
  
      this.$('.js-tagsList').append(view.render().el);
    },
  
    focus: function focus() {
      if (this.hasFocus) return;
      this.$el.focus();
    },
  
    blur: function blur() {
      if (!this.hasFocus) return;
      this.$el.blur();
    },
  
    getValue: function getValue() {
      return this._tagCollection.getValue();
    },
  
    setValue: function setValue(tags) {
      this._tagCollection.reset(this._normalize(tags));
      this._destroyTagit();
      this.render();
      this.trigger('change', this);
    },
  
    _onMouseOver: function _onMouseOver() {
      !this.$el.hasClass('is-focus') && this.$el.addClass('is-hover');
    },
  
    _onMouseOut: function _onMouseOut() {
      !this.$el.hasClass('is-focus') && this.$el.removeClass('is-hover');
    },
  
    _onTagRemoved: function _onTagRemoved(e, ui) {
      var tag = ui.tag.find('.tagit-label').text();
      this._tagCollection.removeTag(tag);
      this.trigger('change', this);
    },
  
    _onTagAdded: function _onTagAdded(e, ui) {
      var tag = ui.tag.find('.tagit-label').text();
      this._tagCollection.addTag(tag);
      this.trigger('change', this);
    },
  
    _normalize: function _normalize(tags) {
      return _.map(tags, function (tag) {
        return {
          label: tag.trim()
        };
      });
    },
  
    _destroyTagit: function _destroyTagit() {
      // cannot call public methods before initilization
      // checking ui-widget class does the trick
      this.$('.ui-widget').length > 0 && this.$('.js-tagsList').tagit('destroy');
    },
  
    remove: function remove() {
      this._destroyTagit();
      Backbone.Form.editors.Base.prototype.remove.apply(this);
    },
  
    clean: function clean() {
      this.$el.remove();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/text.js":
  /*!***********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/text.js ***!
    \***********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var EditorHelpers = __webpack_require__(/*! builder/components/form-components/helpers/editor */ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  
  Backbone.Form.editors.Text = Backbone.Form.editors.Text.extend({
    className: 'CDB-InputText CDB-Text',
  
    initialize: function initialize(opts) {
      Backbone.Form.editors.Base.prototype.initialize.call(this, opts);
      EditorHelpers.setOptions(this, opts);
  
      var schema = this.schema;
  
      // Allow customising text type (email, phone etc.) for HTML5 browsers
      var type = 'text';
  
      if (schema && schema.editorAttrs && schema.editorAttrs.type) type = schema.editorAttrs.type;
      if (schema && schema.dataType) type = schema.dataType;
  
      if (this.options.editorAttrs && this.options.editorAttrs.help) {
        this._help = this.options.editorAttrs.help;
      }
  
      this.$el.attr('type', type);
  
      this.determineChange = _.debounce(this.determineChange, 200);
    },
  
    render: function render() {
      this.setValue(this.value);
      this._toggleDisableState();
  
      if (this._isCopyButtonEnabled()) {
        this._toggleClipboardState();
      }
  
      if (this._help) {
        this._removeTooltip();
  
        if (!this.options.disabled) {
          this._helpTooltip = new TipsyTooltipView({
            el: this.$el,
            gravity: 'w',
            title: function () {
              return this._help;
            }.bind(this)
          });
        }
      }
  
      return this;
    },
  
    getValue: function getValue() {
      var val = this.$el.val();
  
      return val === '' ? null : val;
    },
  
    _toggleClipboardState: function _toggleClipboardState() {
      this.$el.toggleClass('Share-input-field u-ellipsis', this._isCopyButtonEnabled());
    },
  
    _togglePlaceholder: function _togglePlaceholder() {
      if (this.options.placeholder) {
        this.$el.attr('placeholder', this.options.placeholder);
      } else {
        var placeholder = this.value === null ? 'null' : '';
        this.$el.attr('placeholder', placeholder);
      }
    },
  
    _toggleDisableState: function _toggleDisableState() {
      if (this.options.disabled) {
        this.$el.attr('readonly', '');
        this.$el.attr('placeholder', '');
  
        // if it's disabled AND has copy, leave just readonly
        if (this._isCopyButtonEnabled()) {
          this.$el.removeAttr('disabled');
        }
      } else {
        this.$el.removeAttr('readonly');
        this._togglePlaceholder();
      }
  
      this.$el.toggleClass('is-disabled', !!this.options.disabled);
    },
  
    _isCopyButtonEnabled: function _isCopyButtonEnabled() {
      return !!this.options.hasCopyButton;
    },
  
    _removeTooltip: function _removeTooltip() {
      if (this._helpTooltip) {
        this._helpTooltip.clean();
      }
    },
  
    remove: function remove() {
      this._removeTooltip();
  
      Backbone.Form.editors.Base.prototype.remove.apply(this);
    },
  
    clean: function clean() {
      this.$el.remove();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/textarea.js":
  /*!***************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/textarea.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  Backbone.Form.editors.TextArea = Backbone.Form.editors.Text.extend({
    tagName: 'textarea',
    className: 'CDB-Textarea',
  
    render: function render() {
      this.setValue(this.value);
      this._toggleDisableState();
  
      return this;
    },
  
    getValue: function getValue() {
      var val = this.$el.val();
  
      return val === '' ? null : val;
    },
  
    _toggleDisableState: function _toggleDisableState() {
      if (this.options.disabled) {
        this.$el.attr('readonly', '');
        this.$el.attr('placeholder', '');
      } else {
        this.$el.removeAttr('readonly');
        this._togglePlaceholder();
      }
  
      this.$el.toggleClass('is-disabled', !!this.options.disabled);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/editors/toggle/toggle.js":
  /*!********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/editors/toggle/toggle.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var template = __webpack_require__(/*! ./toggle.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/toggle/toggle.tpl");
  
  Backbone.Form.editors.Toggle = Backbone.Form.editors.Radio.extend({
    className: 'Editor-formLabel CDB-Text CDB-Size-medium u-alignCenter',
  
    _arrayToHtml: function _arrayToHtml(array) {
      var name = this.getName();
      var id = this.id;
  
      var items = _.map(array, function (option, index) {
        var val = this.form.model.get(this.key);
        var item = {
          name: name,
          id: id + '-' + index
        };
  
        if (_.isObject(option)) {
          item.value = option.val || option.val === 0 ? option.val : '';
          item.label = option.label;
          item.help = option.help;
          item.labelHTML = option.labelHTML;
          item.selected = val !== void 0 ? val === option.val : option.selected;
        } else {
          item.value = option;
          item.label = option;
          item.selected = val !== void 0 ? val === option : option.selected;
        }
  
        return item;
      }.bind(this));
  
      return template({ items: items });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/field.js":
  /*!****************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/field.js ***!
    \****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view.js */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  var Clipboard = __webpack_require__(/*! clipboard */ "./node_modules/clipboard/lib/clipboard.js");
  
  Backbone.Form.Field = Backbone.Form.Field.extend({
  
    initialize: function initialize(options) {
      this.trackingClass = options.trackingClass;
      this.constructor.__super__.initialize.apply(this, arguments);
    },
  
    render: function render() {
      this.constructor.__super__.render.apply(this, arguments);
      if (this.schema.help) {
        this._setHelp();
      }
  
      if (this._isCopyButtonEnabled()) {
        this._initClipboard();
      }
  
      return this;
    },
  
    /**
    * OVERWRITTEN the creation of the full field schema, merging defaults etc.
    *
    * @param {Object|String} schema
    *
    * @return {Object}
    */
    createSchema: function createSchema(schema) {
      var editorType = schema.type;
      schema = this.constructor.__super__.createSchema.apply(this, arguments);
      schema.editorType = editorType;
      return schema;
    },
  
    /**
     * OVERWRITTEN the creation of the editor specified in the schema; either an
     * editor string name or a constructor function
     *
     * @return {View}
     */
    createEditor: function createEditor() {
      var options = _.extend(_.pick(this, 'schema', 'form', 'key', 'model', 'value', 'trackingClass'), { id: this.createEditorId() });
  
      var ConstructorFn = this.schema.type;
  
      return new ConstructorFn(options);
    },
  
    _setHelp: function _setHelp() {
      this._helpTooltip = this._createTooltip({
        $el: this.$('.js-help')
      });
    },
  
    // Changed original setError function in order to add
    // the error tooltip
    setError: function setError(msg) {
      if (this.editor.hasNestedForm || this.schema.hideValidationErrors) return;
      this.$el.addClass(this.errorClassName);
  
      this._destroyErrorTooltip();
      this._errorTooltip = this._createTooltip({
        gravity: 'w',
        className: 'is-error',
        msg: msg,
        offset: 5
      });
      this._errorTooltip.showTipsy();
    },
  
    // Changed original clearError function in order to remove
    // the error tooltip
    clearError: function clearError() {
      this.$el.removeClass(this.errorClassName);
      this._destroyErrorTooltip();
    },
  
    _initClipboard: function _initClipboard() {
      if (this._clipboard) {
        this._clipboard.destroy();
      }
  
      var btn = this.$('.js-copy');
      this._clipboard = new Clipboard(btn.get(0));
    },
  
    _createTooltip: function _createTooltip(opts) {
      return new TipsyTooltipView({
        el: opts.$el || this.$el,
        gravity: opts.gravity || 's',
        className: opts.className || '',
        offset: opts.offset || 0,
        title: function title() {
          return opts.msg || $(this).data('tooltip');
        }
      });
    },
  
    _destroyErrorTooltip: function _destroyErrorTooltip() {
      if (this._errorTooltip) {
        this._errorTooltip.hideTipsy();
        this._errorTooltip.destroyTipsy();
      }
    },
  
    _destroyHelpTooltip: function _destroyHelpTooltip() {
      if (this._helpTooltip) {
        this._helpTooltip.destroyTipsy();
      }
    },
  
    _destroyClipboard: function _destroyClipboard() {
      if (this._clipboard) {
        this._clipboard.destroy();
      }
    },
  
    // Changed original templateData function in order to add a
    // new template attribute (hasNestedForm)
    templateData: function templateData() {
      var schema = this.schema;
      var type;
  
      try {
        type = this.form.schema[this.key].type;
      } catch (e) {
        type = undefined;
      }
  
      return {
        help: schema.help || '',
        isCopyButtonEnabled: this._isCopyButtonEnabled(),
        hasNestedForm: this.editor.hasNestedForm,
        title: schema.title,
        fieldAttrs: schema.fieldAttrs,
        editorAttrs: schema.editorAttrs,
        key: this.key,
        type: type,
        editorId: this.editor.id,
        editorType: this.editor.el.type
      };
    },
  
    _isCopyButtonEnabled: function _isCopyButtonEnabled() {
      return !!this.schema.hasCopyButton;
    },
  
    remove: function remove() {
      this._destroyErrorTooltip();
      this._destroyHelpTooltip();
      this._destroyClipboard();
      this.editor.remove();
      Backbone.View.prototype.remove.call(this);
    }
  
  }, {
    template: __webpack_require__(/*! ./field.tpl */ "./lib/assets/javascripts/builder/components/form-components/field.tpl"),
    errorClassName: 'CDB-FieldError'
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/fieldset-template.js":
  /*!****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/fieldset-template.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  // overwirte template in order to be able to use flex
  /* eslint-disable */
  Backbone.Form.Fieldset.template = _.template('\
    <div class="Editor-fieldset" data-fields>\
      <% if (legend) { %>\
        <legend><%= legend %></legend>\
      <% } %>\
    </div>\
  ');
  /* eslint-enable */
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/form.js":
  /*!***************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/form.js ***!
    \***************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  Backbone.Form = Backbone.Form.extend({
  
    initialize: function initialize(options) {
      this.options = options;
      Backbone.Form.Original.prototype.initialize.call(this, options);
    },
  
    createField: function createField(key, schema) {
      var options = {
        form: this,
        key: key,
        schema: schema,
        idPrefix: this.idPrefix,
        trackingClass: this.options.trackingClass
      };
  
      if (this.model) {
        options.model = this.model;
      } else if (this.data) {
        options.value = this.data[key];
      } else {
        options.value = undefined;
      }
  
      var field = new this.Field(options);
  
      this.listenTo(field.editor, 'all', this.handleEditorEvent);
  
      return field;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/helpers/editor.js":
  /*!*************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/helpers/editor.js ***!
    \*************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  module.exports = {
  
    setOptions: function setOptions(editor, options) {
      var validators = [];
  
      if (options.schema && options.schema.validators) {
        validators = validators.concat(options.schema.validators);
      }
  
      if (editor.options && editor.options.validators) {
        validators = validators.concat(editor.options.validators);
      }
  
      editor.validators = validators;
      editor.options = this._getEditorOptions(editor, options, validators);
  
      if (editor.options.className) {
        editor.$el.addClass(editor.options.className);
      }
  
      if (editor.options.trackingClass) {
        var trackClasses = editor.options.trackingClass + ' track-' + editor.options.key + editor.options.editorType;
        editor.$el.addClass(trackClasses);
      }
    },
  
    _editorAttrsFromBackboneFormSchema: function _editorAttrsFromBackboneFormSchema(options) {
      return options.schema && options.schema.editorAttrs || {};
    },
  
    _getEditorOptions: function _getEditorOptions(editor, options, validators) {
      var editorOptions = _.omit(editor.options, 'validators') || {};
      var schema = options.schema;
      var backboneFormSchema = this._editorAttrsFromBackboneFormSchema(options);
      var editorAttrs = options.editorAttrs;
      var optionKey = { keyAttr: options.key };
      var optionValidators = { validators: validators };
      var defaultOptions = _.omit(options, 'validators');
  
      return _.extend({}, editorOptions, schema, backboneFormSchema, editorAttrs, optionKey, optionValidators, defaultOptions);
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/index.js":
  /*!****************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/index.js ***!
    \****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  __webpack_require__(/*! backbone-forms */ "./node_modules/backbone-forms/distribution/backbone-forms.js");
  __webpack_require__(/*! rangeslider.js */ "./node_modules/rangeslider.js/dist/rangeslider.js");
  Backbone.$ = $;
  
  // Custom validators
  _.extend(Backbone.Form.validators, {
    columnType: __webpack_require__(/*! ./validators/column-type */ "./lib/assets/javascripts/builder/components/form-components/validators/column-type.js"),
    interval: __webpack_require__(/*! ./validators/interval */ "./lib/assets/javascripts/builder/components/form-components/validators/interval.js"),
    requiredBoolean: __webpack_require__(/*! ./validators/required-boolean */ "./lib/assets/javascripts/builder/components/form-components/validators/required-boolean.js")
  });
  
  Backbone.Form.Original = Backbone.Form;
  
  // Requiring custom form components
  __webpack_require__(/*! ./form */ "./lib/assets/javascripts/builder/components/form-components/form.js");
  __webpack_require__(/*! ./fieldset-template */ "./lib/assets/javascripts/builder/components/form-components/fieldset-template.js");
  __webpack_require__(/*! ./field */ "./lib/assets/javascripts/builder/components/form-components/field.js");
  __webpack_require__(/*! ./editors/base */ "./lib/assets/javascripts/builder/components/form-components/editors/base.js");
  __webpack_require__(/*! ./editors/text */ "./lib/assets/javascripts/builder/components/form-components/editors/text.js");
  __webpack_require__(/*! ./editors/textarea */ "./lib/assets/javascripts/builder/components/form-components/editors/textarea.js");
  __webpack_require__(/*! ./editors/number/number */ "./lib/assets/javascripts/builder/components/form-components/editors/number/number.js");
  __webpack_require__(/*! ./editors/select/select-view */ "./lib/assets/javascripts/builder/components/form-components/editors/select/select-view.js");
  __webpack_require__(/*! ./editors/select/select-placeholder */ "./lib/assets/javascripts/builder/components/form-components/editors/select/select-placeholder.js");
  __webpack_require__(/*! ./editors/select/multi-select-view */ "./lib/assets/javascripts/builder/components/form-components/editors/select/multi-select-view.js");
  __webpack_require__(/*! ./editors/radio/radio */ "./lib/assets/javascripts/builder/components/form-components/editors/radio/radio.js");
  __webpack_require__(/*! ./editors/enabler/enabler-view */ "./lib/assets/javascripts/builder/components/form-components/editors/enabler/enabler-view.js");
  __webpack_require__(/*! ./editors/toggle/toggle */ "./lib/assets/javascripts/builder/components/form-components/editors/toggle/toggle.js");
  __webpack_require__(/*! ./editors/enabler-editor/enabler-editor-view */ "./lib/assets/javascripts/builder/components/form-components/editors/enabler-editor/enabler-editor-view.js");
  __webpack_require__(/*! ./editors/node-dataset/node-dataset-view */ "./lib/assets/javascripts/builder/components/form-components/editors/node-dataset/node-dataset-view.js");
  __webpack_require__(/*! ./editors/operators/operators-view */ "./lib/assets/javascripts/builder/components/form-components/editors/operators/operators-view.js");
  __webpack_require__(/*! ./editors/list/list */ "./lib/assets/javascripts/builder/components/form-components/editors/list/list.js");
  __webpack_require__(/*! ./editors/list/list-item */ "./lib/assets/javascripts/builder/components/form-components/editors/list/list-item.js");
  __webpack_require__(/*! ./editors/sortable-list */ "./lib/assets/javascripts/builder/components/form-components/editors/sortable-list.js");
  __webpack_require__(/*! ./editors/legend/category-item */ "./lib/assets/javascripts/builder/components/form-components/editors/legend/category-item.js");
  __webpack_require__(/*! ./editors/slider/slider */ "./lib/assets/javascripts/builder/components/form-components/editors/slider/slider.js");
  __webpack_require__(/*! ./editors/fill/fill */ "./lib/assets/javascripts/builder/components/form-components/editors/fill/fill.js");
  __webpack_require__(/*! ./editors/fill-color/fill-color */ "./lib/assets/javascripts/builder/components/form-components/editors/fill-color/fill-color.js");
  __webpack_require__(/*! ./editors/size/size */ "./lib/assets/javascripts/builder/components/form-components/editors/size/size.js");
  __webpack_require__(/*! ./editors/taglist/taglist */ "./lib/assets/javascripts/builder/components/form-components/editors/taglist/taglist.js");
  __webpack_require__(/*! ./editors/datetime/datetime */ "./lib/assets/javascripts/builder/components/form-components/editors/datetime/datetime.js");
  __webpack_require__(/*! ./editors/select/suggest-view */ "./lib/assets/javascripts/builder/components/form-components/editors/select/suggest-view.js");
  __webpack_require__(/*! ./editors/code-editor */ "./lib/assets/javascripts/builder/components/form-components/editors/code-editor.js");
  __webpack_require__(/*! ./editors/data-observatory-measurements/data-observatory-measurements-view */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/data-observatory-measurements-view.js");
  __webpack_require__(/*! ./editors/data-observatory-measurements/measurement-item */ "./lib/assets/javascripts/builder/components/form-components/editors/data-observatory-measurements/measurement-item.js");
  __webpack_require__(/*! ./editors/lazy-select/lazy-select-view */ "./lib/assets/javascripts/builder/components/form-components/editors/lazy-select/lazy-select-view.js");
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/nested-form-custom.js":
  /*!*****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/nested-form-custom.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  var CustomForm = Backbone.Form.extend({
    initialize: function initialize(options) {
      this.options = options;
      Backbone.Form.Original.prototype.initialize.call(this, options);
      this.listenTo(this.model, 'updateSchema', this.updateSchema);
    },
  
    updateSchema: function updateSchema(schema) {
      var newFields = _.keys(schema);
      var currentFields = _.keys(this.schema);
      var field;
      var options;
  
      // Remove all fields not present in the new schema
      _.each(currentFields, function (key) {
        if (schema[key] == null) {
          this.fields[key].remove();
          delete this.fields[key];
        }
      }, this);
  
      // Creat all fields not present in the old schema
      _.each(newFields, function (key) {
        var fieldSchema = schema[key];
        if (this.schema[key] == null) {
          this.fields[key] = this.createField(key, fieldSchema);
          this.renderAddedField(key);
        } else {
          // update schema for this field and render
          field = this.fields[key];
          options = _.extend({}, _.omit(field.editor.options, _.keys(schema[key])), {
            schema: schema[key]
          });
  
          field.editor._popupManager && field.editor._popupManager.destroy();
          field.editor._dialogView && field.editor._dialogView.clean();
          field.editor.undelegateEvents();
          if (field.editor._destroyBinds) {
            field.editor._destroyBinds();
          }
          field.editor.initialize(options);
          field.editor.delegateEvents();
          field.editor.render();
        }
      }, this);
  
      // update the schema
      this.schema = _.extend({}, this.schema, schema);
    },
  
    renderAddedField: function renderAddedField(fieldKey) {
      var self = this;
      var fields = this.fields;
      var $form = this.$el;
      var $ = Backbone.$;
  
      $form.find('[data-editors]').each(function (i, el) {
        var $container = $(el);
        var selection = $container.attr('data-editors');
  
        if (_.isUndefined(selection)) return;
  
        // Work out which fields to include
        var keys = selection === '*' ? self.selectedFields || _.keys(fields) : selection.split(',');
  
        // Add them
        _.each(keys, function (key) {
          var field;
          if (key === fieldKey) {
            field = fields[key];
            $container.append(field.editor.render().el);
          }
        });
      });
  
      // Render standalone fields
      $form.find('[data-editors]').each(function (i, el) {
        var $container = $(el);
        var selection = $container.attr('data-editors');
  
        if (_.isUndefined(selection)) return;
  
        // Work out which fields to include
        var keys = selection === '*' ? self.selectedFields || _.keys(fields) : selection.split(',');
  
        // Add them
        _.each(keys, function (key) {
          var field;
          if (key === fieldKey) {
            field = fields[key];
            $container.append(field.editor.render().el);
          }
        });
      });
    }
  });
  
  module.exports = CustomForm;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/validators/column-type.js":
  /*!*********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/validators/column-type.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  module.exports = function (options) {
    var type = options.columnType;
    var collection = options.columnsCollection;
  
    var error = {
      type: options.type,
      message: _t('components.backbone-forms.column-type-error', { columnType: type })
    };
  
    return function columnType(value) {
      var column = collection.findWhere({ name: value });
      var matchesType = column && column.get('type') === type;
  
      if (!matchesType) return error;
    };
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/validators/interval.js":
  /*!******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/validators/interval.js ***!
    \******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  module.exports = function (opts) {
    // get the min value
    var minValue = parseFloat(opts.min) || 0;
    var maxValue = parseFloat(opts.max) || 0;
    var err = {
      type: opts.type,
      message: _t('components.backbone-forms.interval-error', { minValue: opts.min, maxValue: opts.max })
    };
    return function interval(value, attrs) {
      var fieldValue = 0;
  
      if (value === null || value === undefined || value === '') return err;
  
      // check if the value is number
      if (!isNaN(parseFloat(value)) && isFinite(value)) {
        fieldValue = parseFloat(value);
      }
      if (minValue > fieldValue || maxValue < fieldValue) {
        return err;
      }
    };
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/form-components/validators/required-boolean.js":
  /*!**************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/form-components/validators/required-boolean.js ***!
    \**************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  /**
   * Adds a new validator for Boolean fields, based on Form.validators.required
   */
  
  module.exports = function (options) {
    var err = {
      type: 'required',
      message: _t('components.backbone-forms.required-boolean-error')
    };
  
    return function required(value) {
      if (value === undefined) return err;
    };
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/icon/icon-view.js":
  /*!*********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/icon/icon-view.js ***!
    \*********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var iconTemplates = {};
  
  var importAllIconTemplates = function importAllIconTemplates() {
    var templates = __webpack_require__("./lib/assets/javascripts/builder/components/icon/templates sync \\.tpl$");
  
    templates.keys().forEach(function (template) {
      iconTemplates[template] = templates(template);
    });
  };
  
  importAllIconTemplates();
  
  module.exports = CoreView.extend({
    constructor: function constructor(opts) {
      this.placeholder = this._preinitializeWithPlaceholder(opts && opts.placeholder);
      CoreView.prototype.constructor.call(this, opts);
    },
  
    initialize: function initialize(opts) {
      if (!opts || !opts.icon) throw new Error('An icon is required to render IconView');
  
      this.icon = opts.icon;
      this.iconTemplate = this._getIconTemplate(this.icon);
  
      if (!this.iconTemplate) {
        throw new Error('The selected icon does not have any available template');
      }
    },
  
    render: function render() {
      this.$el.html(this.iconTemplate);
  
      if (this.placeholder) {
        this.placeholder.replaceWith(this.$el);
      }
  
      return this;
    },
  
    _getIconTemplate: function _getIconTemplate(icon) {
      var iconTemplate = './' + this.icon + '.tpl';
      return iconTemplates[iconTemplate];
    },
  
    _preinitializeWithPlaceholder: function _preinitializeWithPlaceholder(placeholderNode) {
      if (!placeholderNode) {
        return;
      }
  
      var placeholder = $(placeholderNode);
      this.tagName = placeholder.prop('tagName');
      this.className = placeholder.attr('class');
  
      return placeholder;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/img-loader-view.js":
  /*!**********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/img-loader-view.js ***!
    \**********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  var IMAGE_DIM = 18;
  var IMAGE_FILE_ATTRS = {
    width: '18px',
    height: '18px'
  };
  
  var VIEWBOX = _.template('0 0 <%- w %> <%- h %>');
  module.exports = CoreView.extend({
    initialize: function initialize(opts) {
      if (!opts.imageClass) {
        throw new Error('Image class is mandatory.');
      }
  
      this._imageClass = opts.imageClass;
      this._imageURL = opts.imageUrl;
      this._color = opts.color;
  
      this._lastImage = {
        url: null,
        content: null
      };
    },
  
    render: function render() {
      this.$el.empty();
  
      this._loadImage();
  
      return this;
    },
  
    _loadImage: function _loadImage() {
      if (!this._imageURL) {
        // the URL could be null or undefined
        return;
      }
  
      var self = this;
  
      if (this._isSVG(this._imageURL)) {
        this._loadSVG();
      } else {
        var $img = $('<img crossorigin="anonymous"/>');
        $img.attr('class', self._imageClass + ' js-image');
        $img.attr('src', this._imageURL + '?req=markup');
  
        for (var attribute in IMAGE_FILE_ATTRS) {
          $img.attr(attribute, IMAGE_FILE_ATTRS[attribute]);
        }
  
        this.$el.append($img);
      }
    },
  
    _loadSVG: function _loadSVG() {
      var self = this;
  
      this._requestImageURL(this._imageURL, function (content) {
        var svg = content.cloneNode(true);
        var $svg = $(svg);
        $svg = $svg.removeAttr('xmlns:a');
        $svg.attr('class', self._imageClass + ' js-image');
  
        var bbox = {
          w: IMAGE_DIM,
          h: IMAGE_DIM
        };
  
        if (!$svg.attr('viewBox')) {
          if ($svg.attr('height') && $svg.attr('width')) {
            bbox = {
              w: svg.width.baseVal.value,
              h: svg.height.baseVal.value
            };
          }
  
          $svg.attr('viewBox', VIEWBOX(bbox));
        }
  
        for (var attribute in IMAGE_FILE_ATTRS) {
          $svg.attr(attribute, IMAGE_FILE_ATTRS[attribute]);
        }
  
        self.$el.append($svg);
  
        $svg.css('fill', self._color);
        $svg.find('g').css('fill', 'inherit');
        $svg.find('path').css('fill', 'inherit');
        $svg.find('rect').each(function (_, rect) {
          var $rect = $(rect);
          if ($rect.css('fill') !== 'none') {
            $rect.css('fill', 'inherit');
          }
        });
      });
    },
  
    _requestImageURL: function _requestImageURL(url, callback) {
      var self = this;
      var completeUrl = url + '?req=ajax';
  
      if (this._lastImage.url === completeUrl) {
        callback && callback(this._lastImage.content);
      } else {
        $.ajax(completeUrl).done(function (data) {
          self._lastImage.url = completeUrl;
          var content = self._lastImage.content = data.getElementsByTagName('svg')[0];
          callback && callback(content);
        }).fail(function () {
          throw new Error("Couldn't get " + completeUrl + ' file.');
        });
      }
    },
  
    updateImageColor: function updateImageColor(color) {
      this.$('.js-image').css('fill', color);
    },
  
    _isSVG: function _isSVG(url) {
      if (!url) {
        return false;
      }
      var noQueryString = url.split('?')[0];
      return noQueryString && utils.endsWith(noQueryString.toUpperCase(), 'SVG');
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/infobox/infobox-view.js":
  /*!***************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/infobox/infobox-view.js ***!
    \***************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['infoboxModel', 'infoboxCollection'];
  
  module.exports = CoreView.extend({
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this._initBinds();
      this._setSelectedModel();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this._initViews();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this._infoboxModel, 'change:state', this._onChangeState);
      this.listenTo(this._infoboxModel, 'change:visible', this.render);
    },
  
    _initViews: function _initViews() {
      var createContentView;
  
      if (this._selectedModel) {
        createContentView = this._selectedModel.get('createContentView');
        this.infoboxView = createContentView();
        this.$el.append(this.infoboxView.render().el);
        this.addView(this.infoboxView);
        this._initSubviewBinds();
      }
    },
  
    _setSelectedModel: function _setSelectedModel() {
      var state = this._infoboxModel.get('state');
      this._selectedModel = this._infoboxCollection.setSelected(state);
    },
  
    _onChangeState: function _onChangeState() {
      this._setSelectedModel();
      this.render();
    },
  
    _initSubviewBinds: function _initSubviewBinds() {
      this.listenTo(this.infoboxView, 'action:main', this._onAction);
      this.listenTo(this.infoboxView, 'action:close', this._onClose);
    },
  
    _onAction: function _onAction() {
      var action = this._selectedModel.get('onAction');
      action && action();
    },
  
    _onClose: function _onClose() {
      var action = this._selectedModel.get('onClose');
      if (action) {
        action();
      } else {
        // if no action associated, we still need to hide the infobox
        this._infoboxModel.set('state', null);
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/inline-editor/inline-editor-view.js":
  /*!***************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/inline-editor/inline-editor-view.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var REQUIRED_OPTS = ['template', 'onEdit', 'renderOptions'];
  
  var DBLCLICK_TIMEOUT = 200;
  var clicks = 0;
  var ESCAPE_KEY_CODE = 27;
  var ENTER_KEY_CODE = 13;
  
  module.exports = CoreView.extend({
    events: {
      'blur .js-input': 'blur',
      'keyup .js-input': '_onKeyUpInput'
    },
  
    initialize: function initialize(opts) {
      _.each(REQUIRED_OPTS, function (item) {
        if (!opts[item]) throw new Error(item + ' is required');
        this['_' + item] = opts[item];
      }, this);
  
      this._onClickHandler = this._onClickHandler.bind(this);
      this.edit = this.edit.bind(this);
      this.save = _.debounce(this.save, 200, true);
  
      this._timeout = opts.timeout || DBLCLICK_TIMEOUT;
    },
  
    render: function render() {
      this._unbindEvents();
      this.clearSubViews();
      this.$el.empty();
      this._initViews();
      this._initBinds();
      return this;
    },
  
    _initBinds: function _initBinds() {
      if (this.options.onClick) {
        this._onClick = this.options.onClick;
        this._title().on('click', this._onClickHandler);
      } else {
        this._title().on('dblclick', this.edit);
      }
    },
  
    _unbindEvents: function _unbindEvents() {
      var $title = this._title();
      $title && $title.off('click dblclick');
    },
  
    _onClickHandler: function _onClickHandler(e) {
      var self = this;
      clicks++;
      if (clicks === 1) {
        setTimeout(function () {
          if (clicks === 1) {
            self._onClick && self._onClick(e);
          } else {
            self.edit();
          }
          clicks = 0;
        }, this._timeout);
      }
    },
  
    _initViews: function _initViews() {
      this.$el.append(this._template(this._renderOptions));
      this.setElement(this.$('.Inline-editor'));
    },
  
    _backupText: function _backupText() {
      this._oldText = this.$('.js-title').text();
    },
  
    _restoreText: function _restoreText() {
      this.$('.js-input').val(this._oldText);
    },
  
    edit: function edit() {
      this._backupText();
      this.$('.js-input').val(this._oldText);
      this.$('.js-input').prop('readonly', false).show().focus();
      this.$('.js-input').get(0).setSelectionRange(0, this.$('.js-input').val().length);
    },
  
    getValue: function getValue() {
      return this.$('.js-input').val();
    },
  
    _title: function _title() {
      return this.$('.js-title');
    },
  
    hide: function hide() {
      this.$('.js-input').prop('readonly', true).hide();
    },
  
    blur: function blur() {
      this.save();
      this.hide();
    },
  
    save: function save() {
      var value = this.getValue();
  
      if (value !== this._oldText && !_.isEmpty(value)) {
        this._onEdit && this._onEdit(value);
      }
    },
  
    clean: function clean() {
      this._unbindEvents();
      CoreView.prototype.clean.call(this);
    },
  
    _onKeyUpInput: function _onKeyUpInput(e) {
      if (e.which === ESCAPE_KEY_CODE) {
        this._restoreText();
        this.hide();
      }
  
      if (e.which === ENTER_KEY_CODE) {
        this.$('.js-input').blur();
        this.save();
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-collection/input-collection.js":
  /*!****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-collection/input-collection.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  var INPUT_TYPE_ORDER = ['color', 'image'];
  
  module.exports = Backbone.Collection.extend({
    constructor: function constructor(models, options) {
      options = _.extend(options || {}, { silent: false });
      Backbone.Collection.prototype.constructor.call(this, models, options);
    },
  
    comparator: function comparator(model) {
      return INPUT_TYPE_ORDER.indexOf(model.get('type'));
    },
  
    initialize: function initialize() {
      this.bind('change', this._onModelsChanged, this);
      this.bind('change:selected', this._onSelectedChange, this);
    },
  
    getSelected: function getSelected() {
      return this.find(function (model) {
        return model.get('selected');
      });
    },
  
    unselect: function unselect() {
      this.each(function (model) {
        model.set('selected', false);
      }, this);
    },
  
    _onSelectedChange: function _onSelectedChange(itemModel, isSelected) {
      if (!isSelected) {
        return;
      }
  
      this.each(function (model) {
        if (model !== itemModel) {
          model.set('selected', false);
        }
      }, this);
    },
  
    _onModelsChanged: function _onModelsChanged(model) {
      var modelChanges = model.changed;
  
      if (_.isEmpty(modelChanges) || _.size(modelChanges) === 1 && model.changed.hasOwnProperty('selected')) {
        return;
      }
  
      this.trigger('onInputChanged', model);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/assets-picker/asset-header-view.js":
  /*!**************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/assets-picker/asset-header-view.js ***!
    \**************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var template = __webpack_require__(/*! ./asset-header-view.tpl */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/asset-header-view.tpl");
  
  var REQUIRED_OPTS = ['title', 'editable'];
  
  module.exports = CoreView.extend({
    events: {
      'click .js-remove': '_onClickRemove',
      'click .js-select-all': '_onClickSelectAll',
      'click .js-deselect-all': '_onClickDeselectAll'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this._assetsCollection = this.options.assetsCollection;
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
  
      var selectedCount = this._getSelectedAssetsCount();
  
      var assetsCount = this._assetsCollection.size();
  
      this.$el.html(template({
        title: this._title,
        editable: this._editable,
        assetsCount: assetsCount,
        selectedCount: selectedCount,
        allSelected: selectedCount === assetsCount
      }));
  
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this._assetsCollection, 'add change remove', this.render);
    },
  
    _onClickRemove: function _onClickRemove() {
      this.trigger('remove');
    },
  
    _onClickSelectAll: function _onClickSelectAll() {
      this.trigger('select-all');
    },
  
    _onClickDeselectAll: function _onClickDeselectAll() {
      this.trigger('deselect-all');
    },
  
    _getSelectedAssetsCount: function _getSelectedAssetsCount() {
      var selectedAssets = this._assetsCollection.where({ state: 'selected' });
      return selectedAssets ? selectedAssets.length : 0;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/assets-picker/asset-item-view.js":
  /*!************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/assets-picker/asset-item-view.js ***!
    \************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  var template = __webpack_require__(/*! ./asset-item-view.tpl */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/asset-item-view.tpl");
  
  var ASSET_HEIGHT = 24;
  
  module.exports = CoreView.extend({
    tagName: 'li',
    className: 'AssetsList-item AssetsList-item--medium',
  
    events: {
      'click .js-asset': '_onClick'
    },
  
    initialize: function initialize(opts) {
      this.listenTo(this.model, 'change:state', this._changeState);
    },
  
    render: function render() {
      this.clearSubViews();
  
      this.$el.attr('id', this.model.get('id'));
  
      var type = this.model.get('type') || 'icon';
  
      this.$el.append(template({
        type: type,
        height: this.options.assetHeight || ASSET_HEIGHT,
        name: this.model.get('name'),
        public_url: this.model.get('public_url')
      }));
  
      this.$el.addClass('AssetsList-item--' + type);
  
      return this;
    },
  
    _onClick: function _onClick(e) {
      this.killEvent(e);
      this.trigger('selected', this.model);
    },
  
    _changeState: function _changeState() {
      this.$el.toggleClass('is-selected', this.model.get('state') === 'selected');
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/assets-picker/assets-list-view.js":
  /*!*************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/assets-picker/assets-list-view.js ***!
    \*************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var StaticAssetItemView = __webpack_require__(/*! ./static-asset-item-view */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/static-asset-item-view.js");
  var StaticAssetsCollection = __webpack_require__(/*! builder/data/static-assets-collection */ "./lib/assets/javascripts/builder/data/static-assets-collection.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['icons', 'selectedAsset'];
  
  module.exports = CoreView.extend({
    tagName: 'ul',
    className: 'AssetsList',
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
      this._setupAssets(opts);
    },
  
    render: function render() {
      this.clearSubViews();
      this._renderAssets();
      return this;
    },
  
    _renderAssets: function _renderAssets() {
      this._assetsCollection.each(function (mdl) {
        var item = new StaticAssetItemView({
          model: mdl
        });
  
        if (this.model && item.model.getURLFor(mdl.get('icon')) === this.model.get('image')) {
          item.model.set('state', 'selected');
        }
  
        item.bind('selected', this._selectItem, this);
  
        this.$el.append(item.render().el);
        this.addView(item);
      }, this);
    },
  
    _setupAssets: function _setupAssets(opts) {
      if (!_.isEmpty(opts)) {
        this._icons = _.map(this._icons, function (asset) {
          return _.extend(asset, opts);
        });
      }
  
      var assets = this._icons;
  
      if (this.options.limit) {
        assets = assets.slice(0, this.options.limit);
      }
  
      this._assetsCollection = new StaticAssetsCollection(assets);
      this.add_related_model(this._assetsCollection);
    },
  
    _selectItem: function _selectItem(m) {
      this._selectedAsset.set({
        url: m.get('public_url'),
        kind: m.get('kind')
      });
  
      this._assetsCollection.deselectAll(m);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/assets-picker/assets-view.js":
  /*!********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/assets-picker/assets-view.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var MakiIcons = __webpack_require__(/*! builder/components/input-color/assets/maki-icons */ "./lib/assets/javascripts/builder/components/input-color/assets/maki-icons.js");
  var UserAssetsView = __webpack_require__(/*! ./user-assets-tab */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/user-assets-tab.js");
  var OrganizationAssetsListView = __webpack_require__(/*! ./organization-assets-list-view */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/organization-assets-list-view.js");
  var OrganizationAssetsCollection = __webpack_require__(/*! builder/data/organization-assets-collection */ "./lib/assets/javascripts/builder/data/organization-assets-collection.js");
  var UploadAssetsView = __webpack_require__(/*! ./upload-assets-tab */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/upload-assets-tab.js");
  
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var AssetsCollection = __webpack_require__(/*! builder/data/assets-collection */ "./lib/assets/javascripts/builder/data/assets-collection.js");
  var createTextLabelsTabPane = __webpack_require__(/*! builder/components/tab-pane/create-text-labels-tab-pane */ "./lib/assets/javascripts/builder/components/tab-pane/create-text-labels-tab-pane.js");
  var ScrollView = __webpack_require__(/*! builder/components/scroll/scroll-view */ "./lib/assets/javascripts/builder/components/scroll/scroll-view.js");
  var AssetsListView = __webpack_require__(/*! ./assets-list-view */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/assets-list-view.js");
  var loadingView = __webpack_require__(/*! builder/components/loading/render-loading */ "./lib/assets/javascripts/builder/components/loading/render-loading.js");
  
  var ErrorView = __webpack_require__(/*! builder/components/error/error-view */ "./lib/assets/javascripts/builder/components/error/error-view.js");
  var errorTemplate = __webpack_require__(/*! ./upload-assets-error.tpl */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/upload-assets-error.tpl");
  var errorParser = __webpack_require__(/*! builder/helpers/error-parser */ "./lib/assets/javascripts/builder/helpers/error-parser.js");
  
  var template = __webpack_require__(/*! ./assets-view.tpl */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/assets-view.tpl");
  var tabPaneTemplate = __webpack_require__(/*! ./tab-pane-template.tpl */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/tab-pane-template.tpl");
  
  var KIND = 'custom-marker';
  
  var REQUIRED_OPTS = ['modalModel', 'configModel', 'userModel'];
  
  module.exports = CoreView.extend({
    className: 'Dialog-content Dialog-content--expanded',
  
    events: {
      'click .js-add': '_onSetImage',
      'click .js-upload': '_initUpload',
      'change .js-fileInput': '_onFileSelected',
      'click .js-back': '_onClickBack'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this._initModels();
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template({
        disclaimer: MakiIcons.disclaimer
      }));
  
      if (this._hasFetchedAllCollections()) {
        this._initTabPane();
      } else if (this._isLoading()) {
        this._renderLoading();
      } else if (this._hasError()) {
        this._renderError();
      }
      return this;
    },
  
    _hasFetchedAllCollections: function _hasFetchedAllCollections() {
      return this._stateModel.get('status') === 'show';
    },
  
    _initModels: function _initModels() {
      var self = this;
  
      this._selectedAsset = new Backbone.Model({
        url: this.model.get('image')
      });
  
      this._stateModel = new Backbone.Model({
        status: 'loading',
        modalEnabled: false,
        uploads: 0
      });
  
      this._assetCollections = [];
  
      this._userAssetCollection = new AssetsCollection(null, {
        configModel: this._configModel,
        userModel: this._userModel
      });
  
      this._assetCollections.push(this._userAssetCollection);
  
      if (this._userModel.isInsideOrg()) {
        this._organizationAssetCollection = new OrganizationAssetsCollection(null, {
          configModel: this._configModel,
          orgId: this._userModel.getOrganization().get('id')
        });
        this._assetCollections.push(this._organizationAssetCollection);
      }
  
      var onFetchAssetCollections = _.invoke(this._assetCollections, 'fetch');
      $.when.apply($, onFetchAssetCollections).then(function () {
        self._stateModel.set('status', 'show');
      }, function (model, response) {
        self._setError(response);
      });
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this._selectedAsset, 'change:url', this._onChangeSelectedAsset);
      this.listenTo(this._stateModel, 'change:status', this.render);
      this.listenTo(this._stateModel, 'change:modalEnabled', this._onChangeSetButton);
    },
  
    _onClickBack: function _onClickBack(e) {
      this.killEvent(e);
      this._stateModel.set('status', 'show');
      this._assetsTabPaneView.setSelectedTabPaneByName('upload-file');
    },
  
    _upload: function _upload(data) {
      this._userAssetCollection.create(data, {
        beforeSend: this._beforeAssetUpload.bind(this),
        success: this._onAssetUploaded.bind(this),
        error: this._onAssetUploadError.bind(this),
        complete: this._onAssetUploadComplete.bind(this)
      });
    },
  
    _renderError: function _renderError() {
      this._hideDisclaimer();
  
      this.$('.js-body').html(new ErrorView({
        title: Utils.capitalize(this._stateModel.get('error_message')),
        desc: _t('components.modals.assets-picker.error-desc'),
        template: errorTemplate
      }).render().el);
    },
  
    _renderLoading: function _renderLoading() {
      this._hideDisclaimer();
  
      this.$('.js-body').html(loadingView({
        title: _t('components.modals.assets-picker.loading')
      }));
    },
  
    _isLoading: function _isLoading() {
      return this._stateModel.get('status') === 'loading';
    },
  
    _hasError: function _hasError() {
      return this._stateModel.get('status') === 'error';
    },
  
    _initTabPane: function _initTabPane() {
      var tabPaneTabs = [{
        name: 'maki-icons',
        label: _t('components.modals.add-asset.icons'),
        createContentView: this._createMakiIconsView.bind(this)
      }, {
        name: 'your-uploads',
        label: _t('components.modals.add-asset.your-uploads'),
        createContentView: this._createYourUploadsView.bind(this)
      }];
  
      if (this._userModel.isInsideOrg() && this._organizationAssetCollection.length > 0) {
        tabPaneTabs.push({
          name: 'organization-uploads',
          label: _t('components.modals.add-asset.organization-uploads'),
          createContentView: this._createOrganizationUploadsView.bind(this)
        });
      }
  
      tabPaneTabs.push({
        name: 'upload-file',
        label: _t('components.modals.add-asset.upload-file'),
        createContentView: this._createUploadFileView.bind(this)
      });
  
      var tabPaneOptions = {
        tabPaneOptions: {
          template: tabPaneTemplate,
          disclaimer: MakiIcons.disclaimer,
          tabPaneItemOptions: {
            tagName: 'li',
            klassName: 'CDB-NavMenu-item'
          }
        },
        tabPaneItemLabelOptions: {
          tagName: 'button',
          className: 'CDB-NavMenu-link u-upperCase'
        }
      };
  
      this._assetsTabPaneView = createTextLabelsTabPane(tabPaneTabs, tabPaneOptions);
      this.listenTo(this._assetsTabPaneView.collection, 'change', this._onChangeSelectedTab);
  
      this.addView(this._assetsTabPaneView);
      this.$('.js-body').append(this._assetsTabPaneView.render().el);
  
      this._initSetButtonState();
    },
  
    _onChangeSelectedTab: function _onChangeSelectedTab() {
      switch (this._assetsTabPaneView.getSelectedTabPaneName()) {
        case 'maki-icons':
          this._setDisclaimer(MakiIcons.disclaimer);
          this._toggleSetButton();
          break;
        case 'upload-file':
          this._hideDisclaimer();
          this._disableSetButton();
          break;
        default:
          this._hideDisclaimer();
          this._toggleSetButton();
          break;
      }
    },
  
    _toggleSetButton: function _toggleSetButton() {
      this._stateModel.set('modalEnabled', this._selectedAsset.get('url') !== undefined);
    },
  
    _initSetButtonState: function _initSetButtonState() {
      if (!this.model.get('image')) {
        return;
      }
  
      var selectedAssetExist = false;
  
      if (this.model.get('kind') === 'marker') {
        selectedAssetExist = true;
      }
  
      if (!selectedAssetExist) {
        _.each(this._assetCollections, function (assetCollection) {
          if (!selectedAssetExist) {
            selectedAssetExist = assetCollection.some(function (mdl) {
              return this.model.get('image') === mdl.get('public_url');
            }, this);
          }
        }, this);
      }
  
      if (selectedAssetExist) {
        this._enableSetButton();
      }
    },
  
    _enableSetButton: function _enableSetButton() {
      this._stateModel.set('modalEnabled', true);
    },
  
    _disableSetButton: function _disableSetButton() {
      this._stateModel.set('modalEnabled', false);
    },
  
    _createYourUploadsView: function _createYourUploadsView() {
      var view = new UserAssetsView({
        model: this.model,
        selectedAsset: this._selectedAsset,
        title: _t('components.modals.add-asset.your-uploads'),
        organizationAssetCollection: this._organizationAssetCollection,
        userAssetCollection: this._userAssetCollection,
        userModel: this._userModel
      }).bind(this);
  
      this._userAssetsView = view;
  
      view.bind('init-upload', this._initUpload, this);
  
      this._hideDisclaimer();
  
      return this._userAssetsView;
    },
  
    _createOrganizationUploadsView: function _createOrganizationUploadsView() {
      var view = new ScrollView({
        createContentView: function () {
          return new OrganizationAssetsListView({
            title: _t('components.modals.add-asset.organization-uploads'),
            model: this.model,
            organizationAssetCollection: this._organizationAssetCollection,
            userAssetCollection: this._userAssetCollection,
            selectedAsset: this._selectedAsset
          });
        }.bind(this)
      });
  
      this._hideDisclaimer();
  
      return view;
    },
  
    _createUploadFileView: function _createUploadFileView() {
      var view = new UploadAssetsView({
        model: this.model,
        userModel: this._userModel,
        configModel: this._configModel
      }).bind(this);
  
      view.bind('upload-complete', this._onUploadComplete, this);
      view.bind('upload-files', this._uploadFiles, this);
      view.bind('upload-url', this._uploadURL, this);
      return view;
    },
  
    _createMakiIconsView: function _createMakiIconsView() {
      return new ScrollView({
        createContentView: function () {
          return new AssetsListView({
            model: this.model,
            selectedAsset: this._selectedAsset,
            title: _t('components.modals.add-asset.maki-icons'),
            icons: MakiIcons.icons,
            folder: 'maki-icons',
            kind: 'marker',
            size: '18'
          });
        }.bind(this)
      });
    },
  
    _onUploadComplete: function _onUploadComplete() {
      this._assetsTabPaneView.setSelectedTabPaneByName('your-uploads');
    },
  
    _onChangeSetButton: function _onChangeSetButton() {
      this.$('.js-add').toggleClass('is-disabled', !this._stateModel.get('modalEnabled'));
    },
  
    _onChangeSelectedAsset: function _onChangeSelectedAsset() {
      if (!this._selectedAsset.get('url')) {
        this.model.unset('image');
        this.model.unset('kind');
      }
  
      this._stateModel.set('modalEnabled', !!this._selectedAsset.get('url'));
    },
  
    _initUpload: function _initUpload(e) {
      this.killEvent(e);
      this.$('.js-fileInput').click();
    },
  
    _setDisclaimer: function _setDisclaimer(disclaimer) {
      this.$('.js-disclaimer').html(disclaimer);
    },
  
    _hideDisclaimer: function _hideDisclaimer() {
      this.$('.js-disclaimer').html('');
    },
  
    _getSelectedFiles: function _getSelectedFiles() {
      return this.$('.js-fileInput').prop('files');
    },
  
    _uploadURL: function _uploadURL(url) {
      this._upload({
        type: 'url',
        kind: KIND,
        url: url
      });
    },
  
    _uploadFiles: function _uploadFiles(files) {
      _.each(files, function (file) {
        this._upload({
          kind: KIND,
          type: 'file',
          filename: file
        });
      }, this);
    },
  
    _onFileSelected: function _onFileSelected() {
      this._uploadFiles(this._getSelectedFiles());
    },
  
    _beforeAssetUpload: function _beforeAssetUpload() {
      this._stateModel.set('uploads', this._stateModel.get('uploads') + 1);
  
      if (this._stateModel.get('uploads') > 0) {
        this._stateModel.set('status', 'loading');
      }
    },
  
    _onAssetUploaded: function _onAssetUploaded(iconModel) {
      this._resetFileSelection();
    },
  
    _setError: function _setError(error) {
      this._stateModel.set({
        error_message: errorParser(error),
        status: 'error'
      });
    },
  
    _onAssetUploadError: function _onAssetUploadError(model, response) {
      this._userAssetCollection.remove(model);
      this._resetFileSelection();
      this._setError(response);
    },
  
    _onAssetUploadComplete: function _onAssetUploadComplete() {
      this._stateModel.set('uploads', this._stateModel.get('uploads') - 1);
  
      if (this._stateModel.get('uploads') < 1 && !this._hasError()) {
        this._stateModel.set('status', 'show');
        this._onUploadComplete();
      }
    },
  
    _resetFileSelection: function _resetFileSelection() {
      this.$('.js-fileInput').val('');
    },
  
    _onSetImage: function _onSetImage(e) {
      this.killEvent(e);
  
      if (!this._stateModel.get('modalEnabled')) {
        return;
      }
  
      this.model.set({
        image: this._selectedAsset.get('url'), // backend serves the url of the asset in `image`
        kind: this._selectedAsset.get('kind')
      });
  
      this.trigger('change', {
        url: this._selectedAsset.get('url'),
        kind: this._selectedAsset.get('kind')
      }, this);
  
      this._modalModel.destroy(this.model);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/assets-picker/input-asset-picker-header.js":
  /*!**********************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/assets-picker/input-asset-picker-header.js ***!
    \**********************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./input-asset-picker-header.tpl */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/input-asset-picker-header.tpl");
  var ImageLoaderView = __webpack_require__(/*! builder/components/img-loader-view */ "./lib/assets/javascripts/builder/components/img-loader-view.js");
  
  module.exports = CoreView.extend({
    events: {
      'click .js-back': '_onClickBack',
      'click .js-colorPicker': '_onClickColorPicker'
    },
  
    initialize: function initialize(opts) {
      this._imageEnabled = opts.imageEnabled;
  
      this._initBinds();
    },
  
    render: function render(model, options) {
      this.clearSubViews();
      this.$el.empty();
  
      var rampItem = this._getRampItem();
  
      this.$el.append(template({
        index: this.model.get('index') || 0,
        color: rampItem.color || '',
        label: rampItem.title || _t('form-components.editors.fill.input-qualitative-ramps.others'),
        image: rampItem.image || '',
        imageEnabled: this._imageEnabled
      }));
  
      this._loadImages();
  
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this.model, 'change:image', this.render);
    },
  
    _getRampItem: function _getRampItem() {
      var ramp = this.model.get('ramp');
  
      if (!ramp) {
        return {
          color: '',
          title: _t('form-components.editors.fill.input-qualitative-ramps.others'),
          image: ''
        };
      }
  
      return ramp[this.model.get('index')];
    },
  
    _loadImages: function _loadImages() {
      var rampItem = this._getRampItem();
  
      this.iconView = new ImageLoaderView({
        imageClass: 'CDB-Text u-actionTextColor js-assetPicker',
        imageUrl: rampItem.image,
        color: rampItem.color
      });
      this.addView(this.iconView);
      this.$('.js-image-container').append(this.iconView.render().el);
    },
  
    _onClickBack: function _onClickBack(ev) {
      this.killEvent(ev);
      this.trigger('back', this);
    },
  
    _onClickColorPicker: function _onClickColorPicker(ev) {
      this.killEvent(ev);
      this.trigger('goToColorPicker', this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/assets-picker/input-asset-picker-view.js":
  /*!********************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/assets-picker/input-asset-picker-view.js ***!
    \********************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./input-asset-picker-view.tpl */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/input-asset-picker-view.tpl");
  var InputAssetPickerHeader = __webpack_require__(/*! ./input-asset-picker-header */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/input-asset-picker-header.js");
  var InputAssetPickerView = __webpack_require__(/*! builder/components/input-color/input-color-file-view */ "./lib/assets/javascripts/builder/components/input-color/input-color-file-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var REQUIRED_OPTS = ['configModel', 'modals', 'ramp', 'userModel'];
  
  module.exports = CoreView.extend({
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
      this._imageEnabled = opts.imageEnabled;
  
      this.model = new Backbone.Model({
        index: this.options.index,
        ramp: opts.ramp
      });
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template());
      this._initViews();
      return this;
    },
  
    _initViews: function _initViews() {
      this._headerView = new InputAssetPickerHeader({
        model: this.model,
        imageEnabled: this._imageEnabled
      });
      this._headerView.bind('goToColorPicker', this._onGoToColorPicker, this);
      this._headerView.bind('back', this._onClickBack, this);
      this.$('.js-header').append(this._headerView.render().el);
      this.addView(this._headerView);
  
      this._assetPicker = new InputAssetPickerView({
        model: this.model,
        userModel: this._userModel,
        configModel: this._configModel,
        modals: this._modals,
        imageEnabled: this._imageEnabled
      });
      this._assetPicker.bind('change', _.debounce(this._onChangeImage, 50), this);
      this.$('.js-content').append(this._assetPicker.render().el);
      this.addView(this._assetPicker);
    },
  
    _getRampItem: function _getRampItem() {
      var ramp = this.model.get('ramp');
  
      if (!ramp) {
        return {
          color: '',
          title: _t('form-components.editors.fill.input-qualitative-ramps.others'),
          image: ''
        };
      }
  
      return ramp[this.model.get('index')];
    },
  
    _onChangeImage: function _onChangeImage(data) {
      var url = data && data.url || '';
      var kind = data && data.kind || '';
  
      this._getRampItem().image = url;
      this.model.trigger('change:image');
  
      this.trigger('change:image', {
        url: url,
        kind: kind,
        index: this.model.get('index')
      }, this);
    },
  
    _onClickBack: function _onClickBack(e) {
      this.killEvent(e);
      this.trigger('back', this);
    },
  
    _onGoToColorPicker: function _onGoToColorPicker(e) {
      this.killEvent(e);
      this.trigger('goToColorPicker', this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/assets-picker/organization-assets-list-view.js":
  /*!**************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/assets-picker/organization-assets-list-view.js ***!
    \**************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var AssetItemView = __webpack_require__(/*! ./asset-item-view */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/asset-item-view.js");
  var template = __webpack_require__(/*! ./organization-assets-list-view.tpl */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/organization-assets-list-view.tpl");
  
  var REQUIRED_OPTS = ['userAssetCollection', 'organizationAssetCollection', 'selectedAsset'];
  
  var KIND = 'custom-marker';
  var ASSET_HEIGHT = 48;
  
  module.exports = CoreView.extend({
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template);
  
      this._organizationAssetCollection.deselectAll();
      this._organizationAssetCollection.each(this._renderAsset, this);
  
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this._organizationAssetCollection, 'reset', this.render);
      this.listenTo(this._organizationAssetCollection, 'change', this._onChangeAssets);
    },
  
    _getSelectedAsset: function _getSelectedAsset() {
      var selectedAssets = this._organizationAssetCollection.where({ state: 'selected' });
      return selectedAssets && selectedAssets[0];
    },
  
    _renderAsset: function _renderAsset(assetModel) {
      var assetItemView = new AssetItemView({
        model: assetModel,
        assetHeight: ASSET_HEIGHT,
        selectedAsset: this._selectedAsset
      });
  
      if (assetModel.get('public_url') === this.model.get('image')) {
        assetModel.set('state', 'selected');
      }
  
      assetItemView.bind('selected', this._selectAsset, this);
  
      this.$('.js-assets').append(assetItemView.render().el);
      this.addView(assetItemView);
    },
  
    _onChangeAssets: function _onChangeAssets() {
      var selectedAsset = this._getSelectedAsset();
  
      this._selectedAsset.set({
        url: selectedAsset && selectedAsset.get('public_url'),
        kind: KIND
      });
    },
  
    _selectAsset: function _selectAsset(m) {
      m.set('state', 'selected');
  
      this._organizationAssetCollection.deselectAll(m);
      this._userAssetCollection.deselectAll();
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/assets-picker/static-asset-item-view.js":
  /*!*******************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/assets-picker/static-asset-item-view.js ***!
    \*******************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./static-asset-item-view.tpl */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/static-asset-item-view.tpl");
  
  var AssetStates = {
    SELECTED: 'selected'
  };
  
  module.exports = CoreView.extend({
    tagName: 'li',
    className: 'AssetsList-item AssetsList-item--medium',
  
    events: {
      'click .js-asset': '_onClick'
    },
  
    initialize: function initialize() {
      this.listenTo(this.model, 'change:state', this._changeState);
    },
  
    render: function render() {
      this.clearSubViews();
  
      this.$el.append(template({
        type: 'icon',
        name: this.model.get('name'),
        public_url: this.model.get('public_url')
      }));
      return this;
    },
  
    _onClick: function _onClick(e) {
      this.killEvent(e);
      this.trigger(AssetStates.SELECTED, this.model);
      this.model.set('state', AssetStates.SELECTED);
    },
  
    _changeState: function _changeState() {
      this.$el.toggleClass('is-selected', this.model.get('state') === AssetStates.SELECTED);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/assets-picker/upload-assets-tab.js":
  /*!**************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/assets-picker/upload-assets-tab.js ***!
    \**************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  __webpack_require__(/*! dragster */ "./vendor/assets/javascripts/dragster.js");
  var Dropzone = __webpack_require__(/*! dropzone */ "./vendor/assets/javascripts/dropzone.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var AssetsCollection = __webpack_require__(/*! builder/data/assets-collection */ "./lib/assets/javascripts/builder/data/assets-collection.js");
  var template = __webpack_require__(/*! ./upload-assets-tab.tpl */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/upload-assets-tab.tpl");
  
  var REQUIRED_OPTS = ['configModel', 'userModel'];
  
  module.exports = CoreView.extend({
    className: 'Form-modal',
  
    events: {
      'keyup .js-url': '_onURLChanged',
      'click .js-submit': '_onClickSubmit'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this._stateModel = new Backbone.Model({
        status: 'show',
        uploads: 0
      });
  
      this.listenTo(this._stateModel, 'change:status', this.render);
  
      this._assetCollection = new AssetsCollection(null, {
        configModel: this._configModel,
        userModel: this._userModel
      });
    },
  
    render: function render() {
      this.clearSubViews();
  
      this.$el.html(template());
      this._initDropzone();
  
      return this;
    },
  
    _initDropzone: function _initDropzone() {
      var el = $('html')[0];
      var self = this;
  
      this.dragster = new Dragster(el); // eslint-disable-line
  
      $(el).bind('dragster:enter', function (e) {
        self._showDropzone();
      });
  
      $(el).bind('dragster:leave', function (e) {
        self._hideDropzone();
      });
  
      if (el.dropzone) {
        // avoid loading the dropzone twice
        return;
      }
  
      this.dropzone = new Dropzone(el, {
        url: ':)',
        autoProcessQueue: false,
        previewsContainer: false
      });
  
      this.dropzone.on('dragover', function () {
        self._showDropzone();
      });
  
      this.dropzone.on('drop', function (e) {
        self.trigger('upload-files', e.dataTransfer.files);
        self._hideDropzone();
      });
    },
  
    _showDropzone: function _showDropzone() {
      this.$('.Form-upload').addClass('is-dropping');
    },
  
    _hideDropzone: function _hideDropzone() {
      this.$('.Form-upload').removeClass('is-dropping');
    },
  
    _destroyDropzone: function _destroyDropzone() {
      var el = $('html')[0];
  
      if (this.dragster) {
        this.dragster.removeListeners();
        this.dragster.reset();
        $(el).unbind('dragster:enter dragster:leave');
      }
  
      if (this.dropzone) {
        this.dropzone.destroy();
      }
    },
  
    _hasError: function _hasError() {
      return this._stateModel.get('status') === 'error';
    },
  
    _onClickSubmit: function _onClickSubmit(e) {
      this.killEvent(e);
  
      var url = this._getURL();
  
      if (!url) {
        this._hideURLError();
        return;
      } else if (!Utils.isURL(url)) {
        this._showURLError();
        return;
      } else {
        this._hideURLError();
      }
  
      this.trigger('upload-url', url);
    },
  
    _getURL: function _getURL() {
      return this.$('.js-url').val();
    },
  
    _onURLChanged: function _onURLChanged() {
      var url = this._getURL();
  
      if (!url) {
        this._hideURLError();
      } else if (!Utils.isURL(url)) {
        this._showURLError();
      } else {
        this._hideURLError();
      }
    },
  
    _showURLError: function _showURLError() {
      this.$('.js-url-error').addClass('is-visible');
    },
  
    _hideURLError: function _hideURLError() {
      this.$('.js-url-error').removeClass('is-visible');
    },
  
    clean: function clean() {
      this._destroyDropzone();
      CoreView.prototype.clean.apply(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/assets-picker/user-assets-list-view.js":
  /*!******************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/assets-picker/user-assets-list-view.js ***!
    \******************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var AssetItemView = __webpack_require__(/*! ./asset-item-view */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/asset-item-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var loadingView = __webpack_require__(/*! builder/components/loading/render-loading */ "./lib/assets/javascripts/builder/components/loading/render-loading.js");
  var AssetHeaderView = __webpack_require__(/*! ./asset-header-view */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/asset-header-view.js");
  
  var ErrorView = __webpack_require__(/*! builder/components/error/error-view */ "./lib/assets/javascripts/builder/components/error/error-view.js");
  var errorTemplate = __webpack_require__(/*! ./upload-assets-error.tpl */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/upload-assets-error.tpl");
  var template = __webpack_require__(/*! ./user-assets-list-view.tpl */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/user-assets-list-view.tpl");
  
  var REQUIRED_OPTS = ['userModel', 'userAssetCollection', 'selectedAsset'];
  
  var KIND = 'custom-marker';
  var ASSET_HEIGHT = 48;
  
  module.exports = CoreView.extend({
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      if (this._userModel.isInsideOrg()) {
        if (!opts.organizationAssetCollection) throw new Error('organizationAssetCollection is required');
  
        this._organizationAssetCollection = opts.organizationAssetCollection;
      }
  
      this._stateModel = new Backbone.Model();
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template);
  
      if (this._isLoading()) {
        this._renderLoading();
      } else if (this._hasError()) {
        this._renderError();
      } else {
        this._renderRegularView();
      }
  
      return this;
    },
  
    _addHeaderView: function _addHeaderView() {
      this._assetHeaderView = new AssetHeaderView({
        editable: true,
        title: this.options.title,
        assetsCollection: this._userAssetCollection
      });
  
      this.addView(this._assetHeaderView);
      this.$('.js-nav').append(this._assetHeaderView.render().el);
  
      this._assetHeaderView.bind('select-all', this._selectAllAssets, this);
      this._assetHeaderView.bind('deselect-all', this._deselectAllAssets, this);
      this._assetHeaderView.bind('remove', this._removeSelectedAssets, this);
    },
  
    _renderRegularView: function _renderRegularView() {
      this._addHeaderView();
      this._renderAddButton();
  
      this._userAssetCollection.deselectAll();
      this._userAssetCollection.each(this._renderAsset, this);
    },
  
    _renderAddButton: function _renderAddButton() {
      var addAssetButton = new AssetItemView({
        model: new Backbone.Model({
          type: 'text',
          name: '+'
        }),
        assetHeight: ASSET_HEIGHT
      });
  
      addAssetButton.bind('selected', function () {
        this.trigger('init-upload');
      }, this);
  
      this.addView(addAssetButton);
      this.$('.js-assets').append(addAssetButton.render().$el);
    },
  
    _initBinds: function _initBinds() {
      this._keyDown = this._onKeyDown.bind(this);
      $(document).on('keydown', this._keyDown);
  
      this._keyUp = this._onKeyUp.bind(this);
      $(document).on('keyup', this._keyUp);
  
      this.listenTo(this._stateModel, 'change:status', this.render);
      this.listenTo(this._userAssetCollection, 'change', this._onChangeAssets);
    },
  
    _getSelectedAsset: function _getSelectedAsset() {
      return this._userAssetCollection.findWhere({ state: 'selected' });
    },
  
    _getSelectedAssetsCount: function _getSelectedAssetsCount() {
      var selectedAssets = this._userAssetCollection.where({ state: 'selected' });
      return selectedAssets ? selectedAssets.length : 0;
    },
  
    _onKeyDown: function _onKeyDown(ev) {
      this._shiftKeyPressed = ev.shiftKey;
    },
  
    _onKeyUp: function _onKeyUp(ev) {
      this._shiftKeyPressed = ev.shiftKey;
    },
  
    _onClickBack: function _onClickBack(e) {
      this.killEvent(e);
      this._stateModel.unset('status');
    },
  
    _renderAsset: function _renderAsset(assetModel) {
      var assetItemView = new AssetItemView({
        model: assetModel,
        assetHeight: ASSET_HEIGHT,
        selectedAsset: this._selectedAsset
      });
  
      if (assetModel.get('public_url') === this.model.get('image')) {
        assetModel.set('state', 'selected');
      }
  
      assetItemView.bind('selected', this._selectAsset, this);
  
      this.$('.js-assets').append(assetItemView.render().el);
      this.addView(assetItemView);
    },
  
    _onChangeAssets: function _onChangeAssets() {
      if (this._getSelectedAssetsCount() === 1) {
        var selectedAsset = this._getSelectedAsset();
        this._selectedAsset.set({
          url: selectedAsset && selectedAsset.get('public_url'),
          kind: KIND
        });
      } else {
        this._selectedAsset.set({
          url: '',
          kind: ''
        });
      }
    },
  
    _selectAllAssets: function _selectAllAssets() {
      this._userAssetCollection.selectAll();
    },
  
    _deselectAllAssets: function _deselectAllAssets() {
      this._userAssetCollection.deselectAll();
    },
  
    _selectAsset: function _selectAsset(m) {
      if (this._shiftKeyPressed) {
        m.set('state', m.get('state') === 'selected' ? '' : 'selected');
      } else {
        m.set('state', 'selected');
      }
  
      if (!this._shiftKeyPressed) {
        this._userAssetCollection.deselectAll(m);
  
        if (this._userModel.isInsideOrg()) {
          this._organizationAssetCollection.deselectAll();
        }
      }
    },
  
    _removeSelectedAssetsFromView: function _removeSelectedAssetsFromView() {
      var selectedAssets = this._userAssetCollection.select(function (asset) {
        return asset.get('state') === 'selected';
      }, this);
  
      _.each(selectedAssets, function (asset) {
        this.$('#' + asset.get('id')).remove();
      }, this);
    },
  
    _removeSelectedAssets: function _removeSelectedAssets() {
      this._stateModel.set('status', 'loading');
  
      var selectedAssets = this._userAssetCollection.select(function (asset) {
        return asset.get('state') === 'selected';
      }, this);
  
      _.each(selectedAssets, function (asset) {
        asset.destroy({
          complete: this._onDestroyFinished.bind(this)
        });
      }, this);
    },
  
    _onDestroyFinished: function _onDestroyFinished(response) {
      if (response.status === 200) {
        this._removeSelectedAssetsFromView();
        this._stateModel.unset('status');
        this._selectedAsset.unset('kind');
        this._selectedAsset.unset('url');
      } else {
        this._stateModel.set({
          error_message: response.statusText,
          status: 'error'
        });
      }
    },
  
    _isLoading: function _isLoading() {
      return this._stateModel.get('status') === 'loading';
    },
  
    _hasError: function _hasError() {
      return this._stateModel.get('status') === 'error';
    },
  
    _renderLoading: function _renderLoading() {
      this.$el.html(loadingView({
        title: _t('components.modals.assets-picker.loading')
      }));
    },
  
    _renderError: function _renderError() {
      this.$el.html(new ErrorView({
        title: this._stateModel.get('error_message'),
        desc: _t('components.modals.assets-picker.error-desc'),
        template: errorTemplate
      }).render().el);
    },
  
    _disableBinds: function _disableBinds() {
      $(document).off('keydown', this._keyDown);
      $(document).off('keyup', this._keyUp);
    },
  
    clean: function clean() {
      this._disableBinds();
      CoreView.prototype.clean.apply(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/assets-picker/user-assets-tab.js":
  /*!************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/assets-picker/user-assets-tab.js ***!
    \************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var ScrollView = __webpack_require__(/*! builder/components/scroll/scroll-view */ "./lib/assets/javascripts/builder/components/scroll/scroll-view.js");
  var UserAssetsListView = __webpack_require__(/*! ./user-assets-list-view */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/user-assets-list-view.js");
  
  var REQUIRED_OPTS = ['userModel', 'userAssetCollection', 'title', 'selectedAsset'];
  
  module.exports = CoreView.extend({
  
    className: 'Tab-paneContentInner',
  
    events: {
      'change .js-uploadInput': '_onFileSelected'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      if (this._userModel.isInsideOrg()) {
        if (!opts.organizationAssetCollection) throw new Error('organizationAssetCollection is required');
  
        this._organizationAssetCollection = opts.organizationAssetCollection;
      }
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this._renderAssets();
      return this;
    },
  
    _renderAssets: function _renderAssets() {
      var view = new ScrollView({
        createContentView: function () {
          var view = new UserAssetsListView({
            title: this._title,
            model: this.model,
            organizationAssetCollection: this._organizationAssetCollection,
            userAssetCollection: this._userAssetCollection,
            selectedAsset: this._selectedAsset,
            userModel: this._userModel
          });
  
          view.bind('init-upload', function () {
            this.trigger('init-upload');
          }, this);
  
          return view;
        }.bind(this)
      });
  
      this.addView(view);
      this.$el.append(view.render().el);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/assets/maki-icons.js":
  /*!************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/assets/maki-icons.js ***!
    \************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  // Maki icons from https://github.com/mapbox/maki
  // and https://github.com/mapbox/maki/blob/mb-pages/_includes/maki.json
  module.exports = {
    disclaimer: _t('assets.maki-icons.disclaimer'),
    icons: [{
      'name': 'Square stroked',
      'icon': 'square-stroked'
    }, {
      'name': 'Square solid',
      'icon': 'square'
    }, {
      'name': 'Triangle stroked',
      'icon': 'triangle-stroked'
    }, {
      'name': 'Triangle solid',
      'icon': 'triangle'
    }, {
      'name': 'Star stroked',
      'icon': 'star-stroked'
    }, {
      'name': 'Star solid',
      'icon': 'star'
    }, {
      'name': 'Cross',
      'icon': 'cross'
    }, {
      'name': 'Marker Stroke',
      'icon': 'marker-stroked'
    }, {
      'name': 'Marker Solid',
      'icon': 'marker'
    }, {
      'name': 'Religious Jewish',
      'icon': 'religious-jewish'
    }, {
      'name': 'Religious Christian',
      'icon': 'religious-christian'
    }, {
      'name': 'Religious Muslim',
      'icon': 'religious-muslim'
    }, {
      'name': 'Cemetery',
      'icon': 'cemetery'
    }, {
      'name': 'Rocket',
      'icon': 'rocket'
    }, {
      'name': 'Airport',
      'icon': 'airport'
    }, {
      'name': 'Heliport',
      'icon': 'heliport'
    }, {
      'name': 'Rail',
      'icon': 'rail'
    }, {
      'name': 'Rail Metro',
      'icon': 'rail-metro'
    }, {
      'name': 'Rail Light',
      'icon': 'rail-light'
    }, {
      'name': 'Bus',
      'icon': 'bus'
    }, {
      'name': 'Fuel',
      'icon': 'fuel'
    }, {
      'name': 'Parking',
      'tags': ['parking', 'transportation'],
      'icon': 'parking'
    }, {
      'name': 'Parking Garage',
      'tags': ['parking', 'transportation', 'garage'],
      'icon': 'parking-garage'
    }, {
      'name': 'Airfield',
      'tags': ['airfield', 'airport', 'plane', 'landing strip'],
      'icon': 'airfield'
    }, {
      'name': 'Roadblock',
      'tags': ['roadblock', 'stop', 'warning', 'dead end'],
      'icon': 'roadblock'
    }, {
      'name': 'Ferry',
      'tags': ['ship', 'boat', 'water', 'ferry', 'transportation'],
      'icon': 'ferry'
    }, {
      'name': 'Harbor',
      'tags': ['marine', 'dock', 'water', 'wharf'],
      'icon': 'harbor'
    }, {
      'name': 'Bicycle',
      'tags': ['cycling', 'cycle', 'transportation'],
      'icon': 'bicycle'
    }, {
      'name': 'Park',
      'tags': ['recreation', 'park', 'forest', 'tree', 'green', 'woods', 'nature'],
      'icon': 'park'
    }, {
      'name': 'Park 2',
      'tags': ['recreation', 'park', 'forest', 'tree', 'green', 'woods', 'nature'],
      'icon': 'park2'
    }, {
      'name': 'Museum',
      'tags': ['recreation', 'museum', 'tourism'],
      'icon': 'museum'
    }, {
      'name': 'Lodging',
      'tags': ['lodging', 'hotel', 'recreation', 'motel', 'tourism'],
      'icon': 'lodging'
    }, {
      'name': 'Monument',
      'tags': ['recreation', 'statue', 'monument', 'tourism'],
      'icon': 'monument'
    }, {
      'name': 'Zoo',
      'tags': ['recreation', 'zoo', 'animal', 'giraffe'],
      'icon': 'zoo'
    }, {
      'name': 'Garden',
      'tags': ['recreation', 'garden', 'park', 'flower', 'nature'],
      'icon': 'garden'
    }, {
      'name': 'Campsite',
      'tags': ['recreation', 'campsite', 'camp', 'camping', 'tent', 'nature'],
      'icon': 'campsite'
    }, {
      'name': 'Theatre',
      'tags': ['recreation', 'theatre', 'theater', 'entertainment', 'play', 'performance'],
      'icon': 'theatre'
    }, {
      'name': 'Art gallery',
      'tags': ['art', 'center', 'museum', 'gallery', 'creative', 'recreation', 'entertainment', 'studio'],
      'icon': 'art-gallery'
    }, {
      'name': 'Pitch',
      'tags': ['pitch', 'track', 'athletic', 'sports', 'field'],
      'icon': 'pitch'
    }, {
      'name': 'Soccer',
      'tags': ['soccer', 'sports'],
      'icon': 'soccer'
    }, {
      'name': 'American Football',
      'tags': ['football', 'sports'],
      'icon': 'america-football'
    }, {
      'name': 'Tennis',
      'tags': ['tennis', 'court', 'ball', 'sports'],
      'icon': 'tennis'
    }, {
      'name': 'Basketball',
      'tags': ['basketball', 'ball', 'sports'],
      'icon': 'basketball'
    }, {
      'name': 'Baseball',
      'tags': ['baseball', 'softball', 'ball', 'sports'],
      'icon': 'baseball'
    }, {
      'name': 'Golf',
      'tags': ['golf', 'sports', 'course'],
      'icon': 'golf'
    }, {
      'name': 'Swimming',
      'tags': ['swimming', 'water', 'swim', 'sports'],
      'icon': 'swimming'
    }, {
      'name': 'Cricket',
      'tags': ['cricket', 'sports'],
      'icon': 'cricket'
    }, {
      'name': 'Skiing',
      'tags': ['winter', 'skiing', 'ski', 'sports'],
      'icon': 'skiing'
    }, {
      'name': 'School',
      'tags': ['school', 'highschool', 'elementary', 'children', 'amenity', 'middle'],
      'icon': 'school'
    }, {
      'name': 'College',
      'tags': ['college', 'school', 'amenity', 'university'],
      'icon': 'college'
    }, {
      'name': 'Library',
      'tags': ['library', 'books', 'amenity'],
      'icon': 'library'
    }, {
      'name': 'Post',
      'tags': ['post', 'office', 'amenity', 'mail', 'letter'],
      'icon': 'post'
    }, {
      'name': 'Fire station',
      'tags': ['fire', 'station', 'amenity'],
      'icon': 'fire-station'
    }, {
      'name': 'Town hall',
      'tags': ['townhall', 'mayor', 'building', 'amenity', 'government'],
      'icon': 'town-hall'
    }, {
      'name': 'Police',
      'tags': ['police', 'jail', 'arrest', 'amenity', 'station'],
      'icon': 'police'
    }, {
      'name': 'Prison',
      'tags': ['prison', 'jail', 'amenity'],
      'icon': 'prison'
    }, {
      'name': 'Embassy',
      'tags': ['embassy', 'diplomacy', 'consulate', 'amenity', 'flag'],
      'icon': 'embassy'
    }, {
      'name': 'Beer',
      'tags': ['bar', 'beer', 'drink', 'commercial', 'biergarten', 'pub'],
      'icon': 'beer'
    }, {
      'name': 'Restaurant',
      'tags': ['restaurant', 'commercial'],
      'icon': 'restaurant'
    }, {
      'name': 'Cafe',
      'tags': ['cafe', 'coffee', 'commercial', 'tea'],
      'icon': 'cafe'
    }, {
      'name': 'Shop',
      'tags': ['shop', 'mall', 'commercial', 'store'],
      'icon': 'shop'
    }, {
      'name': 'Fast Food',
      'tags': ['food', 'fast', 'commercial', 'burger', 'drive-through'],
      'icon': 'fast-food'
    }, {
      'name': 'Bar',
      'tags': ['bar', 'drink', 'commercial', 'club', 'martini', 'lounge'],
      'icon': 'bar'
    }, {
      'name': 'Bank',
      'tags': ['bank', 'atm', 'commercial', 'money'],
      'icon': 'bank'
    }, {
      'name': 'Grocery',
      'tags': ['food', 'grocery', 'commercial', 'store', 'market'],
      'icon': 'grocery'
    }, {
      'name': 'Cinema',
      'tags': ['cinema', 'theatre', 'film', 'movie', 'commercial', 'theater', 'entertainment'],
      'icon': 'cinema'
    }, {
      'name': 'Pharmacy',
      'tags': ['pharmacy', 'drugs', 'medication', 'social', 'medicine', 'prescription'],
      'icon': 'pharmacy'
    }, {
      'name': 'Hospital',
      'tags': ['hospital', 'health', 'medication', 'social', 'medicine', 'medical', 'clinic'],
      'icon': 'hospital'
    }, {
      'name': 'Danger',
      'tags': ['minefield', 'landmine', 'disaster', 'dangerous', 'hazard'],
      'icon': 'danger'
    }, {
      'name': 'Industrial',
      'tags': ['industrial', 'factory', 'property', 'building'],
      'icon': 'industrial'
    }, {
      'name': 'Warehouse',
      'tags': ['warehouse', 'property', 'storage', 'building'],
      'icon': 'warehouse'
    }, {
      'name': 'Commercial',
      'tags': ['commercial', 'property', 'business', 'building'],
      'icon': 'commercial'
    }, {
      'name': 'Building',
      'tags': ['building', 'property', 'structure', 'business', 'building'],
      'icon': 'building'
    }, {
      'name': 'Place of worship',
      'tags': ['religion', 'ceremony', 'religious', 'nondenominational', 'church', 'temple'],
      'icon': 'place-of-worship'
    }, {
      'name': 'Alcohol shop',
      'tags': ['alcohol', 'liquor', 'store', 'shop', 'beer', 'wine', 'vodka'],
      'icon': 'alcohol-shop'
    }, {
      'name': 'Logging',
      'tags': ['logger', 'chainsaw', 'woods', 'industry'],
      'icon': 'logging'
    }, {
      'name': 'Oil well',
      'tags': ['oil', 'natural', 'environment', 'industry', 'resources'],
      'icon': 'oil-well'
    }, {
      'name': 'Slaughterhouse',
      'tags': ['cows', 'cattle', 'food', 'meat', 'industry', 'resources'],
      'icon': 'slaughterhouse'
    }, {
      'name': 'Dam',
      'tags': ['water', 'natural', 'hydro', 'hydroelectric', 'energy', 'environment', 'industry', 'resources'],
      'icon': 'dam'
    }, {
      'name': 'Water',
      'tags': ['water', 'natural', 'hydro', 'lake', 'river', 'ocean', 'resources'],
      'icon': 'water'
    }, {
      'name': 'Wetland',
      'tags': ['water', 'swamp', 'natural'],
      'icon': 'wetland'
    }, {
      'name': 'Disability',
      'tags': ['handicap', 'wheelchair', 'access'],
      'icon': 'disability'
    }, {
      'name': 'Telephone',
      'tags': ['payphone', 'call'],
      'icon': 'telephone'
    }, {
      'name': 'Emergency Telephone',
      'tags': ['payphone', 'danger', 'safety', 'call'],
      'icon': 'emergency-telephone'
    }, {
      'name': 'Toilets',
      'tags': ['bathroom', 'men', 'women', 'sink', 'washroom', 'lavatory'],
      'icon': 'toilets'
    }, {
      'name': 'Waste Basket',
      'tags': ['trash', 'rubbish', 'bin', 'garbage'],
      'icon': 'waste-basket'
    }, {
      'name': 'Music',
      'tags': ['stage', 'performance', 'band', 'concert', 'venue'],
      'icon': 'music'
    }, {
      'name': 'Land Use',
      'tags': ['zoning', 'usage', 'area'],
      'icon': 'land-use'
    }, {
      'name': 'City',
      'tags': ['area', 'point', 'place', 'urban'],
      'icon': 'city'
    }, {
      'name': 'Town',
      'tags': ['area', 'point', 'place', 'small'],
      'icon': 'town'
    }, {
      'name': 'Village',
      'tags': ['area', 'point', 'place', 'small', 'rural'],
      'icon': 'village'
    }, {
      'name': 'Farm',
      'tags': ['building', 'farming', 'crops', 'plants', 'agriculture', 'rural'],
      'icon': 'farm'
    }, {
      'name': 'Bakery',
      'tags': ['bakery', 'pastry', 'croissant', 'food', 'shop', 'bread'],
      'icon': 'bakery'
    }, {
      'name': 'Dog Park',
      'tags': ['dog', 'pet'],
      'icon': 'dog-park'
    }, {
      'name': 'Lighthouse',
      'tags': ['building', 'navigation', 'nautical', 'ocean', 'logistics'],
      'icon': 'lighthouse'
    }, {
      'name': 'Clothing Store',
      'tags': ['clothing', 'store', 'shop'],
      'icon': 'clothing-store'
    }, {
      'name': 'Polling Place',
      'icon': 'polling-place'
    }, {
      'name': 'Playground',
      'icon': 'playground'
    }, {
      'name': 'Entrance',
      'icon': 'entrance'
    }, {
      'name': 'Heart',
      'icon': 'heart'
    }, {
      'name': 'London Underground',
      'icon': 'london-underground'
    }, {
      'name': 'Minefield',
      'icon': 'minefield'
    }, {
      'name': 'Rail Underground',
      'icon': 'rail-underground'
    }, {
      'name': 'Rail Above',
      'icon': 'rail-above'
    }, {
      'name': 'Camera',
      'icon': 'camera'
    }, {
      'name': 'Laundry',
      'icon': 'laundry'
    }, {
      'name': 'Car',
      'icon': 'car'
    }, {
      'name': 'Suitcase',
      'icon': 'suitcase'
    }, {
      'name': 'Hairdresser',
      'icon': 'hairdresser'
    }, {
      'name': 'Chemist',
      'icon': 'chemist'
    }, {
      'name': 'Mobile phone',
      'icon': 'mobilephone'
    }, {
      'name': 'Scooter',
      'icon': 'scooter'
    }]
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-color-dialog-content.js":
  /*!*********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-color-dialog-content.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var tabPaneTemplate = __webpack_require__(/*! builder/components/form-components/editors/fill/fill-tab-pane.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/fill/fill-tab-pane.tpl");
  var createTextLabelsTabPane = __webpack_require__(/*! builder/components/tab-pane/create-text-labels-tab-pane */ "./lib/assets/javascripts/builder/components/tab-pane/create-text-labels-tab-pane.js");
  
  var InputColorFixedContentView = __webpack_require__(/*! ./input-color-fixed-content-view */ "./lib/assets/javascripts/builder/components/input-color/input-color-fixed-content-view.js");
  var InputColorValueContentView = __webpack_require__(/*! ./input-color-value-content-view */ "./lib/assets/javascripts/builder/components/input-color/input-color-value-content-view.js");
  var FillConstants = __webpack_require__(/*! builder/components/form-components/_constants/_fill */ "./lib/assets/javascripts/builder/components/form-components/_constants/_fill.js");
  
  module.exports = CoreView.extend({
    initialize: function initialize(opts) {
      if (this.options.editorAttrs) {
        var editorAttrs = this.options.editorAttrs;
  
        if (editorAttrs.hidePanes) {
          this._hidePanes = editorAttrs.hidePanes;
  
          if (!_.contains(this._hidePanes, FillConstants.Panes.BY_VALUE)) {
            if (!opts.configModel) throw new Error('configModel param is required');
            if (!opts.userModel) throw new Error('userModel param is required');
            if (!opts.modals) throw new Error('modals param is required');
            if (!opts.query) throw new Error('query param is required');
          }
        }
  
        if (editorAttrs.categorizeColumns) {
          this._categorizeColumns = true;
        }
  
        if (editorAttrs.hideTabs) {
          this._hideTabs = editorAttrs.hideTabs;
        }
  
        if (editorAttrs.imageEnabled) {
          this._imageEnabled = true;
        }
      }
  
      if (!opts.columns) throw new Error('columns is required');
  
      this._columns = opts.columns;
      this._configModel = opts.configModel;
      this._userModel = opts.userModel;
      this._modals = opts.modals;
      this._query = opts.query;
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this._initViews();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.model.on('change:fixed', this._onChangeFixed, this);
    },
  
    _onChangeFixed: function _onChangeFixed() {
      if (!this.model.get('fixed') || this.model.get('range')) {
        this.model.unset('image', { silent: true });
        this.model.unset('images', { silent: true });
      }
    },
  
    _initViews: function _initViews() {
      var self = this;
  
      var fixedPane = {
        name: 'fixed',
        label: _t('form-components.editors.fill.input-color.solid'),
        createContentView: function createContentView() {
          return self._generateFixedContentView();
        }
      };
  
      var valuePane = {
        name: 'value',
        label: _t('form-components.editors.fill.input-color.value'),
        createContentView: function createContentView() {
          return self._generateValueContentView();
        }
      };
  
      this._tabPaneTabs = [];
  
      if (this._hidePanes) {
        if (!_.contains(this._hidePanes, FillConstants.Panes.FIXED)) {
          this._tabPaneTabs.push(fixedPane);
        }
        if (!_.contains(this._hidePanes, FillConstants.Panes.BY_VALUE)) {
          this._tabPaneTabs.push(valuePane);
        }
      } else {
        this._tabPaneTabs = [fixedPane, valuePane];
      }
  
      var tabPaneOptions = {
        tabPaneOptions: {
          template: tabPaneTemplate,
          tabPaneItemOptions: {
            tagName: 'li',
            klassName: 'CDB-NavMenu-item'
          }
        },
        tabPaneItemLabelOptions: {
          tagName: 'button',
          className: 'CDB-NavMenu-link u-upperCase'
        }
      };
  
      if (this.model.get('range') && this._tabPaneTabs.length > 1) {
        this._tabPaneTabs[1].selected = true;
      }
  
      this._tabPaneView = createTextLabelsTabPane(this._tabPaneTabs, tabPaneOptions);
      this._tabPaneView.collection.bind('change:selected', this._onChangeTabPaneViewTab, this);
      this.$el.append(this._tabPaneView.render().$el);
      this.addView(this._tabPaneView);
    },
  
    _onChangeTabPaneViewTab: function _onChangeTabPaneViewTab() {
      var selectedTabPaneName = this._tabPaneView.getSelectedTabPaneName();
      var attrsToUnsetIfFixed = ['domain', 'bins', 'attribute', 'quantification'];
  
      if (selectedTabPaneName === 'fixed') {
        _.each(attrsToUnsetIfFixed, function (attr) {
          this.model.unset(attr, { silent: true });
        }, this);
  
        if (!this.model.get('fixed')) {
          if (this.model.get('range')) {
            this.model.set('fixed', this.model.get('range')[0]);
            this.model.unset('range');
          } else {
            this.model.set('fixed', '#0303FF');
          }
        }
      }
  
      this.trigger('change', selectedTabPaneName, this);
    },
  
    _generateFixedContentView: function _generateFixedContentView() {
      return new InputColorFixedContentView({
        model: this.model,
        configModel: this._configModel,
        userModel: this._userModel,
        modals: this._modals,
        editorAttrs: this.options.editorAttrs
      });
    },
  
    _generateValueContentView: function _generateValueContentView() {
      return new InputColorValueContentView({
        model: this.model,
        columns: this._columns,
        configModel: this._configModel,
        categorizeColumns: this._categorizeColumns,
        imageEnabled: this._imageEnabled,
        userModel: this._userModel,
        modals: this._modals,
        hideTabs: this._hideTabs,
        query: this._query
      });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-color-file-view.js":
  /*!****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-color-file-view.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./input-color-file-view.tpl */ "./lib/assets/javascripts/builder/components/input-color/input-color-file-view.tpl");
  var AssetsView = __webpack_require__(/*! ./assets-picker/assets-view */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/assets-view.js");
  var CarouselFormView = __webpack_require__(/*! builder/components/carousel-form-view */ "./lib/assets/javascripts/builder/components/carousel-form-view.js");
  var CarouselCollection = __webpack_require__(/*! builder/components/custom-carousel/custom-carousel-collection */ "./lib/assets/javascripts/builder/components/custom-carousel/custom-carousel-collection.js");
  var StaticAssetsCollection = __webpack_require__(/*! builder/data/static-assets-collection */ "./lib/assets/javascripts/builder/data/static-assets-collection.js");
  var StaticAssetModel = __webpack_require__(/*! builder/data/static-asset-model */ "./lib/assets/javascripts/builder/data/static-asset-model.js");
  var StaticAssetItemViewTemplate = __webpack_require__(/*! ./assets-picker/static-asset-item-view.tpl */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/static-asset-item-view.tpl");
  var CarouselTemplate = __webpack_require__(/*! ./input-color-file-carousel.tpl */ "./lib/assets/javascripts/builder/components/input-color/input-color-file-carousel.tpl");
  var MakiIcons = __webpack_require__(/*! ./assets/maki-icons */ "./lib/assets/javascripts/builder/components/input-color/assets/maki-icons.js");
  
  module.exports = CoreView.extend({
  
    events: {
      'click .js-show-collection': '_onClickShowCollection'
    },
  
    initialize: function initialize(options) {
      if (!options.configModel) throw new Error('configModel is required');
      if (!options.userModel) throw new Error('userModel is required');
      if (!options.modals) throw new Error('modals is required');
  
      this._configModel = options.configModel;
      this._userModel = options.userModel;
      this._modals = options.modals;
  
      this._initCarouselCollection();
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template());
      this._renderAssets();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this._carouselCollection, 'change:selected', this._onSelectAsset);
      this.listenTo(this._carouselCollection, 'reset', this.render);
    },
  
    _resetCarouselCollection: function _resetCarouselCollection(url) {
      this._icons.reset(MakiIcons.icons);
  
      var selectedItem = this._carouselCollection.find(function (model) {
        return model.get('url') === url;
      });
  
      if (selectedItem) {
        selectedItem.set('selected', true);
      }
  
      this._icons.unshift(this._resetAsset);
      this._carouselCollection.reset(this._getIcons());
    },
  
    _initCarouselCollection: function _initCarouselCollection() {
      this._icons = new StaticAssetsCollection(MakiIcons.icons);
      this.add_related_model(this._icons);
  
      this._resetAsset = new StaticAssetModel({
        type: 'none',
        selected: !this._getIconSelected(),
        name: _t('form-components.editors.fill.image.none'),
        action: function (model) {
          this._resetImage(model);
        }.bind(this)
      });
  
      this._icons.unshift(this._resetAsset);
  
      this._carouselCollection = new CarouselCollection(this._getIcons());
      this.add_related_model(this._carouselCollection);
    },
  
    _getIcons: function _getIcons() {
      var defaultAction = function (model) {
        this._changeIcon(model);
      }.bind(this);
  
      return this._icons.map(function (icon) {
        var type = icon.get('type') ? icon.get('type') : 'icon';
        var action = icon.get('action') ? icon.get('action') : defaultAction;
        var selectedIcon = this._getIconSelected();
  
        return {
          selected: icon.get('selected') || icon.getURLFor(icon.get('icon')) === selectedIcon,
          icon: icon,
          type: type,
          name: icon.get('name'),
          url: icon.get('public_url'),
          action: action,
          template: function template() {
            return StaticAssetItemViewTemplate({
              type: type,
              public_url: icon.get('public_url') + '?req=markup',
              name: icon.get('name')
            });
          }
        };
      }, this);
    },
  
    _getIconSelected: function _getIconSelected() {
      if (this.model.get('ramp')) {
        var rampIndex = this.model.get('index') || 0;
        var categoryImage = this.model.get('ramp')[rampIndex].image;
  
        return categoryImage || '';
      }
  
      return this.model.get('image') || '';
    },
  
    _renderAssets: function _renderAssets() {
      this.clearSubViews();
      this.$el.html(template());
  
      var view = new CarouselFormView({
        collection: this._carouselCollection,
        template: CarouselTemplate,
        listItemOptions: {
          className: 'Carousel-item AssetListItem'
        },
        itemOptions: {
          className: 'AssetItem-button'
        }
      });
  
      this.addView(view);
      this.$('.js-assets').append(view.render().el);
    },
  
    _onSelectAsset: function _onSelectAsset(model) {
      model.get('action')(model);
    },
  
    _changeIcon: function _changeIcon(model) {
      var icon = model.get('icon');
  
      this.trigger('change', {
        url: icon.get('public_url'),
        kind: icon.get('kind')
      }, this);
    },
  
    _resetImage: function _resetImage() {
      this.trigger('change', null, this);
    },
  
    _onClickShowCollection: function _onClickShowCollection(e) {
      this.killEvent(e);
  
      var self = this;
  
      this._modals.create(function (modalModel) {
        self._assetsView = new AssetsView({
          model: self.model,
          modalModel: modalModel,
          configModel: self._configModel,
          userModel: self._userModel
        });
  
        self._assetsView.bind('change', self._resetAssetsView, self);
  
        return self._assetsView;
      }, {
        breadcrumbsEnabled: true
      });
    },
  
    _resetAssetsView: function _resetAssetsView(data) {
      this._resetCarouselCollection(data.url);
      this.trigger('change', data, this);
    },
  
    _destroyDocumentBinds: function _destroyDocumentBinds() {
      if (this._assetsView) {
        this._assetsView.unbind('change', self._resetAssetsView, self);
      }
    },
  
    clean: function clean() {
      this._destroyDocumentBinds();
      this.trigger('onClean', this);
      CoreView.prototype.clean.apply(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-color-fixed-content-view.js":
  /*!*************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-color-fixed-content-view.js ***!
    \*************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var tabPaneTemplate = __webpack_require__(/*! builder/components/form-components/editors/fill/fill-tab-pane.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/fill/fill-tab-pane.tpl");
  var createMixedLabelsTabPane = __webpack_require__(/*! builder/components/tab-pane/create-mixed-labels-tab-pane */ "./lib/assets/javascripts/builder/components/tab-pane/create-mixed-labels-tab-pane.js");
  var ColorPicker = __webpack_require__(/*! builder/components/color-picker/color-picker */ "./lib/assets/javascripts/builder/components/color-picker/color-picker.js");
  var InputColorFileView = __webpack_require__(/*! ./input-color-file-view */ "./lib/assets/javascripts/builder/components/input-color/input-color-file-view.js");
  var FillConstants = __webpack_require__(/*! builder/components/form-components/_constants/_fill */ "./lib/assets/javascripts/builder/components/form-components/_constants/_fill.js");
  
  module.exports = CoreView.extend({
    initialize: function initialize(opts) {
      if (this.options.editorAttrs) {
        var editorAttrs = this.options.editorAttrs;
  
        this._imageEnabled = editorAttrs.imageEnabled;
  
        if (editorAttrs.hidePanes) {
          this._hidePanes = editorAttrs.hidePanes;
  
          if (this._imageEnabled && !_.contains(this._hidePanes, FillConstants.Panes.FILE)) {
            if (!opts.configModel) throw new Error('configModel param is required');
            if (!opts.userModel) throw new Error('userModel param is required');
            if (!opts.modals) throw new Error('modals param is required');
          }
        }
  
        if (editorAttrs.disableOpacity) {
          this._disableOpacity = true;
        }
      }
  
      this._userModel = opts.userModel;
      this._configModel = opts.configModel;
      this._modals = opts.modals;
      this._query = opts.query;
    },
  
    render: function render() {
      this.clearSubViews();
  
      if (this._imageEnabled) {
        this._setupTabPanes();
      }
  
      if (this._tabPaneView) {
        this.$el.append(this._tabPaneView.render().$el);
      } else {
        this.$el.append(this._generateFixedContentView().render().$el);
      }
      return this;
    },
  
    _setupTabPanes: function _setupTabPanes() {
      var self = this;
  
      var fixedPane = {
        name: 'fixed',
        type: 'color',
        label: this.model.get('fixed'),
        createContentView: function createContentView() {
          return self._generateFixedContentView();
        }
      };
  
      var filePane = {
        name: 'file',
        type: this.model.get('image') ? 'image' : 'text',
        label: this.model.get('image') || _t('form-components.editors.fill.input-color.img'),
        kind: this.model.get('kind') || 'marker',
        color: this.model.get('fixed'),
        createContentView: function createContentView() {
          return self._generateFileContentView();
        }
      };
  
      this._tabPaneTabs = [];
  
      if (this.options.editorAttrs && this.options.editorAttrs.hidePanes) {
        this._hidePanes = this.options.editorAttrs.hidePanes;
  
        if (!_.contains(this._hidePanes, FillConstants.Panes.FIXED)) {
          this._tabPaneTabs.push(fixedPane);
        }
  
        if (!_.contains(this._hidePanes, FillConstants.Panes.FILE)) {
          this._tabPaneTabs.push(filePane);
        }
      } else {
        this._tabPaneTabs = [fixedPane, filePane];
      }
  
      var tabPaneOptions = {
        tabPaneOptions: {
          template: tabPaneTemplate,
          tabPaneItemOptions: {
            tagName: 'li',
            klassName: 'CDB-NavMenu-item'
          }
        },
        tabPaneItemLabelOptions: {
          tagName: 'button',
          className: 'CDB-NavMenu-link u-upperCase'
        }
      };
  
      if (this.model.get('image') && this._tabPaneTabs.length > 1) {
        this._tabPaneTabs[1].selected = true;
      }
      this.listenTo(this.model, 'change:image', this._updateImageTabPane);
      this.listenTo(this.model, 'change:fixed', this._updateTextTabPane);
  
      this._tabPaneView = createMixedLabelsTabPane(this._tabPaneTabs, tabPaneOptions);
      this.addView(this._tabPaneView);
    },
  
    _updateTextTabPane: function _updateTextTabPane() {
      this._updateImageTabPane();
      this._tabPaneView.collection.at(0).set('label', this.model.get('fixed'));
    },
  
    _updateImageTabPane: function _updateImageTabPane() {
      if (this.model.get('image')) {
        this._tabPaneView.collection.at(1).set({ label: this.model.get('image'), color: this.model.get('fixed') });
      } else {
        this._tabPaneView.collection.at(1).set('label', _t('form-components.editors.fill.input-color.img'));
      }
    },
  
    _generateFixedContentView: function _generateFixedContentView() {
      var contentView = new ColorPicker({
        value: this.model.get('fixed'),
        opacity: this.model.get('opacity'),
        disableOpacity: this._disableOpacity
      });
  
      contentView.bind('change', this._onChangeValue, this);
      return contentView;
    },
  
    _generateFileContentView: function _generateFileContentView() {
      var contentView = new InputColorFileView({
        model: this.model,
        userModel: this._userModel,
        configModel: this._configModel,
        modals: this._modals
      });
  
      contentView.bind('change', this._onChangeFile, this);
      return contentView;
    },
  
    _onChangeFile: function _onChangeFile(data) {
      if (data && data.url) {
        this.model.set({
          image: data.url,
          kind: data.kind
        });
      } else {
        this.model.unset('image');
      }
    },
  
    _onChangeValue: function _onChangeValue(color) {
      this.model.set({ fixed: color.hex, opacity: color.opacity });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-color-picker/input-color-picker-header.js":
  /*!***************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-color-picker/input-color-picker-header.js ***!
    \***************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var ImageLoaderView = __webpack_require__(/*! builder/components/img-loader-view */ "./lib/assets/javascripts/builder/components/img-loader-view.js");
  var template = __webpack_require__(/*! ./input-color-picker-header.tpl */ "./lib/assets/javascripts/builder/components/input-color/input-color-picker/input-color-picker-header.tpl");
  var MAX = 1;
  
  module.exports = CoreView.extend({
    events: {
      'click .js-color': '_onClickColor',
      'click .js-assetPicker': '_onClickAssetPicker',
      'keyup .js-a': '_onChangeOpacity'
    },
  
    initialize: function initialize(opts) {
      this.listenTo(this.model, 'change', this.render);
    },
  
    render: function render(model, options) {
      if (model && model.changed && typeof model.changed.opacity !== 'undefined') {
        this._reRenderOpacity();
        return this;
      }
  
      this.clearSubViews();
      this.$el.empty();
  
      var rampItem = this._getRampItem();
      this.$el.append(template({
        ramp: this.model.get('ramp'),
        index: this.model.get('index'),
        opacity: this.model.get('opacity'),
        label: rampItem.title || _t('form-components.editors.fill.input-qualitative-ramps.others'),
        color: rampItem.color || '',
        iconStylingEnabled: this.options.iconStylingEnabled,
        isCategorized: _.has(rampItem, 'image'),
        image: rampItem.image || '',
        imageEnabled: this.options.imageEnabled
      }));
  
      this._slider = this.$('.js-slider').slider({
        range: 'min',
        value: this._inverseSliderValue(this.model.get('opacity')),
        min: 0,
        max: MAX,
        step: 0.02,
        orientation: 'horizontal',
        disabled: false,
        slide: this._onSlideChange.bind(this)
      });
  
      this._loadImages();
  
      return this;
    },
  
    _getRampItem: function _getRampItem() {
      var ramp = this.model.get('ramp');
  
      if (!ramp) {
        return {
          color: '',
          title: _t('form-components.editors.fill.input-qualitative-ramps.others'),
          image: ''
        };
      }
  
      return ramp[this.model.get('index')];
    },
  
    _loadImages: function _loadImages() {
      var rampItem = this._getRampItem();
  
      this.iconView = new ImageLoaderView({
        imageClass: 'CDB-Text u-actionTextColor js-assetPicker',
        imageUrl: rampItem.image,
        color: rampItem.color
      });
      this.addView(this.iconView);
      this.$('.js-image-container').append(this.iconView.render().el);
    },
  
    _onClickColor: function _onClickColor(ev) {
      this.killEvent(ev);
      this.model.set('index', $(ev.target).index());
    },
  
    _onClickBack: function _onClickBack(ev) {
      this.killEvent(ev);
      this.trigger('back', this);
    },
  
    _onClickAssetPicker: function _onClickAssetPicker(ev) {
      this.killEvent(ev);
      this.trigger('goToAssetPicker', this);
    },
  
    _onSlideChange: function _onSlideChange(evt, obj) {
      this.model.set('opacity', this._inverseSliderValue(obj.value));
    },
  
    _inverseSliderValue: function _inverseSliderValue(value) {
      return parseFloat(Number(MAX - value).toFixed(2));
    },
  
    _onChangeOpacity: function _onChangeOpacity() {
      var $input = this.$('.js-a');
      var value = $input.val();
      var isValid = this._isValidOpacity(value);
      $input.toggleClass('has-error', !isValid);
      if (isValid) {
        this.model.set('opacity', parseFloat(value));
      }
    },
  
    _isValidOpacity: function _isValidOpacity(value) {
      var regex = /^((0(\.\d+)?)|(1(\.0)?))$/;
      return regex.test(value);
    },
  
    _reRenderOpacity: function _reRenderOpacity() {
      var $input = this.$('.js-a');
      var $slider = this.$('.js-slider');
      var opacity = this.model.get('opacity');
      var inputValue;
      var sliderValue;
  
      if ($input.length > 0) {
        inputValue = $input.val();
        if (!this._isValidOpacity(inputValue) || this._isValidOpacity(inputValue) && parseFloat(inputValue) !== opacity) {
          $input.val(opacity);
        }
      }
  
      if (typeof $slider.slider('instance') !== 'undefined') {
        sliderValue = $slider.slider('value');
        if (typeof sliderValue !== 'undefined' && sliderValue !== this._inverseSliderValue(opacity)) {
          $slider.slider('value', this._inverseSliderValue(opacity));
        }
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-color-picker/input-color-picker-view.js":
  /*!*************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-color-picker/input-color-picker-view.js ***!
    \*************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var ColorPicker = __webpack_require__(/*! builder/components/color-picker/color-picker */ "./lib/assets/javascripts/builder/components/color-picker/color-picker.js");
  var template = __webpack_require__(/*! ./input-color-picker-view.tpl */ "./lib/assets/javascripts/builder/components/input-color/input-color-picker/input-color-picker-view.tpl");
  var InputColorPickerHeader = __webpack_require__(/*! ./input-color-picker-header */ "./lib/assets/javascripts/builder/components/input-color/input-color-picker/input-color-picker-header.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['ramp', 'opacity'];
  
  module.exports = CoreView.extend({
    events: {
      'click .js-back': '_onClickBack'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this.model = new Backbone.Model({
        index: this.options.index,
        ramp: opts.ramp,
        opacity: opts.opacity
      });
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template());
      this._initViews();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this.model, 'change:index', this._onChangeIndex);
      this.listenTo(this.model, 'change:opacity', this._onOpacityChanged);
    },
  
    _initViews: function _initViews() {
      this._headerView = new InputColorPickerHeader({
        model: this.model,
        imageEnabled: this.options.imageEnabled
      });
  
      this.addView(this._headerView);
      this._headerView.bind('goToAssetPicker', this._onGoToAssetPicker, this);
      this.$('.js-header').append(this._headerView.render().$el);
  
      this._colorPicker = new ColorPicker({
        value: this._getColor(),
        opacity: 1,
        disableOpacity: true
      });
  
      this.addView(this._colorPicker);
      this._colorPicker.bind('change', this._onChangeValue, this);
      this.$('.js-content').append(this._colorPicker.render().$el);
    },
  
    _setColor: function _setColor(color) {
      var ramp = _.clone(this.model.get('ramp'));
      ramp[this.model.get('index')].color = color;
      this.model.set('ramp', ramp);
      this.model.trigger('change', ramp);
      this.trigger('change', ramp);
    },
  
    _getColor: function _getColor() {
      var ramp = this.model.get('ramp');
      return ramp[this.model.get('index') || 0].color;
    },
  
    _onChangeIndex: function _onChangeIndex() {
      this._colorPicker.setColor(this._getColor());
      this.trigger('changeIndex', this.model.get('index'), this);
    },
  
    _onChangeValue: function _onChangeValue(color) {
      this._setColor(color.hex);
    },
  
    _onClickBack: function _onClickBack(e) {
      this.killEvent(e);
      this.trigger('back', this);
    },
  
    _onOpacityChanged: function _onOpacityChanged() {
      var opacity = this.model.get('opacity');
      this.trigger('change:opacity', opacity);
    },
  
    _onGoToAssetPicker: function _onGoToAssetPicker() {
      this.trigger('goToAssetPicker');
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-color-value-content-view.js":
  /*!*************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-color-value-content-view.js ***!
    \*************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var StackLayoutView = __webpack_require__(/*! builder/components/stack-layout/stack-layout-view */ "./lib/assets/javascripts/builder/components/stack-layout/stack-layout-view.js");
  var ColumnListView = __webpack_require__(/*! builder/components/custom-list/column-list/column-list-view */ "./lib/assets/javascripts/builder/components/custom-list/column-list/column-list-view.js");
  var columnListQuantificationMethodItemTemplate = __webpack_require__(/*! builder/components/custom-list/column-list/column-list-quantification-method-item.tpl */ "./lib/assets/javascripts/builder/components/custom-list/column-list/column-list-quantification-method-item.tpl");
  
  var InputQuantitativeRamps = __webpack_require__(/*! ./input-quantitative-ramps/main-view */ "./lib/assets/javascripts/builder/components/input-color/input-quantitative-ramps/main-view.js");
  var InputQualitativeRamps = __webpack_require__(/*! ./input-qualitative-ramps/main-view */ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/main-view.js");
  
  var FillConstants = __webpack_require__(/*! builder/components/form-components/_constants/_fill */ "./lib/assets/javascripts/builder/components/form-components/_constants/_fill.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var MetricsTracker = __webpack_require__(/*! builder/components/metrics/metrics-tracker */ "./lib/assets/javascripts/builder/components/metrics/metrics-tracker.js");
  var MetricsTypes = __webpack_require__(/*! builder/components/metrics/metrics-types */ "./lib/assets/javascripts/builder/components/metrics/metrics-types.js");
  
  var StackViewSteps = {
    COLUMN_LIST_VIEW: 0,
    INPUT_QUALITATIVE_RAMPS_VIEW: 1,
    INPUT_QUANTITATIVE_RAMPS_VIEW: 2
  };
  
  var EXCLUDED_COLUMNS = ['the_geom', 'the_geom_webmercator'];
  var REQUIRED_OPTS = ['columns', 'configModel', 'modals', 'query', 'userModel'];
  
  module.exports = CoreView.extend({
    module: 'components:form-components:editors:fill:input-color:input-color-value-content-view',
  
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      this._settings = _.clone(FillConstants.Settings.COLOR);
      if (this.options.removeByValueCategory) {
        this._removeCategoryFrom(this._settings.quantifications.items);
      }
  
      this._categorizeColumns = options.categorizeColumns;
      this._imageEnabled = options.imageEnabled;
      this._hideTabs = options.hideTabs;
  
      this._column = this._getColumn();
      this._columnType = this._column && this._column.type;
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this._initViews();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this.model, 'change:quantification', function () {
        if (this.model.previous('quantification') === 'category') {
          delete this.model.attributes.range;
        }
  
        if (this.model.get('quantification') !== 'category') {
          this.model.unset('domain');
        }
      });
    },
  
    _initViews: function _initViews() {
      var stackViewCollection = new Backbone.Collection([{
        createStackView: this._createColumnListView.bind(this)
      }, {
        createStackView: this._createInputQuantitativeRamps.bind(this)
      }, {
        createStackView: this._createInputQualitativeRamps.bind(this)
      }]);
  
      if (!this._hideTabs || !_.contains(this._hideTabs, FillConstants.Tabs.QUANTIFICATION)) {
        stackViewCollection.push({ createStackView: this._createQuantificationListView.bind(this) });
      }
  
      this._stackLayoutView = new StackLayoutView({
        collection: stackViewCollection
      });
  
      if (this.model.get('attribute')) {
        var hasDomain = this.model.get('domain') && this.model.get('domain').length;
        var hasRange = this.model.get('range') && this.model.get('range').length;
        var showCategories = this._columnType === 'string' || hasDomain && hasRange;
  
        if (showCategories) {
          this._stackLayoutView.model.set('position', StackViewSteps.INPUT_QUANTITATIVE_RAMPS_VIEW);
        } else {
          this._stackLayoutView.model.set('position', StackViewSteps.INPUT_QUALITATIVE_RAMPS_VIEW);
        }
      }
  
      this.$el.append(this._stackLayoutView.render().$el);
      this.addView(this._stackLayoutView);
    },
  
    _createInputQualitativeRamps: function _createInputQualitativeRamps(stackLayoutModel, options) {
      var view = new InputQualitativeRamps({
        model: this.model,
        query: this._query,
        columns: this._columns,
        configModel: this._configModel,
        userModel: this._userModel,
        modals: this._modals,
        hideTabs: this._hideTabs,
        imageEnabled: this._imageEnabled
      });
  
      view.bind('back', function (value) {
        stackLayoutModel.goToStep(StackViewSteps.COLUMN_LIST_VIEW);
      }, this);
  
      return view;
    },
  
    _createQuantificationListView: function _createQuantificationListView(stackLayoutModel, options) {
      var view = new ColumnListView({
        headerTitle: _t('form-components.editors.fill.quantification.title'),
        stackLayoutModel: stackLayoutModel,
        itemTemplate: columnListQuantificationMethodItemTemplate,
        columns: this._settings.quantifications.items,
        showSearch: false
      });
  
      view.bind('selectItem', function (item) {
        this.model.set('quantification', item.get('val'));
        stackLayoutModel.goToStep(StackViewSteps.INPUT_QUALITATIVE_RAMPS_VIEW);
      }, this);
  
      view.bind('back', function (value) {
        stackLayoutModel.goToStep(StackViewSteps.COLUMN_LIST_VIEW);
      }, this);
  
      return view;
    },
  
    _removeCategoryFrom: function _removeCategoryFrom(items) {
      var categoryIndex = items.indexOf('category');
      if (categoryIndex !== -1) {
        items.splice(categoryIndex, 1);
      }
    },
  
    _createInputQuantitativeRamps: function _createInputQuantitativeRamps(stackLayoutModel, options) {
      var settings = _.clone(FillConstants.Settings.COLOR_RAMPS);
      if (this.options.removeByValueCategory) {
        this._removeCategoryFrom(settings.quantifications.items);
      }
  
      var view = new InputQuantitativeRamps({
        hideTabs: this.options.hideTabs,
        model: this.model,
        settings: settings
      });
  
      view.bind('switch', function () {
        stackLayoutModel.goToStep(StackViewSteps.INPUT_QUANTITATIVE_RAMPS_VIEW);
      }, this);
  
      view.bind('back', function (value) {
        stackLayoutModel.prevStep();
      }, this);
  
      return view;
    },
  
    _getColumn: function _getColumn(columnName) {
      return _.find(this._columns, function (column) {
        return column.label === (columnName || this.model.get('attribute'));
      }, this);
    },
  
    _createColumnListView: function _createColumnListView(stackLayoutModel, options) {
      var view = new ColumnListView({
        stackLayoutModel: stackLayoutModel,
        columns: this._filteredColumns(),
        showSearch: true,
        typeLabel: 'column'
      });
  
      view.bind('selectItem', function (item) {
        this._onChangeAttribute(item.get('val'), stackLayoutModel);
      }, this);
  
      return view;
    },
  
    _filteredColumns: function _filteredColumns() {
      var columns = _.reject(this._columns, function (column) {
        return column.type === 'geometry' || column.type === 'date' || _.contains(EXCLUDED_COLUMNS, column.label);
      }, this);
  
      if (this.options.hideNumericColumns) {
        // eg. color ramps on numeric fields are not currently supported when using torque animations
        columns = _.reject(columns, function (column) {
          return column.type === 'number';
        });
      }
  
      return columns;
    },
  
    _onChangeAttribute: function _onChangeAttribute(columnName, stackLayoutModel) {
      var validCategoryTypes = ['string', 'boolean'];
      var attrsToUnset = ['image', 'fixed', 'quantification', 'opacity'];
      var wasQuantificationCategory = this.model.get('quantification') === 'category';
  
      this._column = this._getColumn(columnName);
      this._columnType = this._column && this._column.type;
  
      _.each(attrsToUnset, function (attr) {
        this.model.unset(attr, { silent: true });
      }, this);
  
      if (_.contains(validCategoryTypes, this._columnType) || this._categorizeColumns) {
        this.model.unset('bins', { silent: true });
        stackLayoutModel.goToStep(StackViewSteps.INPUT_QUANTITATIVE_RAMPS_VIEW);
      } else if (this._columnType === 'number') {
        this.model.unset('images', { silent: true });
        this.model.unset('domain', { silent: true });
  
        // Unset range if previous quantification was category
        if (wasQuantificationCategory) {
          this.model.unset('range', { silent: true });
        }
  
        stackLayoutModel.goToStep(StackViewSteps.INPUT_QUALITATIVE_RAMPS_VIEW);
      }
  
      var attrs = {
        attribute: columnName,
        attribute_type: this._columnType
      };
  
      this.model.set(attrs);
      MetricsTracker.track(MetricsTypes.STYLED_BY_VALUE, attrs);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-color.js":
  /*!******************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-color.js ***!
    \******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./input-color.tpl */ "./lib/assets/javascripts/builder/components/input-color/input-color.tpl");
  var InputDialogContent = __webpack_require__(/*! ./input-color-dialog-content */ "./lib/assets/javascripts/builder/components/input-color/input-color-dialog-content.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var rampList = __webpack_require__(/*! ./input-quantitative-ramps/ramps */ "./lib/assets/javascripts/builder/components/input-color/input-quantitative-ramps/ramps.js");
  var ImageLoaderView = __webpack_require__(/*! builder/components/img-loader-view */ "./lib/assets/javascripts/builder/components/img-loader-view.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  var FillConstants = __webpack_require__(/*! builder/components/form-components/_constants/_fill */ "./lib/assets/javascripts/builder/components/form-components/_constants/_fill.js");
  
  module.exports = CoreView.extend({
    tagName: 'section',
    className: 'CDB-OptionInput-item',
  
    events: {
      'click': '_onClick'
    },
  
    initialize: function initialize(opts) {
      if (this.options.editorAttrs) {
        this._editorAttrs = this.options.editorAttrs;
        this._imageEnabled = this._editorAttrs.imageEnabled;
        this._help = this._editorAttrs.help;
        var hidePanes = this._editorAttrs.hidePanes;
  
        if (hidePanes && !_.contains(hidePanes, FillConstants.Panes.BY_VALUE)) {
          if (!opts.configModel) throw new Error('configModel param is required');
          if (!opts.userModel) throw new Error('userModel param is required');
          if (!opts.modals) throw new Error('modals param is required');
          if (!opts.query) throw new Error('query param is required');
        }
      }
  
      if (!opts.columns) throw new Error('columns is required');
  
      this._columns = opts.columns;
      this._configModel = opts.configModel;
      this._userModel = opts.userModel;
      this._modals = opts.modals;
      this._query = opts.query;
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
  
      if (this.options.disabled) {
        this.$el.addClass('is-disabled');
      }
  
      var column = this._getColumn();
      var columnType = column && column.type;
      var hasDomain = this.model.get('domain') && this.model.get('domain').length;
  
      if (this.model.get('range') && _.isString(this.model.get('range'))) {
        this._migrateRange();
      }
  
      var hasRange = this.model.get('range') && this.model.get('range').length;
      var showCategories = columnType === 'string' || hasDomain && hasRange;
      var imageURL = this._getImageURL();
      var categoryImagesPresent = this._iconStylingEnabled() && !this._getImageURL() && this._categoryImagesPresent();
  
      this.$el.html(template({
        categoryImagesPresent: categoryImagesPresent,
        imageURL: imageURL,
        kind: this._getKind(),
        showCategories: showCategories,
        value: this._getValue(),
        opacity: this._getOpacity(),
        help: this._help || ''
      }));
  
      this._initViews();
  
      return this;
    },
  
    _initViews: function _initViews() {
      this.iconView = new ImageLoaderView({
        imageClass: 'Editor-fillImageAsset',
        imageUrl: this._getImageURL(),
        color: this.model.get('fixed')
      });
      this.addView(this.iconView);
      this.$('.js-image-container').append(this.iconView.render().el);
  
      if (this._help) {
        var tooltip = new TipsyTooltipView({
          el: this.$('.js-help'),
          gravity: 'w',
          title: function title() {
            return $(this).data('tooltip');
          },
          offset: 8
        });
        this.addView(tooltip);
      }
    },
  
    _categoryImagesPresent: function _categoryImagesPresent() {
      var images = this.model.get('images');
  
      for (var i in images) {
        if (!_.isEmpty(images[i])) {
          return true;
        }
      }
  
      return false;
    },
  
    _iconStylingEnabled: function _iconStylingEnabled() {
      return this._imageEnabled;
    },
  
    _getKind: function _getKind() {
      return this.model.get('kind') && this._iconStylingEnabled() ? this.model.get('kind') : '';
    },
  
    _getImageURL: function _getImageURL() {
      return this.model.get('image') && this._iconStylingEnabled() ? this.model.get('image') : '';
    },
  
    // Converts reference to the old color ramp to the full color list
    _migrateRange: function _migrateRange() {
      var rangeName = this.model.get('range');
      var bins = this.model.get('bins') || 3;
  
      if (rampList[rangeName] && rampList[rangeName][bins]) {
        this.model.set('range', rampList[rangeName][bins]);
      }
    },
  
    _getColumn: function _getColumn() {
      return _.find(this._columns, function (column) {
        return column.label === this.model.get('attribute');
      }, this);
    },
  
    _createContentView: function _createContentView() {
      var view = new InputDialogContent({
        configModel: this._configModel,
        userModel: this._userModel,
        modals: this._modals,
        query: this._query,
        model: this.model,
        columns: this._columns,
        editorAttrs: this._editorAttrs
      });
  
      view.bind('change', this.render, this);
  
      return view;
    },
  
    _onClick: function _onClick(e) {
      if (this.options.disabled) {
        return;
      }
      this.trigger('click', this.model);
    },
  
    _initBinds: function _initBinds() {
      var self = this;
  
      this.model.set('createContentView', function () {
        return self._createContentView();
      }).bind(this);
  
      this.model.on('change:images', this.render, this);
      this.model.on('change:selected', this._onToggleSelected, this);
      this.model.on('change:opacity', this.render, this);
      this.model.on('change:fixed', this.render, this);
      this.model.on('change:fixed', this._updateColor, this);
      this.model.on('change:image', this.render, this);
      this.model.on('change:range', this.render, this);
    },
  
    _updateColor: function _updateColor() {
      this.iconView && this.iconView.updateImageColor(this.model.get('fixed'));
    },
  
    _getValue: function _getValue() {
      var value = this.model.get('fixed');
  
      if (value) {
        value = Utils.hexToRGBA(value, this._getOpacity());
      }
  
      if (this.model.get('range') && this.model.get('range').length) {
        value = _.map(this.model.get('range'), function (color) {
          return Utils.hexToRGBA(color, this._getOpacity());
        }, this);
      }
  
      return value;
    },
  
    _getOpacity: function _getOpacity() {
      return this.model.get('opacity') != null ? this.model.get('opacity') : 1;
    },
  
    _onToggleSelected: function _onToggleSelected() {
      this.$el.toggleClass('is-active', this.model.get('selected'));
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/categories-list/list-item-view/categories-list-item-view.js":
  /*!***************************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/categories-list/list-item-view/categories-list-item-view.js ***!
    \***************************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var ImageLoaderView = __webpack_require__(/*! builder/components/img-loader-view */ "./lib/assets/javascripts/builder/components/img-loader-view.js");
  var CustomListItemView = __webpack_require__(/*! builder/components/custom-list/custom-list-item-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item-view.js");
  
  module.exports = CustomListItemView.extend({
    module: 'components:form-components:editors:fill:input-color:input-qualitative-ramps:categories-list:list-item-view:categories-list-item-view',
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
  
      var name = this.model.getName() == null ? 'null' : this.model.getName();
  
      this.$el.append(this.options.template(_.extend({
        typeLabel: this.options.typeLabel,
        isSelected: this.model.get('selected'),
        isDisabled: this.model.get('disabled'),
        isDestructive: this.model.get('destructive'),
        name: name,
        val: this.model.getValue(),
        options: this.model.get('renderOptions'),
        image: this.model.get('image'),
        imageEnabled: this.options.imageEnabled
      })));
  
      this._loadImages();
  
      this.$el.attr('data-val', this.model.getValue()).toggleClass('is-disabled', !!this.model.get('disabled'));
  
      return this;
    },
  
    _loadImages: function _loadImages() {
      this.iconView = new ImageLoaderView({
        imageClass: 'CDB-Text u-actionTextColor js-assetPicker',
        imageUrl: this.model.get('image'),
        color: this.model.get('val')
      });
      this.addView(this.iconView);
      this.$('.js-image-container').append(this.iconView.render().el);
    },
  
    _onClick: function _onClick(ev) {
      this.killEvent(ev);
      var $target = $(ev.target);
      var isIconClicked = $target.closest('.js-image-container').length > 0;
      var isImgClicked = $target.closest('.js-assetPicker').length > 0;
  
      this.model.set({
        selectedClass: isImgClicked || isIconClicked ? ['js-assetPicker'] : [],
        selected: true
      });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/categories-list/list-view/categories-custom-list-view.js":
  /*!************************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/categories-list/list-view/categories-custom-list-view.js ***!
    \************************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CustomListView = __webpack_require__(/*! builder/components/custom-list/custom-list-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-view.js");
  
  module.exports = CustomListView.extend({
    module: 'components:form-components:editors:fill:input-color:input-qualitative-ramps:categories-list:list-view:categories-custom-list-view',
  
    _renderItem: function _renderItem(model, index) {
      var ItemViewClass = this.options.itemView;
      var imageEnabled = this.options.imageEnabled && index < this.options.maxValues; // Disable image for the last item ("Others")
  
      var itemView = new ItemViewClass({
        model: model,
        typeLabel: this.options.typeLabel,
        template: this.options.itemTemplate,
        imageEnabled: imageEnabled
      });
      this.$('.js-list').append(itemView.render().el);
      this.addView(itemView);
  
      // 'customEvent' comes from custom list component
      itemView.bind('customEvent', function (eventName, item) {
        this.trigger('customEvent', eventName, item, this);
      }, this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/categories-list/list-view/categories-list-view.js":
  /*!*****************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/categories-list/list-view/categories-list-view.js ***!
    \*****************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CustomView = __webpack_require__(/*! builder/components/custom-list/custom-view.js */ "./lib/assets/javascripts/builder/components/custom-list/custom-view.js");
  var itemTemplate = __webpack_require__(/*! builder/components/custom-list/custom-list-item.tpl */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item.tpl");
  var CategoriesListItemView = __webpack_require__(/*! ../list-item-view/categories-list-item-view */ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/categories-list/list-item-view/categories-list-item-view.js");
  var CategoriesListView = __webpack_require__(/*! ./categories-custom-list-view */ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/categories-list/list-view/categories-custom-list-view.js");
  
  module.exports = CustomView.extend({
    module: 'components:form-components:editors:fill:input-color:input-qualitative-ramps:categories-list:list-view:categories-list-view',
  
    options: {
      showSearch: true,
      allowFreeTextInput: false,
      typeLabel: 'column',
      itemTemplate: itemTemplate,
      itemView: CategoriesListItemView
    },
  
    _renderList: function _renderList() {
      this._listView = new CategoriesListView({
        model: this.model,
        allowFreeTextInput: this.options.allowFreeTextInput,
        collection: this.collection,
        typeLabel: this.options.typeLabel,
        itemView: this.options.itemView,
        itemTemplate: this.options.itemTemplate,
        size: this.options.size,
        maxValues: this.options.maxValues,
        imageEnabled: this.options.imageEnabled
      });
      this.$el.append(this._listView.render().el);
      this._listView.highlight();
      this.addView(this._listView);
  
      // 'customEvent' comes from custom list component
      this._listView.bind('customEvent', function (eventName, item) {
        this.trigger(eventName, item, this);
      }, this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/categories-list/list-view/input-categories-list-view.js":
  /*!***********************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/categories-list/list-view/input-categories-list-view.js ***!
    \***********************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var CategoriesListView = __webpack_require__(/*! ./categories-list-view */ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/categories-list/list-view/categories-list-view.js");
  var CustomListCollection = __webpack_require__(/*! builder/components/custom-list/custom-list-collection */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-collection.js");
  var template = __webpack_require__(/*! ./input-color-categories-list-view.tpl */ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/categories-list/list-view/input-color-categories-list-view.tpl");
  var itemTemplate = __webpack_require__(/*! ../list-item-view/categories-list-item.tpl */ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/categories-list/list-item-view/categories-list-item.tpl");
  
  module.exports = CoreView.extend({
    module: 'components:form-components:editors:fill:input-color:input-qualitative-ramps:categories-list:list-view:input-categories-list-view',
  
    events: {
      'click .js-color': '_onClickColor',
      'click .js-back': '_onClickBack'
    },
  
    initialize: function initialize(opts) {
      this._showSearch = opts.showSearch || false;
      this._typeLabel = opts.typeLabel;
      this._maxValues = opts.maxValues;
      this._requiredNumberOfColors = opts.requiredNumberOfColors;
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
  
      this.$el.append(template({
        range: this.model.get('range'),
        attribute: this.model.get('attribute'),
        requiredNumberOfColors: this._requiredNumberOfColors
      }));
  
      this._setupCollection();
      this._initBinds();
  
      this._listView = new CategoriesListView({
        itemTemplate: itemTemplate,
        collection: this._collection,
        showSearch: this._showSearch,
        typeLabel: this._typeLabel,
        maxValues: this._maxValues,
        imageEnabled: this.options.imageEnabled
      });
  
      this.addView(this._listView);
  
      this.$('.js-content').append(this._listView.render().$el);
  
      return this;
    },
  
    _setupCollection: function _setupCollection() {
      this._collection = new CustomListCollection(null, { silent: false });
  
      var range = this.model.get('range');
      var domain = this.model.get('domain');
      var images = this.model.get('images');
  
      if (range && range.length && domain && domain.length) {
        var categories = _.map(range, function (color, i) {
          var isNull = domain[i] == null || _.isString(domain[i]) && Utils.isBlank(domain[i]);
          var label = domain[i];
  
          if (i >= this._maxValues) {
            label = _t('form-components.editors.fill.input-qualitative-ramps.others');
          } else if (isNull) {
            label = _t('form-components.editors.fill.input-qualitative-ramps.null');
          }
  
          var attrs = {
            label: label,
            val: color
          };
  
          if (images && images.length) {
            attrs['image'] = images[i];
          }
  
          return attrs;
        }, this);
  
        this._collection.reset(categories);
      }
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this.model, 'change:range', this.render);
      this.listenTo(this.model, 'change:domain', this.render);
      this.listenTo(this.model, 'change:index', this.render);
      this.listenTo(this._collection, 'change:selected', this._onSelectItem);
    },
  
    _onClickBack: function _onClickBack(e) {
      this.killEvent(e);
      this.trigger('back', this);
    },
  
    _onClickColor: function _onClickColor(e) {
      this.killEvent(e);
  
      var index = $(e.target).index();
      var color = this._collection.at(index);
      color && this._onSelectItem(color);
    },
  
    _onSelectItem: function _onSelectItem(item) {
      var selectedItem = {
        index: this._collection.indexOf(item),
        target: _.contains(item.get('selectedClass'), 'js-assetPicker') ? 'asset' : 'color'
      };
  
      this.trigger('selectItem', selectedItem, this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/color-ramps-list/list-item-view/color-ramps-list-item-view.js":
  /*!*****************************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/color-ramps-list/list-item-view/color-ramps-list-item-view.js ***!
    \*****************************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  module.exports = CoreView.extend({
    module: 'components:form-components:editors:fill:input-color:input-qualitative-ramps:color-ramps-list:list-item-view:color-ramps-list-item-view',
  
    className: 'CDB-ListDecoration-item CustomList-item CustomList-item--invert js-listItem',
  
    tagName: 'li',
  
    events: {
      'mouseenter': '_onMouseEnter',
      'mouseleave': '_onMouseLeave',
      'click .js-listItemLink': '_onClick'
    },
  
    initialize: function initialize(opts) {
      this.options = _.extend({}, this.options, opts);
      this.listenTo(this.model, 'change', this.render);
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
  
      this.$el.append(this.options.template({
        typeLabel: this.options.typeLabel,
        isSelected: this.model.get('selected'),
        isDisabled: this.model.get('disabled'),
        isDestructive: this.model.get('destructive'),
        name: this.model.getName(),
        val: this.model.getValue(),
        options: this.model.get('renderOptions')
      }));
  
      this.$el.attr('data-val', this.model.getValue()).toggleClass('is-disabled', !!this.model.get('disabled')).toggleClass('is-selected', !!this.model.get('selected'));
  
      return this;
    },
  
    _onMouseLeave: function _onMouseLeave() {
      this.$el.removeClass('is-highlighted');
    },
  
    _onMouseEnter: function _onMouseEnter() {
      this.$el.addClass('is-highlighted');
    },
  
    _onClick: function _onClick(ev) {
      this.killEvent(ev);
  
      if (this.model.get('selected')) {
        this.trigger('customEvent', 'customize', this.model.getValue(), this);
      } else {
        this.model.set('selected', true);
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/color-ramps-list/list-view/color-ramps-list-view.js":
  /*!*******************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/color-ramps-list/list-view/color-ramps-list-view.js ***!
    \*******************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  var customColorRampTemplate = __webpack_require__(/*! ./color-ramp-custom-item.tpl */ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/color-ramps-list/list-view/color-ramp-custom-item.tpl");
  var colorRampsListTemplate = __webpack_require__(/*! ./color-ramps-list-view.tpl */ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/color-ramps-list/list-view/color-ramps-list-view.tpl");
  var colorRampsListItemTemplate = __webpack_require__(/*! ../list-item-view/color-ramps-list-item.tpl */ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/color-ramps-list/list-item-view/color-ramps-list-item.tpl");
  var ColorRampsListItemView = __webpack_require__(/*! ../list-item-view/color-ramps-list-item-view */ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/color-ramps-list/list-item-view/color-ramps-list-item-view.js");
  
  var CustomListView = __webpack_require__(/*! builder/components/custom-list/custom-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-view.js");
  var CustomListCollection = __webpack_require__(/*! builder/components/custom-list/custom-list-collection */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-collection.js");
  
  var CartoColor = __webpack_require__(/*! builder/helpers/carto-color */ "./lib/assets/javascripts/builder/helpers/carto-color.js");
  
  var EVENTS = {
    CUSTOM_COLOR: 'custom-color',
    RAMP_SELECTED: 'ramp-selected',
    CUSTOMIZE: 'customize'
  };
  
  module.exports = CoreView.extend({
    module: 'components:form-components:editors:fill:input-color:input-qualitative-ramps:color-ramps-list:list-view:color-ramps-list-view',
  
    events: {
      'click .js-customize': '_onClickCustomize',
      'click .js-clear': '_onClickClear',
      'click .js-customRamp': '_onClickCustomRamp',
      'click .js-back': '_onClickBack'
    },
  
    initialize: function initialize(options) {
      this.model = options.model;
      this._maxValues = options.maxValues;
      this._requiredNumberOfColors = options.requiredNumberOfColors;
  
      this._initModels();
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
  
      this.$el.empty();
      this.$el.append(colorRampsListTemplate());
  
      var customRamp = this._customRamp.get('range');
  
      this._listView = new CustomListView({
        collection: this.collection,
        showSearch: false,
        typeLabel: this._typeLabel,
        itemTemplate: colorRampsListItemTemplate,
        itemView: ColorRampsListItemView
      });
  
      this._listView.bind('customize', function (ramp) {
        this.trigger('customize', ramp, this);
      }, this);
  
      this.$('.js-rampsList').append(this._listView.render().el);
      this.addView(this._listView);
  
      if (customRamp && customRamp.length) {
        this.$('.js-customList').addClass('is-customized');
        this.$('.js-customList').prepend(customColorRampTemplate({
          customRamp: customRamp
        }));
      } else {
        var selectedRamp = this.collection.getSelectedItem();
  
        if (!selectedRamp) {
          selectedRamp = this.collection.first();
        }
  
        this._selectRamp(selectedRamp);
      }
  
      return this;
    },
  
    _selectRamp: function _selectRamp(item) {
      if (!item) {
        return;
      }
  
      var range = item.get('val');
  
      // 'manually' select the item to preserve scroll position
      this.$('.js-listItemLink').removeClass('is-selected');
      this.$('.js-listItem[data-val="' + range.join(',') + '"] .js-listItemLink').addClass('is-selected');
    },
  
    _initModels: function _initModels() {
      this._customRamp = new cdb.core.Model();
      this._setupCollection();
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this.collection, 'change:selected', this._onSelectItem);
    },
  
    _onSelectItem: function _onSelectItem(item) {
      var range = item.get('val');
      this.model.set('range', range);
      this.trigger(EVENTS.RAMP_SELECTED, range, this);
    },
  
    _setupCollection: function _setupCollection() {
      var ramps = CartoColor.getQualitativeRamps(this._requiredNumberOfColors);
      var range = this.model.get('range');
  
      ramps = _.map(ramps, function (ramp, name) {
        var isSelected = false;
  
        if (ramp && ramp.length && range && range.length) {
          isSelected = ramp.join().toLowerCase() === range.join().toLowerCase();
        }
  
        if (!ramp) {
          return null;
        }
  
        return {
          selected: isSelected,
          name: name,
          val: ramp
        };
      }, this);
  
      this.collection = new CustomListCollection(_.compact(ramps), { silent: false });
  
      if (!this.collection.getSelectedItem()) {
        this._customRamp.set('range', this.model.get('range'));
      }
    },
  
    _onClickCustomize: function _onClickCustomize(e) {
      this.killEvent(e);
      var ramp = this.collection.getSelectedItem();
      this._customRamp.set('range', ramp);
      this.trigger(EVENTS.CUSTOMIZE, ramp, this);
    },
  
    _onClickClear: function _onClickClear(e) {
      this.killEvent(e);
  
      this._customRamp.set('range', null);
  
      if (!this.collection.getSelectedItem()) {
        this.collection.first().set('selected', true, { silent: true });
      }
  
      this.render();
      this._listView.highlight();
    },
  
    _onClickCustomRamp: function _onClickCustomRamp(e) {
      this.killEvent(e);
  
      if (this._customRamp.get('range')) {
        this.trigger('customize', this.collection.getSelectedItem(), this);
      }
    }
  }, {
    EVENTS: EVENTS
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/main-view.js":
  /*!****************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/main-view.js ***!
    \****************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var mainViewTemplate = __webpack_require__(/*! ./main-view.tpl */ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/main-view.tpl");
  
  var StackLayoutView = __webpack_require__(/*! builder/components/stack-layout/stack-layout-view */ "./lib/assets/javascripts/builder/components/stack-layout/stack-layout-view.js");
  var AssetPickerView = __webpack_require__(/*! ../assets-picker/input-asset-picker-view */ "./lib/assets/javascripts/builder/components/input-color/assets-picker/input-asset-picker-view.js");
  
  var ColorRampsListView = __webpack_require__(/*! ./color-ramps-list/list-view/color-ramps-list-view */ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/color-ramps-list/list-view/color-ramps-list-view.js");
  var CategoriesListView = __webpack_require__(/*! ./categories-list/list-view/input-categories-list-view */ "./lib/assets/javascripts/builder/components/input-color/input-qualitative-ramps/categories-list/list-view/input-categories-list-view.js");
  var InputColorPickerView = __webpack_require__(/*! ../input-color-picker/input-color-picker-view */ "./lib/assets/javascripts/builder/components/input-color/input-color-picker/input-color-picker-view.js");
  var FillConstants = __webpack_require__(/*! builder/components/form-components/_constants/_fill */ "./lib/assets/javascripts/builder/components/form-components/_constants/_fill.js");
  
  var CartoColor = __webpack_require__(/*! cartocolor */ "./node_modules/cartocolor/index.js");
  var MAX_VALUES = 10;
  var DEFAULT_COLORS = _.clone(CartoColor.Prism[MAX_VALUES + 1]); // max values + "others" color
  
  var queryTemplate = _.template('SELECT <%= column %>, count(<%= column %>) FROM (<%= sql %>) _table_sql GROUP BY <%= column %> ORDER BY count DESC, <%= column %> ASC LIMIT <%= max_values %>');
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['columns', 'configModel', 'modals', 'query', 'userModel'];
  
  var STEPS = {
    CATEGORIES_RAMPS_VIEW: 0,
    CATEGORIES_LIST_VIEW: 1,
    COLOR_PICKER_VIEW: 2,
    IMAGE_PICKER_VIEW: 3
  };
  
  module.exports = CoreView.extend({
    module: 'components:form-components:editors:fill:input-color:input-qualitative-ramps:main-view',
  
    events: {
      'click .js-back': '_onClickBack',
      'click .js-quantification': '_onClickQuantification'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
      this._imageEnabled = opts.imageEnabled;
      this._hideTabs = opts.hideTabs;
      this._query = opts.query;
      this._viewModel = new Backbone.Model({
        step: 0,
        status: 'idle'
      });
  
      this.listenTo(this.model, 'change:attribute', this._fetchColumns);
      this.listenTo(this._viewModel, 'change:status', this.render);
  
      if (this.model.hasChanged('quantification')) {
        this._fetchColumns();
      }
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
  
      var column = this._getColumn();
      var columnType = column && column.type;
      var hideQuantification = !!(this._hideTabs && _.contains(this._hideTabs, FillConstants.Tabs.QUANTIFICATION));
  
      this.$el.append(mainViewTemplate({
        status: this._viewModel.get('status'),
        columnType: columnType,
        attribute: this.model.get('attribute'),
        quantification: this.model.get('quantification') || 'category',
        hideQuantification: hideQuantification
      }));
  
      this._generateStackLayoutView();
  
      return this;
    },
  
    _generateStackLayoutView: function _generateStackLayoutView() {
      var currentStep = this._viewModel.get('step');
      var stackViewCollection = new Backbone.Collection([{
        selected: currentStep === STEPS.CATEGORIES_RAMPS_VIEW,
        createStackView: this._createCategoriesRampsListView.bind(this)
      }, {
        selected: currentStep === STEPS.CATEGORIES_LIST_VIEW,
        createStackView: this._createRangeListView.bind(this)
      }, {
        selected: currentStep === STEPS.COLOR_PICKER_VIEW,
        createStackView: this._createColorPickerView.bind(this)
      }]);
  
      if (this._iconStylingEnabled()) {
        stackViewCollection.add({
          selected: currentStep === STEPS.IMAGE_PICKER_VIEW,
          createStackView: this._createImagePickerView.bind(this)
        });
      }
  
      this._stackLayoutView = new StackLayoutView({ collection: stackViewCollection });
      this._stackLayoutView.bind('positionChanged', this._onStackLayoutPositionChange, this);
  
      this.$('.js-content').append(this._stackLayoutView.render().$el);
      this.addView(this._stackLayoutView);
    },
  
    _computeRequiredNumberOfColors: function _computeRequiredNumberOfColors() {
      return this.model.get('domain') ? Math.min(this.model.get('domain').length, MAX_VALUES + 1) : MAX_VALUES + 1;
    },
  
    _onStackLayoutPositionChange: function _onStackLayoutPositionChange() {
      this.$('.js-prevStep').toggle(this._stackLayoutView.getCurrentPosition() === 0);
    },
  
    _iconStylingEnabled: function _iconStylingEnabled() {
      return this._imageEnabled;
    },
  
    _getColumn: function _getColumn() {
      return _.find(this._columns, function (column) {
        return column.label === this.model.get('attribute');
      }, this);
    },
  
    _fetchColumns: function _fetchColumns() {
      if (!this.model.get('attribute')) {
        return;
      }
  
      if (this._query) {
        this._setViewStatus('loading');
  
        var sql = new cdb.SQL({
          user: this._configModel.get('user_name'),
          sql_api_template: this._configModel.get('sql_api_template'),
          api_key: this._configModel.get('api_key')
        });
  
        sql.execute(queryTemplate({
          sql: this._query,
          column: this.model.get('attribute'),
          max_values: MAX_VALUES + 1
        }), null, {
          success: this._onQueryDone.bind(this),
          error: function () {
            this._setViewStatus('error');
          }.bind(this)
        });
      } else {
        this._onQueryDone();
      }
    },
  
    _onQueryDone: function _onQueryDone(data) {
      data = data || {};
      this._updateRangeAndDomain(data.rows);
      this._setViewStatus('idle');
    },
  
    _updateRangeAndDomain: function _updateRangeAndDomain(rows) {
      rows = rows || [];
      var categoryNames = _.pluck(rows, this.model.get('attribute'));
  
      var domain = _.map(categoryNames, function (name, i) {
        return name;
      }).slice(0, MAX_VALUES);
  
      if (this.model.get('attribute_type') !== 'number') {
        domain = domain.filter(function (item, pos, self) {
          return self.indexOf(item) === pos;
        }).map(_quote);
      }
  
      var range = _.map(categoryNames, function (name, i) {
        return i < MAX_VALUES ? DEFAULT_COLORS[i] : DEFAULT_COLORS[MAX_VALUES + 1];
      });
  
      if (this._iconStylingEnabled()) {
        var images = _.map(categoryNames, function () {
          return '';
        });
  
        this.model.attributes.images = images;
      }
  
      this.model.set({
        range: range,
        domain: domain
      });
    },
  
    _setViewStatus: function _setViewStatus(status) {
      var attrs = {
        status: status
      };
  
      if (status === 'loading') {
        attrs.step = 0;
      }
  
      this._viewModel.set(attrs);
    },
  
    _getRange: function _getRange() {
      return _.map(this.model.get('range'), function (color, i) {
        var range = {
          val: color,
          color: color,
          title: this.model.get('domain')[i]
        };
  
        if (this._iconStylingEnabled()) {
          range.image = this.model.get('images')[i];
        }
  
        return range;
      }, this);
    },
  
    _updateRange: function _updateRange(categories) {
      var range = _.clone(this.model.get('range'));
      range[this._index] = categories[this._index].color;
      this.model.set('range', range);
    },
  
    _createColorPickerView: function _createColorPickerView(stackLayoutModel, opts) {
      var range = this._getRange();
  
      var opacity = typeof this.model.get('opacity') !== 'undefined' ? this.model.get('opacity') : 1;
      var imageEnabled = this.options.imageEnabled && this._index < MAX_VALUES; // Disable image for the last item ("Others")
  
      var view = new InputColorPickerView({
        index: this._index,
        ramp: range,
        opacity: opacity,
        imageEnabled: imageEnabled
      });
  
      view.bind('back', function (value) {
        stackLayoutModel.prevStep();
      }, this);
  
      view.bind('goToAssetPicker', function () {
        stackLayoutModel.nextStep();
      }, this);
  
      view.bind('change', this._updateRange, this);
  
      view.bind('changeIndex', function (index) {
        this._index = index;
        this.model.set('index', index);
      }, this);
  
      view.bind('change:opacity', function (opacity) {
        this.model.set('opacity', opacity);
      }, this);
  
      return view;
    },
  
    _createRangeListView: function _createRangeListView(stackLayoutModel, opts) {
      var view = new CategoriesListView({
        model: this.model,
        maxValues: MAX_VALUES,
        imageEnabled: this._iconStylingEnabled(),
        requiredNumberOfColors: this._computeRequiredNumberOfColors()
      });
  
      view.bind('back', function (value) {
        stackLayoutModel.prevStep();
      }, this);
  
      view.bind('selectItem', function (item) {
        this._index = item.index;
  
        if (item.target === 'asset') {
          stackLayoutModel.goToStep(STEPS.IMAGE_PICKER_VIEW);
        } else {
          stackLayoutModel.goToStep(STEPS.COLOR_PICKER_VIEW);
        }
      }, this);
  
      return view;
    },
  
    _createCategoriesRampsListView: function _createCategoriesRampsListView(stackLayoutModel, opts) {
      var view = new ColorRampsListView({
        model: this.model,
        maxValues: MAX_VALUES,
        requiredNumberOfColors: this._computeRequiredNumberOfColors()
      });
  
      var eventsToListen = [ColorRampsListView.EVENTS.RAMP_SELECTED, ColorRampsListView.EVENTS.CUSTOMIZE, ColorRampsListView.EVENTS.CUSTOM_COLOR].join(' ');
  
      view.on(eventsToListen, function () {
        stackLayoutModel.goToStep(STEPS.CATEGORIES_LIST_VIEW);
      }, this);
  
      return view;
    },
  
    _createImagePickerView: function _createImagePickerView(stackLayoutModel, opts) {
      var range = this._getRange();
  
      var view = new AssetPickerView({
        userModel: this._userModel,
        configModel: this._configModel,
        index: this._index,
        ramp: range,
        modals: this._modals,
        imageEnabled: this._iconStylingEnabled()
      });
  
      view.bind('back', function (value) {
        stackLayoutModel.goToStep(STEPS.CATEGORIES_LIST_VIEW);
      }, this);
  
      view.bind('goToColorPicker', function () {
        stackLayoutModel.prevStep();
      }, this);
  
      view.bind('changeIndex', function (index) {
        this._index = index;
      }, this);
  
      if (this._iconStylingEnabled()) {
        view.bind('change:image', this._onImageChanged, this);
      }
  
      return view;
    },
  
    _onImageChanged: function _onImageChanged(data) {
      var images = _.clone(this.model.get('images'));
      images[this._index] = data.url;
      this.model.set('images', images);
    },
  
    _onClickQuantification: function _onClickQuantification(e) {
      this.killEvent(e);
      this.trigger('selectQuantification', this);
    },
  
    _onClickBack: function _onClickBack(e) {
      this.killEvent(e);
      this.trigger('back', this);
    }
  }, {
    MAX_VALUES: MAX_VALUES
  });
  
  function _quote(c) {
    if (c && c !== true) {
      return '"' + c.toString().replace(/"/g, '\\"').replace(/\n/g, '\\n') + '"';
    }
    return c;
  }
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-quantitative-ramps/input-ramp-content-view.js":
  /*!*******************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-quantitative-ramps/input-ramp-content-view.js ***!
    \*******************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var InputRampListView = __webpack_require__(/*! ./input-ramp-list-view */ "./lib/assets/javascripts/builder/components/input-color/input-quantitative-ramps/input-ramp-list-view.js");
  var StackLayoutView = __webpack_require__(/*! builder/components/stack-layout/stack-layout-view */ "./lib/assets/javascripts/builder/components/stack-layout/stack-layout-view.js");
  var InputColorPickerView = __webpack_require__(/*! ../input-color-picker/input-color-picker-view */ "./lib/assets/javascripts/builder/components/input-color/input-color-picker/input-color-picker-view.js");
  
  module.exports = CoreView.extend({
    module: 'components:form-components:editors:fill:input-color:input-quantitative-ramps:input-ramp-content-view',
  
    events: {
      'click .js-back': '_onClickBack'
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this._initViews();
      return this;
    },
  
    _initViews: function _initViews() {
      var self = this;
  
      var stackViewCollection = new Backbone.Collection([{
        createStackView: function createStackView(stackLayoutModel, opts) {
          return self._createInputRampListView(stackLayoutModel, opts).bind(self);
        }
      }, {
        createStackView: function createStackView(stackLayoutModel, opts) {
          return self._createColorPickerView(stackLayoutModel, opts).bind(self);
        }
      }]);
  
      this._stackLayoutView = new StackLayoutView({
        collection: stackViewCollection
      });
  
      this.$el.append(this._stackLayoutView.render().$el);
      this.addView(this._stackLayoutView);
    },
  
    _createColorPickerView: function _createColorPickerView(stackLayoutModel, opts) {
      var range = _.map(this.model.get('range'), function (color, i) {
        return {
          val: color,
          color: color,
          title: this.model.get('attribute')
        };
      }, this);
  
      var opacity = typeof this.model.get('opacity') !== 'undefined' ? this.model.get('opacity') : 1;
  
      var view = new InputColorPickerView({
        index: 0,
        ramp: range,
        opacity: opacity
      });
  
      view.bind('back', function (value) {
        stackLayoutModel.prevStep();
      }, this);
  
      view.bind('change', this._updateRange, this);
      view.bind('change:opacity', function (opacity) {
        this.model.set('opacity', opacity);
      }, this);
  
      return view;
    },
  
    _createInputRampListView: function _createInputRampListView(stackLayoutModel, opts) {
      var view = new InputRampListView({
        model: this.model,
        showSearch: this.options.showSearch || false,
        typeLabel: this.options.typeLabel
      });
  
      view.bind('customize', function (value) {
        stackLayoutModel.nextStep();
      }, this);
  
      view.bind('change_ramp', this._updateRamp, this);
      view.bind('change', this._updateRange, this);
  
      view.bind('back', function (value) {
        this.trigger('back', this);
      }, this);
  
      view.bind('switch', function (value) {
        this.trigger('switch', this);
      }, this);
  
      view.bind('selectItem', function (item) {
        this.trigger('selectItem', item.get('val'), this);
      }, this);
  
      view.bind('selectBins', function (item) {
        this.trigger('selectBins', this);
      }, this);
  
      view.bind('selectQuantification', function (item) {
        this.trigger('selectQuantification', this);
      }, this);
  
      return view;
    },
  
    _updateRamp: function _updateRamp(ramp) {
      this.model.set('range', ramp);
    },
  
    _updateRange: function _updateRange(categories) {
      this.model.set('range', _.pluck(categories, 'color'));
    },
  
    _onClickBack: function _onClickBack(e) {
      this.killEvent(e);
      this.trigger('back', this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-quantitative-ramps/input-ramp-list-item-view.js":
  /*!*********************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-quantitative-ramps/input-ramp-list-item-view.js ***!
    \*********************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  module.exports = CoreView.extend({
  
    className: 'CDB-ListDecoration-item CustomList-item CustomList-item--invert js-listItem',
    tagName: 'li',
  
    events: {
      'mouseenter': '_onMouseEnter',
      'mouseleave': '_onMouseLeave',
      'click .js-listItemLink': '_onClick',
      'click .js-invert': '_onClickInvert'
    },
  
    initialize: function initialize(opts) {
      this.options = _.extend({}, this.options, opts);
      this.listenTo(this.model, 'change', this.render);
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
  
      this.$el.append(this.options.template(_.extend({
        typeLabel: this.options.typeLabel,
        isSelected: this.model.get('selected'),
        isInverted: this.model.get('inverted'),
        isDisabled: this.model.get('disabled'),
        isDestructive: this.model.get('destructive'),
        name: this.model.getName(),
        val: this.model.getValue(),
        options: this.model.get('renderOptions')
      })));
  
      this.$el.attr('data-val', this.model.getValue()).toggleClass('is-disabled', !!this.model.get('disabled')).toggleClass('is-selected', !!this.model.get('selected')).toggleClass('is-inverted', !!this.model.get('inverted'));
  
      return this;
    },
  
    _onMouseLeave: function _onMouseLeave() {
      this.$el.removeClass('is-highlighted');
    },
  
    _onMouseEnter: function _onMouseEnter() {
      this.$el.addClass('is-highlighted');
    },
  
    _onClick: function _onClick(ev) {
      this.killEvent(ev);
  
      if (this.model.get('selected')) {
        this.trigger('customEvent', 'customize', this.model.get('val'), this);
      } else {
        this.model.set('selected', true);
      }
    },
  
    _onClickInvert: function _onClickInvert(e) {
      this.killEvent(e);
      this.model.set('inverted', !this.model.get('inverted'));
      this.trigger('customEvent', 'invert', this.model, this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-quantitative-ramps/input-ramp-list-view.js":
  /*!****************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-quantitative-ramps/input-ramp-list-view.js ***!
    \****************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var CustomListView = __webpack_require__(/*! builder/components/custom-list/custom-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-view.js");
  var CustomListCollection = __webpack_require__(/*! builder/components/custom-list/custom-list-collection */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-collection.js");
  var rampItemTemplate = __webpack_require__(/*! ./input-ramp-list-item-template.tpl */ "./lib/assets/javascripts/builder/components/input-color/input-quantitative-ramps/input-ramp-list-item-template.tpl");
  var rampItemView = __webpack_require__(/*! ./input-ramp-list-item-view */ "./lib/assets/javascripts/builder/components/input-color/input-quantitative-ramps/input-ramp-list-item-view.js");
  var customRampTemplate = __webpack_require__(/*! ./custom-ramp-template.tpl */ "./lib/assets/javascripts/builder/components/input-color/input-quantitative-ramps/custom-ramp-template.tpl");
  var rampList = __webpack_require__(/*! cartocolor */ "./node_modules/cartocolor/index.js");
  var template = __webpack_require__(/*! ./input-ramp-content-view.tpl */ "./lib/assets/javascripts/builder/components/input-color/input-quantitative-ramps/input-ramp-content-view.tpl");
  
  var DEFAULT_RAMP_ITEM_COLOR = '#CCCCCC';
  
  module.exports = CoreView.extend({
    module: 'components:form-components:editors:fill:input-color:input-quantitative-ramps:input-ramp-list-view',
  
    events: {
      'click .js-customize': '_onClickCustomize',
      'click .js-clear': '_onClickClear',
      'click .js-customRamp': '_onClickCustomRamp',
      'click .js-back': '_onClickBack',
      'click .js-switch': '_onClickSwitch',
      'click .js-quantification': '_onClickQuantification',
      'click .js-bins': '_onClickBins'
    },
  
    initialize: function initialize(opts) {
      this._showSearch = opts.showSearch || false;
      this._typeLabel = opts.typeLabel;
  
      this._initModels();
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
  
      this.$el.append(template({
        bins: this.model.get('bins'),
        attribute: this.model.get('attribute'),
        quantification: this.model.get('quantification')
      }));
  
      this._initViews();
  
      var customRamp = this._customRamp.get('range');
  
      if (customRamp && customRamp.length) {
        this.$('.js-customList').addClass('is-customized');
        this.$('.js-customList').prepend(customRampTemplate({
          customRamp: customRamp
        }));
      } else {
        var selectedRamp = this.collection.getSelectedItem();
  
        if (!selectedRamp) {
          selectedRamp = this.collection.first();
        }
  
        this._selectRamp(selectedRamp);
      }
  
      return this;
    },
  
    _initModels: function _initModels() {
      this._customRamp = new cdb.core.Model();
      this._setupCollection();
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this.model, 'change:bins', this._onChangeBins);
      this.listenTo(this.model, 'change:attribute_type', this._updateRampOnAttributeChange);
      this.listenTo(this.collection, 'change:selected', this._onSelectItem);
    },
  
    _initViews: function _initViews() {
      this._listView = new CustomListView({
        collection: this.collection,
        showSearch: this._showSearch,
        typeLabel: this._typeLabel,
        itemTemplate: rampItemTemplate,
        itemView: rampItemView
      });
  
      this._listView.bind('invert', this._invertRamp, this);
      this._listView.bind('customize', function (ramp) {
        this.trigger('customize', ramp, this);
      }, this);
  
      this.$('.js-content').append(this._listView.render().el);
      this.addView(this._listView);
    },
  
    _getRamps: function _getRamps() {
      var attributeType = this.model.get('attribute_type');
      // select only suitable ramps for the data type
      // number -> ramps
      // string -> category
      var rampTypeFromType = {
        number: ['quantitative', 'diverging'],
        string: ['qualitative']
      };
      var ramps = rampList;
      if (rampTypeFromType[attributeType]) {
        ramps = _.filter(ramps, function (r) {
          // ramp without tags is discarded
          if (r.tags) {
            return _.contains(rampTypeFromType[attributeType], r.tags[0]);
          }
          return false;
        });
      }
  
      ramps = _.map(ramps, function (rampItem, name) {
        var ramp = rampItem[this.model.get('bins')];
        var range = this.model.get('range');
        var isSelected = false;
        var isInverted = false;
  
        if (ramp && ramp.length && range && range.length) {
          isSelected = ramp.join().toLowerCase() === range.join().toLowerCase();
  
          if (!isSelected) {
            isSelected = _.clone(ramp).reverse().join().toLowerCase() === range.join().toLowerCase();
            isInverted = isSelected;
          }
        }
  
        if (!ramp) {
          return null;
        }
  
        return {
          selected: isSelected,
          inverted: isInverted,
          name: name,
          val: ramp
        };
      }, this);
  
      return ramps;
    },
  
    _setupCollection: function _setupCollection() {
      var ramps = this._getRamps();
      this.collection = new CustomListCollection(_.compact(ramps), { silent: false });
      if (!this.collection.getSelectedItem()) {
        this._customRamp.set('range', this.model.get('range'));
      }
    },
  
    _updateRampOnAttributeChange: function _updateRampOnAttributeChange(m, type) {
      var ramps = this._getRamps();
      // Update the ramps when the attribute changes
      this.collection.reset(_.compact(ramps), { silent: true });
      // and delete the custom ramp
      this._customRamp.set('range', false);
  
      // apply the first ramp
      var first = this.collection.first();
      first && first.set('selected', true);
      this.render();
    },
  
    _invertRamp: function _invertRamp(item) {
      if (!item) {
        return;
      }
  
      this._customRamp.set('range', null);
      item.set('selected', false);
      var ramp = [].concat(item.get('val')).reverse();
      item.set({ val: ramp, selected: true });
      this.model.set('range', ramp);
    },
  
    _selectRamp: function _selectRamp(item) {
      if (!item) {
        return;
      }
  
      var range = item.get('val');
      // 'manually' select the item to preserve scroll position
      this.$('.js-listItemLink').removeClass('is-selected');
      this.$('.js-listItem[data-val="' + range.join(',') + '"] .js-listItemLink').addClass('is-selected');
    },
  
    _onClickClear: function _onClickClear(e) {
      this.killEvent(e);
  
      this._customRamp.set('range', null);
  
      if (!this.collection.getSelectedItem()) {
        this.collection.first().set('selected', true);
      }
  
      this.render();
      this._listView.highlight();
    },
  
    _onClickCustomRamp: function _onClickCustomRamp(e) {
      this.killEvent(e);
  
      if (this.model.get('range') === this._customRamp.get('range')) {
        this.trigger('customize', this.collection.getSelectedItem(), this);
      } else {
        this.model.set('range', this._customRamp.get('range'));
      }
  
      this.$('.js-listItemLink').removeClass('is-selected');
      this.$('.js-customRamp').addClass('is-selected');
    },
  
    _onClickCustomize: function _onClickCustomize(e) {
      this.killEvent(e);
      var ramp = this.collection.getSelectedItem();
      this._customRamp.set('range', ramp);
      this.trigger('customize', ramp, this);
    },
  
    _onChangeBins: function _onChangeBins() {
      var customRange = this._customRamp.get('range');
  
      if (customRange) {
        if (this.model.get('bins') > customRange.length) {
          customRange = _.range(this.model.get('bins')).map(function (i) {
            return i >= customRange.length ? DEFAULT_RAMP_ITEM_COLOR : customRange[i];
          });
        } else {
          customRange = customRange.slice(0, this.model.get('bins'));
        }
  
        this.model.set('range', customRange);
        this._customRamp.set('range', customRange);
      }
    },
  
    _onSelectItem: function _onSelectItem(item) {
      this._selectRamp(item);
      this.trigger('selectItem', item, this);
    },
  
    _onClickSwitch: function _onClickSwitch(e) {
      this.killEvent(e);
      this.trigger('switch', this);
    },
  
    _onClickBack: function _onClickBack(e) {
      this.killEvent(e);
      this.trigger('back', this);
    },
  
    _onClickQuantification: function _onClickQuantification(e) {
      this.killEvent(e);
      this.trigger('selectQuantification', this);
    },
  
    _onClickBins: function _onClickBins(e) {
      this.killEvent(e);
      this.trigger('selectBins', this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-quantitative-ramps/main-view.js":
  /*!*****************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-quantitative-ramps/main-view.js ***!
    \*****************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var StackLayoutView = __webpack_require__(/*! builder/components/stack-layout/stack-layout-view */ "./lib/assets/javascripts/builder/components/stack-layout/stack-layout-view.js");
  var ColumnListView = __webpack_require__(/*! builder/components/custom-list/column-list/column-list-view */ "./lib/assets/javascripts/builder/components/custom-list/column-list/column-list-view.js");
  var columnListQuantificationMethodItemTemplate = __webpack_require__(/*! builder/components/custom-list/column-list/column-list-quantification-method-item.tpl */ "./lib/assets/javascripts/builder/components/custom-list/column-list/column-list-quantification-method-item.tpl");
  var InputRampContentView = __webpack_require__(/*! ./input-ramp-content-view */ "./lib/assets/javascripts/builder/components/input-color/input-quantitative-ramps/input-ramp-content-view.js");
  var rampList = __webpack_require__(/*! cartocolor */ "./node_modules/cartocolor/index.js");
  var FillConstants = __webpack_require__(/*! builder/components/form-components/_constants/_fill */ "./lib/assets/javascripts/builder/components/form-components/_constants/_fill.js");
  
  module.exports = CoreView.extend({
    module: 'components:form-components:editors:fill:input-color:input-quantitative-ramps:main-view',
  
    initialize: function initialize(opts) {
      this._settings = opts.settings || FillConstants.Settings.COLOR_RAMPS;
  
      this._setupModel();
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this._initViews();
      return this;
    },
  
    _setupModel: function _setupModel() {
      var options = {};
  
      if (!this.model.get('quantification')) {
        options.quantification = this._settings.quantifications.items[this._settings.quantifications.defaultIndex];
      }
  
      if (!this.model.get('bins')) {
        options.bins = this._settings.bins.items[this._settings.bins.defaultIndex];
      }
  
      if (+this.model.get('bins') > +this._settings.bins.items[this._settings.bins.items.length - 1]) {
        options.bins = this._settings.bins.items[this._settings.bins.items.length - 1];
      }
  
      this.model.set(options);
    },
  
    _initBinds: function _initBinds() {
      var range = this.model.get('range');
  
      this.listenTo(this.model, 'change:bins', this._updateRange);
      this.listenTo(this.model, 'change:attribute', this.render);
      this.listenTo(this.model, 'change:quantification', this._onChangeQuantification);
  
      this.model.unset('fixed');
  
      if (!range || !this._isValidRange(range)) {
        this.model.set('range', this._getDefaultRamp());
      }
    },
  
    // range minimun size should be 2
    _isValidRange: function _isValidRange(range) {
      return range && range.length > 1 || false;
    },
  
    _initViews: function _initViews() {
      var self = this;
  
      var collectionOptions = [{
        createStackView: function createStackView(stackLayoutModel, opts) {
          return self._createInputRampContentView(stackLayoutModel, opts).bind(self);
        }
      }];
  
      if (!this.options.hideTabs || !_.contains(this.options.hideTabs, FillConstants.Tabs.QUANTIFICATION)) {
        collectionOptions.push({
          createStackView: function createStackView(stackLayoutModel, opts) {
            return self._createQuantificationListView(stackLayoutModel, opts).bind(self);
          }
        });
      }
  
      if (!this.options.hideTabs || !_.contains(this.options.hideTabs, FillConstants.Tabs.BINS)) {
        collectionOptions.push({
          createStackView: function createStackView(stackLayoutModel, opts) {
            return self._createBinsListView(stackLayoutModel, opts).bind(self);
          }
        });
      }
  
      var stackViewCollection = new Backbone.Collection(collectionOptions);
  
      this._stackLayoutView = new StackLayoutView({
        collection: stackViewCollection
      });
  
      this.$el.append(this._stackLayoutView.render().$el);
      this.addView(this._stackLayoutView);
    },
  
    _updateRange: function _updateRange() {
      var previousBins = this.model.previous('bins');
  
      if (!previousBins) {
        return;
      }
  
      var previousRamps = _.find(rampList, function (ramp) {
        var previousRamp = ramp[previousBins];
        var range = this.model.get('range');
        return previousRamp && range && previousRamp.join('').toLowerCase() === range.join('').toLowerCase();
      }, this);
  
      if (previousRamps) {
        var bins = this.model.get('bins');
        this.model.set('range', previousRamps[bins]);
      }
    },
  
    _createInputRampContentView: function _createInputRampContentView(stackLayoutModel, opts) {
      var view = new InputRampContentView({
        stackLayoutModel: stackLayoutModel,
        model: this.model
      });
  
      view.bind('back', function (value) {
        this.trigger('back');
      }, this);
  
      view.bind('selectItem', function (value) {
        this.model.unset('domain');
        this.model.set('range', value);
      }, this);
  
      view.bind('selectQuantification', function (value) {
        stackLayoutModel.goToStep(1);
      }, this);
  
      view.bind('selectBins', function (value) {
        stackLayoutModel.goToStep(2);
      }, this);
  
      return view;
    },
  
    _createBinsListView: function _createBinsListView(stackLayoutModel, opts) {
      var view = new ColumnListView({
        headerTitle: _t('form-components.editors.fill.bins'),
        stackLayoutModel: stackLayoutModel,
        columns: this._settings.bins.items
      });
  
      view.bind('selectItem', function (item) {
        this.model.set('bins', item.get('val'));
        stackLayoutModel.goToStep(0);
      }, this);
  
      view.bind('back', function (value) {
        stackLayoutModel.goToStep(0);
      }, this);
  
      return view;
    },
  
    _createQuantificationListView: function _createQuantificationListView(stackLayoutModel, opts) {
      var view = new ColumnListView({
        headerTitle: _t('form-components.editors.fill.quantification.title'),
        stackLayoutModel: stackLayoutModel,
        itemTemplate: columnListQuantificationMethodItemTemplate,
        columns: this._settings.quantifications.items,
        showSearch: false
      });
  
      view.bind('selectItem', function (item) {
        this.model.set('quantification', item.get('val'));
        stackLayoutModel.prevStep();
      }, this);
  
      view.bind('back', function (value) {
        stackLayoutModel.goToStep(0);
      }, this);
  
      return view;
    },
  
    _getDefaultRamp: function _getDefaultRamp() {
      return _.map(rampList, function (ramp) {
        return ramp[this.model.get('bins')];
      }, this)[0];
    },
  
    _onChangeQuantification: function _onChangeQuantification() {
      if (this.model.get('quantification') === 'category') {
        this.trigger('switch', this);
      }
    },
  
    remove: function remove() {
      CoreView.prototype.remove.apply(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-color/input-quantitative-ramps/ramps.js":
  /*!*************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-color/input-quantitative-ramps/ramps.js ***!
    \*************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  module.exports = {
    green: {
      '3': ['#E5F5F9', '#99D8C9', '#2CA25F'],
      '4': ['#EDF8FB', '#B2E2E2', '#66C2A4', '#238B45'],
      '5': ['#EDF8FB', '#B2E2E2', '#66C2A4', '#2CA25F', '#006D2C'],
      '6': ['#EDF8FB', '#CCECE6', '#99D8C9', '#66C2A4', '#2CA25F', '#006D2C'],
      '7': ['#EDF8FB', '#D7FAF4', '#CCECE6', '#66C2A4', '#41AE76', '#238B45', '#005824']
    },
    blue: {
      '3': ['#EDF8B1', '#7FCDBB', '#2C7FB8'],
      '4': ['#FFFFCC', '#A1DAB4', '#41B6C4', '#225EA8'],
      '5': ['#FFFFCC', '#A1DAB4', '#41B6C4', '#2C7FB8', '#253494'],
      '6': ['#FFFFCC', '#C7E9B4', '#7FCDBB', '#41B6C4', '#2C7FB8', '#253494'],
      '7': ['#FFFFCC', '#C7E9B4', '#7FCDBB', '#41B6C4', '#1D91C0', '#225EA8', '#0C2C84']
    },
    pink: {
      '3': ['#E7E1EF', '#C994C7', '#DD1C77'],
      '4': ['#F1EEF6', '#D7B5D8', '#DF65B0', '#CE1256'],
      '5': ['#F1EEF6', '#D7B5D8', '#DF65B0', '#DD1C77', '#980043'],
      '6': ['#F1EEF6', '#D4B9DA', '#C994C7', '#DF65B0', '#DD1C77', '#980043'],
      '7': ['#F1EEF6', '#D4B9DA', '#C994C7', '#DF65B0', '#E7298A', '#CE1256', '#91003F']
    },
    black: {
      '3': ['#F0F0F0', '#BDBDBD', '#636363'],
      '4': ['#F7F7F7', '#CCCCCC', '#969696', '#525252'],
      '5': ['#F7F7F7', '#CCCCCC', '#969696', '#636363', '#252525'],
      '6': ['#F7F7F7', '#D9D9D9', '#BDBDBD', '#969696', '#636363', '#252525'],
      '7': ['#F7F7F7', '#D9D9D9', '#BDBDBD', '#969696', '#737373', '#525252', '#252525']
    },
    red: {
      '3': ['#FFEDA0', '#FEB24C', '#F03B20'],
      '4': ['#FFFFB2', '#FECC5C', '#FD8D3C', '#E31A1C'],
      '5': ['#FFFFB2', '#FECC5C', '#FD8D3C', '#F03B20', '#BD0026'],
      '6': ['#FFFFB2', '#FED976', '#FEB24C', '#FD8D3C', '#F03B20', '#BD0026'],
      '7': ['#FFFFB2', '#FED976', '#FEB24C', '#FD8D3C', '#FC4E2A', '#E31A1C', '#B10026']
    },
    inverted_green: {
      '3': ['#2CA25F', '#99D8C9', '#E5F5F9'],
      '4': ['#238B45', '#66C2A4', '#B2E2E2', '#EDF8FB'],
      '5': ['#006D2C', '#2CA25F', '#66C2A4', '#B2E2E2', '#EDF8FB'],
      '6': ['#006D2C', '#2CA25F', '#66C2A4', '#99D8C9', '#CCECE6', '#EDF8FB'],
      '7': ['#005824', '#238B45', '#41AE76', '#66C2A4', '#CCECE6', '#D7FAF4', '#EDF8FB']
    },
    inverted_blue: {
      '3': ['#2C7FB8', '#7FCDBB', '#EDF8B1'],
      '4': ['#225EA8', '#41B6C4', '#A1DAB4', '#FFFFCC'],
      '5': ['#253494', '#2C7FB8', '#41B6C4', '#A1DAB4', '#FFFFCC'],
      '6': ['#253494', '#2C7FB8', '#41B6C4', '#7FCDBB', '#C7E9B4', '#FFFFCC'],
      '7': ['#0C2C84', '#225EA8', '#1D91C0', '#41B6C4', '#7FCDBB', '#C7E9B4', '#FFFFCC']
    },
    inverted_pink: {
      '3': ['#DD1C77', '#C994C7', '#E7E1EF'],
      '4': ['#CE1256', '#DF65B0', '#D7B5D8', '#F1EEF6'],
      '5': ['#980043', '#DD1C77', '#DF65B0', '#D7B5D8', '#F1EEF6'],
      '6': ['#980043', '#DD1C77', '#DF65B0', '#C994C7', '#D4B9DA', '#F1EEF6'],
      '7': ['#91003F', '#CE1256', '#E7298A', '#DF65B0', '#C994C7', '#D4B9DA', '#F1EEF6']
    },
    inverted_black: {
      '3': ['#636363', '#BDBDBD', '#F0F0F0'],
      '4': ['#525252', '#969696', '#CCCCCC', '#F7F7F7'],
      '5': ['#252525', '#636363', '#969696', '#CCCCCC', '#F7F7F7'],
      '6': ['#252525', '#636363', '#969696', '#BDBDBD', '#D9D9D9', '#F7F7F7'],
      '7': ['#252525', '#525252', '#737373', '#969696', '#BDBDBD', '#D9D9D9', '#F7F7F7']
    },
    inverted_red: {
      '3': ['#F03B20', '#FEB24C', '#FFEDA0'],
      '4': ['#E31A1C', '#FD8D3C', '#FECC5C', '#FFFFB2'],
      '5': ['#BD0026', '#F03B20', '#FD8D3C', '#FECC5C', '#FFFFB2'],
      '6': ['#BD0026', '#F03B20', '#FD8D3C', '#FEB24C', '#FED976', '#FFFFB2'],
      '7': ['#B10026', '#E31A1C', '#FC4E2A', '#FD8D3C', '#FEB24C', '#FED976', '#FFFFB2']
    },
    spectrum1: {
      '3': ['#1a9850', '#fff2cc', '#d73027'],
      '4': ['#1a9850', '#d2ecb4', '#fed6b0', '#d73027'],
      '5': ['#1a9850', '#8cce8a', '#fff2cc', '#f79272', '#d73027'],
      '6': ['#1a9850', '#8cce8a', '#d2ecb4', '#fed6b0', '#f79272', '#d73027'],
      '7': ['#1a9850', '#8cce8a', '#d2ecb4', '#fff2cc', '#fed6b0', '#f79272', '#d73027']
    },
    spectrum2: {
      '3': ['#0080ff', '#fff2cc', '#ff4d4d'],
      '4': ['#0080ff', '#7fbfff', '#ffa6a6', '#ff4d4d'],
      '5': ['#0080ff', '#40a0ff', '#fff2cc', '#ff7a7a', '#ff4d4d'],
      '6': ['#0080ff', '#40a0ff', '#7fbfff', '#ffa6a6', '#ff7a7a', '#ff4d4d'],
      '7': ['#0080ff', '#40a0ff', '#7fbfff', '#fff2cc', '#ffa6a6', '#ff7a7a', '#ff4d4d']
    },
    purple_states: {
      '3': ['#F1E6F1', '#B379B3', '#8A4E8A'],
      '4': ['#F1E6F1', '#D8BBD8', '#A05AA0', '#8A4E8A'],
      '5': ['#F1E6F1', '#D8BBD8', '#B379B3', '#A05AA0', '#8A4E8A'],
      '6': ['#F1E6F1', '#D8BBD8', '#CCA5CC', '#B379B3', '#A05AA0', '#8A4E8A'],
      '7': ['#F1E6F1', '#D8BBD8', '#CCA5CC', '#C08FC0', '#B379B3', '#A05AA0', '#8A4E8A']
    },
    red_states: {
      '3': ['#F2D2D3', '#D4686C', '#C1373C'],
      '4': ['#F2D2D3', '#EBB7B9', '#CC4E52', '#C1373C'],
      '5': ['#F2D2D3', '#EBB7B9', '#D4686C', '#CC4E52', '#C1373C'],
      '6': ['#F2D2D3', '#EBB7B9', '#E39D9F', '#D4686C', '#CC4E52', '#C1373C'],
      '7': ['#F2D2D3', '#EBB7B9', '#E39D9F', '#DB8286', '#D4686C', '#CC4E52', '#C1373C']
    },
    blue_states: {
      '3': ['#ECF0F6', '#6182B5', '#43618F'],
      '4': ['#ECF0F6', '#B2C2DB', '#4E71A6', '#43618F'],
      '5': ['#ECF0F6', '#B2C2DB', '#6182B5', '#4E71A6', '#43618F'],
      '6': ['#ECF0F6', '#B2C2DB', '#9BB0D0', '#6182B5', '#4E71A6', '#43618F'],
      '7': ['#ECF0F6', '#B2C2DB', '#9BB0D0', '#849EC5', '#6182B5', '#4E71A6', '#43618F']
    },
    inverted_purple_states: {
      '3': ['#8A4E8A', '#B379B3', '#F1E6F1'],
      '4': ['#8A4E8A', '#A05AA0', '#D8BBD8', '#F1E6F1'],
      '5': ['#8A4E8A', '#A05AA0', '#B379B3', '#D8BBD8', '#F1E6F1'],
      '6': ['#8A4E8A', '#A05AA0', '#B379B3', '#CCA5CC', '#D8BBD8', '#F1E6F1'],
      '7': ['#8A4E8A', '#A05AA0', '#B379B3', '#C08FC0', '#CCA5CC', '#D8BBD8', '#F1E6F1']
    },
    inverted_red_states: {
      '3': ['#C1373C', '#D4686C', '#F2D2D3'],
      '4': ['#C1373C', '#CC4E52', '#EBB7B9', '#F2D2D3'],
      '5': ['#C1373C', '#CC4E52', '#D4686C', '#EBB7B9', '#F2D2D3'],
      '6': ['#C1373C', '#CC4E52', '#D4686C', '#E39D9F', '#EBB7B9', '#F2D2D3'],
      '7': ['#C1373C', '#CC4E52', '#D4686C', '#DB8286', '#E39D9F', '#EBB7B9', '#F2D2D3']
    },
    inverted_blue_states: {
      '3': ['#43618F', '#6182B5', '#ECF0F6'],
      '4': ['#43618F', '#4E71A6', '#B2C2DB', '#ECF0F6'],
      '5': ['#43618F', '#4E71A6', '#6182B5', '#B2C2DB', '#ECF0F6'],
      '6': ['#43618F', '#4E71A6', '#6182B5', '#9BB0D0', '#B2C2DB', '#ECF0F6'],
      '7': ['#43618F', '#4E71A6', '#6182B5', '#849EC5', '#9BB0D0', '#B2C2DB', '#ECF0F6']
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-fill/input-fill-view.js":
  /*!*********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-fill/input-fill-view.js ***!
    \*********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var PopupManager = __webpack_require__(/*! builder/components/popup-manager */ "./lib/assets/javascripts/builder/components/popup-manager.js");
  var FillTemplate = __webpack_require__(/*! builder/components/input-fill/input-fill.tpl */ "./lib/assets/javascripts/builder/components/input-fill/input-fill.tpl");
  var DialogModel = __webpack_require__(/*! builder/components/dialog/dialog-model */ "./lib/assets/javascripts/builder/components/dialog/dialog-model.js");
  var DialogView = __webpack_require__(/*! builder/components/dialog/dialog-view */ "./lib/assets/javascripts/builder/components/dialog/dialog-view.js");
  var InputCollection = __webpack_require__(/*! builder/components/input-collection/input-collection */ "./lib/assets/javascripts/builder/components/input-collection/input-collection.js");
  
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['columns', 'query', 'configModel', 'userModel', 'editorAttrs', 'modals', 'dialogMode', 'popupConfig'];
  
  module.exports = CoreView.extend({
    className: 'Form-InputFill CDB-OptionInput CDB-Text js-input',
  
    events: {
      focus: function focus() {
        this.trigger('focus', this);
      },
      blur: function blur() {
        this.trigger('blur', this);
      }
    },
  
    focus: function focus() {
      if (this.hasFocus) return;
      this.$('.js-fillInput').focus();
    },
  
    blur: function blur() {
      if (!this.hasFocus) return;
      this.$('.js-fillInput').blur();
    },
  
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      this._initViews();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this._initViews();
  
      return this;
    },
  
    clean: function clean() {
      this.removeDialog();
      this._popupManager && this._popupManager.destroy();
  
      CoreView.prototype.clean.call(this);
    },
  
    removeDialog: function removeDialog() {
      if (!this._dialogView) return;
  
      this._popupManager.untrack();
      this._inputCollection.unselect();
      this._dialogView.clean();
    },
  
    _initViews: function _initViews() {
      this.$el.append(FillTemplate());
  
      if (this.options.editorAttrs && this.options.editorAttrs.disabled) {
        this.$el.addClass('is-disabled');
      }
  
      this._initFillDialog();
      this._initInputFields();
  
      this._popupManager = new PopupManager(this._popupConfig.cid, this._popupConfig.$el, this._dialogView.$el);
    },
  
    _initInputFields: function _initInputFields() {
      this._inputCollection = new InputCollection();
      this._inputCollection.bind('onInputChanged', this._onInputChanged, this);
    },
  
    _onInputChanged: function _onInputChanged() {
      this.trigger('onInputChanged', this);
    },
  
    _initFillDialog: function _initFillDialog() {
      var dialogModel = new DialogModel();
  
      this.listenToOnce(dialogModel, 'destroy', function () {
        this._dialogView = null;
        this.stopListening(dialogModel);
      });
  
      this._dialogView = new DialogView({
        model: dialogModel
      });
    },
  
    _onInputClick: function _onInputClick(inputModel) {
      if (inputModel.get('selected')) {
        this.removeDialog();
        return;
      }
  
      inputModel.set('selected', true);
      this._dialogView.model.set('createContentView', inputModel.get('createContentView'));
      this._dialogView.render();
      this._dialogView.show();
  
      this._popupManager.append(this._dialogMode);
      this._popupManager.track();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-number/input-number-content-view.js":
  /*!*********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-number/input-number-content-view.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./input-number-value-content-view.tpl */ "./lib/assets/javascripts/builder/components/input-number/input-number-value-content-view.tpl");
  
  module.exports = CoreView.extend({
    events: {
      'click .js-back': '_onClickBack',
      'click .js-bins': '_onClickBins',
      'click .js-quantification': '_onClickQuantification'
    },
  
    render: function render() {
      this.clearSubViews();
      this._removeForm();
      this.$el.empty();
  
      this.$el.append(template({
        bins: this.model.get('bins'),
        attribute: this.model.get('attribute'),
        quantification: this.model.get('quantification')
      }));
  
      this._initForm();
  
      return this;
    },
  
    _calculateRangeFromFixed: function _calculateRangeFromFixed(fixed, percent) {
      percent = percent || 30;
  
      var span = this.options.max - this.options.min;
      var delta = fixed / span;
  
      return [Math.floor(Math.max(this.options.min, fixed - percent * delta)), Math.floor(Math.min(this.options.max, fixed + percent * delta))];
    },
  
    _initForm: function _initForm() {
      var self = this;
  
      if (this._formView) {
        this._formView.remove();
      }
  
      // when range min === max means we come from a fixed value, probably
      // calculate the range values based on this
      var range = this.model.get('range');
      var min, max;
  
      min = max = this.model.get('fixed');
  
      if (range) {
        min = +range[0];
        max = +range[1];
      }
  
      if (min === max) {
        var r = this._calculateRangeFromFixed(min);
        // set the range so changes are propagated
        min = r[0];
        max = r[1];
        this.model.set('range', r);
      }
  
      this._formModel = new Backbone.Model({
        min: min,
        max: max
      });
  
      this._formModel.schema = {
        min: {
          type: 'Number',
          validators: ['required', {
            type: 'interval',
            min: self.options.min,
            max: self.options.max
          }]
        },
        max: {
          type: 'Number',
          validators: ['required', {
            type: 'interval',
            min: self.options.min,
            max: self.options.max
          }]
        }
      };
  
      this._formModel.bind('change', function (input) {
        this.model.set('range', [+input.get('min'), +input.get('max')]);
      }, this);
  
      this._formView = new Backbone.Form({
        className: 'Editor-boxList',
        model: this._formModel
      });
  
      this._formView.bind('change', function () {
        this.commit();
      });
  
      this.$('.js-content').append(this._formView.render().$el);
    },
  
    _removeForm: function _removeForm() {
      // Backbone.Form removes the view with the following method
      this._formView && this._formView.remove();
    },
  
    _onClickBack: function _onClickBack(e) {
      this.killEvent(e);
      this.trigger('back', this);
    },
  
    _onClickQuantification: function _onClickQuantification(e) {
      this.killEvent(e);
      this.trigger('selectQuantification', this);
    },
  
    _onClickBins: function _onClickBins(e) {
      this.killEvent(e);
      this.trigger('selectBins', this);
    },
  
    clean: function clean() {
      this._removeForm();
      CoreView.prototype.clean.call(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-number/input-number-dialog-content.js":
  /*!***********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-number/input-number-dialog-content.js ***!
    \***********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var tabPaneTemplate = __webpack_require__(/*! builder/components/form-components/editors/fill/fill-tab-pane.tpl */ "./lib/assets/javascripts/builder/components/form-components/editors/fill/fill-tab-pane.tpl");
  var createTextLabelsTabPane = __webpack_require__(/*! builder/components/tab-pane/create-text-labels-tab-pane */ "./lib/assets/javascripts/builder/components/tab-pane/create-text-labels-tab-pane.js");
  var InputNumberFixedContentView = __webpack_require__(/*! ./input-number-fixed-content-view */ "./lib/assets/javascripts/builder/components/input-number/input-number-fixed-content-view.js");
  var InputNumberValueContentView = __webpack_require__(/*! ./input-number-value-content-view */ "./lib/assets/javascripts/builder/components/input-number/input-number-value-content-view.js");
  var FillConstants = __webpack_require__(/*! builder/components/form-components/_constants/_fill */ "./lib/assets/javascripts/builder/components/form-components/_constants/_fill.js");
  
  var DEFAULT_INPUT_MIN_VALUE = 0;
  var DEFAULT_INPUT_MAX_VALUE = 100;
  var DEFAULT_INPUT_STEP_VALUE = 1;
  
  module.exports = CoreView.extend({
    initialize: function initialize(opts) {
      if (!opts.columns) throw new Error('columns param is required');
      this._columns = opts.columns;
  
      this.listenTo(this.model, 'change:attribute', this._updateRangeValue);
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this._initViews();
      return this;
    },
  
    _initViews: function _initViews() {
      var self = this;
  
      var fixedPane = {
        name: 'fixed',
        label: _t('form-components.editors.fill.input-number.fixed'),
        createContentView: function createContentView() {
          return self._generateFixedContentView();
        }
      };
  
      var valuePane = {
        name: 'value',
        label: _t('form-components.editors.fill.input-number.by-value'),
        createContentView: function createContentView() {
          return self._generateValueContentView();
        }
      };
  
      this._tabPaneTabs = [];
  
      if (this.options.editorAttrs && this.options.editorAttrs.hidePanes) {
        var hidePanes = this.options.editorAttrs.hidePanes;
        if (!_.contains(hidePanes, FillConstants.Panes.FIXED)) {
          this._tabPaneTabs.push(fixedPane);
        }
        if (!_.contains(hidePanes, FillConstants.Panes.BY_VALUE)) {
          this._tabPaneTabs.push(valuePane);
        }
      } else {
        this._tabPaneTabs = [fixedPane, valuePane];
      }
  
      var tabPaneOptions = {
        tabPaneOptions: {
          template: tabPaneTemplate,
          tabPaneItemOptions: {
            tagName: 'li',
            klassName: 'CDB-NavMenu-item'
          }
        },
        tabPaneItemLabelOptions: {
          tagName: 'button',
          className: 'CDB-NavMenu-link u-upperCase'
        }
      };
  
      if (this.model.get('range') && this._tabPaneTabs.length > 1) {
        this._tabPaneTabs[1].selected = true;
      }
  
      this._tabPaneView = createTextLabelsTabPane(this._tabPaneTabs, tabPaneOptions);
      this.listenTo(this._tabPaneView.collection, 'change:selected', this._onChangeTabPaneViewTab);
      this.addView(this._tabPaneView);
      this.$el.append(this._tabPaneView.render().$el);
    },
  
    _onChangeTabPaneViewTab: function _onChangeTabPaneViewTab() {
      var selectedTabPaneName = this._tabPaneView.getSelectedTabPaneName();
  
      if (selectedTabPaneName === 'fixed') {
        this._updateFixedValue();
      } else {
        this._updateRangeValue();
      }
  
      this.trigger('change', selectedTabPaneName, this);
    },
  
    _updateFixedValue: function _updateFixedValue() {
      if (this.model.get('range')) {
        // when coming from range calculate the average
        var r = this.model.get('range');
        var avg = 0.5 * (+r[0] + +r[1]);
        this.model.set('fixed', avg);
        this.model.unset('range');
      }
    },
  
    _updateRangeValue: function _updateRangeValue() {
      if (this.model.get('fixed') !== null && this.model.get('fixed') !== undefined && this.model.get('attribute')) {
        var editorAttrs = this.options.editorAttrs;
        var range = editorAttrs && editorAttrs.defaultRange || [this.model.get('fixed'), this.model.get('fixed')];
        this.model.set('range', range);
        this.model.unset('fixed');
      }
    },
  
    _generateFixedContentView: function _generateFixedContentView() {
      var editorAttrs = this.options.editorAttrs;
      return new InputNumberFixedContentView({
        model: this.model,
        min: editorAttrs && editorAttrs.min || DEFAULT_INPUT_MIN_VALUE,
        max: editorAttrs && editorAttrs.max || DEFAULT_INPUT_MAX_VALUE,
        step: editorAttrs && editorAttrs.step || DEFAULT_INPUT_STEP_VALUE
      });
    },
  
    _generateValueContentView: function _generateValueContentView() {
      var editorAttrs = this.options.editorAttrs;
      return new InputNumberValueContentView({
        model: this.model,
        columns: this._columns,
        min: editorAttrs && editorAttrs.min || DEFAULT_INPUT_MIN_VALUE,
        max: editorAttrs && editorAttrs.max || DEFAULT_INPUT_MAX_VALUE
      });
    },
  
    _onChangeValue: function _onChangeValue(input) {
      this.model.set('fixed', input.value);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-number/input-number-fixed-content-view.js":
  /*!***************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-number/input-number-fixed-content-view.js ***!
    \***************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  module.exports = CoreView.extend({
    render: function render() {
      this.clearSubViews();
      this._removeForm();
      this.$el.empty();
      this._initForm();
      return this;
    },
  
    _initForm: function _initForm() {
      this._formModel = new Backbone.Model({
        value: this.model.get('fixed')
      });
  
      this._formModel.schema = {
        value: {
          type: 'Number',
          validators: ['required', {
            type: 'interval',
            min: this.options.min,
            max: this.options.max,
            step: this.options.step
          }]
        }
      };
  
      this._formModel.bind('change', function (input) {
        this.model.set('fixed', input.get('value'));
      }, this);
  
      this._formView = new Backbone.Form({
        className: 'CDB-ListDecoration-itemPadding',
        model: this._formModel
      });
  
      this._formView.bind('change', function () {
        this.commit();
      });
  
      this.$el.append(this._formView.render().$el);
    },
  
    _removeForm: function _removeForm() {
      // Backbone.Form removes the view with the following method
      this._formView && this._formView.remove();
    },
  
    clean: function clean() {
      this._removeForm();
      CoreView.prototype.clean.call(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-number/input-number-value-content-view.js":
  /*!***************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-number/input-number-value-content-view.js ***!
    \***************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var StackLayoutView = __webpack_require__(/*! builder/components/stack-layout/stack-layout-view */ "./lib/assets/javascripts/builder/components/stack-layout/stack-layout-view.js");
  var ColumnListView = __webpack_require__(/*! builder/components/custom-list/column-list/column-list-view */ "./lib/assets/javascripts/builder/components/custom-list/column-list/column-list-view.js");
  var columnListQuantificationMethodItemTemplate = __webpack_require__(/*! builder/components/custom-list/column-list/column-list-quantification-method-item.tpl */ "./lib/assets/javascripts/builder/components/custom-list/column-list/column-list-quantification-method-item.tpl");
  var InputNumberContentView = __webpack_require__(/*! ./input-number-content-view */ "./lib/assets/javascripts/builder/components/input-number/input-number-content-view.js");
  var FillConstants = __webpack_require__(/*! builder/components/form-components/_constants/_fill */ "./lib/assets/javascripts/builder/components/form-components/_constants/_fill.js");
  
  /**
   * add the number of classes
   * change the max depending on the min
   * smaller values on top
   */
  var COLUMN_PANE_INDEX = 0;
  var MAIN_PAIN_INDEX = 1;
  var QUANTIFICATION_PANE_INDEX = 2;
  
  module.exports = CoreView.extend({
    events: {
      'click .js-back': '_onClickBack'
    },
  
    initialize: function initialize(opts) {
      if (!opts.columns) throw new Error('columns param is required');
      this._columns = opts.columns;
  
      this._settings = FillConstants.Settings.NUMBER;
  
      this._setupModel();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this._initViews();
      return this;
    },
  
    _setupModel: function _setupModel() {
      var options = {};
  
      if (!this.model.get('quantification')) {
        options.quantification = this._settings.quantifications.items[this._settings.quantifications.defaultIndex];
      }
  
      if (!this.model.get('bins')) {
        options.bins = this._settings.bins.items[this._settings.bins.defaultIndex];
      }
  
      if (+this.model.get('bins') > +this._settings.bins.items[this._settings.bins.items.length - 1]) {
        options.bins = this._settings.bins.items[this._settings.bins.items.length - 1];
      }
  
      this.model.set(options);
    },
  
    _initViews: function _initViews() {
      var self = this;
  
      var stackViewCollection = new Backbone.Collection([{
        createStackView: function createStackView(stackLayoutModel, opts) {
          return self._createInputRampContentView(stackLayoutModel, opts).bind(self);
        }
      }, {
        createStackView: function createStackView(stackLayoutModel, opts) {
          return self._createInputNumberContentView(stackLayoutModel, opts).bind(self);
        }
      }, {
        createStackView: function createStackView(stackLayoutModel, opts) {
          return self._createQuantificationListView(stackLayoutModel, opts).bind(self);
        }
      }, {
        createStackView: function createStackView(stackLayoutModel, opts) {
          return self._createBinsListView(stackLayoutModel, opts).bind(self);
        }
      }]);
  
      this._stackLayoutView = new StackLayoutView({
        collection: stackViewCollection
      });
  
      var position = MAIN_PAIN_INDEX;
  
      if (!this.model.get('attribute')) {
        position = COLUMN_PANE_INDEX;
      } else if (!this.model.get('quantification')) {
        position = QUANTIFICATION_PANE_INDEX;
      }
  
      this._stackLayoutView.model.set('position', position);
      this.$el.append(this._stackLayoutView.render().$el);
      this.addView(this._stackLayoutView);
    },
  
    _createInputRampContentView: function _createInputRampContentView(stackLayoutModel, opts) {
      var view = new ColumnListView({
        stackLayoutModel: stackLayoutModel,
        columns: this._columns.filter(function (f) {
          return f.type === 'number';
        }),
        showSearch: true,
        typeLabel: 'column'
      });
  
      view.bind('selectItem', function (item) {
        this.model.set('attribute', item.get('val'));
        var step = MAIN_PAIN_INDEX;
        if (!this.model.get('quantification')) {
          step = QUANTIFICATION_PANE_INDEX;
        }
        this._stackLayoutView.model.goToStep(step);
      }, this);
  
      return view;
    },
  
    _createInputNumberContentView: function _createInputNumberContentView(stackLayoutModel, opts) {
      var view = new InputNumberContentView({
        stackLayoutModel: stackLayoutModel,
        model: this.model,
        min: this.options.min,
        max: this.options.max
      });
  
      view.bind('back', function (value) {
        stackLayoutModel.prevStep();
      }, this);
  
      view.bind('selectQuantification', function (value) {
        stackLayoutModel.goToStep(2);
      }, this);
  
      view.bind('selectBins', function (value) {
        stackLayoutModel.goToStep(3);
      }, this);
  
      return view;
    },
  
    _createQuantificationListView: function _createQuantificationListView(stackLayoutModel, opts) {
      var view = new ColumnListView({
        headerTitle: _t('form-components.editors.fill.quantification.title'),
        stackLayoutModel: stackLayoutModel,
        columns: this._settings.quantifications.items,
        itemTemplate: columnListQuantificationMethodItemTemplate,
        showSearch: false
      });
  
      view.bind('selectItem', function (item) {
        this.model.set('quantification', item.get('val'));
        stackLayoutModel.prevStep();
      }, this);
  
      view.bind('back', function (value) {
        stackLayoutModel.prevStep();
      }, this);
  
      return view;
    },
  
    _createBinsListView: function _createBinsListView(stackLayoutModel, opts) {
      var view = new ColumnListView({
        headerTitle: _t('form-components.editors.fill.bins'),
        stackLayoutModel: stackLayoutModel,
        columns: this._settings.bins.items
      });
  
      view.bind('selectItem', function (item) {
        this.model.set('bins', item.get('val'));
        stackLayoutModel.goToStep(1);
      }, this);
  
      view.bind('back', function (value) {
        stackLayoutModel.goToStep(1);
      }, this);
  
      return view;
    },
  
    _onClickBack: function _onClickBack(e) {
      this.killEvent(e);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/input-number/input-number.js":
  /*!********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/input-number/input-number.js ***!
    \********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./input-number.tpl */ "./lib/assets/javascripts/builder/components/input-number/input-number.tpl");
  var InputDialogContent = __webpack_require__(/*! ./input-number-dialog-content */ "./lib/assets/javascripts/builder/components/input-number/input-number-dialog-content.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  
  module.exports = CoreView.extend({
    tagName: 'li',
    className: 'CDB-OptionInput-item',
  
    events: {
      'click': '_onClick'
    },
  
    initialize: function initialize(opts) {
      if (!opts.columns) throw new Error('columns is required');
      this._columns = opts.columns;
  
      if (this.options.editorAttrs && this.options.editorAttrs.help) {
        this._help = this.options.editorAttrs.help;
      }
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
  
      if (this.options.disabled) {
        this.$el.addClass('is-disabled');
      }
  
      this.$el.html(template({
        help: this._help || '',
        value: this._getValue()
      }));
  
      this._initViews();
  
      return this;
    },
  
    _initViews: function _initViews() {
      if (this._help) {
        var tooltip = new TipsyTooltipView({
          el: this.$('.js-help'),
          gravity: 'w',
          title: function title() {
            return $(this).data('tooltip');
          }
        });
        this.addView(tooltip);
      }
    },
  
    _createContentView: function _createContentView() {
      var view = new InputDialogContent({
        model: this.model,
        columns: this._columns,
        editorAttrs: this.options.editorAttrs
      });
  
      view.bind('change', this.render, this);
  
      return view;
    },
  
    _onClick: function _onClick(e) {
      if (this.options.disabled) {
        return;
      }
      this.trigger('click', this.model);
    },
  
    _initBinds: function _initBinds() {
      this.model.set('createContentView', function () {
        return this._createContentView();
      }.bind(this));
  
      this.listenTo(this.model, 'change:selected', this._onToggleSelected);
      this.listenTo(this.model, 'change:fixed', this._onChangeValue);
      this.listenTo(this.model, 'change:range', this._onChangeValue);
    },
  
    _getValue: function _getValue() {
      // 1.0 -> 1
      function dropDecimal(f) {
        return f.replace(/\.0$/, '');
      }
  
      if (this.model.get('range')) {
        return this.model.get('range').map(function (v) {
          return dropDecimal((+v).toFixed(1));
        }).join('..');
      }
      return dropDecimal((+this.model.get('fixed')).toFixed(1));
    },
  
    _onChangeValue: function _onChangeValue() {
      this.$('.js-value').text(this._getValue());
    },
  
    _onToggleSelected: function _onToggleSelected() {
      this.$el.toggleClass('is-active', this.model.get('selected'));
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/loading/random-quote.js":
  /*!***************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/loading/random-quote.js ***!
    \***************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var template = __webpack_require__(/*! ./quote.tpl */ "./lib/assets/javascripts/builder/components/loading/quote.tpl");
  
  var QUOTES = [{ quote: 'Geographers never get lost. They just do accidental field work.', author: 'Nicholas Chrisman' }, { quote: 'Geography is just physics slowed down, with a couple of trees stuck in it.', author: 'Terry Pratchett' }, { quote: 'Not all those who wander are lost.', author: 'J. R. R. Tolkien' }, { quote: 'In that Empire, the Art of Cartography attained such Perfection that the map of a single Province occupied the entirety of a City.', author: 'Jorge Luis Borges' }, { quote: 'X marks the spot', author: 'Indiana Jones' }, { quote: "It's turtles all the way down.", author: null }, { quote: 'Remember: no matter where you go, there you are.', author: null }, { quote: "Without geography, you're nowhere!", author: 'Jimmy Buffett' }, { quote: 'our earth is a globe / whose surface we probe /<br />no map can replace her / but just try to trace her', author: 'Steve Waterman' }, { quote: 'Everything happens somewhere.', author: 'Doctor Who' }, { quote: 'A map is the greatest of all epic poems. Its lines and colors show the realization of great dreams.', author: 'Gilbert H. Grosvenor' }, { quote: 'Everything is related to everything else,<br />but near things are more related than distant things.', author: "Tobler's first law of geography" }, { quote: 'Hic Sunt Dracones', author: null }, { quote: 'Here be dragons', author: null }, { quote: "Stand in the place where you live / Now face North /<br/>Think about direction / Wonder why you haven't before", author: 'R.E.M' }, { quote: 'The virtue of maps, they show what can be done with limited space, they foresee that everything can happen therein.', author: 'Jos Saramago' }];
  
  /**
   * Random quote
   */
  module.exports = function () {
    var idx = Math.round(Math.random() * (QUOTES.length - 1));
  
    return template(QUOTES[idx]);
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/loading/render-loading.js":
  /*!*****************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/loading/render-loading.js ***!
    \*****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var template = __webpack_require__(/*! ./loading.tpl */ "./lib/assets/javascripts/builder/components/loading/loading.tpl");
  var randomQuote = __webpack_require__(/*! ./random-quote */ "./lib/assets/javascripts/builder/components/loading/random-quote.js");
  
  /**
   * @param {Object} opts
   * @param {String=} opts.title
   * @param {String=} opts.desc
   */
  module.exports = function (opts) {
    var customDesc = opts.desc && cdb.core.sanitize(opts.desc);
  
    return template({
      title: opts.title || '',
      descHTML: customDesc || randomQuote()
    });
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/metrics/metrics-model.js":
  /*!****************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/metrics/metrics-model.js ***!
    \****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  module.exports = Backbone.Model.extend({
  
    defaults: {
      eventName: '',
      eventProperties: {}
    },
  
    url: function url() {
      return this._configModel.get('base_url') + '/api/v3/metrics';
    },
  
    initialize: function initialize(attrs, opts) {
      if (!opts.configModel) {
        throw new Error('configModel is required');
      }
  
      this._userId = opts.userId;
      this._visId = opts.visId;
      this._configModel = opts.configModel;
    },
  
    toJSON: function toJSON() {
      return {
        name: this.get('eventName'),
        properties: _.extend({}, this.get('eventProperties'), {
          visualization_id: this._visId,
          user_id: this._userId
        })
      };
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/metrics/metrics-tracker.js":
  /*!******************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/metrics/metrics-tracker.js ***!
    \******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var MetricsModel = __webpack_require__(/*! ./metrics-model */ "./lib/assets/javascripts/builder/components/metrics/metrics-model.js");
  var MetricsTypes = __webpack_require__(/*! ./metrics-types */ "./lib/assets/javascripts/builder/components/metrics/metrics-types.js");
  
  /**
   *  Metrics singleton tracker.
   *  It sends any event to metrics endpoint.
   */
  
  module.exports = function () {
    return {
      init: function init(opts) {
        if (!opts || !opts.configModel) {
          throw new Error('configModel is required');
        }
  
        this._userId = opts.userId;
        this._visId = opts.visId;
        this._configModel = opts.configModel;
      },
  
      track: function track(eventName, eventProperties) {
        if (!eventName) {
          throw new Error('eventName is required');
        }
        this._checkEventIsConfigured(eventName);
  
        var metricModel = new MetricsModel({
          eventName: eventName,
          eventProperties: eventProperties
        }, {
          userId: this._userId,
          visId: this._visId,
          configModel: this._configModel
        });
  
        metricModel.save();
      },
  
      _checkEventIsConfigured: function _checkEventIsConfigured(eventName) {
        var allowed = _.values(MetricsTypes);
        if (!_.contains(allowed, eventName)) {
          throw new Error('"' + eventName + '" is not an allowed event type');
        }
      }
    };
  }();
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/metrics/metrics-types.js":
  /*!****************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/metrics/metrics-types.js ***!
    \****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  // IMPORTANT: Events must be kept in sync with backend!
  // See `/lib/carto/tracking/events.rb`
  
  var METRIC_TYPES = {
    STYLED_BY_VALUE: 'Styled by value',
    DOWNLOADED_LAYER: 'Downloaded layer',
    CREATED_LAYER: 'Created Layer',
    MODIFIED_ANALYSIS: 'Modified analysis',
    CREATED_ANALYSIS: 'Created analysis',
    DELETED_ANALYSIS: 'Deleted analysis',
    DRAGGED_NODE: 'Dragged node',
    APPLIED_SQL: 'Applied sql',
    WEBGL_STATS: 'WebGL stats',
    USED_ADVANCED_MODE: 'Used advanced mode',
    AGGREGATED_GEOMETRIES: 'Aggregated geometries',
    MODIFIED_STYLE_FORM: 'Modified Style Form',
    CHANGED_DEFAULT_GEOMETRY: 'Changed default geometry',
    APPLIED_CARTOCSS: 'Applied Cartocss',
    VISITED_PRIVATE_PAGE: 'visited_private_page'
  };
  
  module.exports = METRIC_TYPES;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/content-result-view.js":
  /*!************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/content-result-view.js ***!
    \************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var randomQuote = __webpack_require__(/*! builder/components/loading/random-quote */ "./lib/assets/javascripts/builder/components/loading/random-quote.js");
  
  /*
   *  Content result default view
   */
  
  module.exports = CoreView.extend({
    events: {
      'click .js-connect': '_onConnectClick'
    },
  
    initialize: function initialize(opts) {
      if (!opts.routerModel) throw new Error('routerModel is required');
      if (!opts.tablesCollection) throw new Error('tablesCollection is required');
      if (!opts.userModel) throw new Error('userModel is required');
      if (!opts.template) throw new Error('template is required');
  
      this._userModel = opts.userModel;
      this._routerModel = opts.routerModel;
      this._tablesCollection = opts.tablesCollection;
      this.template = opts.template;
  
      this._initBinds();
    },
  
    render: function render() {
      var type = this._routerModel.get('content_type');
  
      this.$el.html(this.template({
        page: this._routerModel.get('page'),
        tag: this._routerModel.get('tag'),
        q: this._routerModel.get('q'),
        shared: this._routerModel.get('shared'),
        locked: this._routerModel.get('locked'),
        library: this._routerModel.get('library'),
        quote: randomQuote(),
        type: type,
        totalItems: this._tablesCollection.size(),
        totalEntries: this._tablesCollection.getTotalStat('total_entries')
      }));
  
      return this;
    },
  
    _initBinds: function _initBinds() {
      this._routerModel.bind('change', this.render, this);
      this._tablesCollection.bind('sync', this.render, this);
      this.add_related_model(this._routerModel);
      this.add_related_model(this._tablesCollection);
    },
  
    _onConnectClick: function _onConnectClick() {
      this.trigger('connectDataset', this);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/dataset-item-view.js":
  /*!**********************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/dataset-item-view.js ***!
    \**********************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  var template = __webpack_require__(/*! ./dataset-item.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/dataset-item.tpl");
  
  /**
   * View representing an item in the list under datasets route.
   */
  module.exports = CoreView.extend({
    tagName: 'li',
    className: 'ModalBlockList-item ModalBlockList-item--full',
  
    events: {
      'click .js-tag-link': '_onTagClick',
      'click': '_toggleSelected'
    },
  
    initialize: function initialize(opts) {
      if (!opts.createModel) throw new Error('createModel is required');
      if (!opts.userModel) throw new Error('userModel is required');
  
      this._createModel = opts.createModel;
      this._userModel = opts.userModel;
      this._routerModel = this._createModel.getVisualizationFetchModel();
  
      this.model.on('change', this.render, this);
    },
  
    render: function render() {
      var tableModel = this.model.getTableModel();
      var permissionModel = this.model.getPermissionModel();
      var synchronizationModel = this.model.getSynchronizationModel();
      var tags = this.model.get('tags') || [];
      var description = cdb.core.sanitize.html(this.model.get('description'));
      var tableGeomColumnTypes = (tableModel.getGeometryType ? tableModel.getGeometryType() : tableModel.geomColumnTypes()) || [];
  
      var d = {
        isRaster: this.model.isRaster(),
        geometryType: tableGeomColumnTypes.length > 0 ? tableGeomColumnTypes[0] : '',
        title: this.model.get('name'),
        isOwner: permissionModel.isOwner(this._userModel),
        owner: permissionModel.getOwner().renderData(this._userModel),
        showPermissionIndicator: !permissionModel.hasWriteAccess(this._userModel),
        description: description,
        privacy: this.model.get('privacy').toLowerCase(),
        timeDiff: moment(this.model.get('updated_at')).fromNow(),
        tags: tags,
        tagsCount: tags.length,
        maxTagsToShow: 3,
        rowCount: undefined,
        datasetSize: undefined,
        syncStatus: undefined,
        syncRanAt: undefined
      };
  
      var rowCount = tableModel.get('row_count');
      if (rowCount >= 0) {
        d.rowCount = rowCount;
        d.rowCountFormatted = rowCount < 10000 ? Utils.formatNumber(rowCount) : Utils.readizableNumber(rowCount);
      }
  
      var datasetSize = tableModel.get('size');
      if (datasetSize >= 0) {
        d.datasetSize = Utils.readablizeBytes(datasetSize, true);
      }
  
      if (!_.isEmpty(synchronizationModel)) {
        d.syncRanAt = moment(synchronizationModel.get('ran_at') || new Date()).fromNow();
        d.syncStatus = synchronizationModel.get('state');
      }
  
      this.$el.html(template(d));
  
      this._renderTooltips();
  
      // Item selected?
      this.$el.toggleClass('is-selected', !!this.model.get('selected'));
  
      return this;
    },
  
    _renderTooltips: function _renderTooltips() {
      if (!_.isEmpty(this.model.get('synchronization'))) {
        this.addView(new TipsyTooltipView({
          el: this.$('.DatasetsList-itemStatus'),
          title: function title(e) {
            return $(this).attr('data-title');
          }
        }));
      }
    },
  
    _onTagClick: function _onTagClick(ev) {
      var tag = $(ev.target).val();
  
      if (tag) {
        this._routerModel.set('tag', tag);
      }
    },
  
    _toggleSelected: function _toggleSelected(ev) {
      // Let links use default behaviour
      if (ev.target.tagName !== 'A') {
        this.killEvent(ev);
        if (this._createModel.canSelect(this.model)) {
          this.model.set('selected', !this.model.get('selected'));
        }
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/datasets-list-view.js":
  /*!***********************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/datasets-list-view.js ***!
    \***********************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var DATASETS_ITEMS = {
    'datasets': __webpack_require__(/*! ./dataset-item-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/dataset-item-view.js"),
    'remotes': __webpack_require__(/*! ./remote-dataset-item-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/remote-dataset-item-view.js")
  };
  
  /**
   * View representing the list of datasets
   */
  module.exports = CoreView.extend({
  
    tagName: 'ul',
    className: 'DatasetsList fs-DatasetsList',
  
    initialize: function initialize(opts) {
      if (!opts.createModel) throw new Error('createModel is required');
      if (!opts.userModel) throw new Error('userModel is required');
  
      this._createModel = opts.createModel;
      this._userModel = opts.userModel;
      this._tablesCollection = this._createModel.getTablesCollection();
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this._tablesCollection.each(this._addItem, this);
      return this;
    },
  
    _initBinds: function _initBinds() {
      this._tablesCollection.bind('sync', this.render, this);
      this.add_related_model(this._tablesCollection);
    },
  
    _addItem: function _addItem(m, i) {
      var type = m.get('type') === 'remote' ? 'remotes' : 'datasets';
  
      var item = new DATASETS_ITEMS[type]({
        model: m,
        createModel: this._createModel,
        userModel: this._userModel
      });
  
      this.addView(item);
      this.$el.append(item.render().el);
    },
  
    show: function show() {
      this.$el.removeClass('is-hidden');
    },
  
    hide: function hide() {
      this.$el.addClass('is-hidden');
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/datasets-pagination-view.js":
  /*!*****************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/datasets-pagination-view.js ***!
    \*****************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var PaginationModel = __webpack_require__(/*! builder/components/pagination/pagination-model */ "./lib/assets/javascripts/builder/components/pagination/pagination-model.js");
  var PaginationView = __webpack_require__(/*! builder/components/pagination/pagination-view */ "./lib/assets/javascripts/builder/components/pagination/pagination-view.js");
  
  /**
   * Responsible for the datasets paginator
   *  ___________________________________________________________________________
   * |                                                                           |
   * |                                             Page 2 of 42 [1] 2 [3][4][5]  |
   * |___________________________________________________________________________|
   *
   */
  
  module.exports = CoreView.extend({
    className: 'DatasetsPaginator',
  
    initialize: function initialize(opts) {
      if (!opts.routerModel) throw new TypeError('routerModel is required');
      if (!opts.tablesCollection) throw new TypeError('tablesCollection is required');
  
      this._routerModel = opts.routerModel;
      this._tablesCollection = opts.tablesCollection;
  
      this.model = new PaginationModel({
        current_page: this._routerModel.get('page')
      });
  
      this._initBinds();
      this._initViews();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html('');
      if (this.model.shouldBeVisible()) {
        this.$el.append(this.paginationView.render().el);
      }
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change', this.render, this);
      this.model.bind('change:current_page', function () {
        this._routerModel.set('page', this.model.get('current_page'));
      }, this);
      this._tablesCollection.bind('sync', this._updatePaginationModelByCollection, this);
      this._routerModel.bind('change:page', this._updatePaginationModelByRouterModel, this);
  
      this.add_related_model(this._routerModel);
      this.add_related_model(this._tablesCollection);
      this.add_related_model(this.model);
    },
  
    _initViews: function _initViews() {
      this.paginationView = new PaginationView({
        model: this.model
      });
      this.addView(this.paginationView);
    },
  
    _updatePaginationModelByCollection: function _updatePaginationModelByCollection() {
      this.model.set({
        per_page: this._tablesCollection.getDefaultParam('per_page'),
        total_count: this._tablesCollection.getTotalStat('total_entries')
      });
    },
  
    _updatePaginationModelByRouterModel: function _updatePaginationModelByRouterModel() {
      this.model.set('current_page', this._routerModel.get('page'));
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/datasets-view.js":
  /*!******************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/datasets-view.js ***!
    \******************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var ContentResultView = __webpack_require__(/*! ./content-result-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/content-result-view.js");
  var DatasetsListView = __webpack_require__(/*! ./datasets-list-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/datasets-list-view.js");
  var DatasetsPaginationView = __webpack_require__(/*! ./datasets-pagination-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/datasets-pagination-view.js");
  var noResultsTemplate = __webpack_require__(/*! ./no-datasets.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/no-datasets.tpl");
  var datasetsNoResultTemplate = __webpack_require__(/*! ./datasets-no-result.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/datasets-no-result.tpl");
  var datasetsErrorTemplate = __webpack_require__(/*! ./datasets-error.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/datasets-error.tpl");
  var datasetsLoaderTemplate = __webpack_require__(/*! ./datasets-loader.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/datasets-loader.tpl");
  
  /**
   *  Datasets list view
   *
   *  Show datasets view to select them for
   *  creating a map or importing a dataset
   *
   */
  
  module.exports = CoreView.extend({
    initialize: function initialize(opts) {
      if (!opts.createModel) throw new Error('createModel is required');
      if (!opts.userModel) throw new Error('userModel is required');
  
      this._createModel = opts.createModel;
      this._userModel = opts.userModel;
      this._routerModel = this._createModel.getVisualizationFetchModel();
      this._tablesCollection = this._createModel.getTablesCollection();
  
      this._initViews();
      this._initBinds();
      this._onDataLoading();
    },
  
    _initBinds: function _initBinds() {
      this._routerModel.bind('change', this._onRouterChange, this);
      this._tablesCollection.bind('loading', this._onDataLoading, this);
      this._tablesCollection.bind('sync', this._onDataFetched, this);
      this._tablesCollection.bind('error', function (e) {
        // Old requests can be stopped, so aborted requests are not
        // considered as an error
        if (!e || e && e.statusText !== 'abort') {
          this._onDataError();
        }
      }, this);
      this.add_related_model(this._routerModel);
      this.add_related_model(this._tablesCollection);
    },
  
    _initViews: function _initViews() {
      this.controlledViews = {}; // All available views
      this.enabledViews = []; // Visible views
  
      var noDatasetsView = new ContentResultView({
        className: 'ContentResult no-datasets',
        userModel: this._userModel,
        routerModel: this._routerModel,
        tablesCollection: this._tablesCollection,
        template: noResultsTemplate
      });
      noDatasetsView.bind('connectDataset', function () {
        if (this._userModel.canCreateDatasets()) {
          this._createModel.set('listing', 'import');
        }
      }, this);
      noDatasetsView.render().hide();
      this.controlledViews['no_datasets'] = noDatasetsView;
      this.$el.append(noDatasetsView.el);
      this.addView(noDatasetsView);
  
      var listView = new DatasetsListView({
        userModel: this._userModel,
        createModel: this._createModel
      });
      this.controlledViews.list = listView;
      this.$el.append(listView.render().el);
      this.addView(listView);
  
      var noResultsView = new ContentResultView({
        userModel: this._userModel,
        routerModel: this._routerModel,
        tablesCollection: this._tablesCollection,
        template: datasetsNoResultTemplate
      });
      noResultsView.render().hide();
      this.controlledViews.no_results = noResultsView;
      this.$el.append(noResultsView.el);
      this.addView(noResultsView);
  
      var errorView = new ContentResultView({
        userModel: this._userModel,
        routerModel: this._routerModel,
        tablesCollection: this._tablesCollection,
        template: datasetsErrorTemplate
      });
      errorView.render().hide();
      this.controlledViews.error = errorView;
      this.$el.append(errorView.el);
      this.addView(errorView);
  
      var mainLoaderView = new ContentResultView({
        userModel: this._userModel,
        routerModel: this._routerModel,
        tablesCollection: this._tablesCollection,
        template: datasetsLoaderTemplate
      });
      this.controlledViews.main_loader = mainLoaderView;
      this.$el.append(mainLoaderView.render().el);
      this.addView(mainLoaderView);
  
      var datasetsPaginationView = new DatasetsPaginationView({
        routerModel: this._routerModel,
        tablesCollection: this._tablesCollection
      });
      this.controlledViews.content_footer = datasetsPaginationView;
      this.$el.append(datasetsPaginationView.render().el);
      this.addView(datasetsPaginationView);
    },
  
    _onRouterChange: function _onRouterChange() {
      this._hideBlocks();
      this._showBlocks(['main_loader']);
    },
  
    /**
     * Arguments may vary, depending on if it's the collection or a model that triggers the event callback.
     * @private
     */
    _onDataFetched: function _onDataFetched() {
      var activeViews = ['content_footer'];
      var tag = this._routerModel.get('tag');
      var q = this._routerModel.get('q');
      var shared = this._routerModel.get('shared');
      var locked = this._routerModel.get('locked');
      var library = this._routerModel.get('library');
  
      if (library && this._tablesCollection.getTotalStat('total_user_entries') === 0) {
        activeViews.push('no_datasets');
      }
  
      if (this._tablesCollection.size() === 0) {
        if (!tag && !q && shared === 'no' && !locked) {
          if (!library) {
            this._goToLibrary();
            return;
          } else {
            activeViews.push('no_results');
          }
        } else {
          activeViews.push('no_results');
        }
      } else {
        activeViews.push('list');
      }
  
      this._hideBlocks();
      this._showBlocks(activeViews);
    },
  
    _onDataLoading: function _onDataLoading() {
      this._hideBlocks();
      this._showBlocks(['main_loader']);
    },
  
    _onDataError: function _onDataError(e) {
      this._hideBlocks();
      this._showBlocks(['error']);
    },
  
    _showBlocks: function _showBlocks(views) {
      var self = this;
      if (views) {
        _.each(views, function (v) {
          if (self.controlledViews[v]) {
            self.controlledViews[v].show();
            self.enabledViews.push(v);
          }
        });
      } else {
        self.enabledViews = [];
        _.each(this.controlledViews, function (v) {
          v.show();
          self.enabledViews.push(v);
        });
      }
    },
  
    _goToLibrary: function _goToLibrary() {
      this._routerModel.set({
        shared: 'no',
        library: true,
        page: 1
      });
    },
  
    _hideBlocks: function _hideBlocks(views) {
      var self = this;
      if (views) {
        _.each(views, function (v) {
          if (self.controlledViews[v]) {
            self.controlledViews[v].hide();
            self.enabledViews = _.without(self.enabledViews, v);
          }
        });
      } else {
        _.each(this.controlledViews, function (v) {
          v.hide();
        });
        self.enabledViews = [];
      }
    },
  
    _isBlockEnabled: function _isBlockEnabled(name) {
      if (name) {
        return _.contains(this.enabledViews, name);
      }
      return false;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/remote-dataset-item-view.js":
  /*!*****************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/remote-dataset-item-view.js ***!
    \*****************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var DatasetItem = __webpack_require__(/*! ./dataset-item-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/dataset-item-view.js");
  var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  var markdown = __webpack_require__(/*! markdown */ "./vendor/assets/javascripts/markdown.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  var UploadConfig = __webpack_require__(/*! builder/config/upload-config */ "./lib/assets/javascripts/builder/config/upload-config.js");
  var template = __webpack_require__(/*! ./remote-dataset-item.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/remote-dataset-item.tpl");
  
  /**
   *  Remote dataset item view
   *
   */
  
  module.exports = DatasetItem.extend({
    tagName: 'li',
    className: 'ModalBlockList-item ModalBlockList-item--full',
  
    events: {
      'click .js-tag-link': '_onTagClick',
      'click': '_toggleSelected'
    },
  
    render: function render() {
      var tableModel = this.model.getTableModel();
      var tags = this.model.get('tags') || [];
      var description = cdb.core.sanitize.html(this.model.get('description') || '');
      var source = markdown.toHTML(this.model.get('source') || '');
      var tableGeomColumnTypes = tableModel.getGeometryType() || [];
  
      var d = {
        isRaster: this.model.isRaster(),
        geometryType: tableGeomColumnTypes.length > 0 ? tableGeomColumnTypes[0] : '',
        title: this.model.get('display_name') || this.model.get('name'),
        source: source,
        description: description,
        timeDiff: moment(this.model.get('updated_at')).fromNow(),
        tags: tags,
        tagsCount: tags.length,
        routerModel: this._routerModel,
        maxTagsToShow: 3,
        canImportDataset: this._canImportDataset(),
        rowCount: undefined,
        datasetSize: undefined
      };
  
      var rowCount = tableModel.get('row_count');
      if (rowCount >= 0) {
        d.rowCount = rowCount;
        d.rowCountFormatted = rowCount < 10000 ? Utils.formatNumber(rowCount) : Utils.readizableNumber(rowCount);
      }
  
      var datasetSize = tableModel.get('size');
      if (datasetSize >= 0) {
        d.datasetSize = Utils.readablizeBytes(datasetSize, datasetSize.toString().length > 9);
      }
  
      this.$el.html(template(d));
      this._setItemClasses();
      this._renderTooltips();
  
      return this;
    },
  
    _setItemClasses: function _setItemClasses() {
      // Item selected?
      this.$el.toggleClass('is-selected', !!this.model.get('selected'));
      // Check if it is selectable
      this.$el.toggleClass('is-selectable', !!this._canImportDataset());
      // Check if it is importable
      this.$el.toggleClass('is-banned', !this._canImportDataset());
    },
  
    _renderTooltips: function _renderTooltips() {
      this.addView(new TipsyTooltipView({
        el: this.$('.DatasetsList-itemStatus'),
        title: function title(e) {
          return $(this).attr('data-title');
        }
      }));
    },
  
    _onTagClick: function _onTagClick(ev) {
      if (ev) {
        this.killEvent(ev);
      }
  
      var tag = $(ev.target).val();
  
      if (tag) {
        this._routerModel.set({
          tag: tag,
          library: true
        });
      }
    },
  
    _canImportDataset: function _canImportDataset() {
      var tableModel = this.model.getTableModel();
      var tableSize = tableModel.get('size') || 0;
      return this._userModel.get('remaining_byte_quota') * UploadConfig.fileTimesBigger >= tableSize && this._userModel.get('limits')['import_file_size'] > tableSize;
    },
  
    _toggleSelected: function _toggleSelected(ev) {
      // Let links use default behaviour
      if (ev.target.tagName !== 'A') {
        this.killEvent(ev);
        if (this._canImportDataset() && this._createModel.canSelect(this.model)) {
          this.model.set('selected', !this.model.get('selected'));
        }
      }
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-arcgis/import-arcgis-selected-dataset-view.js":
  /*!*****************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-arcgis/import-arcgis-selected-dataset-view.js ***!
    \*****************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var SelectedDatasetView = __webpack_require__(/*! builder/components/modals/add-layer/content/imports/import-selected-dataset-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-selected-dataset-view.js");
  var template = __webpack_require__(/*! builder/components/modals/add-layer/content/imports/import-selected-dataset.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-selected-dataset.tpl");
  
  /**
   *  Selected ArcGIS dataset
   *
   *  - Displays the result when an ArcGIS url/dataset is selected, no matter the type.
   *  - It will show available sync options if user can and the url is an ArcGIS layer.
   *  - Upgrade link for people who don't have sync permissions.
   *
   */
  
  module.exports = SelectedDatasetView.extend({
    render: function render() {
      var title = this.options.fileAttrs.title && this.model.get('value')[this.options.fileAttrs.title] || this.model.get('value');
      var description = this._genDescription();
      var ext = this.options.fileAttrs.ext ? Utils.getFileExtension(title) : '';
  
      if (this.options.fileAttrs.ext) {
        title = title && title.replace('.' + ext, '');
      }
  
      var upgradeUrl = window.upgrade_url;
      var userCanSync = this._userModel.isActionEnabled('sync_tables');
      var customInstall = this._configModel.get('cartodb_com_hosted');
  
      this.$el.html(template({
        title: title,
        description: description,
        ext: ext,
        interval: this.model.get('interval'),
        importCanSync: this.options.acceptSync && this._isArcGISLayer(title),
        userCanSync: userCanSync,
        showTrial: this._userModel.canStartTrial(),
        showUpgrade: !userCanSync && !customInstall && upgradeUrl && !this._userModel.isInsideOrg(),
        upgradeUrl: upgradeUrl
      }));
      return this;
    },
  
    _isArcGISLayer: function _isArcGISLayer(url) {
      return url.search(/([0-9]+\/|[0-9]+)/) !== -1;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-arcgis/import-arcgis-view.js":
  /*!************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-arcgis/import-arcgis-view.js ***!
    \************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var FormView = __webpack_require__(/*! builder/components/modals/add-layer/content/imports/import-data/import-data-form-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-data/import-data-form-view.js");
  var HeaderView = __webpack_require__(/*! builder/components/modals/add-layer/content/imports/import-data/import-data-header-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-data/import-data-header-view.js");
  var SelectedDatasetView = __webpack_require__(/*! ./import-arcgis-selected-dataset-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-arcgis/import-arcgis-selected-dataset-view.js");
  var ImportDataView = __webpack_require__(/*! builder/components/modals/add-layer/content/imports/import-data/import-data-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-data/import-data-view.js");
  var headerTemplate = __webpack_require__(/*! ./import-arcgis-header.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-arcgis/import-arcgis-header.tpl");
  var formTemplate = __webpack_require__(/*! ./import-arcgis-form.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-arcgis/import-arcgis-form.tpl");
  
  /**
   *  Import ArcGIS panel
   *
   *  - It only accepts an url, and it could be a map or a layer.
   *
   */
  
  module.exports = ImportDataView.extend({
    options: {
      fileExtensions: [],
      type: 'service',
      service: 'arcgis',
      acceptSync: true,
      fileEnabled: false,
      fileAttrs: {
        ext: false,
        title: '',
        description: ''
      }
    },
  
    _initViews: function _initViews() {
      var headerView = new HeaderView({
        el: this.$('.ImportPanel-header'),
        model: this.model,
        userModel: this._userModel,
        collection: this.collection,
        fileEnabled: this.options.fileEnabled,
        acceptSync: this.options.acceptSync,
        template: headerTemplate
      });
      headerView.render();
      this.addView(headerView);
  
      var selected = new SelectedDatasetView({
        el: this.$('.DatasetSelected'),
        userModel: this._userModel,
        model: this.model,
        acceptSync: this.options.acceptSync,
        fileAttrs: this.options.fileAttrs,
        configModel: this._configModel
      });
      selected.render();
      this.addView(selected);
  
      var formView = new FormView({
        el: this.$('.ImportPanel-form'),
        userModel: this._userModel,
        model: this.model,
        template: formTemplate,
        fileEnabled: this.options.fileEnabled
      });
  
      formView.render();
      this.addView(formView);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-data/import-data-form-view.js":
  /*!*************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-data/import-data-form-view.js ***!
    \*************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  __webpack_require__(/*! dragster */ "./vendor/assets/javascripts/dragster.js");
  var Dropzone = __webpack_require__(/*! dropzone */ "./vendor/assets/javascripts/dropzone.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./import-data-form.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-data/import-data-form.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  /**
   *  Form view for url import for example
   *
   *  - It accepts an url
   *  - It checks if it is valid
   *  - It could have a file option
   *
   */
  
  var REQUIRED_OPTS = ['userModel'];
  
  module.exports = CoreView.extend({
    options: {
      template: '',
      fileEnabled: false
    },
  
    events: {
      'keyup .js-textInput': '_onTextChanged',
      'submit .js-form': '_onSubmitForm'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this.template = opts.template || template;
  
      this._initBinds();
      this._checkVisibility();
    },
  
    render: function render() {
      this.$el.html(this.template(this.options));
      this._initViews();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change:state', this._checkVisibility, this);
    },
  
    _initViews: function _initViews() {
      if (this.options.fileEnabled) {
        var self = this;
        this.$('.js-fileInput').bind('change', function (e) {
          if (this.files && this.files.length > 0) {
            self._onFileChanged(this.files);
          }
          this.value = '';
        });
  
        this._initDropzone();
      }
    },
  
    _initDropzone: function _initDropzone() {
      var el = $('html')[0]; // :(
      var self = this;
  
      this.dragster = new Dragster(el); // eslint-disable-line
  
      $(el).bind('dragster:enter', function (e) {
        self._showDropzone();
      });
  
      $(el).bind('dragster:leave', function (e) {
        self._hideDropzone();
      });
  
      if (el.dropzone) {
        // avoid loading the dropzone twice
        el.dropzone.destroy();
      }
  
      this.dropzone = new Dropzone(el, {
        url: ':)',
        autoProcessQueue: false,
        previewsContainer: false
      });
  
      this.dropzone.on('dragover', function () {
        self._showDropzone();
      });
  
      this.dropzone.on('drop', function (ev) {
        var files = ev.dataTransfer.files;
        self._onFileChanged(files);
        self._hideDropzone();
      });
    },
  
    _destroyDropzone: function _destroyDropzone() {
      var el = $('html')[0]; // :(
  
      if (this.dragster) {
        this.dragster.removeListeners();
        this.dragster.reset();
        $(el).unbind('dragster:enter dragster:leave');
      }
  
      if (this.dropzone) {
        this.dropzone.destroy();
      }
    },
  
    _setValidFileExtensions: function _setValidFileExtensions(list) {
      return RegExp('(\.|\/)(' + list.join('|') + ')$', 'i');
    },
  
    _onTextChanged: function _onTextChanged() {
      var value = this.$('.js-textInput').val();
      if (!value) {
        this._hideTextError();
      }
    },
  
    _onFileChanged: function _onFileChanged(files) {
      this.trigger('fileSelected', this);
  
      if (files && files.length === 1) {
        files = files[0];
      }
  
      this.model.setUpload({
        type: 'file',
        value: files
      });
  
      if (this.model.get('state') !== 'error') {
        this._hideFileError();
        this.model.set('state', 'selected');
      } else {
        this._showFileError();
      }
    },
  
    _showTextError: function _showTextError() {
      this.$('.Form-inputError').addClass('is-visible');
    },
  
    _hideTextError: function _hideTextError() {
      this.$('.Form-inputError').removeClass('is-visible');
    },
  
    _showDropzone: function _showDropzone() {
      this.$('.Form-upload').addClass('is-dropping');
      this._hideFileError();
    },
  
    _hideDropzone: function _hideDropzone() {
      this.$('.Form-upload').removeClass('is-dropping');
    },
  
    _showFileError: function _showFileError() {
      if (this.model.get('state') === 'error') {
        this.$('.js-fileError').text(this.model.get('get_error_text').what_about).show();
        this.$('.js-fileLabel').hide();
        this.$('.js-fileButton').addClass('Button--negative');
      }
    },
  
    _hideFileError: function _hideFileError() {
      this.$('.js-fileError').hide();
      this.$('.js-fileLabel').show();
      this.$('.js-fileButton').removeClass('Button--negative');
    },
  
    _onSubmitForm: function _onSubmitForm(e) {
      if (e) this.killEvent(e);
  
      var value = this.$('.js-textInput').val();
  
      if (!value) {
        this._hideTextError();
        return;
      }
  
      // Change file attributes :S
      this.trigger('urlSelected', this);
  
      // Change model
      var importType = this.model.get('service_name') ? 'service' : 'url';
      this.model.setUpload({
        type: importType,
        value: value,
        service_item_id: value,
        state: 'idle'
      });
  
      if (this.model.get('state') !== 'error') {
        this._hideFileError();
        this._hideTextError();
        this.model.set('state', 'selected');
  
        this.trigger('urlSubmitted', this);
      } else {
        this._showTextError();
      }
    },
  
    _checkVisibility: function _checkVisibility() {
      var state = this.model.get('state');
      this[state !== 'selected' ? 'show' : 'hide']();
    },
  
    clean: function clean() {
      this._destroyDropzone();
      this.$('.js-fileInput').unbind('change');
      CoreView.prototype.clean.apply(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-data/import-data-header-view.js":
  /*!***************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-data/import-data-header-view.js ***!
    \***************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./import-data-header.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-data/import-data-header.tpl");
  
  /**
   *  Data header view
   *
   *  - It will change when upload state changes
   *  - Possibility to change state with a header button
   *
   */
  
  module.exports = CoreView.extend({
    events: {
      'click .js-back': '_goToStart'
    },
  
    options: {
      fileEnabled: false,
      acceptSync: false
    },
  
    initialize: function initialize(opts) {
      if (!opts.userModel) throw new Error('userModel is required');
  
      this._userModel = opts.userModel;
      this.template = opts.template || template;
      this._initBinds();
      this._checkVisibility();
    },
  
    render: function render() {
      var acceptSync = this.options.acceptSync && this._userModel.get('actions') && this._userModel.isActionEnabled('sync_tables') && this.model.get('type') !== 'file';
  
      this.$el.html(this.template({
        type: this.model.get('type'),
        fileEnabled: this.options.fileEnabled,
        acceptSync: acceptSync,
        state: this.model.get('state')
      }));
      this._checkVisibility();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change:state', this.render, this);
    },
  
    _checkVisibility: function _checkVisibility() {
      this.show();
    },
  
    _goToStart: function _goToStart() {
      this.model.set('state', 'idle');
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-data/import-data-view.js":
  /*!********************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-data/import-data-view.js ***!
    \********************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var ImportView = __webpack_require__(/*! builder/components/modals/add-layer/content/imports/import-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-view.js");
  var UploadModel = __webpack_require__(/*! builder/data/upload-model */ "./lib/assets/javascripts/builder/data/upload-model.js");
  var FormView = __webpack_require__(/*! ./import-data-form-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-data/import-data-form-view.js");
  var HeaderView = __webpack_require__(/*! ./import-data-header-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-data/import-data-header-view.js");
  var SelectedDatasetView = __webpack_require__(/*! builder/components/modals/add-layer/content/imports/import-selected-dataset-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-selected-dataset-view.js");
  var template = __webpack_require__(/*! ./import-data.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-data/import-data.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  /**
   *  Import data panel
   *
   *  - It accepts an url
   *  - It checks if it is valid
   *
   */
  
  var REQUIRED_OPTS = ['userModel', 'configModel', 'createModel', 'privacyModel', 'guessingModel'];
  
  module.exports = ImportView.extend({
    options: {
      fileExtensions: [],
      type: 'url',
      service: '',
      acceptSync: false,
      fileEnabled: false,
      formTemplate: '',
      headerTemplate: '',
      fileAttrs: {}
    },
  
    className: 'ImportPanel ImportDataPanel',
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this._initModels();
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template());
      this._initViews();
      this._initBinds();
      return this;
    },
  
    _initModels: function _initModels() {
      this.model = new UploadModel({
        type: this.options.type,
        service_name: this.options.service
      }, {
        userModel: this._userModel,
        configModel: this._configModel
      });
    },
  
    _initViews: function _initViews() {
      this.model.setFresh();
  
      var headerView = new HeaderView({
        el: this.$('.ImportPanel-header'),
        model: this.model,
        userModel: this._userModel,
        fileEnabled: this.options.fileEnabled,
        acceptSync: this.options.acceptSync,
        template: this.options.headerTemplate
      });
      headerView.render();
      this.addView(headerView);
  
      var selected = new SelectedDatasetView({
        el: this.$('.DatasetSelected'),
        userModel: this._userModel,
        model: this.model,
        acceptSync: this.options.acceptSync,
        fileAttrs: this.options.fileAttrs,
        configModel: this._configModel
      });
      selected.render();
      this.addView(selected);
  
      var formView = new FormView({
        el: this.$('.ImportPanel-form'),
        userModel: this._userModel,
        model: this.model,
        template: this.options.formTemplate,
        fileEnabled: this.options.fileEnabled
      });
  
      formView.bind('fileSelected', function () {
        selected.setOptions({
          acceptSync: false,
          fileAttrs: {
            ext: true,
            title: 'name',
            description: {
              content: [{
                name: 'size',
                format: 'size'
              }]
            }
          }
        });
      });
  
      formView.bind('urlSelected', function () {
        selected.setOptions({
          acceptSync: true,
          fileAttrs: {
            ext: false,
            title: '',
            description: ''
          }
        });
      });
  
      formView.bind('urlSubmitted', function () {
        this._finish();
      }.bind(this));
  
      formView.render();
      this.addView(formView);
    },
  
    _finish: function _finish() {
      if (this._createModel.canFinish()) {
        this.model.setPrivacy(this._privacyModel.get('privacy'));
        this.model.setGuessing(this._guessingModel.get('guessing'));
  
        this._createModel.finish();
      }
    },
  
    _initBinds: function _initBinds() {
      this.model.unbind('change:state', this._checkState, this);
      this.model.unbind('change', this._triggerChange, this);
  
      this.model.bind('change:state', this._checkState, this);
      this.model.bind('change', this._triggerChange, this);
    },
  
    _checkState: function _checkState() {
      if (this.model.previous('state') === 'selected') {
        this.model.set({
          type: undefined,
          value: '',
          service_name: '',
          service_item_id: '',
          interval: 0
        });
      }
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-options.js":
  /*!******************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-options.js ***!
    \******************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var ImportDataView = __webpack_require__(/*! ./import-data/import-data-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-data/import-data-view.js");
  var ImportServiceView = __webpack_require__(/*! ./import-service/import-service-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-view.js");
  var ImportArcGISView = __webpack_require__(/*! ./import-arcgis/import-arcgis-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-arcgis/import-arcgis-view.js");
  var ImportTwitterView = __webpack_require__(/*! ./import-twitter/import-twitter-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/import-twitter-view.js");
  
  /**
   * Attributes:
   *
   *  view: import pane class view
   *  enabled: function that takes configModel and returns whether the service is enabled
   *  fallbackClassName: ...
   *  name: local name
   *  title: text for tab link
   *  options:
   *    - service:
   *    - fileExtensions:
   *    - showAvailableFormats:
   *    - acceptSync:
   *    - fileAttrs:
   *
   */
  
  module.exports = {
  
    File: {
      view: ImportDataView,
      enabled: function enabled(config, userModel) {
        return true;
      },
      name: 'file',
      title: 'Data file',
      options: {
        type: 'url',
        fileEnabled: true,
        acceptSync: true
      }
    },
    GDrive: {
      view: ImportServiceView,
      enabled: function enabled(config, userModel) {
        return !!config.get('oauth_gdrive');
      },
      name: 'gdrive',
      title: 'Google Drive',
      options: {
        service: 'gdrive',
        fileExtensions: ['Google SpreadSheet', 'CSV'],
        showAvailableFormats: false,
        acceptSync: true,
        fileAttrs: {
          ext: true,
          title: 'filename',
          description: {
            content: [{
              name: 'size',
              format: 'size',
              key: true
            }]
          }
        }
      }
    },
    Dropbox: {
      view: ImportServiceView,
      enabled: function enabled(config, userModel) {
        return !!config.get('oauth_dropbox');
      },
      name: 'dropbox',
      title: 'Dropbox',
      options: {
        service: 'dropbox',
        fileExtensions: ['CSV', 'XLS'],
        showAvailableFormats: false,
        acceptSync: true,
        fileAttrs: {
          ext: true,
          title: 'filename',
          description: {
            content: [{
              name: 'id',
              format: ''
            }, {
              name: 'size',
              format: 'size',
              key: true
            }],
            separator: '-'
          }
        }
      }
    },
    Box: {
      view: ImportServiceView,
      enabled: function enabled(config, userModel) {
        return !!config.get('oauth_box');
      },
      name: 'box',
      title: 'Box',
      fallback: __webpack_require__(/*! ./fallbacks/import-box-fallback.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/fallbacks/import-box-fallback.tpl"),
      options: {
        service: 'box',
        fileExtensions: ['CSV', 'XLS'],
        showAvailableFormats: false,
        acceptSync: true,
        fileAttrs: {
          ext: true,
          title: 'filename',
          description: {
            content: [{
              name: 'size',
              format: 'size',
              key: true
            }],
            separator: '-'
          }
        }
      }
    },
    Twitter: {
      view: ImportTwitterView,
      enabled: function enabled(config, userModel) {
        return userModel.get('twitter').enabled && !!config.get('datasource_search_twitter');
      },
      fallback: __webpack_require__(/*! ./fallbacks/import-twitter-fallback.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/fallbacks/import-twitter-fallback.tpl"),
      name: 'twitter',
      title: 'Twitter'
    },
    Mailchimp: {
      view: ImportServiceView,
      enabled: function enabled(config, userModel) {
        return userModel.get('mailchimp').enabled && !!config.get('oauth_mailchimp');
      },
      fallback: __webpack_require__(/*! ./fallbacks/import-mailchimp-fallback.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/fallbacks/import-mailchimp-fallback.tpl"),
      name: 'mailchimp',
      title: 'MailChimp',
      options: {
        service: 'mailchimp',
        fileExtensions: [],
        acceptSync: true,
        showAvailableFormats: false,
        headerTemplate: __webpack_require__(/*! ./import-mailchimp/import-data-header-mailchimp.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-mailchimp/import-data-header-mailchimp.tpl"),
        fileAttrs: {
          ext: true,
          title: 'filename',
          description: {
            content: [{
              name: 'member_count',
              format: 'number',
              key: true
            }],
            itemName: 'member',
            separator: ''
          }
        }
      }
    },
    // Instagram: {
    //   view: ImportServiceView,
    //   fallback: require('./fallbacks/import-instagram-fallback.tpl'),
    //   name: 'instagram',
    //   title: 'Instagram',
    //   options: {
    //     service: 'instagram',
    //     fileExtensions: [],
    //     acceptSync: false,
    //     showAvailableFormats: false,
    //     fileAttrs: {
    //       ext: false,
    //       title: 'title'
    //     }
    //   }
    // },
    Arcgis: {
      view: ImportArcGISView,
      enabled: function enabled(config, userModel) {
        return config.get('arcgis_enabled');
      },
      fallback: __webpack_require__(/*! ./fallbacks/import-arcgis-fallback.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/fallbacks/import-arcgis-fallback.tpl"),
      name: 'arcgis',
      title: 'ArcGIS Server&trade;'
    },
    Salesforce: {
      view: ImportDataView,
      enabled: function enabled(config, userModel) {
        return config.get('salesforce_enabled');
      },
      fallback: __webpack_require__(/*! ./fallbacks/import-salesforce-fallback.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/fallbacks/import-salesforce-fallback.tpl"),
      name: 'salesforce',
      title: 'Salesforce'
      // options: {
      //   type: 'service',
      //   service_name: 'salesforce',
      //   acceptSync: true,
      //   formTemplate: require('./import-salesforce/import-data-form-salesforce.tpl'),
      //   headerTemplate: require('./import-salesforce/import-data-header-salesforce.tpl')
      // }
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-selected-dataset-view.js":
  /*!********************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-selected-dataset-view.js ***!
    \********************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var template = __webpack_require__(/*! ./import-selected-dataset.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-selected-dataset.tpl");
  
  /**
   *  Selected dataset
   *
   *  - Displays the result when a dataset is selected, no matter the type.
   *  - It will show available sync options if that import lets it.
   *  - Upgrade link for people who don't have sync permissions.
   *
   */
  
  module.exports = CoreView.extend({
    className: 'DatasetSelected',
  
    _FORMATTERS: {
      'size': Utils.readablizeBytes,
      'number': Utils.formatNumber
    },
  
    options: {
      acceptSync: false,
      fileAttrs: {
        ext: false,
        title: '',
        description: {
          content: [{
            name: 'id',
            format: ''
          }],
          itemName: '',
          separator: ''
        }
      }
    },
  
    events: {
      'click .js-interval-0': '_onIntervalZero',
      'click .js-interval-1': '_onIntervalHour',
      'click .js-interval-2': '_onIntervalDay',
      'click .js-interval-3': '_onIntervalWeek',
      'click .js-interval-4': '_onIntervalMonth'
    },
  
    initialize: function initialize(opts) {
      if (!opts.userModel) throw new TypeError('userModel is required');
      if (!opts.configModel) throw new TypeError('configModel is required');
  
      this._configModel = opts.configModel;
      this._userModel = opts.userModel;
      this._initBinds();
      this._checkVisibility();
    },
  
    render: function render() {
      var title = this.options.fileAttrs.title && this.model.get('value')[this.options.fileAttrs.title] || this.model.get('value');
      var description = this._genDescription();
      var ext = this.options.fileAttrs.ext ? Utils.getFileExtension(title) : '';
  
      if (this.options.fileAttrs.ext) {
        title = title && title.replace('.' + ext, '');
      }
  
      var upgradeUrl = window.upgrade_url;
      var userCanSync = this._userModel.isActionEnabled('sync_tables');
      var customInstall = this._configModel.get('cartodb_com_hosted');
  
      this.$el.html(template({
        title: title,
        description: description,
        ext: ext,
        interval: this.model.get('interval'),
        importCanSync: this.options.acceptSync,
        userCanSync: userCanSync,
        showTrial: this._userModel.canStartTrial(),
        showUpgrade: !userCanSync && !customInstall && upgradeUrl && !this._userModel.isInsideOrg(),
        upgradeUrl: upgradeUrl
      }));
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change:value', this.render, this);
      this.model.bind('change:interval', this.render, this);
      this.model.bind('change:state', this._checkVisibility, this);
    },
  
    _genDescription: function _genDescription() {
      if (this.options.fileAttrs && this.options.fileAttrs.description) {
        var descriptionOpts = this.options.fileAttrs.description;
        var descriptionKeyValue = '';
        var descriptionStr = '';
        var self = this;
  
        if (descriptionOpts.content && descriptionOpts.content.length > 0) {
          _.each(descriptionOpts.content, function (item, i) {
            if (i > 0 && descriptionOpts.separator) {
              descriptionStr += ' ' + descriptionOpts.separator + ' ';
            }
  
            var value = self.model.get('value')[item.name];
            var format = item.format && self._FORMATTERS[item.format];
            descriptionStr += format && format(value) || value;
  
            if (item.key) {
              descriptionKeyValue = item.name;
            }
          });
        }
  
        if (descriptionOpts.itemName && descriptionKeyValue) {
          descriptionStr += ' ' + (descriptionOpts.itemName && _t('components.modals.add-layer.imports.' + descriptionOpts.itemName + '-pluralize', { smart_count: descriptionKeyValue }) || '');
        }
  
        return descriptionStr;
      }
  
      return '';
    },
  
    _onIntervalZero: function _onIntervalZero() {
      this.model.set('interval', 0);
    },
  
    _onIntervalHour: function _onIntervalHour() {
      if (this.options.acceptSync && this._userModel.isActionEnabled('sync_tables')) {
        this.model.set('interval', 3600);
      }
    },
  
    _onIntervalDay: function _onIntervalDay() {
      if (this.options.acceptSync && this._userModel.isActionEnabled('sync_tables')) {
        this.model.set('interval', 86400);
      }
    },
  
    _onIntervalWeek: function _onIntervalWeek() {
      if (this.options.acceptSync && this._userModel.isActionEnabled('sync_tables')) {
        this.model.set('interval', 604800);
      }
    },
  
    _onIntervalMonth: function _onIntervalMonth() {
      if (this.options.acceptSync && this._userModel.isActionEnabled('sync_tables')) {
        this.model.set('interval', 2592000);
      }
    },
  
    setOptions: function setOptions(d) {
      if (d && !_.isEmpty(d)) {
        _.extend(this.options, d);
      }
    },
  
    _checkVisibility: function _checkVisibility() {
      var state = this.model.get('state');
      if (state === 'selected') {
        this.show();
      } else {
        this.hide();
      }
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-header-view.js":
  /*!*********************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-header-view.js ***!
    \*********************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./import-service-header.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-header.tpl");
  
  /**
   *  Service header
   *
   *  - It will change when upload state changes
   *  - Possibility to change state with a header button
   *
   */
  
  module.exports = CoreView.extend({
    events: {
      'click .js-back': '_goToList'
    },
  
    options: {
      title: 'Service',
      showAvailableFormats: false,
      acceptSync: false,
      fileExtensions: [],
      template: ''
    },
  
    initialize: function initialize(opts) {
      if (!opts.userModel) throw new Error('userModel is required');
      this._userModel = opts.userModel;
      this.template = opts.template || template;
      this._initBinds();
    },
  
    render: function render() {
      this.$el.html(this.template({
        items: this.collection.size(),
        service_name: this.model.get('service_name'),
        showAvailableFormats: this.options.showAvailableFormats,
        fileExtensions: this.options.fileExtensions,
        acceptSync: this.options.acceptSync && this._userModel.isActionEnabled('sync_tables'),
        state: this.model.get('state'),
        title: this.options.title
      }));
      this._checkVisibility();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change:state', this.render, this);
    },
  
    _checkVisibility: function _checkVisibility() {
      var state = this.model.get('state');
      this[state !== 'list' ? 'show' : 'hide']();
    },
  
    _goToList: function _goToList() {
      this.model.set('state', 'list');
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-item-description-format.js":
  /*!*********************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-item-description-format.js ***!
    \*********************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  
  /**
   *  Service list item format utils
   *
   *  - Create customized functions for service list items.
   *
   */
  
  module.exports = {
    // Due to the fact that backend data source service
    // returns 0 size when it doesn't know it
    formatSize: function formatSize(s) {
      if (s && s > 0) {
        return Utils.readablizeBytes(s);
      } else {
        return 'Unknown';
      }
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-item-model.js":
  /*!********************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-item-model.js ***!
    \********************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   *  Service item model
   *
   */
  
  module.exports = Backbone.Model.extend({
    defaults: {
      id: '',
      filename: '',
      checksum: '',
      service: '',
      size: '',
      title: ''
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-items-collection.js":
  /*!**************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-items-collection.js ***!
    \**************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var ServiceItem = __webpack_require__(/*! ./import-service-item-model */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-item-model.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   *  Service item model + Service items collection
   *
   *  - It needs a datasource name or it won't work.
   *
   */
  
  module.exports = Backbone.Collection.extend({
  
    _DATASOURCE_NAME: 'dropbox',
  
    model: ServiceItem,
  
    url: function url(method) {
      var version = this._configModel.urlVersion('imports_service');
      var baseUrl = this._configModel.get('base_url');
      return baseUrl + '/api/' + version + '/imports/service/' + this._DATASOURCE_NAME + '/list_files';
    },
  
    initialize: function initialize(coll, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
      if (!opts.datasourceName) throw new Error('datasourceName is required');
      this._configModel = opts.configModel;
      this._DATASOURCE_NAME = opts.datasourceName;
    },
  
    fetch: function fetch() {
      this.trigger('fetch', this);
      return Backbone.Collection.prototype.fetch.apply(this, arguments);
    },
  
    parse: function parse(r) {
      return r.files;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-list-item-view.js":
  /*!************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-list-item-view.js ***!
    \************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var ServiceUtilsFormat = __webpack_require__(/*! ./import-service-item-description-format */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-item-description-format.js");
  var template = __webpack_require__(/*! ./import-service-list-item.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-list-item.tpl");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  /**
   *  Service list item view
   *
   *  - Displays the item info.
   *  - It lets user to select the item for a future import.
   *
   */
  
  module.exports = CoreView.extend({
    options: {
      title: '',
      fileAttrs: {
        ext: false,
        title: 'filename',
        description: 'size',
        itemName: 'file',
        formatDescription: ''
      }
    },
  
    _FORMATTERS: {
      'size': ServiceUtilsFormat.formatSize,
      'number': Utils.formatNumber
    },
  
    className: 'ServiceList-item',
    tagName: 'li',
  
    events: {
      'click .js-choose': '_onSelectItem'
    },
  
    render: function render() {
      var title = this.model.get(this.options.fileAttrs.title);
      var description = this._genDescription();
      var ext = this.options.fileAttrs.ext ? Utils.getFileExtension(title) : '';
  
      if (this.options.fileAttrs.ext) {
        title = title && title.replace('.' + ext, '');
      }
  
      this.$el.html(template({
        name: this.options.title,
        ext: ext,
        title: title,
        description: description
      }));
      return this;
    },
  
    _genDescription: function _genDescription() {
      if (this.options.fileAttrs && this.options.fileAttrs.description) {
        var descriptionOpts = this.options.fileAttrs.description;
        var descriptionKeyValue = '';
        var descriptionStr = '';
        var self = this;
  
        if (descriptionOpts.content && descriptionOpts.content.length > 0) {
          _.each(descriptionOpts.content, function (item, i) {
            if (i > 0 && descriptionOpts.separator) {
              descriptionStr += ' ' + descriptionOpts.separator + ' ';
            }
  
            var value = self.model.get(item.name);
            var format = item.format && self._FORMATTERS[item.format];
            descriptionStr += format && format(value) || value;
  
            if (item.key) {
              descriptionKeyValue = item.name;
            }
          });
        }
  
        if (descriptionOpts.itemName && descriptionKeyValue) {
          descriptionStr += ' ' + (descriptionOpts.itemName && _t('components.modals.add-layer.imports.' + descriptionOpts.itemName + '-pluralize', { smart_count: descriptionKeyValue }) || '');
        }
  
        return descriptionStr;
      }
  
      return '';
    },
  
    _onSelectItem: function _onSelectItem() {
      this.trigger('selected', this.model, this);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-list-view.js":
  /*!*******************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-list-view.js ***!
    \*******************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var ServiceListItemView = __webpack_require__(/*! ./import-service-list-item-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-list-item-view.js");
  var template = __webpack_require__(/*! ./import-service-list.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-list.tpl");
  
  /**
   *  Service list view
   *
   *  - It will display all the items available under
   *  the service and the possibility to chose one of
   *  them.
   *
   */
  
  module.exports = CoreView.extend({
    options: {
      title: 'service',
      fileAttrs: {}
    },
  
    initialize: function initialize() {
      this._initBinds();
      this._checkVisibility();
    },
  
    render: function render() {
      this.clearSubViews();
      var size = this.collection.size();
      this.$el.html(template({
        size: size,
        title: this.options.title,
        pluralize: _t('components.modals.add-layer.imports.item-pluralize', { smart_count: size })
      }));
      if (this.collection.size() > 0) {
        this.collection.each(this._addItem, this);
      }
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.collection.bind('sync', this.render, this);
      this.model.bind('change:state', this._checkVisibility, this);
      this.add_related_model(this.collection);
    },
  
    _addItem: function _addItem(m) {
      var item = new ServiceListItemView({
        model: m,
        title: this.options.title,
        fileAttrs: this.options.fileAttrs
      });
      item.bind('selected', this._onSelectedItem, this);
      this.$('.ServiceList-items').append(item.render().el);
      this.addView(item);
    },
  
    _onSelectedItem: function _onSelectedItem(mdl) {
      this.model.setUpload({
        state: 'selected',
        value: mdl.toJSON(),
        service_item_id: mdl.get('id')
      });
    },
  
    _checkVisibility: function _checkVisibility() {
      var state = this.model.get('state');
      if (state === 'list') {
        this.show();
      } else {
        this.hide();
      }
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-loader-view.js":
  /*!*********************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-loader-view.js ***!
    \*********************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./import-service-loader.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-loader.tpl");
  
  /**
   *  Service loader view
   *
   *  - It will be on charge to make token and oauth petitions
   *
   */
  
  module.exports = CoreView.extend({
    events: {
      'click .js-connect': '_checkToken'
    },
  
    initialize: function initialize(opts) {
      if (!opts.serviceTokenModel) throw new Error('serviceTokenModel provider is required');
      if (!opts.serviceOauthModel) throw new Error('serviceOauthModel is required');
  
      this._serviceTokenModel = opts.serviceTokenModel;
      this._serviceOauthModel = opts.serviceOauthModel;
      this._initBinds();
      this._checkVisibility();
    },
  
    render: function render() {
      this.$el.html(template({
        state: this.model.get('state')
      }));
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change:state', function () {
        this.render();
        this._checkVisibility();
      }, this);
    },
  
    _checkToken: function _checkToken() {
      var self = this;
      this.model.set('state', 'token');
      this._serviceTokenModel.fetch({
        success: function success(r) {
          if (!r.get('oauth_valid')) {
            self._getOauthURL();
          }
        },
        error: function error(e) {
          self._getOauthURL();
        }
      });
    },
  
    _checkVisibility: function _checkVisibility() {
      var state = this.model.get('state');
      if (state !== 'list' && state !== 'selected') {
        this.show();
      } else {
        this.hide();
      }
    },
  
    _getOauthURL: function _getOauthURL() {
      var self = this;
      this.model.set('state', 'oauth');
      this._serviceOauthModel.set({ url: '' }, { silent: true });
      this._serviceOauthModel.fetch({
        error: function error() {
          self.model.set('state', 'error');
        }
      });
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-oauth-model.js":
  /*!*********************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-oauth-model.js ***!
    \*********************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   *  Get oauth url from the service requested
   *
   *  - It needs a datasource name or it won't work.
   *
   *  new ServiceOauthModel({ datasourceName: 'dropbox', configModel: configModel })
   */
  
  module.exports = Backbone.Model.extend({
  
    _DATASOURCE_NAME: 'dropbox',
  
    url: function url(method) {
      var version = this._configModel.urlVersion('imports_service');
      var baseUrl = this._configModel.get('base_url');
      return baseUrl + '/api/' + version + '/imports/service/' + this._DATASOURCE_NAME + '/auth_url';
    },
  
    initialize: function initialize(attrs, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
      if (!opts.datasourceName) throw new Error('datasource_name is required');
      this._configModel = opts.configModel;
      this._DATASOURCE_NAME = opts.datasourceName;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-token-model.js":
  /*!*********************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-token-model.js ***!
    \*********************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   *  Model to check if oAuth token is valid or not
   *
   *  - It needs a datasource name or it won't work.
   *
   *  new ServiceTokenModel({ datasourceName: 'dropbox', configModel: configModel })
   */
  
  module.exports = Backbone.Model.extend({
  
    _DATASOURCE_NAME: 'dropbox',
  
    url: function url(method) {
      var version = this._configModel.urlVersion('imports_service');
      var baseUrl = this._configModel.get('base_url');
      return baseUrl + '/api/' + version + '/imports/service/' + this._DATASOURCE_NAME + '/token_valid';
    },
  
    initialize: function initialize(attrs, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
      if (!opts.datasourceName) throw new Error('datasource_name is required');
      this._configModel = opts.configModel;
      this._DATASOURCE_NAME = opts.datasourceName;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-view.js":
  /*!**************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-view.js ***!
    \**************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var ImportView = __webpack_require__(/*! builder/components/modals/add-layer/content/imports/import-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-view.js");
  var UploadModel = __webpack_require__(/*! builder/data/upload-model */ "./lib/assets/javascripts/builder/data/upload-model.js");
  var ServiceHeaderView = __webpack_require__(/*! ./import-service-header-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-header-view.js");
  var ServiceLoaderView = __webpack_require__(/*! ./import-service-loader-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-loader-view.js");
  var ServiceListView = __webpack_require__(/*! ./import-service-list-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-list-view.js");
  var ServiceSelectedFileView = __webpack_require__(/*! builder/components/modals/add-layer/content/imports/import-selected-dataset-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-selected-dataset-view.js");
  var ServiceTokenModel = __webpack_require__(/*! ./import-service-token-model */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-token-model.js");
  var ServiceOauthModel = __webpack_require__(/*! ./import-service-oauth-model */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-oauth-model.js");
  var ServiceCollection = __webpack_require__(/*! ./import-service-items-collection */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service-items-collection.js");
  var template = __webpack_require__(/*! ./import-service.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-service/import-service.tpl");
  var WINDOW_INTERVAL = 1000; // miliseconds
  
  /**
   *  Import service view
   *
   *  - Use a service import panel
   *  - It will request login to the service
   *  - If it works, a list of available files will appear.
   *  - Once a file is selected, sync options will appear.
   *
   */
  
  module.exports = ImportView.extend({
    _DATASOURCE_NAME: 'dropbox',
  
    className: 'ImportPanel ImportPanelService',
  
    options: {
      service: '', // Name of the service
      showAvailableFormats: false, // If all available format link should appear or not
      fileExtensions: [], // File extensions
      acceptSync: false, // Accept sync this service?
      fileAttrs: { // Attributes or changes for service list or selected file:
        ext: false, // If files should show extension
        title: 'filename', // Title attribute
        description: '<%- size %>', // Description attribute
        formatDescription: 'size', // If any format function should be applied over the description
        headerTemplate: '' // Header template
      }
    },
  
    initialize: function initialize(opts) {
      if (!opts.service) throw new Error('service prodiver is required');
      if (!opts.userModel) throw new Error('userModel is required');
      if (!opts.configModel) throw new Error('configModel is required');
  
      this._userModel = opts.userModel;
      this._configModel = opts.configModel;
      this._DATASOURCE_NAME = this.options.service;
  
      this.model = new UploadModel({
        type: 'service',
        service_name: this._DATASOURCE_NAME
      }, {
        userModel: this._userModel,
        configModel: this._configModel
      });
  
      this._initModels();
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template(this.options));
      this._initViews();
      return this;
    },
  
    _initModels: function _initModels() {
      this._serviceTokenModel = new ServiceTokenModel(null, {
        datasourceName: this._DATASOURCE_NAME,
        configModel: this._configModel
      });
      this._serviceOauthModel = new ServiceOauthModel(null, {
        datasourceName: this._DATASOURCE_NAME,
        configModel: this._configModel
      });
      this.collection = new ServiceCollection(null, {
        datasourceName: this._DATASOURCE_NAME,
        configModel: this._configModel
      });
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change', this._triggerChange, this);
      this.model.bind('change:state', this._checkState, this);
      this._serviceTokenModel.bind('change:oauth_valid', this._onOauthChange, this);
      this._serviceOauthModel.bind('change:url', this._openWindow, this);
      this.add_related_model(this._serviceOauthModel);
      this.add_related_model(this._serviceTokenModel);
    },
  
    _initViews: function _initViews() {
      var header = new ServiceHeaderView({
        el: this.$('.ImportPanel-header'),
        userModel: this._userModel,
        model: this.model,
        collection: this.collection,
        title: this.options.title,
        showAvailableFormats: this.options.showAvailableFormats,
        fileExtensions: this.options.fileExtensions,
        acceptSync: this.options.acceptSync,
        template: this.options.headerTemplate
      });
      header.render();
      this.addView(header);
  
      var loader = new ServiceLoaderView({
        el: this.$('.ServiceLoader'),
        model: this.model,
        serviceTokenModel: this._serviceTokenModel,
        serviceOauthModel: this._serviceOauthModel
      });
      loader.render();
      this.addView(loader);
  
      var list = new ServiceListView({
        el: this.$('.ServiceList'),
        model: this.model,
        collection: this.collection,
        title: this.options.title,
        fileAttrs: this.options.fileAttrs
      });
      list.render();
      this.addView(list);
  
      var selected = new ServiceSelectedFileView({
        el: this.$('.ServiceSelected'),
        userModel: this._userModel,
        model: this.model,
        acceptSync: this.options.acceptSync,
        fileAttrs: this.options.fileAttrs,
        configModel: this._configModel
      });
      selected.render();
      this.addView(selected);
    },
  
    _onOauthChange: function _onOauthChange() {
      if (this._serviceTokenModel.get('oauth_valid')) {
        this._getFiles();
      }
    },
  
    _getFiles: function _getFiles() {
      var self = this;
  
      this.model.set('state', 'retrieving');
  
      this.collection.fetch({
        error: function error() {
          self.model.set('state', 'error');
        },
        success: function success() {
          self.model.set('state', 'list');
        }
      });
    },
  
    _checkState: function _checkState() {
      if (this.model.get('state') === 'list') {
        if (this.collection.size() === 1) {
          var item = this.collection.at(0);
          this.model.setUpload({
            state: 'selected',
            value: item.toJSON(),
            service_item_id: item.get('id')
          });
        }
      }
      if (this.model.get('state') !== 'selected') {
        this.model.set({
          value: '',
          service_item_id: '',
          interval: 0
        });
      }
    },
  
    _openWindow: function _openWindow() {
      var url = this._serviceOauthModel.get('url');
      var self = this;
      var i = window.open(url, null, 'menubar=no,toolbar=no,width=600,height=495');
      var e = window.setInterval(function () {
        if (i && i.closed) {
          self._getFiles();
          clearInterval(e);
        } else if (!i) {
          self.model.set('state', 'error');
          clearInterval(e);
        }
      }, WINDOW_INTERVAL);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/credits-info-view.js":
  /*!************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/credits-info-view.js ***!
    \************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var template = __webpack_require__(/*! ./credits-info.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/credits-info.tpl");
  
  /**
   *  Credits info view
   *
   *  - Percentage of use
   *  - Possible money spent
   *
   */
  
  module.exports = CoreView.extend({
  
    initialize: function initialize(opts) {
      this._userModel = opts.userModel;
      this._initBinds();
    },
  
    render: function render() {
      var twitterData = this._userModel.get('twitter');
      var remaining = twitterData.quota - twitterData.monthly_use;
      var per = Math.min(100, Math.ceil(this.model.get('value') * 100 / remaining));
  
      this.$el.html(template({
        value: this.model.get('value'),
        remaining: remaining,
        per: per,
        hardLimit: twitterData.hard_limit,
        remainingFormatted: Utils.formatNumber(remaining),
        quota: twitterData.quota,
        block_price: twitterData.block_price,
        block_size: Utils.readizableNumber(twitterData.block_size)
      }));
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change', this.render, this);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/credits-usage-view.js":
  /*!*************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/credits-usage-view.js ***!
    \*************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  __webpack_require__(/*! jquery-ui */ "./lib/assets/javascripts/vendor/jquery-ui.js");
  var CreditsInfoView = __webpack_require__(/*! ./credits-info-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/credits-info-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['userModel'];
  
  var DEFAULT_PER_VALUE = 80;
  var MIN_PER_VALUE = 1;
  
  /**
   *  Set max use of credits for Twitter
   *
   *  - Slider range = 1000 credits
   *  - Last step should be infinite if user doesn't
   *    have "soft_limit".
   *
   */
  
  module.exports = CoreView.extend({
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
      this._disabled = opts && opts.disabled ? opts.disabled : false;
  
      this.model = new Backbone.Model();
      this._initBinds();
      this._setModel();
    },
  
    render: function render() {
      this.clearSubViews();
      this._destroySlider();
      this._initViews();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change:value', this._onValueChange, this);
    },
  
    _setModel: function _setModel() {
      var twitterData = this._userModel.get('twitter');
      var max = twitterData.quota - twitterData.monthly_use;
      var min = MIN_PER_VALUE * max / 100; // Just 1% of the quota
      var defaultValue = max * DEFAULT_PER_VALUE / 100;
      var value = max > 0 ? defaultValue : max + 1;
  
      var self = this;
      this.model.set({
        max: twitterData.hard_limit ? max : max + 1,
        min: min,
        step: min,
        value: max > 0 ? value : twitterData.quota,
        disabled: self._disabled || max <= 0
      });
    },
  
    _initViews: function _initViews() {
      this._setModel();
      this.$('.js-slider').slider(_.extend({
        range: 'min',
        orientation: 'horizontal',
        slide: this._onSlideChange.bind(this),
        change: this._onSlideChange.bind(this)
      }, this.model.attributes));
  
      var creditsInfo = new CreditsInfoView({
        el: this.$('.js-info'),
        userModel: this._userModel,
        model: this.model
      });
      creditsInfo.render();
      this.addView(creditsInfo);
    },
  
    _onSlideChange: function _onSlideChange(ev, ui) {
      this.model.set('value', ui.value);
    },
  
    _onValueChange: function _onValueChange() {
      this.trigger('maxCreditsChange', this.getMaxCredits(), this);
    },
  
    getMaxCredits: function getMaxCredits() {
      var twitterData = this._userModel.get('twitter');
      var max = twitterData.quota - twitterData.monthly_use;
      var value = this.model.get('value');
      return value > max ? 0 : value;
    },
  
    _destroySlider: function _destroySlider() {
      if (this.$('.js-slider').data('ui-slider')) {
        this.$('.js-slider').slider('destroy');
      }
    },
  
    clean: function clean() {
      this._destroySlider();
      CoreView.prototype.clean.call(this);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/import-twitter-view.js":
  /*!**************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/import-twitter-view.js ***!
    \**************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  var ImportView = __webpack_require__(/*! builder/components/modals/add-layer/content/imports/import-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-view.js");
  var UploadModel = __webpack_require__(/*! builder/data/upload-model */ "./lib/assets/javascripts/builder/data/upload-model.js");
  var DatesRangePickerView = __webpack_require__(/*! builder/components/date-picker-range/date-picker-range-view */ "./lib/assets/javascripts/builder/components/date-picker-range/date-picker-range-view.js");
  var TwitterCategoriesView = __webpack_require__(/*! ./twitter-categories/twitter-categories-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/twitter-categories/twitter-categories-view.js");
  var CreditsUsageView = __webpack_require__(/*! ./credits-usage-view.js */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/credits-usage-view.js");
  var template = __webpack_require__(/*! ./import-twitter.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/import-twitter.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel', 'userModel'];
  
  /**
   *  Import twitter panel
   *
   *  - It accepts up to 3 categories
   *  - Date range can't be longer than 30 days
   *
   */
  
  module.exports = ImportView.extend({
    options: {
      acceptSync: false,
      type: 'service',
      service: 'twitter_search'
    },
  
    className: 'ImportPanel ImportTwitterPanel',
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this.model = new UploadModel({
        type: this.options.type,
        service_name: this.options.service
      }, {
        userModel: this._userModel,
        configModel: this._configModel
      });
  
      this._initBinds();
    },
  
    _disabledDueLackOfCredentials: function _disabledDueLackOfCredentials() {
      return !this._userModel.hasOwnTwitterCredentials();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template({
        currentGMT: moment().format('Z')
      }));
      this._initViews();
      return this;
    },
  
    _initViews: function _initViews() {
      // Categories
      var categories = this.categories = new TwitterCategoriesView({
        disabled: this._disabledDueLackOfCredentials()
      });
      categories.bind('changeCategory', this._setModel, this);
      this.$('.ImportTwitterPanel-categories').append(categories.render().el);
      this.addView(categories);
  
      // Date picker
      var datepicker = this.datepicker = new DatesRangePickerView({
        className: 'DatePicker DatePicker--withBorder',
        disabled: this._disabledDueLackOfCredentials()
      });
      datepicker.bind('changeDate', this._setModel, this);
      this.$('.js-picker').append(datepicker.render().el);
      this.addView(datepicker);
  
      // Use slider
      var creditsUsage = this.creditsUsage = new CreditsUsageView({
        el: this.$('.CreditsUsage'),
        userModel: this._userModel,
        disabled: this._disabledDueLackOfCredentials()
      });
      creditsUsage.bind('maxCreditsChange', this._setModel, this);
      creditsUsage.render();
      this.addView(creditsUsage);
  
      this._setModel();
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change', this._triggerChange, this);
    },
  
    _getCategories: function _getCategories() {
      var categories = this.categories.getCategories();
      return _.filter(categories, function (c) {
        return c.category && c.terms.length > 0;
      });
    },
  
    _getDates: function _getDates() {
      return this.datepicker.getDates();
    },
  
    _getMaxCredits: function _getMaxCredits() {
      return this.creditsUsage.getMaxCredits();
    },
  
    _setModel: function _setModel() {
      var categories = this._getCategories();
      var dates = this._getDates();
      var maxCredits = this._getMaxCredits();
      var d = {
        categories: categories,
        dates: dates
      };
  
      this.model.setUpload({
        value: d,
        service_item_id: d,
        user_defined_limits: {
          twitter_credits_limit: maxCredits
        }
      });
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/twitter-categories/twitter-categories-collection.js":
  /*!*******************************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/twitter-categories/twitter-categories-collection.js ***!
    \*******************************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var TwitterCategoryModel = __webpack_require__(/*! ./twitter-category-model */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/twitter-categories/twitter-category-model.js");
  
  // Twitter categories collection
  
  module.exports = Backbone.Collection.extend({
    model: TwitterCategoryModel
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/twitter-categories/twitter-categories-view.js":
  /*!*************************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/twitter-categories/twitter-categories-view.js ***!
    \*************************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var TwitterCategoriesCollection = __webpack_require__(/*! ./twitter-categories-collection */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/twitter-categories/twitter-categories-collection.js");
  var TwitterCategoryModel = __webpack_require__(/*! ./twitter-category-model */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/twitter-categories/twitter-category-model.js");
  var TwitterCategoryView = __webpack_require__(/*! ./twitter-category-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/twitter-categories/twitter-category-view.js");
  
  /**
   *  Twitter category list view
   *  - It will generate a collection to store all the
   *    terms added.
   */
  
  module.exports = CoreView.extend({
    _MAX_CATEGORIES: 4,
    _MAX_TERMS: 29,
  
    initialize: function initialize(opts) {
      this._disabled = opts && opts.disabled ? opts.disabled : false;
  
      // Add a first empty model
      var m = this._generateCategory();
      this.collection = new TwitterCategoriesCollection([m]);
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.collection.each(this._addCategory, this);
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.collection.bind('change', this._manageCategories, this);
      this.collection.bind('change', this._onCategoryChange, this);
      this.add_related_model(this.collection);
    },
  
    _manageCategories: function _manageCategories() {
      var collection_size = this.collection.size();
  
      // Check if already created models are completed
      var nonFilled = this.collection.filter(function (m) {
        return m.get('terms').length === 0;
      });
  
      // if so, generate new one
      if (nonFilled.length === 0 && collection_size < this._MAX_CATEGORIES) {
        var categoryModel = this._generateCategory();
        this.collection.add(categoryModel);
        this._addCategory(categoryModel);
        return false;
      }
  
      // else, let's check
      if (nonFilled.length > 0) {
        var mdl = _.first(nonFilled);
        var view = _.find(this._subviews, function (view) {
          return mdl.cid === view.model.cid;
        });
        var pos = view.$el.index();
  
        // Only one item in the collection, do nothing
        if (collection_size === 1) return false;
  
        // If it is the last item but there is no more items, do nothing
        if (pos === collection_size - 1) return false;
  
        // If it is not the last item and there is another non-filled element
        // let's remove that one.
        if (pos !== collection_size - 1 && nonFilled.length > 1) {
          mdl = nonFilled[1];
          view = _.find(this._subviews, function (view) {
            return mdl.cid === view.model.cid;
          });
          this._removeCategory(view);
        }
  
        // Reorder category indexes :(
        this._sortCategoryIndex();
      }
    },
  
    // Set proper index after any category removed
    _sortCategoryIndex: function _sortCategoryIndex() {
      var self = this;
  
      // Hack to set properly category numbers
      this.$('.twitter-category').each(function (i, el) {
        // Get category, removing Category word
        var category = $(el).find('.js-category').text().replace(_t('components.modals.add-layer.imports.twitter.category') + ' ', '');
  
        if (category !== i + 1) {
          // Find model
          var m = self.collection.find(function (m) {
            return m.get('category') === category;
          });
          // Find view
          m.set('category', (i + 1).toString());
        }
      });
    },
  
    _generateCategory: function _generateCategory() {
      return new TwitterCategoryModel({
        disabled: this._disabled,
        terms: [],
        category: (this.collection ? this.collection.size() + 1 : 1).toString()
      });
    },
  
    _addCategory: function _addCategory(m) {
      var category = new TwitterCategoryView({ model: m });
  
      category.bind('submit', this._onCategorySubmit, this);
      category.bind('limit', this._onCategoryLimit, this);
      category.bind('nolimit', this._onCategoryNoLimit, this);
  
      this.$el.append(category.render().el);
  
      this.addView(category);
      this.trigger('addCategory');
    },
  
    _removeCategory: function _removeCategory(v) {
      v.hide();
      v.clean();
      v.model.destroy();
      this.trigger('removeCategory');
    },
  
    _onCategorySubmit: function _onCategorySubmit() {
      this.trigger('submitCategory', this.collection.toJSON(), this);
    },
  
    _onCategoryLimit: function _onCategoryLimit() {
      this.trigger('limitCategory', this.collection.toJSON(), this);
    },
  
    _onCategoryNoLimit: function _onCategoryNoLimit() {
      this.trigger('noLimitCategory', this.collection.toJSON(), this);
    },
  
    _onCategoryChange: function _onCategoryChange() {
      this.trigger('changeCategory', this.collection.toJSON(), this);
    },
  
    getCategories: function getCategories() {
      return this.collection.toJSON();
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/twitter-categories/twitter-category-model.js":
  /*!************************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/twitter-categories/twitter-category-model.js ***!
    \************************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var TERMS_CHARS = 4;
  
  // Twitter category model
  
  module.exports = Backbone.Model.extend({
    _MAX_COUNTER: 1014,
  
    _CHAR_MAP: {
      ' ': 2,
      '-': 2,
      '_': 2,
      '.': 2
    },
  
    defaults: {
      terms: [],
      category: '',
      counter: 1014
    },
  
    initialize: function initialize() {
      this._initBinds();
    },
  
    _initBinds: function _initBinds() {
      this.bind('change:terms', this._setCounter, this);
    },
  
    _setCounter: function _setCounter() {
      var count = this._MAX_COUNTER;
      var self = this;
  
      // Check terms number
      if (this.get('terms').length > 1) {
        count = count - (this.get('terms').length - 1) * TERMS_CHARS;
      }
  
      // Count characters
      _.each(this.get('terms'), function (term) {
        _.each(term, function (c) {
          if (self._CHAR_MAP[c] !== undefined) {
            count = count - self._CHAR_MAP[c];
          } else {
            count--;
          }
        });
      });
  
      // Count never should be less than 0 please!
      this.set('counter', Math.max(0, count));
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/twitter-categories/twitter-category-view.js":
  /*!***********************************************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/twitter-categories/twitter-category-view.js ***!
    \***********************************************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var template = __webpack_require__(/*! ./twitter-category.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-twitter/twitter-categories/twitter-category.tpl");
  
  /**
   *  Twitter category item view
   *  - It just needs a twitter category model
   */
  
  module.exports = CoreView.extend({
    className: 'TwitterCategory',
  
    _MAX_CATEGORIES: 4,
    _MAX_TERMS: 29,
  
    events: {
      'keydown .js-terms': '_onInputChange',
      'keypress .js-terms': '_onInputChange',
      'keyup .js-terms': '_onInputChange'
    },
  
    initialize: function initialize() {
      this._initBinds();
    },
  
    render: function render() {
      this.$el.empty();
      this.$el.append(template({
        disabled: this.model.get('disabled'),
        terms: this.model.get('terms'),
        category: this.model.get('category'),
        counter: this.model.get('counter')
      }));
  
      this.show();
  
      return this;
    },
  
    _initBinds: function _initBinds() {
      _.bindAll(this, '_onInputChange');
      this.model.bind('change:category', this._onCategoryChange, this);
    },
  
    _onCategoryChange: function _onCategoryChange() {
      this.$('.js-category').text(_t('components.modals.add-layer.imports.twitter.category') + ' ' + this.model.get('category'));
    },
  
    _onInputChange: function _onInputChange(e) {
      var value = $(e.target).val();
      var d = {};
  
      if (e.keyCode === 13 /* ENTER */) {
          e.preventDefault();
          this.trigger('submit', this.model, this);
          return false;
        }
  
      this.$('.CDB-IconFont-twitter').toggleClass('is-highlighted', value.length > 0);
  
      // Check if it is possible to add new characters
      // if not, stop the action, unless user is deleting
      // any previous character
      if ((this.model.get('counter') === 0 || this.model.get('terms').length > this._MAX_TERMS) && e.keyCode !== 37 /* left */ && e.keyCode !== 39 /* right */ && e.keyCode !== 8 && value.length > 0) {
        this.killEvent(e);
        this.trigger('limit', this.model, this);
        return false;
      } else {
        this.trigger('nolimit', this.model, this);
      }
  
      // Get valid terms array
      if (!value) {
        value = [];
      } else {
        value = value.split(',');
      }
  
      d['terms'] = value;
  
      this.model.set(d);
    },
  
    show: function show() {
      this.$el.addClass('enabled');
    },
  
    hide: function hide() {
      this.$el.removeClass('enabled');
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-view.js":
  /*!***************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-view.js ***!
    \***************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var UploadModel = __webpack_require__(/*! builder/data/upload-model */ "./lib/assets/javascripts/builder/data/upload-model.js");
  
  /**
   *  Default view for an import item
   *
   *  - It is based in an upload model.
   *  - Will trigger a change when model changes.
   *  - It returns their data if it is requested with a method.
   */
  
  module.exports = CoreView.extend({
  
    initialize: function initialize(opts) {
      if (!opts.userModel) throw new Error('userModel is required');
      if (!opts.configModel) throw new Error('configModel is required');
  
      this._configModel = opts.configModel;
      this._userModel = opts.userModel;
      this.model = new UploadModel(null, {
        configModel: this._configModel,
        userModel: this._userModel
      });
      this._initBinds();
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change', this._triggerChange, this);
    },
  
    _triggerChange: function _triggerChange() {
      this.trigger('change', this.model.toJSON(), this);
    },
  
    getModelData: function getModelData() {
      if (this.model) {
        return this.model.toJSON();
      }
      return {};
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/imports-view.js":
  /*!****************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/imports-view.js ***!
    \****************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var ViewFactory = __webpack_require__(/*! builder/components/view-factory */ "./lib/assets/javascripts/builder/components/view-factory.js");
  var importViewTemplate = __webpack_require__(/*! ./imports.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/imports.tpl");
  var importTabViewTemplate = __webpack_require__(/*! ./import-tab.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-tab.tpl");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  var TabPaneView = __webpack_require__(/*! builder/components/tab-pane/tab-pane-view */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-view.js");
  var TabPaneCollection = __webpack_require__(/*! builder/components/tab-pane/tab-pane-collection */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-collection.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var IMPORT_OPTIONS = __webpack_require__(/*! ./import-options */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/import-options.js");
  var TABS_PER_ROW = 5;
  var DEFAULT_IMPORT = 'file';
  var ROW_WIDTH = 800;
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['createModel', 'userModel', 'configModel', 'privacyModel', 'guessingModel'];
  
  /**
   *  Imports view
   *
   *  Displays all the import options available
   *  through new create dialog.
   *
   *  IMPORTANT!!
   *
   *  If you need to add a new import pane:
   *
   *  - Create the proper class within imports folder and its tests.
   *  - Add necessary info in import_options file.
   *  - Create a check function here if needed, if not will appear
   *    always enabled (for everybody!).
   *
   */
  
  module.exports = CoreView.extend({
    className: 'ImportOptions',
  
    events: {
      'click .js-goNext': '_moveToNextTabs',
      'click .js-goPrev': '_moveToPrevTabs'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this._initModels();
    },
  
    render: function render() {
      this._destroyBinds();
      this.clearSubViews();
      this.$el.empty();
  
      this._generateContent();
      this._generateNavigationTabs();
      this._initBinds();
      this._setOption();
  
      return this;
    },
  
    _initModels: function _initModels() {
      this.model = new Backbone.Model({
        page: 1,
        maxPages: 0
      });
    },
  
    // //////////////////
    // TABS && PANES!  //
    // //////////////////
  
    _generateContent: function _generateContent() {
      var paneItems = [];
  
      _.each(IMPORT_OPTIONS, function (importConfig, i) {
        var obj = {};
        if (!_.isEmpty(importConfig) && importConfig.enabled(this._configModel, this._userModel)) {
          obj = {
            name: importConfig.name,
            selected: importConfig.name === 'file'
          };
  
          obj.createButtonView = function () {
            return ViewFactory.createByTemplate(importTabViewTemplate, {
              title: cdb.core.sanitize.html(importConfig.title || importConfig.name),
              name: importConfig.name
            }, {
              tagName: 'button',
              className: 'TabLink ' + 'js-' + importConfig.name + 'Tab'
            });
          };
  
          var pane;
  
          // Check if import option function exists
          var fn = this['_check' + i + 'Import'];
          var isEnabled;
  
          if (fn) {
            isEnabled = fn.bind(this)();
          }
  
          if ((isEnabled || isEnabled === undefined) && !_.isEmpty(importConfig)) {
            var ImportView = importConfig.view;
            pane = new ImportView(_.extend(importConfig.options || {}, {
              userModel: this._userModel,
              configModel: this._configModel,
              title: importConfig.title,
              createModel: this._createModel,
              privacyModel: this._privacyModel,
              guessingModel: this._guessingModel
            }));
          } else if (importConfig.fallback) {
            pane = ViewFactory.createByTemplate(importConfig.fallback);
          }
  
          if (pane) {
            pane.render();
            pane.bind('change', this._setUploadModel, this);
            obj.createContentView = function () {
              return pane;
            };
          }
  
          paneItems.push(obj);
        }
      }, this);
  
      this._tabPaneCollection = new TabPaneCollection(paneItems);
      this._tabPaneView = new TabPaneView({
        template: importViewTemplate,
        collection: this._tabPaneCollection,
        tabPaneItemOptions: {
          tagName: 'li',
          klassName: 'ImportOptions-tab'
        }
      });
      this.$el.append(this._tabPaneView.render().el);
    },
  
    _generateNavigationTabs: function _generateNavigationTabs() {
      var numTabs = this.$('.ImportOptions-tab').size();
      if (numTabs <= 1) {
        this.$('.AddLayer-tabs').hide();
      }
  
      this.model.set('maxPages', Math.ceil(numTabs / TABS_PER_ROW));
      this._checkNavigationTabs();
      if (this.model.get('maxPages') <= 1) {
        this.$('.ImportOptions-navigation').hide();
      }
    },
  
    _moveToNextTabs: function _moveToNextTabs() {
      var page = this.model.get('page');
      var maxPages = this.model.get('maxPages');
  
      if (page < maxPages) {
        this.model.set('page', page + 1);
      }
    },
  
    _moveToPrevTabs: function _moveToPrevTabs() {
      var page = this.model.get('page');
      if (page > 1) {
        this.model.set('page', page - 1);
      }
    },
  
    _moveNavigationTabs: function _moveNavigationTabs() {
      var page = this.model.get('page');
      var rowWidth = ROW_WIDTH;
  
      this.$('.js-menu').css('margin-left', '-' + rowWidth * (page - 1) + 'px');
      this._checkNavigationTabs();
    },
  
    _checkNavigationTabs: function _checkNavigationTabs() {
      var page = this.model.get('page');
      var maxPages = this.model.get('maxPages');
      this.$('.js-goPrev').toggleClass('is-disabled', page < 2);
      this.$('.js-goNext').toggleClass('is-disabled', page >= maxPages);
    },
  
    _checkGDriveImport: function _checkGDriveImport() {
      if (!this._configModel.get('oauth_gdrive')) {
        this._setFailedTab('gdrive', 'key');
        return false;
      }
      return true;
    },
  
    _checkDropboxImport: function _checkDropboxImport() {
      if (!this._configModel.get('oauth_dropbox')) {
        this._setFailedTab('dropbox', 'key');
        return false;
      }
      return true;
    },
  
    _checkBoxImport: function _checkBoxImport() {
      if (!this._configModel.get('oauth_box')) {
        this._setFailedTab('box', 'key');
        return false;
      }
      return true;
    },
  
    _checkTwitterImport: function _checkTwitterImport() {
      if (!this._configModel.get('datasource_search_twitter')) {
        this._setFailedTab('twitter', 'key');
        return false;
      }
  
      if (!this._userModel.get('twitter').enabled) {
        return false;
      }
  
      if (!this._userModel.canCreateTwitterDataset()) {
        this._setFailedTab('twitter', 'credits');
        return false;
      }
      return true;
    },
  
    _checkInstagramImport: function _checkInstagramImport() {
      if (!this._userModel.featureEnabled('instagram_import')) {
        return false;
      }
      if (!this._configModel.get('oauth_instagram')) {
        this._setFailedTab('instagram', 'key');
        return false;
      }
      return true;
    },
  
    _checkSalesforceImport: function _checkSalesforceImport() {
      // Connector is now disabled for everyone.
      // You might be able to use the following check to determine
      // if user/org has this connector enabled:
      // this._userModel.get('salesforce').enabled
      return false;
    },
  
    _checkMailchimpImport: function _checkMailchimpImport() {
      if (!this._configModel.get('oauth_mailchimp')) {
        this._setFailedTab('mailchimp', 'key');
        return false;
      }
  
      if (!this._userModel.featureEnabled('mailchimp_import')) {
        return false;
      }
      return true;
    },
  
    _setFailedTab: function _setFailedTab(tabName, type) {
      var $tab = this.$('.js-' + tabName + 'Tab');
      $tab.addClass('disabled');
  
      var tooltip = new TipsyTooltipView({
        el: $tab,
        title: function title() {
          return _t('components.modals.add-layer.imports.tab-options-error.' + type, { name: tabName });
        }
      });
      this.addView(tooltip);
    },
  
    _setUploadModel: function _setUploadModel(d) {
      var uploadModel = this._createModel.getUploadModel();
      uploadModel.setFresh(d);
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change:page', this._moveNavigationTabs, this);
      if (this._tabPaneCollection) {
        this._tabPaneCollection.bind('change:selected', this._onTabChange, this);
      }
    },
  
    _destroyBinds: function _destroyBinds() {
      if (this._tabPaneCollection) {
        this._tabPaneCollection.bind('change:selected', null, this);
      }
    },
  
    _setOption: function _setOption() {
      // First option > data file
      var tabPaneModel = _.first(this._tabPaneCollection.where({ name: DEFAULT_IMPORT }));
      if (tabPaneModel) {
        tabPaneModel.set('selected', true);
        this._updateImportOption();
      }
    },
  
    _updateImportOption: function _updateImportOption() {
      this._createModel.setActiveImportPane(this._tabPaneView.getSelectedTabPaneName());
    },
  
    // //////////
    // Events //
    // //////////
  
    _onTabChange: function _onTabChange(tabModel) {
      // When the tab changes we lose all event listeners
      this._tabPaneCollection.each(function (model) {
        if (!model.get('selected')) return;
        var pane = model.attributes.createContentView();
        pane.unbind('change', this._setUploadModel, this);
        pane.bind('change', this._setUploadModel, this);
      }, this);
      this._updateImportOption();
    },
  
    clean: function clean() {
      this._destroyBinds();
      CoreView.prototype.clean.call(this);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/listing-view.js":
  /*!********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/listing-view.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var DatasetsView = __webpack_require__(/*! ./datasets/datasets-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/datasets/datasets-view.js");
  var ImportsView = __webpack_require__(/*! ./imports/imports-view */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/imports/imports-view.js");
  var TabPaneView = __webpack_require__(/*! builder/components/tab-pane/tab-pane-view */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-view.js");
  var TabPaneCollection = __webpack_require__(/*! builder/components/tab-pane/tab-pane-collection */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-collection.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['createModel', 'userModel', 'configModel', 'privacyModel', 'guessingModel'];
  
  /**
   *  Create listing view
   *
   *  It will display all the possibilities to select
   *  any of your current datasets or connect a new dataset.
   *
   */
  module.exports = CoreView.extend({
    className: 'CreateDialog-listing CreateDialog-listing--noPaddingTop',
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this._initBinds();
      this._onChangeListing();
    },
  
    render: function render() {
      this.clearSubViews();
  
      this._initViews();
  
      return this;
    },
  
    _initBinds: function _initBinds() {
      // Bug with binding... do not work with the usual one for some reason :(
      this.listenTo(this._createModel, 'change:listing', this._onChangeListing);
    },
  
    _initViews: function _initViews() {
      var self = this;
      var paneModels = [];
  
      paneModels.push({
        name: 'datasets',
        selected: false,
        createContentView: function createContentView() {
          return new DatasetsView({
            userModel: self._userModel,
            createModel: self._createModel
          });
        }
      });
  
      if (this._userModel.canCreateDatasets()) {
        paneModels.push({
          name: 'import',
          selected: false,
          createContentView: function createContentView() {
            return new ImportsView({
              userModel: self._userModel,
              configModel: self._configModel,
              createModel: self._createModel,
              privacyModel: self._privacyModel,
              guessingModel: self._guessingModel
            });
          }
        });
      }
  
      this._tabPaneCollection = new TabPaneCollection(paneModels);
      var paneTabPaneView = new TabPaneView({
        collection: this._tabPaneCollection
      });
      this.addView(paneTabPaneView);
      this.$el.append(paneTabPaneView.render().el);
    },
  
    _onChangeListing: function _onChangeListing() {
      if (this._tabPaneCollection) {
        var context = this._createModel.get('listing');
        var paneModel = _.first(this._tabPaneCollection.where({ name: context }));
        paneModel.set('selected', true);
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/content/navigation-view.js":
  /*!***********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/content/navigation-view.js ***!
    \***********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var template = __webpack_require__(/*! ./navigation.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/content/navigation.tpl");
  
  var REQUIRED_OPTS = ['configModel', 'createModel', 'userModel', 'routerModel', 'tablesCollection'];
  
  /**
   *  Listing datasets navigation.
   *
   *  - 'Filter by' datasets.
   *  - 'Search' any pattern within dataset collection.
   *
   */
  module.exports = CoreView.extend({
    events: {
      'submit .js-search-form': '_submitSearch',
      'keydown .js-search-form': '_onSearchKeyDown',
      'click .js-search-form': 'killEvent',
      'click .js-search-link': '_onSearchClick',
      'click .js-clean-search': '_onCleanSearchClick',
      'click .js-shared': '_onSharedClick',
      'click .js-library': '_onLibraryClick',
      'click .js-connect': '_onConnectClick',
      'click .js-datasets': '_onDatasetsClick',
      'click .js-create-empty': '_onCreateEmptyClick'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
      this.model = new Backbone.Model();
  
      this._preRender();
      this._initBinds();
    },
  
    // It is necessary to add two static elements because
    // they can't be removed/replaced using render method
    // each time a change (in a model or a collection) happens.
    // This is due to the behaviour of the CSS animations.
    _preRender: function _preRender() {
      var $uInner = $('<div>').addClass('u-inner');
      var $filtersInner = $('<div>').addClass('Filters-inner');
      this.$el.append($uInner.append($filtersInner));
    },
  
    render: function render(m, c) {
      this.clearSubViews();
  
      this.$('.Filters-inner').html(template(_.extend({
        showDatasets: this._createModel.showDatasets(),
        createModelType: this._createModel.get('type'),
        canCreateDataset: this._userModel.canCreateDatasets(),
        listingType: this._createModel.get('listing'),
        isInsideOrg: this._userModel.isInsideOrg(),
        totalShared: this._tablesCollection.getTotalStat('total_shared'),
        selectedItemsCount: this._selectedItems().length,
        hasDataLibrary: this._configModel.dataLibraryEnabled()
      }, this._routerModel.attributes)));
  
      this._animate();
      if (this._routerModel.isSearching()) {
        this._focusSearchInput();
      }
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this.model, 'change:isSearchEnabled', this._onChangeIsSearchEnabled, this);
      this.listenTo(this._createModel, 'change:listing', this.render, this);
      this.listenTo(this._routerModel, 'change', this.render, this);
      this.listenTo(this._tablesCollection, 'sync', this.render, this);
    },
  
    _onChangeIsSearchEnabled: function _onChangeIsSearchEnabled(model, isSearchEnabled) {
      this._enableSearchUI(isSearchEnabled);
  
      if (this._routerModel.isSearching()) {
        this._cleanSearch();
      } else if (isSearchEnabled) {
        this._$searchInput().val('');
        this._focusSearchInput();
      }
    },
  
    _$searchInput: function _$searchInput() {
      return this.$('.js-search-input');
    },
  
    _focusSearchInput: function _focusSearchInput() {
      this._$searchInput().select().focus();
    },
  
    _onSearchKeyDown: function _onSearchKeyDown(e) {
      if (e.keyCode === 27) {
        // ESC
        this.killEvent(e);
        this._cleanSearch();
      }
    },
  
    _selectedItems: function _selectedItems() {
      return this._tablesCollection.where({ selected: true });
    },
  
    _animate: function _animate() {
      this._enableSearchUI(!!this._routerModel.isSearching());
  
      // Check if user doesn't have any table and it is in library section
      // to remove useless shadow
      var inLibrarySection = this._routerModel.get('library');
      var inDatasetsSection = this._createModel.get('listing') === 'datasets';
      var hasDatasets = this._tablesCollection.getTotalStat('total_user_entries') > 0;
      this.$el.toggleClass('no-shadow', inLibrarySection && !hasDatasets && inDatasetsSection);
    },
  
    _enableSearchUI: function _enableSearchUI(enable) {
      this.$('.js-search-field').toggle(enable);
      this.$('.js-links-list').toggleClass('is-hidden', enable);
      this.$('.js-order-list').toggleClass('is-hidden', enable);
    },
  
    _onDatasetsClick: function _onDatasetsClick() {
      this._routerModel.set({
        shared: 'no',
        library: false,
        page: 1
      });
      this._routerModel.trigger('change', this._routerModel);
      this._createModel.set('listing', 'datasets');
    },
  
    _onSharedClick: function _onSharedClick() {
      this._routerModel.set({
        shared: 'only',
        library: false,
        page: 1
      });
      this._routerModel.trigger('change', this._routerModel);
      this._createModel.set('listing', 'datasets');
    },
  
    _onLibraryClick: function _onLibraryClick() {
      this._routerModel.set({
        shared: 'no',
        library: true,
        page: 1
      });
      this._routerModel.trigger('change', this._routerModel);
      this._createModel.set('listing', 'datasets');
    },
  
    _onConnectClick: function _onConnectClick() {
      if (this._userModel.canCreateDatasets()) {
        this._createModel.set('listing', 'import');
      }
    },
  
    _onCreateEmptyClick: function _onCreateEmptyClick() {
      if (this._userModel.canCreateDatasets()) {
        this._createModel.createFromScratch();
      }
    },
  
    // Selection actions
    _onSearchClick: function _onSearchClick(e) {
      this.killEvent(e);
      this.model.set('isSearchEnabled', !this.model.get('isSearchEnabled'));
    },
  
    // Filter actions
    _onCleanSearchClick: function _onCleanSearchClick(e) {
      if (e) {
        e.preventDefault();
      }
      this._cleanSearch();
    },
  
    _cleanSearch: function _cleanSearch() {
      this._routerModel.set({
        q: '',
        tag: '',
        shared: 'no',
        library: this._createModel.showLibrary()
      });
      this.model.set('isSearchEnabled', false);
    },
  
    _submitSearch: function _submitSearch(e) {
      this.killEvent(e);
      var val = cdb.core.sanitize.html(this.$('.js-search-input').val().trim());
      var tag = val.search(':') === 0 ? val.replace(':', '') : '';
      var q = val.search(':') !== 0 ? val : '';
  
      this._routerModel.set({
        page: 1,
        tag: tag,
        q: q,
        shared: 'yes'
      });
  
      this._createModel.set('listing', 'datasets');
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/footer/guessing-toggler-view.js":
  /*!****************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/footer/guessing-toggler-view.js ***!
    \****************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./guessing-toggler.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/footer/guessing-toggler.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['createModel', 'guessingModel', 'configModel', 'userModel'];
  
  /**
  * Manages if upcoming import should guess or not.
   * Expected to be rendered in the footer of a create dialog.
   */
  
  module.exports = CoreView.extend({
  
    events: {
      'click .js-toggle': '_toggle'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this._initBinds();
    },
  
    render: function render() {
      var htmlStr = '';
      if (this._createModel.showGuessingToggler()) {
        var uploadModel = this._createModel.getUploadModel();
        htmlStr = template({
          isGuessingEnabled: this._guessingModel.get('guessing'),
          importState: this._createModel.getImportState(),
          isUploadValid: uploadModel.isValidToUpload(),
          customHosted: this._configModel.get('cartodb_com_hosted'),
          isTwitterDeprecatedForUser: !this._userModel.hasOwnTwitterCredentials()
        });
      }
      this.$el.html(htmlStr);
      return this;
    },
  
    _initBinds: function _initBinds() {
      this._createModel.bind('change', this.render, this);
      this._guessingModel.bind('change', this.render, this);
      this.add_related_model(this._createModel);
    },
  
    _toggle: function _toggle() {
      var value = !this._guessingModel.get('guessing');
      this._guessingModel.set('guessing', value);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/add-layer/footer/privacy-toggler-view.js":
  /*!***************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/add-layer/footer/privacy-toggler-view.js ***!
    \***************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var template = __webpack_require__(/*! ./privacy-toggler.tpl */ "./lib/assets/javascripts/builder/components/modals/add-layer/footer/privacy-toggler.tpl");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var publicPrivacy = 'PUBLIC';
  var privatePrivacy = 'PRIVATE';
  
  var REQUIRED_OPTS = ['createModel', 'privacyModel', 'configModel', 'userModel'];
  
  /**
   *  Change the privacy of the new dataset.
   *  - If the user can't change the privacy, it will refer to the upgrade page
   *   unless app is the "open source" version
   *
   */
  
  module.exports = CoreView.extend({
    events: {
      'click': '_onClick'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
  
      if (this._createModel.showPrivacyToggler()) {
        var canChangePrivacy = this._userModel.canCreatePrivateDatasets();
        var privacy = this._privacyModel.get('privacy');
        var isPublic = privacy === publicPrivacy;
        var nextPrivacy = isPublic ? privatePrivacy : publicPrivacy;
        var icon = isPublic ? 'unlock' : 'lock';
        var upgradeUrl = this._configModel.get('upgrade_url') || window.upgrade_url;
        var canUpgrade = !this._configModel.get('cartodb_com_hosted') && !canChangePrivacy && upgradeUrl;
  
        this.$el.html(template({
          privacy: privacy,
          isDisabled: !canChangePrivacy,
          canUpgrade: canUpgrade,
          nextPrivacy: nextPrivacy,
          upgradeUrl: upgradeUrl,
          icon: icon
        }));
  
        this._initViews();
      }
  
      return this;
    },
  
    _initBinds: function _initBinds() {
      this._privacyModel.bind('change:privacy', this.render, this);
    },
  
    _initViews: function _initViews() {
      // Tooltip
      this.addView(new TipsyTooltipView({
        el: this.$('.js-toggler'),
        html: true,
        title: function title() {
          return $(this).attr('data-title');
        }
      }));
    },
  
    _onClick: function _onClick() {
      if (this._userModel.canCreatePrivateDatasets()) {
        var privacy = this._privacyModel.get('privacy');
        this._privacyModel.set('privacy', privacy === publicPrivacy ? privatePrivacy : publicPrivacy);
      }
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/confirmation/modal-confirmation-view.js":
  /*!**************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/confirmation/modal-confirmation-view.js ***!
    \**************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var renderLoading = __webpack_require__(/*! builder/components/loading/render-loading */ "./lib/assets/javascripts/builder/components/loading/render-loading.js");
  var ENTER_KEY_CODE = 13;
  var REQUIRED_OPTS = ['template', 'runAction', 'modalModel'];
  
  /**
   *  Confirmation modal dialog
   */
  
  module.exports = CoreView.extend({
    className: 'Dialog-content',
  
    events: {
      'click .js-confirm': '_onConfirm',
      'click .js-cancel': '_onCancel'
    },
  
    initialize: function initialize(opts) {
      _.each(REQUIRED_OPTS, function (item) {
        if (!opts[item]) throw new Error(item + ' is required');
        this['_' + item] = opts[item];
      }, this);
  
      if (opts.loadingTitle) {
        this._hasLoading = true;
        this._loadingTitle = opts.loadingTitle;
      }
  
      if (opts.renderOpts) {
        this._hasRenderOpts = true;
        this._renderOpts = opts.renderOpts;
      }
  
      this._onKeyDown = this._onKeyDown.bind(this);
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
  
      var html = this._hasRenderOpts ? this._template(this._renderOpts) : this._template();
      this.$el.html(html);
  
      return this;
    },
  
    _initBinds: function _initBinds() {
      $(document).bind('keydown', this._onKeyDown);
    },
  
    _disableBinds: function _disableBinds() {
      $(document).unbind('keydown', this._onKeyDown);
    },
  
    _onKeyDown: function _onKeyDown(ev) {
      var keyCode = ev.which;
      if (keyCode === ENTER_KEY_CODE) {
        this._onConfirm();
      }
    },
  
    _renderLoadingView: function _renderLoadingView() {
      this.$el.html(renderLoading({
        title: this._loadingTitle
      }));
    },
  
    _$content: function _$content() {
      return this.$('.js-content');
    },
  
    _onConfirm: function _onConfirm() {
      if (this._hasLoading) {
        this._renderLoadingView();
      } else {
        this._modalModel.destroy();
      }
  
      this._runAction();
    },
  
    _onCancel: function _onCancel() {
      this._modalModel.destroy();
    },
  
    clean: function clean() {
      this._disableBinds();
      CoreView.prototype.clean.apply(this);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/creation/modal-creation-view.js":
  /*!******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/creation/modal-creation-view.js ***!
    \******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var renderLoading = __webpack_require__(/*! builder/components/loading/render-loading */ "./lib/assets/javascripts/builder/components/loading/render-loading.js");
  var ErrorView = __webpack_require__(/*! builder/components/error/error-view */ "./lib/assets/javascripts/builder/components/error/error-view.js");
  var REQUIRED_OPTS = ['errorTitle', 'loadingTitle', 'runAction', 'modalModel'];
  
  /**
   *  Remove confirmation dialog
   */
  module.exports = CoreView.extend({
    className: 'Dialog-content',
  
    initialize: function initialize(opts) {
      _.each(REQUIRED_OPTS, function (item) {
        if (!opts[item]) throw new Error(item + ' is required');
        this['_' + item] = opts[item];
      }, this);
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(renderLoading({
        title: this._loadingTitle
      }));
      this._runAction({
        error: this._renderErrorView.bind(this)
      });
      return this;
    },
  
    _renderErrorView: function _renderErrorView(errorMessage) {
      var errorView = new ErrorView({
        title: this._errorTitle,
        desc: errorMessage
      });
      this.$el.html(errorView.render().el);
      this.addView(errorView);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/dataset-metadata/dataset-metadata-view.js":
  /*!****************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/dataset-metadata/dataset-metadata-view.js ***!
    \****************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var VisMetadataModel = __webpack_require__(/*! builder/data/vis-metadata-model */ "./lib/assets/javascripts/builder/data/vis-metadata-model.js");
  var template = __webpack_require__(/*! ./dataset-metadata.tpl */ "./lib/assets/javascripts/builder/components/modals/dataset-metadata/dataset-metadata.tpl");
  var FooterView = __webpack_require__(/*! ./footer/footer-view */ "./lib/assets/javascripts/builder/components/modals/dataset-metadata/footer/footer-view.js");
  var templateError = __webpack_require__(/*! ./dataset-metadata-error.tpl */ "./lib/assets/javascripts/builder/components/modals/dataset-metadata/dataset-metadata-error.tpl");
  var templateLoading = __webpack_require__(/*! builder/components/loading/render-loading */ "./lib/assets/javascripts/builder/components/loading/render-loading.js");
  var FormView = __webpack_require__(/*! ./form/form-view */ "./lib/assets/javascripts/builder/components/modals/dataset-metadata/form/form-view.js");
  var saveMetadata = __webpack_require__(/*! ./save-metadata-dataset */ "./lib/assets/javascripts/builder/components/modals/dataset-metadata/save-metadata-dataset.js");
  var errorParser = __webpack_require__(/*! builder/helpers/error-parser */ "./lib/assets/javascripts/builder/helpers/error-parser.js");
  var Notifier = __webpack_require__(/*! builder/components/notifier/notifier */ "./lib/assets/javascripts/builder/components/notifier/notifier.js");
  var utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  
  module.exports = CoreView.extend({
    events: {
      'click .js-back': '_onBackFromError'
    },
  
    className: 'Dialog-content Dialog-content--expanded',
  
    initialize: function initialize(opts) {
      if (!opts.modalModel) throw new TypeError('modalModel is required');
      if (!opts.visDefinitionModel) throw new TypeError('visDefinitionModel is required');
      if (!opts.configModel) throw new TypeError('configModel is required');
      if (opts.isLocked === undefined) throw new TypeError('isLocked is required');
  
      this._modalModel = opts.modalModel;
      this._visDefinitionModel = opts.visDefinitionModel;
      this._configModel = opts.configModel;
      this._isLocked = opts.isLocked;
  
      this._visMetadataModel = new VisMetadataModel({
        name: this._visDefinitionModel.get('name'),
        description: this._visDefinitionModel.get('description'),
        license: this._visDefinitionModel.get('license'),
        source: this._visDefinitionModel.get('source'),
        attributions: this._visDefinitionModel.get('attributions'),
        tags: this._visDefinitionModel.get('tags')
      });
  
      this._stateModel = new Backbone.Model({
        status: 'show'
      });
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
  
      if (this._hasError()) {
        this._renderError();
      } else if (this._isLoading()) {
        this._renderLoading();
      } else {
        this.$el.html(template());
        this._initViews();
      }
      return this;
    },
  
    _initViews: function _initViews() {
      var formView = new FormView({
        visDefinitionModel: this._visDefinitionModel,
        visMetadataModel: this._visMetadataModel,
        configModel: this._configModel,
        isLocked: this._isLocked
      });
  
      this.$('.js-content').append(formView.render().el);
      this.addView(formView);
  
      var footerView = new FooterView({
        visMetadataModel: this._visMetadataModel,
        onSaveAction: this._onSave.bind(this),
        onCloseAction: this._onClose.bind(this)
      });
  
      this.$('.js-footer').append(footerView.render().el);
      this.addView(footerView);
    },
  
    _renderError: function _renderError() {
      var error = this._stateModel.get('error');
      this.$el.html(templateError({
        error: _t('components.modals.dataset-metadata.error.subtitle', { error: error })
      }));
    },
  
    _renderLoading: function _renderLoading() {
      this.$el.html(templateLoading({
        title: _t('components.modals.dataset-metadata.loading')
      }));
    },
  
    _initBinds: function _initBinds() {
      this._stateModel.on('change:status', this.render, this);
      this.add_related_model(this._stateModel);
    },
  
    _hasError: function _hasError() {
      return this._stateModel.get('status') === 'error';
    },
  
    _isLoading: function _isLoading() {
      return this._stateModel.get('status') === 'loading';
    },
  
    _onSave: function _onSave() {
      this._stateModel.set({ status: 'loading' });
  
      saveMetadata({
        onSuccess: this._onSuccessSave.bind(this),
        onError: this._onErrorSave.bind(this),
        visDefinitionModel: this._visDefinitionModel,
        name: this._getMetadataName(),
        description: this._getMetadataDescription(),
        tags: this._getMetadataTags(),
        source: this._visMetadataModel.get('source'),
        attributions: this._visMetadataModel.get('attributions'),
        license: this._visMetadataModel.get('license')
      });
    },
  
    _onSuccessSave: function _onSuccessSave() {
      var self = this;
      Notifier.addNotification({
        status: 'success',
        info: _t('components.modals.dataset-metadata.success', {
          name: self._getMetadataName()
        }),
        closable: true,
        delay: Notifier.DEFAULT_DELAY
      });
  
      this._modalModel.destroy();
    },
  
    _onClose: function _onClose() {
      this._modalModel.destroy();
    },
  
    _onErrorSave: function _onErrorSave(e) {
      this._stateModel.set({
        status: 'error',
        error: errorParser(e)
      });
    },
  
    _onBackFromError: function _onBackFromError() {
      this._stateModel.set({ status: 'show' });
    },
  
    _getMetadataName: function _getMetadataName() {
      return utils.sanitizeHtml(this._visMetadataModel.get('name'));
    },
  
    _getMetadataDescription: function _getMetadataDescription() {
      return utils.sanitizeHtml(this._visMetadataModel.get('description'));
    },
  
    _getMetadataTags: function _getMetadataTags() {
      return _.map(this._visMetadataModel.get('tags'), function (tag) {
        return utils.sanitizeHtml(tag);
      });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/dataset-metadata/footer/footer-view.js":
  /*!*************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/dataset-metadata/footer/footer-view.js ***!
    \*************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./footer.tpl */ "./lib/assets/javascripts/builder/components/modals/dataset-metadata/footer/footer.tpl");
  
  module.exports = CoreView.extend({
  
    tagName: 'ul',
    className: 'Modal-listActions u-flex u-alignCenter ',
  
    events: {
      'click .js-save': '_save',
      'click .js-close': '_close'
    },
  
    initialize: function initialize(opts) {
      if (!opts.visMetadataModel) throw new Error('visMetadataModel is required');
      if (!opts.onSaveAction) throw new Error('onSaveAction is required');
  
      this._visMetadataModel = opts.visMetadataModel;
      this._onSaveAction = opts.onSaveAction;
      this._onCloseAction = opts.onCloseAction;
      this._initBinds();
    },
  
    _initBinds: function _initBinds() {
      this._visMetadataModel.on('change', this.render, this);
    },
  
    render: function render() {
      this.$el.html(template({
        canFinish: this._visMetadataModel.isValid()
      }));
      return this;
    },
  
    _save: function _save() {
      this._visMetadataModel.isValid() && this._onSaveAction();
    },
  
    _close: function _close() {
      this._onCloseAction && this._onCloseAction();
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/dataset-metadata/form/form-view.js":
  /*!*********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/dataset-metadata/form/form-view.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var templateForm = __webpack_require__(/*! ./form.tpl */ "./lib/assets/javascripts/builder/components/modals/dataset-metadata/form/form.tpl");
  __webpack_require__(/*! builder/components/form-components/index */ "./lib/assets/javascripts/builder/components/form-components/index.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  var utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  
  var REQUIRED_OPTS = ['visDefinitionModel', 'visMetadataModel', 'configModel'];
  
  module.exports = CoreView.extend({
    className: 'Metadata-form',
  
    initialize: function initialize(opts) {
      _.each(REQUIRED_OPTS, function (item) {
        if (!opts[item]) throw new Error(item + ' is required');
        this['_' + item] = opts[item];
      }, this);
  
      if (opts.isLocked === undefined) throw new TypeError('isLocked is required');
      this._isLocked = opts.isLocked;
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(templateForm());
      this._initViews();
      return this;
    },
  
    _initViews: function _initViews() {
      this._addNameView();
      this._addDescriptionView();
      this._addSourceView();
      this._addAttributionView();
      this._addLicenseView();
      this._addTagsView();
      this._addTooltip();
    },
  
    _addInputView: function _addInputView(key, view, placeholder, container, disabled) {
      var obj = '_' + view;
      var $view = new Backbone.Form.editors.Text({
        key: key,
        model: this._visMetadataModel,
        schema: {
          options: this._visDefinitionModel.get(key),
          editorAttrs: {
            placeholder: placeholder,
            disabled: disabled || false
          }
        }
      });
      $view.on('change', this._commitView, this);
      this[obj] = $view;
      container.append($view.render().$el);
    },
  
    _addNameView: function _addNameView() {
      this._addInputView('name', 'nameInput', _t('components.modals.dataset-metadata.form.name-placeholder'), this.$('.js-name-field'), this._isLocked);
    },
  
    _addSourceView: function _addSourceView() {
      this._addInputView('source', 'sourceInput', _t('components.modals.dataset-metadata.form.source-placeholder'), this.$('.js-source-field'));
    },
  
    _addAttributionView: function _addAttributionView() {
      this._addInputView('attributions', 'attributionInput', _t('components.modals.dataset-metadata.form.attributions-placeholder'), this.$('.js-attributions-field'));
    },
  
    _buildLicenseOptions: function _buildLicenseOptions() {
      var items = this._configModel.get('licenses');
      var emptyOption = [{
        id: '',
        name: '-'
      }];
      return _.chain(emptyOption.concat(items)).compact().map(function (d) {
        return {
          val: d.id,
          label: d.name
        };
      }).value();
    },
  
    _addLicenseView: function _addLicenseView() {
      var options = this._buildLicenseOptions();
  
      this._selectView = new Backbone.Form.editors.Select({
        className: 'u-flex u-alignCenter',
        key: 'license',
        schema: {
          options: options
        },
        model: this._visMetadataModel,
        showSearch: false
      });
  
      this._selectView.on('change', this._commitView, this);
      this._selectView.setValue(this._visMetadataModel.get('license') || 0);
      this.$('.js-license-field').append(this._selectView.render().$el);
    },
  
    _addDescriptionView: function _addDescriptionView() {
      this._descriptionView = new Backbone.Form.editors.TextArea({
        className: 'CDB-Textarea Metadata-textarea',
        key: 'description',
        model: this._visMetadataModel,
        schema: {
          options: this._visDefinitionModel.get('description'),
          editorAttrs: {
            placeholder: _t('components.modals.dataset-metadata.form.description-placeholder')
          }
        }
      });
  
      this._descriptionView.on('change', this._commitView, this);
  
      this.$('.js-description-field').append(this._descriptionView.render().$el);
    },
  
    _addTagsView: function _addTagsView() {
      this._taglistView = new Backbone.Form.editors.Taglist({
        key: 'tags',
        model: this._visMetadataModel,
        schema: {
          options: {
            tags: this._visDefinitionModel.get('tags') || []
          }
        }
      });
  
      this._taglistView.on('change', this._commitView, this);
  
      this.$('.js-tags-field').append(this._taglistView.render().$el);
      this.addView(this._taglistView);
    },
  
    _addTooltip: function _addTooltip() {
      var _title = this.$('.js-markdown').data('tooltip');
      this._removeTooltip();
  
      this._tooltip = new TipsyTooltipView({
        el: this.$('.js-markdown'),
        html: true,
        title: function title() {
          return _title;
        }
      });
    },
  
    _commitView: function _commitView(view) {
      view.commit();
      // Commit moves values from form to model. We need to override model value after commit()
      if (view.model.changed.hasOwnProperty('name')) {
        this._sanitizeName(view.model.get('name'));
      }
    },
  
    _sanitizeName: function _sanitizeName(name) {
      this._visMetadataModel.set('name', utils.sanitizeHtml(name));
    },
  
    _removeTooltip: function _removeTooltip() {
      if (this._tooltip) {
        this._tooltip.clean();
      }
    },
  
    _removeBinds: function _removeBinds() {
      this._nameView && this._nameView.off('change', this._commitView, this);
      this._descriptionView && this._descriptionView.off('change', this._commitView, this);
      this._taglistView && this._taglistView.off('change', this._commitView, this);
      this._sourceInput && this._sourceInput.off('change', this._commitView, this);
      this._attributionView && this._attributionView.off('change', this._commitView, this);
      this._selectView && this._selectView.off('change', this._commitView, this);
    },
  
    clean: function clean() {
      this._removeBinds();
      CoreView.prototype.clean.call(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/dataset-metadata/save-metadata-dataset.js":
  /*!****************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/dataset-metadata/save-metadata-dataset.js ***!
    \****************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var TITLE_SUFIX = __webpack_require__(/*! builder/components/modals/visualization-title-suffix-metadata */ "./lib/assets/javascripts/builder/components/modals/visualization-title-suffix-metadata.js");
  
  module.exports = function (opts) {
    if (!opts.visDefinitionModel) throw new Error('visDefinitionModel is required');
    if (!opts.name) throw new Error('name is required');
  
    var visDefinitionModel = opts.visDefinitionModel;
    var successCallback = opts.onSuccess;
    var errorCallback = opts.onError;
    var name = opts.name;
    var description = opts.description;
    var tags = opts.tags;
    var source = opts.source;
    var license = opts.license;
    var attributions = opts.attributions;
  
    var oldName = visDefinitionModel.get('name');
  
    visDefinitionModel.save({
      name: name,
      description: description,
      tags: tags,
      source: source,
      license: license,
      attributions: attributions
    }, {
      wait: true,
      success: function success(mdl, attrs) {
        document.title = name + TITLE_SUFIX;
        successCallback && successCallback();
      },
      error: function error(mdl, e) {
        document.title = oldName + TITLE_SUFIX;
        errorCallback && errorCallback(e);
      }
    });
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/export-data/modal-export-data-format-view.js":
  /*!*******************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/export-data/modal-export-data-format-view.js ***!
    \*******************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./modal-export-data-format.tpl */ "./lib/assets/javascripts/builder/components/modals/export-data/modal-export-data-format.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['format', 'isDisabled', 'isChecked'];
  
  module.exports = CoreView.extend({
    tagName: 'li',
    className: 'Modal-listFormItem',
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this._initViews();
      return this;
    },
  
    _initViews: function _initViews() {
      this.$el.html(template({
        format: this._format,
        isDisabled: this._isDisabled,
        isChecked: this._isChecked
      }));
  
      this.$el.toggleClass('is-disabled', this._isDisabled);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/export-data/modal-export-data-view.js":
  /*!************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/export-data/modal-export-data-view.js ***!
    \************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var renderLoading = __webpack_require__(/*! builder/components/loading/render-loading */ "./lib/assets/javascripts/builder/components/loading/render-loading.js");
  var ErrorView = __webpack_require__(/*! builder/components/error/error-view */ "./lib/assets/javascripts/builder/components/error/error-view.js");
  var template = __webpack_require__(/*! ./modal-export-data.tpl */ "./lib/assets/javascripts/builder/components/modals/export-data/modal-export-data.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var MetricsTracker = __webpack_require__(/*! builder/components/metrics/metrics-tracker */ "./lib/assets/javascripts/builder/components/metrics/metrics-tracker.js");
  var MetricsTypes = __webpack_require__(/*! builder/components/metrics/metrics-types */ "./lib/assets/javascripts/builder/components/metrics/metrics-types.js");
  
  var FormatView = __webpack_require__(/*! ./modal-export-data-format-view */ "./lib/assets/javascripts/builder/components/modals/export-data/modal-export-data-format-view.js");
  
  var MAX_SQL_GET_LENGTH = 1000;
  var CSV_FILTER = 'SELECT * FROM (%%sql%%) as subq ';
  var FORMATS = [{
    format: 'csv',
    fetcher: 'fetchCSV',
    geomRequired: false
  }, {
    format: 'shp',
    fetcher: 'fetch',
    geomRequired: true
  }, {
    format: 'kml',
    fetcher: 'fetch',
    geomRequired: true
  }, {
    format: 'geojson',
    label: 'geo json',
    fetcher: 'fetch',
    geomRequired: true
  }, {
    format: 'svg',
    fetcher: 'fetchSVG',
    geomRequired: true
  }, {
    format: 'gpkg',
    fetcher: 'fetch',
    geomRequired: true
  }];
  
  var REQUIRED_OPTS = ['configModel', 'queryGeometryModel', 'querySchemaModel', 'canHideColumns', 'modalModel', 'fromView'];
  
  module.exports = CoreView.extend({
    className: 'Dialog-content',
  
    events: {
      'click .js-confirm': '_onConfirm',
      'click .js-cancel': '_close'
    },
  
    options: {
      autoClose: true
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
      this._layerModel = opts.layerModel;
      this._filename = opts.filename;
  
      this._initBinds();
  
      if (this._queryGeometryModel.get('status') === 'unfetched') {
        this._queryGeometryModel.fetch();
      }
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
  
      if (this._queryGeometryModel.get('status') === 'fetched' || this._queryGeometryModel.get('status') === 'unavailable') {
        this._renderFormats();
      } else {
        this._renderLoadingContent(_t('components.modals.export-data.loading.geometry'));
      }
  
      return this;
    },
  
    _renderFormats: function _renderFormats() {
      var geometry = this._queryGeometryModel.get('simple_geom');
      var isGeoreferenced = !!geometry;
  
      this.$el.html(template({
        isGeoreferenced: isGeoreferenced,
        url: this._configModel.getSqlApiUrl()
      }));
  
      var isChecked = true;
  
      _.each(FORMATS, function (format) {
        var isDisabled = isGeoreferenced === false && format.geomRequired === true;
        if (isGeoreferenced === true && format.geomRestricted != null && !isDisabled) {
          isDisabled = !_.contains(format.geomRestricted, geometry);
        }
  
        this._renderFormat(format, isDisabled, !isDisabled && isChecked);
  
        if (!isDisabled) {
          isChecked = false;
        }
      }, this);
    },
  
    _renderFormat: function _renderFormat(format, isDisabled, isChecked) {
      var view = new FormatView({
        format: format,
        isDisabled: isDisabled,
        isChecked: isChecked
      });
  
      this.$('.js-formats').append(view.render().el);
      this.addView(view);
    },
  
    _initBinds: function _initBinds() {
      this._queryGeometryModel.bind('change:status', function () {
        if (this._queryGeometryModel.get('status') !== 'unavailable') {
          this.render();
        } else {
          this.showError(_t('components.modals.export-data.error.geometry-error'));
        }
      }, this);
      this.add_related_model(this._queryGeometryModel);
    },
  
    /**
     * search a format based on its name in the format array
     * @param  {string} format Format name
     * @return {Object}
     */
    _getFormat: function _getFormat(format) {
      for (var n in FORMATS) {
        if (FORMATS[n].format === format) {
          return FORMATS[n];
        }
      }
    },
  
    _onConfirm: function _onConfirm() {
      this._form = this.$('.js-form');
      var formatName = $('.js-format[name=format]:checked', this._form).data('format');
      var format = this._getFormat(formatName);
  
      if (this._layerModel) {
        MetricsTracker.track(MetricsTypes.DOWNLOADED_LAYER, {
          format: formatName,
          layer_id: this._layerModel.get('id'),
          source: this._layerModel.get('source'),
          visible: this._layerModel.get('visible'),
          table_name: this._layerModel.get('table_name'),
          from_view: this._fromView
        });
      }
  
      this[format.fetcher](formatName);
    },
  
    /**
     * Create a dictionary with the options shared between all the methods
     * @return {Object}
     */
    getBaseOptions: function getBaseOptions() {
      return {
        filename: this._filename,
        apiKey: this._configModel.get('api_key')
      };
    },
  
    /**
     * Returns a specific sql filtered by the_geom, used on CSV exports
     * @return {string}
     */
    getGeomFilteredSql: function getGeomFilteredSql() {
      var sql = this._queryGeometryModel.get('query');
      var geom = this._queryGeometryModel.get('simple_geom');
  
      // if we have "the_geom" in our current schema, we apply a custom sql
      if (geom) {
        return CSV_FILTER.replace(/%%sql%%/g, sql);
      }
      // Otherwise, we apply regular sql
      return sql;
    },
  
    /**
     * Populates the hidden form with the format related values and submits them to get the file
     * @param  {Object} options Base options
     * @param  {String} sql Sql of the document to be retrieved
     */
    _fetch: function _fetch(options, sql) {
      this.$('.js-format').val(options.format);
      this.$('.js-q').val(sql);
      this.$('.js-filename').val(options.filename);
      this.$('.js-apiKey').val(options.apiKey);
  
      var skipFields = ['the_geom_webmercator'];
  
      if (options.format !== 'csv') {
        skipFields.push('the_geom');
      }
  
      // We remove the center column only if there's a time buffer analysis on this layer
      // and not a deprecated SQL function analysis. Time buffer always adds this column, but
      // a SQL analysis might add arbitrary columns.
      if (this._canHideColumns) {
        var columnNames = this._querySchemaModel.getColumnNames();
        // Skip column center if it's of type geometry
        if (columnNames.indexOf('center') !== -1 && this._querySchemaModel.getColumnType('center') === 'geometry') {
          skipFields.push('center');
        }
      }
  
      this.$('.js-skipfields').val(skipFields.join(','));
  
      // TODO: track metrics
  
      // check if the sql is big or not, and send the request as a verb or other. This is a HACK.
      if (sql.length < MAX_SQL_GET_LENGTH) {
        var location = this.$('.js-form').attr('action') + '?' + this.$('.js-form').serialize();
        this._fetchGET(location);
      } else {
        // I can't find a way of making the iframe trigger load event when its get a form posted,
        // so we need to leave like it was until
        this.submit();
      }
  
      this.$('.js-skipfields').attr('disabled', 'disabled');
  
      if (this.options.autoClose) {
        this._close();
      } else {
        this._renderLoadingContent(_t('components.modals.export-data.loading.preparing'));
      }
    },
  
    showError: function showError(errorMessage) {
      var errorView = new ErrorView({
        title: _t('hello'),
        desc: errorMessage
      });
      this.$el.html(errorView.render().el);
      this.addView(errorView);
    },
  
    _fetchGET: function _fetchGET(url) {
      function getError(content) {
        // sql api returns a json when it fails
        // but if the browser is running some plugin that
        // formats it, the window content is the html
        // so search for the word "error"
        var error = null;
        try {
          var json = JSON.parse(content);
          error = json.error[0];
        } catch (e) {
          if (content && content.indexOf('error') !== -1) {
            error = _t('components.modals.export-data.error.unknown');
          }
        }
        return error;
      }
  
      var self = this;
      var checkInterval;
  
      var w = window.open(url);
      w.onload = function () {
        clearInterval(checkInterval);
        var error = getError(w.document.body.textContent);
        if (error) {
          self.showError(error);
        } else {
          self._close();
        }
        w.close();
      };
      window.focus();
      checkInterval = setInterval(function check() {
        // safari needs to check the body because it never
        // calls onload
        if (w.closed || w.document && w.document.body.textContent.length === 0) {
          self._close();
          clearInterval(checkInterval);
        }
      }, 100);
    },
  
    /**
     * Base fetch, for the formats that don't require special threatment
     * @param  {String} formatName
     */
    fetch: function fetch(formatName) {
      var options = this.getBaseOptions();
      options.format = formatName;
      var sql = this._queryGeometryModel.get('query');
      this._fetch(options, sql);
    },
  
    /**
     * Gets the options needed for csv format and fetch the document
     * @param  {String} formatName
     */
    fetchCSV: function fetchCSV() {
      var options = this.getBaseOptions();
      options.format = 'csv';
      var sql = this.getGeomFilteredSql();
      this.$('.js-skipfields').removeAttr('disabled');
      this._fetch(options, sql);
    },
    /**
     * Gets the options needed for svg format and fetch the document
     * @param  {String} formatName
     */
    fetchSVG: function fetchSVG() {
      this.fetch('svg');
    },
  
    /**
     * Submits the form. This method is separated to ease the testing
     */
    submit: function submit() {
      this.$('.js-form').submit();
    },
  
    _renderLoadingContent: function _renderLoadingContent(title) {
      this.$el.html(renderLoading({
        title: title
      }));
    },
  
    _close: function _close() {
      this._modalModel.destroy();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/map-metadata/footer/footer-view.js":
  /*!*********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/map-metadata/footer/footer-view.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./footer.tpl */ "./lib/assets/javascripts/builder/components/modals/map-metadata/footer/footer.tpl");
  
  module.exports = CoreView.extend({
  
    tagName: 'ul',
    className: 'Modal-listActions u-flex u-alignCenter ',
  
    events: {
      'click .js-save': '_save',
      'click .js-close': '_close'
    },
  
    initialize: function initialize(opts) {
      if (!opts.visMetadataModel) throw new Error('visMetadataModel is required');
      if (!opts.onSaveAction) throw new Error('onSaveAction is required');
  
      this._visMetadataModel = opts.visMetadataModel;
      this._onSaveAction = opts.onSaveAction;
      this._onCloseAction = opts.onCloseAction;
      this._initBinds();
    },
  
    _initBinds: function _initBinds() {
      this._visMetadataModel.on('change', this.render, this);
    },
  
    render: function render() {
      this.$el.html(template({
        canFinish: this._visMetadataModel.isValid()
      }));
      return this;
    },
  
    _save: function _save() {
      this._visMetadataModel.isValid() && this._onSaveAction();
    },
  
    _close: function _close() {
      this._onCloseAction && this._onCloseAction();
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/map-metadata/form/form-view.js":
  /*!*****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/map-metadata/form/form-view.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var templateForm = __webpack_require__(/*! ./form.tpl */ "./lib/assets/javascripts/builder/components/modals/map-metadata/form/form.tpl");
  __webpack_require__(/*! builder/components/form-components/index */ "./lib/assets/javascripts/builder/components/form-components/index.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  var utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  
  var REQUIRED_OPTS = ['visDefinitionModel', 'visMetadataModel'];
  
  module.exports = CoreView.extend({
    className: 'Metadata-form',
  
    initialize: function initialize(opts) {
      _.each(REQUIRED_OPTS, function (item) {
        if (!opts[item]) throw new Error(item + ' is required');
        this['_' + item] = opts[item];
      }, this);
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(templateForm());
      this._initViews();
      return this;
    },
  
    _initViews: function _initViews() {
      this._addInputView();
      this._addTextareaView();
      this._addTagsView();
      this._addTooltip();
    },
  
    _addInputView: function _addInputView() {
      this._inputView = new Backbone.Form.editors.Text({
        key: 'name',
        model: this._visMetadataModel,
        schema: {
          options: this._visDefinitionModel.get('name'),
          editorAttrs: {
            placeholder: _t('components.modals.maps-metadata.form.name-placeholder')
          }
        }
      });
      this._inputView.on('change', this._commitView, this);
  
      this.$('.js-name-field').append(this._inputView.render().$el);
    },
  
    _addTextareaView: function _addTextareaView() {
      this._textareaView = new Backbone.Form.editors.TextArea({
        className: 'CDB-Textarea Metadata-textarea',
        key: 'description',
        model: this._visMetadataModel,
        schema: {
          options: this._visDefinitionModel.get('description'),
          editorAttrs: {
            placeholder: _t('components.modals.maps-metadata.form.description-placeholder')
          }
        }
      });
  
      this._textareaView.on('change', this._commitView, this);
  
      this.$('.js-description-field').append(this._textareaView.render().$el);
    },
  
    _addTagsView: function _addTagsView() {
      this._taglistView = new Backbone.Form.editors.Taglist({
        key: 'tags',
        model: this._visMetadataModel,
        schema: {
          options: {
            tags: this._visDefinitionModel.get('tags') || []
          }
        }
      });
  
      this._taglistView.on('change', this._commitView, this);
  
      this.$('.js-tags-field').append(this._taglistView.render().$el);
      this.addView(this._taglistView);
    },
  
    _addTooltip: function _addTooltip() {
      var _title = this.$('.js-markdown').data('tooltip');
      this._removeTooltip();
  
      this._tooltip = new TipsyTooltipView({
        el: this.$('.js-markdown'),
        html: true,
        title: function title() {
          return _title;
        }
      });
    },
  
    _commitView: function _commitView(view) {
      view.commit();
      // Commit moves values from form to model. We need to override model value after commit()
      if (view.model.changed.hasOwnProperty('name')) {
        this._sanitizeName(view.model.get('name'));
      }
    },
  
    _sanitizeName: function _sanitizeName(name) {
      this._visMetadataModel.set('name', utils.sanitizeHtml(name));
    },
  
    _removeTooltip: function _removeTooltip() {
      if (this._tooltip) {
        this._tooltip.clean();
      }
    },
  
    _removeBinds: function _removeBinds() {
      this._inputView && this._inputView.off('change', this._commitView, this);
      this._textareaView && this._textareaView.off('change', this._commitView, this);
      this._taglistView && this._taglistView.off('change', this._commitView, this);
    },
  
    clean: function clean() {
      this._removeBinds();
      CoreView.prototype.clean.call(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/map-metadata/map-metadata-view.js":
  /*!********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/map-metadata/map-metadata-view.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var VisMetadataModel = __webpack_require__(/*! builder/data/vis-metadata-model */ "./lib/assets/javascripts/builder/data/vis-metadata-model.js");
  var template = __webpack_require__(/*! ./map-metadata.tpl */ "./lib/assets/javascripts/builder/components/modals/map-metadata/map-metadata.tpl");
  var FooterView = __webpack_require__(/*! ./footer/footer-view */ "./lib/assets/javascripts/builder/components/modals/map-metadata/footer/footer-view.js");
  var templateError = __webpack_require__(/*! ./map-metadata-error.tpl */ "./lib/assets/javascripts/builder/components/modals/map-metadata/map-metadata-error.tpl");
  var templateLoading = __webpack_require__(/*! builder/components/loading/render-loading */ "./lib/assets/javascripts/builder/components/loading/render-loading.js");
  var FormView = __webpack_require__(/*! ./form/form-view */ "./lib/assets/javascripts/builder/components/modals/map-metadata/form/form-view.js");
  var saveMetadata = __webpack_require__(/*! ./save-metadata-map */ "./lib/assets/javascripts/builder/components/modals/map-metadata/save-metadata-map.js");
  var errorParser = __webpack_require__(/*! builder/helpers/error-parser */ "./lib/assets/javascripts/builder/helpers/error-parser.js");
  var Notifier = __webpack_require__(/*! builder/components/notifier/notifier */ "./lib/assets/javascripts/builder/components/notifier/notifier.js");
  var utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  
  /**
   * Add layer dialog, typically used from editor
   */
  module.exports = CoreView.extend({
    events: {
      'click .js-back': '_onBackFromError'
    },
  
    className: 'Dialog-content Dialog-content--expanded',
  
    initialize: function initialize(opts) {
      if (!opts.modalModel) throw new TypeError('modalModel is required');
      if (!opts.visDefinitionModel) throw new TypeError('visDefinitionModel is required');
  
      this._modalModel = opts.modalModel;
      this._visDefinitionModel = opts.visDefinitionModel;
  
      this._visMetadataModel = new VisMetadataModel({
        name: this._visDefinitionModel.get('name'),
        description: this._visDefinitionModel.get('description'),
        tags: this._visDefinitionModel.get('tags')
      });
  
      this._stateModel = new Backbone.Model({
        status: 'show'
      });
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
  
      if (this._hasError()) {
        this._renderError();
      } else if (this._isLoading()) {
        this._renderLoading();
      } else {
        this.$el.html(template());
        this._initViews();
      }
      return this;
    },
  
    _initViews: function _initViews() {
      var formView = new FormView({
        visDefinitionModel: this._visDefinitionModel,
        visMetadataModel: this._visMetadataModel
      });
  
      this.$('.js-content').append(formView.render().el);
      this.addView(formView);
  
      var footerView = new FooterView({
        visMetadataModel: this._visMetadataModel,
        onSaveAction: this._onSave.bind(this),
        onCloseAction: this._onClose.bind(this)
      });
  
      this.$('.js-footer').append(footerView.render().el);
      this.addView(footerView);
    },
  
    _renderError: function _renderError() {
      var error = this._stateModel.get('error');
      this.$el.html(templateError({
        error: _t('components.modals.maps-metadata.error.subtitle', { error: error })
      }));
    },
  
    _renderLoading: function _renderLoading() {
      this.$el.html(templateLoading({
        title: _t('components.modals.maps-metadata.loading')
      }));
    },
  
    _initBinds: function _initBinds() {
      this._stateModel.on('change:status', this.render, this);
      this.add_related_model(this._stateModel);
    },
  
    _hasError: function _hasError() {
      return this._stateModel.get('status') === 'error';
    },
  
    _isLoading: function _isLoading() {
      return this._stateModel.get('status') === 'loading';
    },
  
    _onSave: function _onSave() {
      this._stateModel.set({ status: 'loading' });
  
      saveMetadata({
        onSuccess: this._onSuccessSave.bind(this),
        onError: this._onErrorSave.bind(this),
        visDefinitionModel: this._visDefinitionModel,
        name: this._getMetadataName(),
        description: this._getMetadataDescription(),
        tags: this._getMetadataTags()
      });
    },
  
    _onSuccessSave: function _onSuccessSave() {
      var self = this;
      Notifier.addNotification({
        status: 'success',
        info: _t('components.modals.maps-metadata.success', {
          name: self._getMetadataName()
        }),
        closable: true,
        delay: Notifier.DEFAULT_DELAY
      });
  
      this._modalModel.destroy();
    },
  
    _onClose: function _onClose() {
      this._modalModel.destroy();
    },
  
    _onErrorSave: function _onErrorSave(e) {
      this._stateModel.set({
        status: 'error',
        error: errorParser(e)
      });
    },
  
    _onBackFromError: function _onBackFromError() {
      this._stateModel.set({ status: 'show' });
    },
  
    _getMetadataName: function _getMetadataName() {
      return utils.sanitizeHtml(this._visMetadataModel.get('name'));
    },
  
    _getMetadataDescription: function _getMetadataDescription() {
      return utils.sanitizeHtml(this._visMetadataModel.get('description'));
    },
  
    _getMetadataTags: function _getMetadataTags() {
      return _.map(this._visMetadataModel.get('tags'), function (tag) {
        return utils.sanitizeHtml(tag);
      });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/map-metadata/save-metadata-map.js":
  /*!********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/map-metadata/save-metadata-map.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var TITLE_SUFIX = __webpack_require__(/*! builder/components/modals/visualization-title-suffix-metadata */ "./lib/assets/javascripts/builder/components/modals/visualization-title-suffix-metadata.js");
  
  module.exports = function (opts) {
    if (!opts.visDefinitionModel) throw new Error('visDefinitionModel is required');
    if (!opts.name) throw new Error('name is required');
  
    var visDefinitionModel = opts.visDefinitionModel;
    var successCallback = opts.onSuccess;
    var errorCallback = opts.onError;
    var name = opts.name;
    var description = opts.description;
    var tags = opts.tags;
  
    var oldName = visDefinitionModel.get('name');
  
    visDefinitionModel.save({
      name: name,
      description: description,
      tags: tags
    }, {
      wait: true,
      success: function success(mdl, attrs) {
        document.title = name + TITLE_SUFIX;
        successCallback && successCallback();
      },
      error: function error(mdl, e) {
        document.title = oldName + TITLE_SUFIX;
        errorCallback && errorCallback(e);
      }
    });
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/modal-view-model.js":
  /*!******************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/modal-view-model.js ***!
    \******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  /**
   * View model of a modal
   */
  module.exports = Backbone.Model.extend({
  
    defaults: {
      show: true,
      createContentView: function createContentView() {
        return new CoreView();
      }
    },
  
    createContentView: function createContentView() {
      return this.get('createContentView')(this);
    },
  
    show: function show() {
      this.set('show', true);
    },
  
    hide: function hide() {
      this.set('show', false);
    },
  
    isHidden: function isHidden() {
      return !this.get('show');
    },
  
    /**
     * @override {Backbone.Model.prototype.destroy}
     */
    destroy: function destroy() {
      var args = Array.prototype.slice.call(arguments);
      this.trigger.apply(this, ['destroy'].concat(args));
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/modal-view.js":
  /*!************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/modal-view.js ***!
    \************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./modal.tpl */ "./lib/assets/javascripts/builder/components/modals/modal.tpl");
  
  // Ought to match the duration of the .Dialog.is-closing animation.
  var CLOSE_DELAY_MS = 120;
  
  module.exports = CoreView.extend({
    className: function className() {
      var classes = ['Dialog', 'is-white'];
      if (!this.options.escapeOptionsDisabled) {
        classes.push('is-opening');
      }
  
      if (this.options.breadcrumbsEnabled) {
        classes.push('Dialog--withBreadcrumbs');
      }
  
      return classes.join(' ');
    },
  
    events: {
      'click .js-close': '_onClose'
    },
  
    initialize: function initialize() {
      this.listenTo(this.model, 'change:show', this._onShowChange);
      this.listenTo(this.model, 'destroy', this._onDestroy);
  
      this._escapeOptionsDisabled = this.options.escapeOptionsDisabled;
      this._breadcrumbsEnabled = this.options.breadcrumbsEnabled;
      this._keepOpenOnRouteChange = this.options.keepOpenOnRouteChange;
    },
  
    render: function render() {
      this.clearSubViews();
  
      this.$el.html(template({
        escapeOptionsDisabled: this._escapeOptionsDisabled || false,
        breadcrumbsEnabled: this._breadcrumbsEnabled || false
      }));
  
      var view = this.model.createContentView();
      this.addView(view);
  
      view.render();
  
      this.$('.js-content').append(view.el);
  
      return this;
    },
  
    show: function show() {
      this.model.show();
    },
  
    hide: function hide() {
      this.model.hide();
    },
  
    destroy: function destroy() {
      // 'remove' would be a better name ofc, but there is already an internal method with that name in CoreView
      this.model.destroy();
    },
  
    keepOpenOnRouteChange: function keepOpenOnRouteChange() {
      return this.model.get('keepOpenOnRouteChange');
    },
  
    _onShowChange: function _onShowChange(m, show) {
      if (show) {
        this.$el.show();
        this.$el.removeClass('is-closing').addClass('is-opening');
      } else {
        this.$el.removeClass('is-opening').addClass('is-closing');
        this._delayDueToAnimation(function () {
          this.$el.hide();
        });
      }
    },
  
    _onClose: function _onClose(e) {
      e.stopPropagation();
      this.destroy();
    },
  
    _onDestroy: function _onDestroy() {
      this.hide();
      _.invoke(this._subviews, 'allOff');
      this._delayDueToAnimation(function () {
        this.clean();
      });
    },
  
    _delayDueToAnimation: function _delayDueToAnimation(fn) {
      setTimeout(fn.bind(this), CLOSE_DELAY_MS);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/modals-service-model.js":
  /*!**********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/modals-service-model.js ***!
    \**********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var ModalView = __webpack_require__(/*! ./modal-view */ "./lib/assets/javascripts/builder/components/modals/modal-view.js");
  var ModalViewModel = __webpack_require__(/*! ./modal-view-model */ "./lib/assets/javascripts/builder/components/modals/modal-view-model.js");
  
  var DESTROYED_MODAL_EVENT = 'destroyedModal';
  
  /**
   * Top-level API to handle modals.
   * Is intended to be instantiated and registered in some top-level namespace to be accessible within the lifecycle of
   * an client-side application.
   *
   * Example:
   * // In some entry-point:
   * cdb.modals = new ModalsServiceModel();
   *
   * // Later, in any view, calling create will create a new modal viewModel
   * var modalView = cdb.modals.create(fn)
   *
   * You will probably see the name of "Dialog" here and there, it's the old nomenclature for the concept of Modal.
   */
  module.exports = Backbone.Model.extend({
  
    /**
     * Creates a new modal view
     *
     * @param {Function} createContentView
     * @return {View} the new modal view
     */
    create: function create(createContentView, options) {
      if (!_.isFunction(createContentView)) throw new Error('createContentView is required');
  
      if (!this._modalView) {
        this.trigger('willCreateModal');
        this._modalView = this._newModalView(options);
        this.trigger('didCreateModal', this._modalView);
        document.body.appendChild(this._modalView.el);
      }
  
      this._modalView.model.set('createContentView', createContentView);
      this._modalView.render();
  
      return this._modalView;
    },
  
    /**
     * Convenience method to add a listener when current modal is destroyed
     *
     * This is the same as doing
     * modals.create(function (model) {
     *   model.once('destroy', callback, context); // <-- same as modals.onDestroyOnce(callback, context);
     *   return new MyView({  });
     * });
     *
     * @param {Function} callback
     * @param {Object} [context = undefined]
     */
    onDestroyOnce: function onDestroyOnce(callback, context) {
      this.once(DESTROYED_MODAL_EVENT, callback, context);
    },
  
    destroy: function destroy() {
      if (this._modalView) {
        this._modalView.model.destroy();
      }
    },
  
    keepOpenOnRouteChange: function keepOpenOnRouteChange() {
      return this._modalView && this._modalView.keepOpenOnRouteChange();
    },
  
    _newModalView: function _newModalView(options) {
      var viewModel = new ModalViewModel({
        keepOpenOnRouteChange: options && options.keepOpenOnRouteChange
      });
  
      this._handleBodyClass(viewModel);
  
      var escapeOptionsDisabled = options && options.escapeOptionsDisabled;
      var breadcrumbsEnabled = options && options.breadcrumbsEnabled;
  
      if (!escapeOptionsDisabled) {
        this._destroyOnEsc(viewModel);
      }
  
      this.listenToOnce(viewModel, 'destroy', function () {
        this._modalView = null;
        this.trigger.apply(this, [DESTROYED_MODAL_EVENT].concat(Array.prototype.slice.call(arguments)));
        this.stopListening(viewModel);
      });
  
      return new ModalView({
        model: viewModel,
        escapeOptionsDisabled: escapeOptionsDisabled,
        breadcrumbsEnabled: breadcrumbsEnabled
      });
    },
  
    _destroyOnEsc: function _destroyOnEsc(viewModel) {
      var destroyOnEsc = function destroyOnEsc(ev) {
        if (ev.keyCode === 27) {
          ev.stopPropagation();
          viewModel.destroy();
        }
      };
      document.addEventListener('keydown', destroyOnEsc);
      this.listenToOnce(viewModel, 'destroy', function () {
        document.removeEventListener('keydown', destroyOnEsc);
      });
    },
  
    /**
     * TL;DR this method manages document.body class state, to enable scroll inside of an open modal.
     *
     * Some modal content have too much content that can be displayed in the viewport the scroll needs to be enabled.
     * Since the modal is implemented as a fixed positioned element the body needs to be fixated too, for the scroll to
     * be enabled inside the modal instead.
     */
    _handleBodyClass: function _handleBodyClass(viewModel) {
      var bodyClass = 'is-inDialog';
      document.body.classList.add(bodyClass);
      this.set('open', true);
  
      this.listenTo(viewModel, 'change:show', function (m, show) {
        document.body.classList[show ? 'add' : 'remove'](bodyClass);
        this.set('open', show);
      });
  
      this.listenToOnce(viewModel, 'destroy', function () {
        document.body.classList.remove(bodyClass);
        this.set('open', false);
      });
    },
  
    isOpen: function isOpen() {
      return this.get('open') === true;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/privacy-warning/privacy-warning-view.js":
  /*!**************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/privacy-warning/privacy-warning-view.js ***!
    \**************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var ConfirmationView = __webpack_require__(/*! builder/components/modals/confirmation/modal-confirmation-view */ "./lib/assets/javascripts/builder/components/modals/confirmation/modal-confirmation-view.js");
  var IconView = __webpack_require__(/*! builder/components/icon/icon-view */ "./lib/assets/javascripts/builder/components/icon/icon-view.js");
  var template = __webpack_require__(/*! ./privacy-warning.tpl */ "./lib/assets/javascripts/builder/components/modals/privacy-warning/privacy-warning.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['modalModel', 'privacyType'];
  
  /**
   *  Privacy Warning modal dialog
   */
  module.exports = ConfirmationView.extend({
    className: 'Dialog-content',
  
    events: {
      'click .js-confirm': '_onConfirm',
      'click .js-cancel': '_onDismiss'
    },
  
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      if (this.options.onConfirm) {
        this._onConfirmCallback = this.options.onConfirm;
      }
  
      if (this.options.onDismiss) {
        this._onDismissCallback = this.options.onDismiss;
      }
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template({
        type: this.options.type || 'visualization',
        selectedPrivacyType: this._privacyType
      }));
  
      var warningIcon = new IconView({
        placeholder: this.$el.find('.js-icon-warning'),
        icon: 'warning'
      });
      warningIcon.render();
      this.addView(warningIcon);
  
      return this;
    },
  
    _onConfirm: function _onConfirm() {
      this._modalModel.destroy();
      this._onConfirmCallback && this._onConfirmCallback();
    },
  
    _onDismiss: function _onDismiss() {
      this._modalModel.destroy();
      this._onDismissCallback && this._onDismissCallback();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/publish/create-privacy-options.js":
  /*!********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/publish/create-privacy-options.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  /**
   * type property should match the value given from the API.
   */
  var ALL_OPTIONS = [{
    privacy: 'PUBLIC',
    title: _t('components.modals.publish.privacy.public.title'),
    desc: _t('components.modals.publish.privacy.public.body'),
    alwaysEnabled: true,
    cssClass: 'green'
  }, {
    privacy: 'LINK',
    title: _t('components.modals.publish.privacy.link.title'),
    desc: _t('components.modals.publish.privacy.link.body'),
    cssClass: 'orange'
  }, {
    privacy: 'PASSWORD',
    title: _t('components.modals.publish.privacy.password.title'),
    desc: _t('components.modals.publish.privacy.password.body'),
    cssClass: 'orange-dark'
  }, {
    privacy: 'PRIVATE',
    title: _t('components.modals.publish.privacy.private.title'),
    desc: _t('components.modals.publish.privacy.private.body'),
    cssClass: 'red'
  }];
  
  module.exports = function (visDefinitionModel, userModel) {
    var isVisualization = visDefinitionModel.isVisualization();
    var actions = userModel.get('actions');
    var canSelectPremiumOptions = actions[isVisualization ? 'private_maps' : 'private_tables'];
    var currentPrivacy = visDefinitionModel.get('privacy');
    var availableOptions = visDefinitionModel.privacyOptions();
  
    return _.chain(ALL_OPTIONS).filter(function (option) {
      return _.contains(availableOptions, option.privacy);
    }).map(function (option) {
      // Set state that depends on vis and user attrs, they should not vary during the lifecycle of this collection
      return _.defaults({
        selected: option.privacy === currentPrivacy,
        disabled: !(option.alwaysEnabled || canSelectPremiumOptions)
      }, option);
    }).value();
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/publish/privacy-collection.js":
  /*!****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/publish/privacy-collection.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var PrivacyModel = __webpack_require__(/*! ./privacy-model */ "./lib/assets/javascripts/builder/components/modals/publish/privacy-model.js");
  var PasswordModel = __webpack_require__(/*! ./privacy-password-model */ "./lib/assets/javascripts/builder/components/modals/publish/privacy-password-model.js");
  
  /**
   * Collection that holds the different privacy options.
   */
  module.exports = Backbone.Collection.extend({
  
    model: function model(attrs, options) {
      if (attrs.privacy === 'PASSWORD') {
        return new PasswordModel(attrs, options);
      } else {
        return new PrivacyModel(attrs, options);
      }
    },
  
    initialize: function initialize() {
      this.bind('change:selected', this._deselectLastSelected, this);
    },
  
    searchByPrivacy: function searchByPrivacy(privacy) {
      return this.findWhere({ privacy: privacy });
    },
  
    selectedOption: function selectedOption() {
      return this.find(function (option) {
        return option.get('selected');
      });
    },
  
    passwordOption: function passwordOption() {
      return this.find(function (option) {
        return option.get('privacy') === 'PASSWORD';
      });
    },
  
    _deselectLastSelected: function _deselectLastSelected(m, isSelected) {
      if (isSelected) {
        this.each(function (option) {
          if (option !== m) {
            option.set({ selected: false });
          }
        });
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/publish/privacy-model.js":
  /*!***********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/publish/privacy-model.js ***!
    \***********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  module.exports = Backbone.Model.extend({
  
    defaults: {
      privacy: 'PUBLIC',
      disabled: false,
      selected: false,
      password: undefined
    },
  
    validate: function validate(attrs) {
      if (attrs.disabled && attrs.selected) {
        return 'Option can not be disabled and selected at the same time';
      }
    },
  
    classNames: function classNames() {
      return _.chain(['disabled', 'selected']).map(function (attr) {
        return this.attributes[attr] !== undefined ? 'is-' + attr : undefined;
      }, this).compact().value().join(' ');
    },
  
    canSave: function canSave() {
      return !this.get('disabled');
    },
  
    isPassword: function isPassword() {
      return false;
    },
  
    isSelected: function isSelected() {
      return this.get('selected') === true;
    },
  
    saveToVis: function saveToVis(vis, callbacks) {
      return vis.save(this._attrsToSave(), _.extend({ wait: true }, callbacks));
    },
  
    _attrsToSave: function _attrsToSave() {
      return _.pick(this.attributes, 'privacy', 'password');
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/publish/privacy-password-model.js":
  /*!********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/publish/privacy-password-model.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var PrivacyModel = __webpack_require__(/*! ./privacy-model */ "./lib/assets/javascripts/builder/components/modals/publish/privacy-model.js");
  
  var FAKE_PASSWORD = '!@#!@#';
  
  /**
   * View model for the special privacy option representing a password protected map.
   * It handles the logic related to the password that needs to be set for the option.
   */
  module.exports = PrivacyModel.extend({
  
    initialize: function initialize() {
      PrivacyModel.prototype.initialize.apply(this, arguments);
      this.set('password', FAKE_PASSWORD);
    },
  
    /**
     * @override OptionModel.attrsToSave
     */
    _attrsToSave: function _attrsToSave() {
      var attrs = PrivacyModel.prototype._attrsToSave.call(this);
  
      if (attrs.password === FAKE_PASSWORD) {
        delete attrs.password;
      }
  
      return attrs;
    },
  
    canSave: function canSave() {
      return !this.get('disabled') && !_.isEmpty(this.get('password'));
    },
  
    isPassword: function isPassword() {
      return true;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/publish/publish-button-view.js":
  /*!*****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/publish/publish-button-view.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var PrivacyWarningView = __webpack_require__(/*! builder/components/modals/privacy-warning/privacy-warning-view */ "./lib/assets/javascripts/builder/components/modals/privacy-warning/privacy-warning-view.js");
  var ModalsServiceModel = __webpack_require__(/*! builder/components/modals/modals-service-model */ "./lib/assets/javascripts/builder/components/modals/modals-service-model.js");
  var VisDefinitionModel = __webpack_require__(/*! builder/data/vis-definition-model */ "./lib/assets/javascripts/builder/data/vis-definition-model.js");
  var template = __webpack_require__(/*! ./publish-button.tpl */ "./lib/assets/javascripts/builder/components/modals/publish/publish-button.tpl");
  
  var REQUIRED_OPTS = ['visDefinitionModel', 'mapcapsCollection', 'configModel', 'userModel'];
  
  module.exports = CoreView.extend({
  
    events: {
      'click .js-button': '_onUpdate'
    },
  
    initialize: function initialize(opts) {
      _.each(REQUIRED_OPTS, function (item) {
        if (opts[item] === undefined) throw new Error(item + ' is required');
        this['_' + item] = opts[item];
      }, this);
  
      // We recreate this modal stack to be able to
      // have two modals stacked on screen
      this._modals = new ModalsServiceModel();
  
      this.model = new Backbone.Model({
        status: 'idle'
      });
  
      this._initBinds();
    },
  
    render: function render() {
      var publishedOn = this._mapcapsCollection.length > 0 ? _t('components.modals.publish.share.last-published', { date: this.model.get('status') === 'updated' ? moment(this._mapcapsCollection.first().get('created_at')).fromNow() : moment(this._mapcapsCollection.first().get('created_at')).format('Do MMMM YYYY, HH:mm')
      }) : _t('components.modals.publish.share.unpublished');
  
      this.clearSubViews();
      this.$el.html(template({
        isPublished: this._isPublished(),
        isLoading: this._isLoading(),
        isDisabled: this._isDisabled(),
        publishedOn: publishedOn
      }));
      return this;
    },
  
    _initBinds: function _initBinds() {
      this._mapcapsCollection.on('reset', this.render, this);
      this.add_related_model(this._mapcapsCollection);
      this.model.on('change:status', this.render, this);
    },
  
    _isPublished: function _isPublished() {
      return this._mapcapsCollection.length > 0;
    },
  
    _isLoading: function _isLoading() {
      return this.model.get('status') === 'loading';
    },
  
    _isDisabled: function _isDisabled() {
      return this.model.get('status') === 'updated';
    },
  
    _onUpdate: function _onUpdate() {
      var self = this;
      var url = this._visDefinitionModel.mapcapsURL();
      var data = {
        api_key: this._configModel.get('api_key')
      };
  
      if (this._isDisabled()) return false;
  
      if (this._shouldShowPrivacyWarning()) {
        this._checkPrivacyChange(this._visDefinitionModel.get('privacy'), function () {
          self._createMapCap(url, data);
        });
      } else {
        this._createMapCap(url, data);
      }
    },
  
    _checkPrivacyChange: function _checkPrivacyChange(newPrivacyStatus, confirmCallback, dismissCallback) {
      this._modals.create(function (modalModel) {
        return new PrivacyWarningView({
          modalModel: modalModel,
          privacyType: newPrivacyStatus,
          onConfirm: confirmCallback,
          onDismiss: dismissCallback
        });
      });
    },
  
    _createMapCap: function _createMapCap(url, data) {
      var self = this;
      this.model.set({ status: 'loading' });
  
      $.post(url, data).done(function (data) {
        self._visDefinitionModel.set('visChanges', 0);
        self._mapcapsCollection.add(data, { at: 0 });
        self.model.set({ status: 'updated' });
      }).fail(function () {
        self.model.set({ status: 'error' });
      });
    },
  
    _shouldShowPrivacyWarning: function _shouldShowPrivacyWarning() {
      return this._userModel.canSelectPremiumOptions(this._visDefinitionModel) && !this._isPublished() && VisDefinitionModel.isPubliclyAvailable(this._visDefinitionModel.get('privacy'));
    },
  
    clean: function clean() {
      this._modals.destroy();
      CoreView.prototype.clean.apply(this, arguments);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/publish/publish-view.js":
  /*!**********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/publish/publish-view.js ***!
    \**********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./publish.tpl */ "./lib/assets/javascripts/builder/components/modals/publish/publish.tpl");
  var TabPaneTemplate = __webpack_require__(/*! ./tab-pane-submenu.tpl */ "./lib/assets/javascripts/builder/components/modals/publish/tab-pane-submenu.tpl");
  var createTextLabelsTabPane = __webpack_require__(/*! builder/components/tab-pane/create-text-labels-tab-pane */ "./lib/assets/javascripts/builder/components/tab-pane/create-text-labels-tab-pane.js");
  var PublishView = __webpack_require__(/*! ./publish/publish-view */ "./lib/assets/javascripts/builder/components/modals/publish/publish/publish-view.js");
  var ShareView = __webpack_require__(/*! ./share/share-view */ "./lib/assets/javascripts/builder/components/modals/publish/share/share-view.js");
  var PrivacyDropdown = __webpack_require__(/*! builder/components/privacy-dropdown/privacy-dropdown-view */ "./lib/assets/javascripts/builder/components/privacy-dropdown/privacy-dropdown-view.js");
  var PublishButton = __webpack_require__(/*! ./publish-button-view */ "./lib/assets/javascripts/builder/components/modals/publish/publish-button-view.js");
  var ShareWith = __webpack_require__(/*! ./share-with-view */ "./lib/assets/javascripts/builder/components/modals/publish/share-with-view.js");
  var UpgradeView = __webpack_require__(/*! ./upgrade-view */ "./lib/assets/javascripts/builder/components/modals/publish/upgrade-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['modalModel', 'visDefinitionModel', 'privacyCollection', 'userModel', 'configModel', 'isOwner'];
  
  var MODE_FULL = 'full';
  var MODE_SHARE = 'share';
  var MODE_PUBLISH = 'publish';
  
  module.exports = CoreView.extend({
    className: 'Publish-modal',
  
    events: {
      'click .js-done': '_onDone'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      // Optional options
      this._mapcapsCollection = opts.mapcapsCollection;
      this.mode = opts.mode || MODE_FULL;
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template({
        name: this._visDefinitionModel.get('name'),
        isSimple: !this._hasTabs(),
        hasShareStats: this._hasShareStats()
      }));
  
      this._initViews();
  
      if (this.mode === MODE_FULL) {
        if (!this._hasOrganization()) {
          this._makePublishView();
        } else {
          this._initTabsViews();
        }
      } else if (this.mode === MODE_SHARE) {
        this._makeShareView();
      } else if (this.mode === MODE_PUBLISH) {
        this._makePublishView();
      }
  
      return this;
    },
  
    _hasShareStats: function _hasShareStats() {
      return this.mode !== MODE_PUBLISH && this._hasOrganization();
    },
  
    _hasOrganization: function _hasOrganization() {
      return this._userModel.isInsideOrg();
    },
  
    _hasTabs: function _hasTabs() {
      var hasOrganization = this._hasOrganization();
      return hasOrganization && this.mode === MODE_FULL;
    },
  
    _makePublishView: function _makePublishView() {
      var view = this._createPublishView();
      this.$('.js-panes').append(view.render().el);
      this.addView(view);
    },
  
    _makeShareView: function _makeShareView() {
      var view = this._createShareView();
      this.$('.js-panes').append(view.render().el);
      this.addView(view);
    },
  
    _initViews: function _initViews() {
      var dropdown;
      var publishButton;
      var shareWith;
      var upgradeView;
      var publishedOn;
  
      dropdown = new PrivacyDropdown({
        privacyCollection: this._privacyCollection,
        visDefinitionModel: this._visDefinitionModel,
        mapcapsCollection: this._mapcapsCollection,
        userModel: this._userModel,
        configModel: this._configModel,
        isOwner: this._isOwner
      });
  
      this.$('.js-dropdown').append(dropdown.render().el);
      this.addView(dropdown);
  
      if (this._mapcapsCollection !== undefined) {
        publishButton = new PublishButton({
          visDefinitionModel: this._visDefinitionModel,
          mapcapsCollection: this._mapcapsCollection,
          configModel: this._configModel,
          userModel: this._userModel
        });
  
        this.$('.js-update').append(publishButton.render().el);
        this.addView(publishButton);
      } else {
        publishedOn = _t('components.modals.publish.share.last-published', { date: moment(this._visDefinitionModel.get('updated_at')).format('Do MMMM YYYY, HH:mm')
        });
  
        this.$('.js-update').html(publishedOn);
      }
  
      if (this._hasShareStats()) {
        shareWith = new ShareWith({
          visDefinitionModel: this._visDefinitionModel,
          userModel: this._userModel,
          avatarClass: 'Share-user--big',
          separationClass: 'u-rSpace--xl'
        });
        this.$('.js-share-users').append(shareWith.render().el);
        this.addView(shareWith);
      }
  
      if (!this._hasOrganization()) {
        upgradeView = new UpgradeView();
        this.$('.js-upgrade').append(upgradeView.render().el);
        this.addView(upgradeView);
      }
    },
  
    _initTabsViews: function _initTabsViews() {
      var self = this;
  
      var tabPaneTabs = [{
        name: 'share',
        label: _t('components.modals.publish.menu.share'),
        createContentView: self._createShareView.bind(self)
      }, {
        name: 'publish',
        label: _t('components.modals.publish.menu.publish'),
        createContentView: self._createPublishView.bind(self)
      }];
  
      var tabPaneOptions = {
        tabPaneOptions: {
          template: TabPaneTemplate,
          tabPaneItemOptions: {
            tagName: 'li',
            klassName: 'CDB-NavSubmenu-item'
          }
        },
        tabPaneItemLabelOptions: {
          tagName: 'button',
          className: 'CDB-NavSubmenu-link u-upperCase Publish-modalLink'
        }
      };
  
      this._layerTabPaneView = createTextLabelsTabPane(tabPaneTabs, tabPaneOptions);
      this.$('.js-panes').append(this._layerTabPaneView.render().$el);
      this.addView(this._layerTabPaneView);
    },
  
    _createShareView: function _createShareView() {
      return new ShareView({
        className: 'Share-wrapper',
        currentUserId: this._userModel.id,
        visDefinitionModel: this._visDefinitionModel,
        organization: this._userModel._organizationModel,
        configModel: this._configModel
      });
    },
  
    _createPublishView: function _createPublishView() {
      return new PublishView({
        visDefinitionModel: this._visDefinitionModel,
        mapcapsCollection: this._mapcapsCollection,
        userModel: this._userModel
      });
    },
  
    _onDone: function _onDone() {
      this._modalModel.destroy();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/publish/publish/create-share-options.js":
  /*!**************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/publish/publish/create-share-options.js ***!
    \**************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var linkIconTemplate = __webpack_require__(/*! ./icon-link.tpl */ "./lib/assets/javascripts/builder/components/modals/publish/publish/icon-link.tpl");
  var embedIconTemplate = __webpack_require__(/*! ./icon-embed.tpl */ "./lib/assets/javascripts/builder/components/modals/publish/publish/icon-embed.tpl");
  
  module.exports = function (visDefinitionModel) {
    return [{
      createIcon: function createIcon() {
        return linkIconTemplate();
      },
      type: 'get-link',
      content: visDefinitionModel.embedURL(),
      private: visDefinitionModel.get('privacy') === 'PRIVATE'
    }, {
      createIcon: function createIcon() {
        return embedIconTemplate();
      },
      type: 'embed',
      content: '<iframe width="100%" height="520" frameborder="0" src="' + encodeURI(visDefinitionModel.embedURL()) + '" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>',
      url: encodeURI(visDefinitionModel.embedURL()),
      private: visDefinitionModel.get('privacy') === 'PRIVATE'
    }];
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/publish/publish/publish-view.js":
  /*!******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/publish/publish/publish-view.js ***!
    \******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var CreateShareOptions = __webpack_require__(/*! ./create-share-options */ "./lib/assets/javascripts/builder/components/modals/publish/publish/create-share-options.js");
  var ShareCollection = __webpack_require__(/*! ./share-collection */ "./lib/assets/javascripts/builder/components/modals/publish/publish/share-collection.js");
  var ShareItemView = __webpack_require__(/*! ./share-item-view */ "./lib/assets/javascripts/builder/components/modals/publish/publish/share-item-view.js");
  var template = __webpack_require__(/*! ./publish.tpl */ "./lib/assets/javascripts/builder/components/modals/publish/publish/publish.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['visDefinitionModel', 'mapcapsCollection', 'userModel'];
  
  module.exports = CoreView.extend({
    className: 'Publish-modalShare u-inner',
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this.hasOrganization = this._userModel.isInsideOrg();
  
      var shareOptions = CreateShareOptions(this._visDefinitionModel);
      this._shareCollection = new ShareCollection(shareOptions);
  
      this._initBinds();
    },
  
    render: function render() {
      var isPublished = this._mapcapsCollection.length > 0;
      this.clearSubViews();
      this.$el.html(template({
        isPublished: isPublished
      }));
      this._initViews();
      return this;
    },
  
    _initViews: function _initViews() {
      var renderItemView = this._renderItemView.bind(this);
      this._shareCollection.each(renderItemView);
    },
  
    _renderItemView: function _renderItemView(model) {
      var self = this;
      var isPublished = this._mapcapsCollection.length > 0;
      var view = new ShareItemView({
        model: model,
        isPublished: isPublished,
        hasOrganization: self.hasOrganization
      });
  
      this.$('.js-list').append(view.render().el);
      this.addView(view);
    },
  
    _revampPrivacyOptions: function _revampPrivacyOptions() {
      var shareOptions = CreateShareOptions(this._visDefinitionModel);
      this._shareCollection.reset(shareOptions);
    },
  
    _initBinds: function _initBinds() {
      this._visDefinitionModel.on('sync', this._revampPrivacyOptions, this);
      this.add_related_model(this._visDefinitionModel);
  
      this._shareCollection.on('reset', this.render, this);
      this.add_related_model(this._shareCollection);
  
      this._mapcapsCollection.on('reset add', this.render, this);
      this.add_related_model(this._mapcapsCollection);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/publish/publish/share-collection.js":
  /*!**********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/publish/publish/share-collection.js ***!
    \**********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var ShareModel = __webpack_require__(/*! ./share-model */ "./lib/assets/javascripts/builder/components/modals/publish/publish/share-model.js");
  
  module.exports = Backbone.Collection.extend({
    model: ShareModel
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/publish/publish/share-item-view.js":
  /*!*********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/publish/publish/share-item-view.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var Clipboard = __webpack_require__(/*! clipboard */ "./node_modules/clipboard/lib/clipboard.js");
  var template = __webpack_require__(/*! ./share-item.tpl */ "./lib/assets/javascripts/builder/components/modals/publish/publish/share-item.tpl");
  var browserDetect = __webpack_require__(/*! builder/helpers/browser-detect */ "./lib/assets/javascripts/builder/helpers/browser-detect.js");
  
  var PRIVATE_LABEL_TEMPLATE = _.template("<span class='CDB-Text CDB-Size-small is-semibold u-errorTextColor'><%- private %></span>.<br>")({
    private: _t('components.modals.publish.share.private')
  });
  
  module.exports = CoreView.extend({
    className: 'Card',
    tagName: 'li',
  
    events: {
      'click .js-change-privacy': '_onChangePrivacyClick'
    },
  
    initialize: function initialize(opts) {
      if (!opts.model) throw new Error('model is required');
      if (opts.isPublished == null) throw new Error('isPublished is required');
  
      this._isPublished = opts.isPublished;
      this._type = this.model.type();
      this._hasOrganization = opts.hasOrganization;
      this._title = _t('components.modals.publish.share.' + this._type + '.title');
  
      if (this.model.isPrivate()) {
        this._body = _t('components.modals.publish.share.' + this._type + '.private.body', {
          private: PRIVATE_LABEL_TEMPLATE
        });
      } else {
        this._body = _t('components.modals.publish.share.' + this._type + '.body');
      }
  
      this._link = _t('components.modals.publish.share.' + this._type + '.link');
      this._copy = this._getButtonLabel();
      this.$el.toggleClass('is-disabled', this.model.isPrivate());
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this._initViews();
      if (!this.model.isPrivate() && this._isPublished) {
        this._initClipboard();
      }
      return this;
    },
  
    _getButtonLabel: function _getButtonLabel() {
      var browser = browserDetect();
      var label = _t('components.modals.publish.share.' + this._type + '.copy');
      if (browser.name === 'Safari') {
        label = _t('components.modals.publish.share.' + this._type + '.select');
      }
  
      return label;
    },
  
    getValue: function getValue() {
      return this.$('.js-input').val();
    },
  
    _initViews: function _initViews() {
      var view = template({
        id: this.cid,
        isPrivate: this.model.isPrivate(),
        type: this._type,
        title: this._title,
        body: this._body,
        content: this.model.content(),
        link: this._link,
        copy: this._copy,
        url: this.model.url(),
        isPublished: this._isPublished
      });
  
      this.$el.append(view);
  
      var iconTemplate = this.model.createIcon();
      this.$('.js-icon').append(iconTemplate());
    },
  
    _initClipboard: function _initClipboard() {
      if (this._clipboard) {
        this._clipboard.destroy();
      }
  
      var btn = this.$('.js-copy');
      this._clipboard = new Clipboard(btn.get(0));
    },
  
    _onChangePrivacyClick: function _onChangePrivacyClick(e) {
      this.killEvent(e);
      this.options.onChangePrivacy && this.options.onChangePrivacy();
    },
  
    clean: function clean() {
      this._clipboard && this._clipboard.destroy();
      CoreView.prototype.clean.call(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/publish/publish/share-model.js":
  /*!*****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/publish/publish/share-model.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  module.exports = Backbone.Model.extend({
    createIcon: function createIcon() {
      return this.get('createIcon');
    },
  
    type: function type() {
      return this.get('type');
    },
  
    content: function content() {
      return this.get('content');
    },
  
    url: function url() {
      return this.get('url');
    },
  
    isPrivate: function isPrivate() {
      return this.get('private');
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/publish/share-with-view.js":
  /*!*************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/publish/share-with-view.js ***!
    \*************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./share-with.tpl */ "./lib/assets/javascripts/builder/components/modals/publish/share-with.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['visDefinitionModel', 'userModel'];
  
  module.exports = CoreView.extend({
    className: 'Share-with u-flex u-alignCenter',
  
    events: {
      'click': '_onClick'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this.separationClass = opts.separationClass || '';
      this.avatarClass = opts.avatarClass || '';
  
      if (this.options.clickPrivacyAction) {
        this._clickPrivacyAction = this.options.clickPrivacyAction;
      }
  
      this._acl = this._visDefinitionModel.getPermissionModel().acl;
      this._initBinds();
    },
  
    render: function render() {
      var people = this._getPeople();
  
      this.clearSubViews();
      this.$el.html(template({
        avatar: this._userModel.get('avatar_url'),
        people: people,
        avatarClass: this.avatarClass,
        separationClass: this.separationClass,
        hasAction: !!this._clickPrivacyAction
      }));
      this.$el.toggleClass('is-pointer', !!this._clickPrivacyAction);
  
      return this;
    },
  
    _getPeople: function _getPeople() {
      var types = this._acl.pluck('type');
      if (types.indexOf('org') > -1) {
        return this._userModel.getOrganization().get('user_count') - 1;
      } else {
        var users = [];
  
        // Grab all ids from every group
        _.each(this._acl.where({ type: 'group' }), function (group) {
          var entity = group.get('entity');
          Array.prototype.push.apply(users, entity.users.pluck('id'));
        }, this);
  
        // Grab all ids from every user
        _.each(this._acl.where({ type: 'user' }), function (group) {
          var entity = group.get('entity');
          users.push(entity.get('id'));
        }, this);
  
        // remove current user id because it can be part of a group
        users = _.without(users, this._userModel.id);
  
        // counts unique ids
        return _.unique(users).length;
      }
    },
  
    _initBinds: function _initBinds() {
      this._acl.on('fetch', this.render, this);
      this.add_related_model(this._acl);
    },
  
    _onClick: function _onClick() {
      this._clickPrivacyAction && this._clickPrivacyAction();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/publish/share/share-list-view.js":
  /*!*******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/publish/share/share-list-view.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var PermissionView = __webpack_require__(/*! ./share-permission-view */ "./lib/assets/javascripts/builder/components/modals/publish/share/share-permission-view.js");
  
  var REQUIRED_OPTS = ['collection', 'currentUserId', 'organization', 'hasOrganization', 'sharePermissionModel', 'isVisualization'];
  
  module.exports = CoreView.extend({
    className: 'Share-list',
  
    initialize: function initialize(opts) {
      _.each(REQUIRED_OPTS, function (item) {
        if (opts[item] === undefined) throw new Error(item + ' is required');
        this['_' + item] = opts[item];
      }, this);
  
      // To avoid jumps in rendering when the user gets permission
      // we sort the collection only the first time
      this._sortedCollection = this._sortCollection();
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this._initViews();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this._sharePermissionModel.acl.on('add remove reset change', this.render, this);
      this.add_related_model(this._sharePermissionModel);
    },
  
    _initViews: function _initViews() {
      if (this._hasOrganization) {
        this._renderOrganization();
      }
  
      _.each(this._sortedCollection, this._renderItem, this);
    },
  
    _sortCollection: function _sortCollection() {
      // sharing first
      var sharing = this._collection.filter(function (model) {
        var permission = this._sharePermissionModel;
        var hasWriteAccess = permission.hasWriteAccess(model);
        var hasReadAccess = permission.hasReadAccess(model);
        return hasWriteAccess || hasReadAccess;
      }, this);
  
      var noSharing = this._collection.filter(function (model) {
        var permission = this._sharePermissionModel;
        var hasWriteAccess = permission.hasWriteAccess(model);
        var hasReadAccess = permission.hasReadAccess(model);
        return !hasWriteAccess && !hasReadAccess;
      }, this);
  
      return sharing.concat(noSharing);
    },
  
    _renderOrganization: function _renderOrganization() {
      var self = this;
      var organization = this._organization;
      var permission = this._sharePermissionModel;
      var hasWriteAccessAvailable = !self._isVisualization;
      var canChangeWriteAccess = permission.canChangeWriteAccess(organization);
      var hasWriteAccess = permission.hasWriteAccess(organization);
      var canChangeReadAccess = permission.canChangeReadAccess(organization);
      var hasReadAccess = permission.hasReadAccess(organization);
  
      var view = new PermissionView({
        model: organization,
        permission: permission,
        avatar: organization.get('avatar_url'),
        description: _t('components.modals.publish.share.organization.desc'),
        name: _t('components.modals.publish.share.organization.title'),
        canChangeReadAccess: canChangeReadAccess,
        hasReadAccess: hasReadAccess,
        hasWriteAccessAvailable: hasWriteAccessAvailable,
        canChangeWriteAccess: canChangeWriteAccess,
        hasWriteAccess: hasWriteAccess,
        isSelected: hasReadAccess || hasWriteAccess
      });
  
      this.$el.append(view.render().$el);
      this.addView(view);
    },
  
    _renderItem: function _renderItem(model) {
      var self = this;
      var view;
      var o = model.get('model');
      var permission = this._sharePermissionModel;
      var hasWriteAccessAvailable = !self._isVisualization;
      var canChangeWriteAccess = permission.canChangeWriteAccess(model);
      var hasWriteAccess = permission.hasWriteAccess(model);
      var canChangeReadAccess = permission.canChangeReadAccess(model);
      var hasReadAccess = permission.hasReadAccess(model);
      var role = this._getRole(o);
  
      if (model.id !== this._currentUserId) {
        view = new PermissionView({
          model: model,
          permission: permission,
          name: model.get('name') || model.get('username'),
          avatar: model.get('avatar_url'),
          role: role,
          users: o.users,
          canChangeReadAccess: canChangeReadAccess,
          hasReadAccess: hasReadAccess,
          hasWriteAccessAvailable: hasWriteAccessAvailable,
          canChangeWriteAccess: canChangeWriteAccess,
          hasWriteAccess: hasWriteAccess,
          isSelected: hasReadAccess || hasWriteAccess
        });
  
        this.$el.append(view.render().$el);
        this.addView(view);
      }
    },
  
    _getRole: function _getRole(d) {
      if (d.viewer !== undefined) {
        return d.viewer === true ? _t('components.modals.publish.share.role.viewer') : _t('components.modals.publish.share.role.builder');
      }
  
      return false;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/publish/share/share-permission-view.js":
  /*!*************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/publish/share/share-permission-view.js ***!
    \*************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./share-permission.tpl */ "./lib/assets/javascripts/builder/components/modals/publish/share/share-permission.tpl");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view.js */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var UsersGroup = __webpack_require__(/*! ./users-group-view */ "./lib/assets/javascripts/builder/components/modals/publish/share/users-group-view.js");
  
  var REQUIRED_OPTS = ['model', 'permission', 'name', 'canChangeReadAccess', 'hasReadAccess', 'hasWriteAccessAvailable', 'canChangeWriteAccess', 'hasWriteAccess', 'isSelected'];
  
  var OPTIONALS_OPT = ['description', 'role', 'avatar', 'users'];
  
  module.exports = CoreView.extend({
    className: 'Share-permission',
  
    events: {
      'change .js-read': '_onChangeRead',
      'change .js-write': '_onChangeWrite',
      'mouseover .js-toggler.is-disabled': '_onHoverDisabledToggler',
      'mouseout .js-toggler': '_destroyTooltip',
      'mouseleave .js-toggler': '_destroyTooltip'
    },
  
    initialize: function initialize(opts) {
      _.each(REQUIRED_OPTS, function (item) {
        if (opts[item] === undefined) throw new Error(item + ' is required');
        this['_' + item] = opts[item];
      }, this);
  
      _.each(OPTIONALS_OPT, function (item) {
        this['_' + item] = opts[item];
      }, this);
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template({
        name: this._name,
        avatar: this._avatar,
        role: this._role,
        users: this._users,
        description: this._description,
        canChangeReadAccess: this._canChangeReadAccess,
        hasReadAccess: this._hasReadAccess,
        hasWriteAccessAvailable: this._hasWriteAccessAvailable,
        canChangeWriteAccess: this._canChangeWriteAccess,
        hasWriteAccess: this._hasWriteAccess
      }));
  
      if (this._users) {
        this._renderUsers();
      }
  
      this.$el.toggleClass('is-selected', this._isSelected);
      return this;
    },
  
    _renderUsers: function _renderUsers() {
      var view = new UsersGroup({
        className: 'u-flex u-alignCenter',
        users: this._users
      });
  
      this.$('.js-users').append(view.render().el);
      this.addView(view);
    },
  
    _onChangeWrite: function _onChangeWrite() {
      var p = this._permission;
      if (p.canChangeWriteAccess(this._model)) {
        if (p.hasWriteAccess(this._model)) {
          p.revokeWriteAccess(this._model);
        } else {
          p.grantWriteAccess(this._model);
        }
      }
    },
  
    _onChangeRead: function _onChangeRead() {
      var p = this._permission;
      if (p.canChangeReadAccess(this._model)) {
        if (p.hasReadAccess(this._model)) {
          p.revokeAccess(this._model);
        } else {
          p.grantReadAccess(this._model);
        }
      }
    },
  
    _onHoverDisabledToggler: function _onHoverDisabledToggler(e) {
      var aclItem = this._permission.findRepresentableAclItem(this._model);
      var msg;
      var $el;
  
      if (aclItem && !aclItem.isOwn(this._model)) {
        msg = this._inheritedAccessTooltipText(aclItem);
        $el = $(e.currentTarget);
  
        this._tooltip = this._createTooltip({
          $el: $el,
          msg: msg
        });
        this._tooltip.showTipsy();
      }
    },
  
    _createTooltip: function _createTooltip(opts) {
      return new TipsyTooltipView({
        el: opts.$el,
        title: function title() {
          return opts.msg;
        }
      });
    },
  
    _destroyTooltip: function _destroyTooltip() {
      if (this._tooltip) {
        this._tooltip.hideTipsy();
        this._tooltip.destroyTipsy();
      }
    },
  
    _inheritedAccessTooltipText: function _inheritedAccessTooltipText(aclItem) {
      var type = aclItem.get('type');
  
      switch (type) {
        case 'group':
          return _t('components.modals.publish.share.tooltip.group', {
            name: aclItem.get('entity').get('name')
          });
        case 'org':
          return _t('components.modals.publish.share.tooltip.org');
        default:
          console.error('Trying to display inherited access for an unrecognized type ' + type);
          return '';
      }
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/publish/share/share-view.js":
  /*!**************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/publish/share/share-view.js ***!
    \**************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./share.tpl */ "./lib/assets/javascripts/builder/components/modals/publish/share/share.tpl");
  var GrantableCollection = __webpack_require__(/*! builder/data/grantables-collection */ "./lib/assets/javascripts/builder/data/grantables-collection.js");
  var SearchPaginationView = __webpack_require__(/*! builder/components/pagination-search/pagination-search-view */ "./lib/assets/javascripts/builder/components/pagination-search/pagination-search-view.js");
  var ListView = __webpack_require__(/*! ./share-list-view */ "./lib/assets/javascripts/builder/components/modals/publish/share/share-list-view.js");
  
  var REQUIRED_OPTS = ['configModel', 'currentUserId', 'organization', 'visDefinitionModel'];
  
  module.exports = CoreView.extend({
    initialize: function initialize(opts) {
      _.each(REQUIRED_OPTS, function (item) {
        if (!opts[item]) throw new Error(item + ' is required');
        this['_' + item] = opts[item];
      }, this);
  
      this._grantablesCollection = new GrantableCollection([], {
        currentUserId: this._currentUserId,
        organization: this._organization,
        configModel: this._configModel
      });
  
      this._sharePermissionModel = this._visDefinitionModel.getPermissionModel().clone();
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template({
        name: this._visDefinitionModel.get('name')
      }));
      this._initViews();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this._sharePermissionModel.acl.on('add remove reset change', this._onSave, this);
      this.add_related_model(this._sharePermissionModel.acl);
    },
  
    _initViews: function _initViews() {
      var self = this;
  
      this._searchPaginationView = new SearchPaginationView({
        className: 'u-inner',
        listCollection: this._grantablesCollection,
        createContentView: function createContentView(opts) {
          return new ListView(_.extend({}, opts, {
            collection: self._grantablesCollection,
            currentUserId: self._currentUserId,
            sharePermissionModel: self._sharePermissionModel,
            organization: self._organization,
            isVisualization: self._visDefinitionModel.isVisualization()
          }));
        }
      });
      this.addView(this._searchPaginationView);
      this.$('.js-body').html(this._searchPaginationView.render().el);
    },
  
    _onCancel: function _onCancel() {
      this._modalModel.destroy();
    },
  
    _onBack: function _onBack() {
      this._modalModel.destroy();
      this._onBack();
    },
  
    _onSave: function _onSave() {
      var permission = this._visDefinitionModel.getPermissionModel();
      permission.overwriteAcl(this._sharePermissionModel);
      // Show loading here
      permission.save().fail(this._searchPaginationView.showError.bind(this._searchPaginationView));
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/publish/share/user-view.js":
  /*!*************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/publish/share/user-view.js ***!
    \*************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./user.tpl */ "./lib/assets/javascripts/builder/components/modals/publish/share/user.tpl");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  
  var REQUIRED_OPTS = ['username', 'avatar'];
  
  module.exports = CoreView.extend({
  
    initialize: function initialize(opts) {
      _.each(REQUIRED_OPTS, function (item) {
        if (opts[item] === undefined) throw new Error(item + ' is required');
        this['_' + item] = opts[item];
      }, this);
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template({
        avatar: this._avatar,
        username: this._username
      }));
  
      this._initViews();
      return this;
    },
  
    _initViews: function _initViews() {
      var tooltip = new TipsyTooltipView({
        el: this.$('.js-avatar'),
        title: function title() {
          return $(this).attr('data-title');
        }
      });
  
      this.addView(tooltip);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/publish/share/users-group-view.js":
  /*!********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/publish/share/users-group-view.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var template = __webpack_require__(/*! ./users-group.tpl */ "./lib/assets/javascripts/builder/components/modals/publish/share/users-group.tpl");
  var UserView = __webpack_require__(/*! ./user-view */ "./lib/assets/javascripts/builder/components/modals/publish/share/user-view.js");
  
  var REQUIRED_OPTS = ['users'];
  
  var MAX_USERS_TO_SHOW = 3;
  
  module.exports = CoreView.extend({
    initialize: function initialize(opts) {
      _.each(REQUIRED_OPTS, function (item) {
        if (!opts[item]) throw new Error(item + ' is required');
        this['_' + item] = opts[item];
      }, this);
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template({
        people: this._getRemainsPeople()
      }));
      this._renderUsers();
      return this;
    },
  
    _getRemainsPeople: function _getRemainsPeople() {
      return Math.max(0, this._users.length - MAX_USERS_TO_SHOW);
    },
  
    _renderUsers: function _renderUsers() {
      _.each(this._users.slice(0, MAX_USERS_TO_SHOW), this._renderUser, this);
    },
  
    _renderUser: function _renderUser(user) {
      var view = new UserView({
        username: user.username,
        avatar: user.avatar_url
      });
  
      this.$('.js-content').append(view.render().el);
      this.addView(view);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/publish/upgrade-view.js":
  /*!**********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/publish/upgrade-view.js ***!
    \**********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./upgrade.tpl */ "./lib/assets/javascripts/builder/components/modals/publish/upgrade.tpl");
  
  var CONTACT_LINK_TEMPLATE = _.template("<a href='mailto:<%- mail %>'><%- contact %></a>")({
    contact: _t('components.modals.publish.privacy.upgrade.contact'),
    mail: _t('components.modals.publish.privacy.upgrade.mail')
  });
  
  module.exports = CoreView.extend({
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this._initViews();
      return this;
    },
  
    _initViews: function _initViews() {
      var html = template({
        title: _t('components.modals.publish.privacy.upgrade.title'),
        desc: _t('components.modals.publish.privacy.upgrade.desc', {
          contact: CONTACT_LINK_TEMPLATE
        })
      });
      this.$el.html(html);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/sync-options/sync-options-modal-view.js":
  /*!**************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/sync-options/sync-options-modal-view.js ***!
    \**************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./sync-options-modal.tpl */ "./lib/assets/javascripts/builder/components/modals/sync-options/sync-options-modal.tpl");
  var renderLoading = __webpack_require__(/*! builder/components/loading/render-loading */ "./lib/assets/javascripts/builder/components/loading/render-loading.js");
  var ErrorView = __webpack_require__(/*! builder/components/error/error-view */ "./lib/assets/javascripts/builder/components/error/error-view.js");
  var errorParser = __webpack_require__(/*! builder/helpers/error-parser */ "./lib/assets/javascripts/builder/helpers/error-parser.js");
  
  module.exports = CoreView.extend({
    className: 'Dialog-content',
  
    events: {
      'click .js-confirm': '_onConfirm',
      'click .js-cancel': '_onCancel'
    },
  
    initialize: function initialize(opts) {
      if (!opts.modalModel) throw new Error('modalModel is required');
      if (!opts.syncModel) throw new Error('syncModel is required');
      if (!opts.tableName) throw new Error('tableName is required');
  
      this._syncModel = opts.syncModel;
      this._modalModel = opts.modalModel;
      this._tableName = opts.tableName;
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template({
        interval: this._syncModel.get('interval'),
        service: this._syncModel.get('service_name') || '',
        isExternalSource: this._syncModel.get('from_external_source'),
        url: this._getServiceURL()
      }));
    },
  
    _renderErrorView: function _renderErrorView(errorMessage) {
      var errorView = new ErrorView({
        title: _t('dataset.sync.error'),
        desc: errorMessage
      });
      this.$el.html(errorView.render().el);
      this.addView(errorView);
    },
  
    _renderLoadingView: function _renderLoadingView() {
      this.$el.html(renderLoading({
        title: _t('dataset.sync.loading', { tableName: this._tableName })
      }));
    },
  
    _getServiceURL: function _getServiceURL() {
      var serviceName = this._syncModel.get('service_name');
      var serviceItemId = this._syncModel.get('service_item_id');
      if (serviceName || serviceItemId) {
        if (serviceName === 'connector') {
          return this._obfuscatePassword(serviceItemId);
        }
        return serviceItemId;
      }
      return this._syncModel.get('url');
    },
  
    _onConfirm: function _onConfirm() {
      var interval = parseInt(this.$('[name="interval"]:checked').val(), 10);
      var opts = {
        wait: true,
        success: function () {
          this._modalModel.destroy();
        }.bind(this),
        error: function (mdl, e) {
          this._renderErrorView(errorParser(e));
        }.bind(this)
      };
  
      this._renderLoadingView();
  
      if (this._syncModel.get('interval') !== interval) {
        if (!interval) {
          this._syncModel.destroy(opts);
        } else {
          this._syncModel.save({
            interval: interval
          }, opts);
        }
      } else {
        this._modalModel.destroy();
      }
    },
  
    _onCancel: function _onCancel() {
      this._modalModel.destroy();
    },
  
    _obfuscatePassword: function _obfuscatePassword(text) {
      var pattern = /"password"\s*:\s*"[^"]*"/g;
      return text.replace(pattern, '"password":"******"');
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/modals/visualization-title-suffix-metadata.js":
  /*!*************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/modals/visualization-title-suffix-metadata.js ***!
    \*************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  module.exports = ' | CARTO';
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/no-results/render-no-results.js":
  /*!***********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/no-results/render-no-results.js ***!
    \***********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var template = __webpack_require__(/*! ./no-results.tpl */ "./lib/assets/javascripts/builder/components/no-results/no-results.tpl");
  
  /**
   * @param {Object} opts
   * @param {String=} opts.icon
   * @param {String=} opts.title
   * @param {String=} opts.desc
   */
  
  module.exports = function (opts) {
    return template({
      icon: opts.icon || 'CDB-IconFont-cockroach',
      title: opts.title || '',
      desc: opts.desc
    });
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/notifier/notifier-action-view.js":
  /*!************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/notifier/notifier-action-view.js ***!
    \************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  module.exports = CoreView.extend({
    tagName: 'button',
  
    initialize: function initialize(opts) {
      if (!opts.template) throw new Error('template is required');
      if (!opts.editorModel) throw new Error('editorModel is required');
      this.template = opts.template;
      this._editorModel = opts.editorModel;
      this._data = {};
      if (opts.model) {
        this._data = opts.model.toJSON();
      }
      this._initBinds();
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this._editorModel, 'change:edition', this._changeStyle);
      this.add_related_model(this._editorModel);
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this.$el.append(this.template(this._data));
      return this;
    },
  
    _changeStyle: function _changeStyle() {
      this.$('.js-theme').toggleClass('is-white', this._editorModel.isEditing());
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/notifier/notifier-collection.js":
  /*!***********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/notifier/notifier-collection.js ***!
    \***********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var NotifierModel = __webpack_require__(/*! ./notifier-model */ "./lib/assets/javascripts/builder/components/notifier/notifier-model.js");
  
  module.exports = Backbone.Collection.extend({
    model: function model(attrs, opts) {
      return new NotifierModel(attrs, opts);
    },
  
    findById: function findById(id) {
      return this.findWhere({ id: id });
    },
  
    addNotification: function addNotification(attrs, options) {
      var notification = this._findNotificationByAttrs(attrs);
  
      return notification ? notification.update(attrs) : this.add(attrs, options);
    },
  
    _findNotificationByAttrs: function _findNotificationByAttrs(attrs) {
      return this.findWhere({ info: attrs.info });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/notifier/notifier-item-view.js":
  /*!**********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/notifier/notifier-item-view.js ***!
    \**********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var Template = __webpack_require__(/*! ./notifier-item.tpl */ "./lib/assets/javascripts/builder/components/notifier/notifier-item.tpl");
  var ActionView = __webpack_require__(/*! ./notifier-action-view */ "./lib/assets/javascripts/builder/components/notifier/notifier-action-view.js");
  var closeTemplate = __webpack_require__(/*! ./notifier-close.tpl */ "./lib/assets/javascripts/builder/components/notifier/notifier-close.tpl");
  var actionTemplate = __webpack_require__(/*! ./notifier-action.tpl */ "./lib/assets/javascripts/builder/components/notifier/notifier-action.tpl");
  
  module.exports = CoreView.extend({
    className: 'Notifier-inner',
    tagName: 'li',
    events: {
      'click .js-close': '_closeHandler',
      'click .js-action': '_actionHandler'
    },
  
    initialize: function initialize(opts) {
      if (!opts.notifierModel) throw new Error('notifierModel is required');
      if (!opts.editorModel) throw new Error('editorModel is required');
  
      this._editorModel = opts.editorModel;
      this.template = this.options.template || Template;
      this._notifierModel = opts.notifierModel;
      this.$el.attr('id', this._notifierModel.get('id'));
  
      this._delay = this._notifierModel.get('delay') || this._notifierModel.get('defaultDelay');
  
      if (this._notifierModel.get('delay') && this._notifierModel.get('closable') !== false) {
        this._timeout = setTimeout(this._autoClose.bind(this), this._delay);
      }
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this._initViews();
      this._changeStyle();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this._notifierModel, 'change', this.render);
      this.listenTo(this._notifierModel, 'change:status', this._onChangeStatus);
      this.add_related_model(this._notifierModel);
  
      this.listenTo(this._editorModel, 'change:edition', this._changeStyle);
      this.add_related_model(this._editorModel);
    },
  
    _initViews: function _initViews() {
      var actionable = this._notifierModel.getButton();
      var closable = this._notifierModel.isClosable();
      var view = this.template({
        status: this._notifierModel.getStatus(),
        info: this._notifierModel.getInfo(),
        isActionable: actionable,
        isClosable: closable
      });
  
      this.$el.append(view);
  
      if (actionable) {
        this._createActionView(actionable);
      }
  
      if (closable) {
        this._createCloseView();
      }
    },
  
    _createActionView: function _createActionView(action) {
      var actionView = new ActionView({
        template: actionTemplate,
        className: 'js-action',
        model: this._notifierModel,
        editorModel: this._editorModel
      });
  
      this.$('.js-actionButton').append(actionView.render().el);
      this.addView(actionView);
    },
  
    _createCloseView: function _createCloseView() {
      var actionView = new ActionView({
        template: closeTemplate,
        className: 'CDB-Shape js-close',
        editorModel: this._editorModel
      });
  
      this.$('.js-closeButton').append(actionView.render().el);
      this.addView(actionView);
    },
  
    _closeHandler: function _closeHandler() {
      var status = this._notifierModel.getStatus();
      var action = this._notifierModel.getAction();
      this._notifierModel.trigger('notification:close', action || status);
      clearTimeout(this._timeout);
      if (this._notifierModel && this._notifierModel.collection) {
        this._notifierModel.collection.remove(this._notifierModel);
      }
    },
  
    _actionHandler: function _actionHandler() {
      var status = this._notifierModel.getStatus();
      var action = this._notifierModel.getAction();
      this._notifierModel.trigger('notification:action', action || status);
    },
  
    _changeStyle: function _changeStyle() {
      this.$('.Notifier-info').toggleClass('u-whiteTextColor', this._editorModel.isEditing());
      this.$('.Notifier-actions .CDB-Shape-close').toggleClass('is-blue', !this._editorModel.isEditing());
      this.$('.Notifier-actions .CDB-Shape-close').toggleClass('is-white', this._editorModel.isEditing());
    },
  
    _autoClose: function _autoClose() {
      this._notifierModel.set({ action: 'autoclose' }, { silent: true });
      this._closeHandler();
    },
  
    _onChangeStatus: function _onChangeStatus(model, status) {
      if ((status === 'success' || status === 'error') && this._notifierModel.get('closable') !== false && this._notifierModel.get('autoclosable') !== false) {
        this._timeout = setTimeout(this._autoClose.bind(this), this._delay);
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/notifier/notifier-model.js":
  /*!******************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/notifier/notifier-model.js ***!
    \******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  module.exports = Backbone.Model.extend({
    defaults: {
      status: 'idle',
      info: '',
      closable: true
    },
  
    initialize: function initialize(attrs, opts) {
      if (attrs.id === undefined) {
        this.set('id', 'notifier' + this.cid);
      }
  
      this.set('defaultDelay', opts.delay);
  
      if (opts.visDefinitionModel) {
        this._retriggerEvent(opts.visDefinitionModel, 'vis:reload');
        this._retriggerEvent(opts.visDefinitionModel, 'vis:error');
      }
    },
  
    isClosable: function isClosable() {
      return this.get('closable') === true;
    },
  
    updateClosable: function updateClosable(val) {
      this.set({ closable: val });
    },
  
    getButton: function getButton() {
      return this.get('button');
    },
  
    updateButton: function updateButton(val) {
      this.set({ button: val });
    },
  
    getStatus: function getStatus() {
      return this.get('status');
    },
  
    updateStatus: function updateStatus(val) {
      this.set({ status: val });
    },
  
    getInfo: function getInfo() {
      return this.get('info');
    },
  
    getAction: function getAction() {
      return this.get('action');
    },
  
    setAction: function setAction(val) {
      this.set({ action: val });
    },
  
    updateInfo: function updateInfo(val) {
      this.set({ info: val });
    },
  
    update: function update(state) {
      this.set(state);
    },
  
    _retriggerEvent: function _retriggerEvent(model, event) {
      model.on(event, function () {
        this.trigger(event, arguments);
      }, this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/notifier/notifier-view.js":
  /*!*****************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/notifier/notifier-view.js ***!
    \*****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var NotifierItemView = __webpack_require__(/*! ./notifier-item-view */ "./lib/assets/javascripts/builder/components/notifier/notifier-item-view.js");
  var template = __webpack_require__(/*! ./notifier.tpl */ "./lib/assets/javascripts/builder/components/notifier/notifier.tpl");
  
  module.exports = CoreView.extend({
    className: 'Notifier',
  
    initialize: function initialize(opts) {
      if (!opts.collection) throw new Error('collection is mandatory');
      if (!opts.editorModel) throw new Error('editorModel is mandatory');
  
      this._editorModel = opts.editorModel;
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template());
      this._renderAllSubviews();
      this._renderLoading();
      return this;
    },
  
    rebindEvents: function rebindEvents() {
      // Just in case
      this.stopListening(this.collection);
      this.stopListening(this._editorModel);
      this._initBinds();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this.collection, 'reset update change:status', this.render);
      this.add_related_model(this.collection);
  
      this.listenTo(this._editorModel, 'change:edition', this._changeStyle);
      this.add_related_model(this._editorModel);
    },
  
    _renderAllSubviews: function _renderAllSubviews() {
      this.collection.each(this._renderSubview, this);
    },
  
    _renderSubview: function _renderSubview(model) {
      var view = new NotifierItemView({
        notifierModel: model,
        editorModel: this._editorModel
      });
  
      var status = model.get('status');
      var container = status === 'success' || status === 'error' ? this._getDoneContainer() : this._getLoadingContainer();
      container.append(view.render().el);
      this.addView(view);
    },
  
    _removeSubview: function _removeSubview(model) {
      var id = model.get('id');
      var view = _.first(_.filter(this._subviews, function (subview) {
        return subview._notifierModel.get('id') === id;
      }));
  
      if (view) {
        this.removeView(view);
        view.remove();
      }
    },
  
    _renderLoading: function _renderLoading() {
      this._getLoader().toggleClass('is-visible', this._anyNotificationLoading());
    },
  
    _anyNotificationLoading: function _anyNotificationLoading() {
      return this.collection.any(function (model) {
        return !_.contains(['success', 'error', 'warning'], model.get('status'));
      });
    },
  
    _changeStyle: function _changeStyle() {
      this.$el.toggleClass('is-dark', this._editorModel.isEditing());
    },
  
    _getDoneContainer: function _getDoneContainer() {
      return this.$('.js-status-done');
    },
  
    _getLoadingContainer: function _getLoadingContainer() {
      return this.$('.js-status-loading');
    },
  
    _getLoader: function _getLoader() {
      return this.$('.js-loader');
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/notifier/notifier.js":
  /*!************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/notifier/notifier.js ***!
    \************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var NotifierView = __webpack_require__(/*! ./notifier-view */ "./lib/assets/javascripts/builder/components/notifier/notifier-view.js");
  var NotifierCollection = __webpack_require__(/*! ./notifier-collection */ "./lib/assets/javascripts/builder/components/notifier/notifier-collection.js");
  
  var manager = function () {
    var initialized = false;
    var notifierView;
    var collection = new NotifierCollection();
    var editorModel;
  
    function _init(opts) {
      if (!editorModel && !opts) {
        throw new Error('editorModel is required');
      }
  
      if (!editorModel && opts && opts.editorModel) {
        editorModel = opts.editorModel;
      }
  
      initialized = true;
      notifierView = new NotifierView({
        collection: collection,
        editorModel: editorModel
      });
    }
  
    return {
      DEFAULT_DELAY: 5000,
      init: function init(opts) {
        if (opts.visDefinitionModel) {
          this._visDefinitionModel = opts.visDefinitionModel;
        }
        _init(opts);
      },
  
      // For testing porposes only
      off: function off() {
        if (false) {}
      },
  
      getView: function getView() {
        if (!initialized) _init();
        return notifierView.rebindEvents();
      },
  
      getCollection: function getCollection() {
        return collection;
      },
  
      getCount: function getCount() {
        return collection.size();
      },
  
      getNotification: function getNotification(model) {
        return typeof model === 'string' ? collection.findById(model) : collection.findById(model.id);
      },
  
      addNotification: function addNotification(attrs) {
        return collection.addNotification(attrs, {
          visDefinitionModel: this._visDefinitionModel,
          delay: this.DEFAULT_DELAY
        });
      },
  
      removeNotification: function removeNotification(model) {
        var notification = typeof model === 'string' ? collection.findById(model) : collection.findById(model.id);
  
        return collection.remove(notification);
      }
    };
  }();
  
  module.exports = manager;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/pagination-search/pagination-search-model.js":
  /*!************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/pagination-search/pagination-search-model.js ***!
    \************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   * Model representing the query string params for a "paged search" of a collection (matching the server-side APIs).
   *
   * @example usage
   *   pagedSearch = new PaginationSearchModel({  })
   *   pagedSearch.fetch(collection) // => jqXHR, GET /collection/123?page=1&per_page20
   *   pagedSearch.set({ page: 2, per_page: 10, q: 'test' });
   *   pagedSearch.fetch(collection) // => GET /collection/123?page=2&per_page10&q=test
   */
  module.exports = Backbone.Model.extend({
  
    defaults: {
      per_page: 20,
      page: 1,
      q: ''
    },
  
    initialize: function initialize(attrs, opts) {
      if (!opts.collection) throw new Error('collection is required');
      if (!opts.collection.totalCount) throw new Error('collection requires to implement totalCount method');
  
      this.collection = opts.collection;
      this._initBinds();
    },
  
    _initBinds: function _initBinds() {
      this.collection.on('sync', this._updateStateFetched, this);
      this.collection.on('error', this._updateStateError, this);
    },
  
    fetch: function fetch() {
      this.trigger('fetching', this);
      return this.collection.fetch({
        data: this.attributes
      }, { reset: true });
    },
  
    _updateStateFetched: function _updateStateFetched() {
      this.trigger('fetched', this);
    },
  
    _updateStateError: function _updateStateError() {
      this.trigger('error', this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/pagination-search/pagination-search-view.js":
  /*!***********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/pagination-search/pagination-search-view.js ***!
    \***********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var PaginationModel = __webpack_require__(/*! builder/components/pagination/pagination-model */ "./lib/assets/javascripts/builder/components/pagination/pagination-model.js");
  var PaginationSearchModel = __webpack_require__(/*! ./pagination-search-model */ "./lib/assets/javascripts/builder/components/pagination-search/pagination-search-model.js");
  var renderLoading = __webpack_require__(/*! builder/components/loading/render-loading */ "./lib/assets/javascripts/builder/components/loading/render-loading.js");
  var renderNoResults = __webpack_require__(/*! builder/components/no-results/render-no-results */ "./lib/assets/javascripts/builder/components/no-results/render-no-results.js");
  var ErrorView = __webpack_require__(/*! builder/components/error/error-view */ "./lib/assets/javascripts/builder/components/error/error-view.js");
  var template = __webpack_require__(/*! ./pagination-search.tpl */ "./lib/assets/javascripts/builder/components/pagination-search/pagination-search.tpl");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var PaginationView = __webpack_require__(/*! builder/components/pagination/pagination-view */ "./lib/assets/javascripts/builder/components/pagination/pagination-view.js");
  var paginationTemplate = __webpack_require__(/*! ./pagination.tpl */ "./lib/assets/javascripts/builder/components/pagination-search/pagination.tpl");
  
  /**
   * View to render a searchable/pageable collection.
   * Also allows to filter/search list.
   *
   */
  
  var REQUIRED_OPTS = ['listCollection', 'createContentView'];
  
  var ENTER_KEY_CODE = 13;
  var ESCAPE_KEY_CODE = 27;
  
  module.exports = CoreView.extend({
  
    events: {
      'click .js-search-link': '_onSearchClick',
      'click .js-clean-search': '_onCleanSearchClick',
      'keydown .js-search-input': '_onKeyDown'
    },
  
    initialize: function initialize(opts) {
      _.each(REQUIRED_OPTS, function (item) {
        if (opts[item] === undefined) throw new Error(item + ' is required');
        this['_' + item] = opts[item];
      }, this);
  
      this._paginationModel = new PaginationModel({
        current_page: 1
      });
  
      this._paginationSearchModel = new PaginationSearchModel({}, {
        collection: this._listCollection
      });
  
      this._stateModel = new Backbone.Model({
        state: 'idle'
      });
  
      this._initBinds();
      this._initPagination();
      this._paginationSearchModel.fetch();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.html(template({
        q: this._paginationSearchModel.get('q')
      }));
      this._initViews();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this._paginationSearchModel.on('fetching', this.showLoading, this);
      this._paginationSearchModel.on('fetched', this._updateStateFetched, this);
      this._paginationSearchModel.on('error', this.showError, this);
  
      this._paginationModel.bind('change:current_page', this._fetchByPagination, this);
  
      this._stateModel.on('change:state', this.render, this);
  
      this.add_related_model(this._paginationModel);
      this.add_related_model(this._stateModel);
      this.add_related_model(this._stateModel);
    },
  
    _fetchByPagination: function _fetchByPagination() {
      this._paginationSearchModel.set('page', this._paginationModel.get('current_page'));
      this._paginationSearchModel.fetch();
    },
  
    showError: function showError() {
      this._stateModel.set('state', 'error');
    },
  
    showLoading: function showLoading() {
      this._stateModel.set('state', 'loading');
    },
  
    _updateStateFetched: function _updateStateFetched() {
      this._paginationModel.set({
        per_page: this._paginationSearchModel.get('per_page'),
        total_count: this._listCollection.totalCount()
      });
      if (this._listCollection.length > 0) {
        this._stateModel.set('state', 'show');
      } else {
        this._stateModel.set('state', 'no-results');
      }
    },
  
    _initPagination: function _initPagination() {
      this._paginationView = new PaginationView({
        className: 'Pagination Pagination--search Pagination--searchShare',
        model: this._paginationModel,
        template: paginationTemplate
      });
      this.addView(this._paginationView);
    },
  
    _initViews: function _initViews() {
      var state = this._stateModel.get('state');
      var view;
  
      this.$el.append(this._paginationView.render().el);
  
      if (state === 'loading') {
        this._content().html(renderLoading({
          title: _t('components.pagination-search.loading.title')
        }));
      }
  
      if (state === 'error') {
        var errorView = new ErrorView({
          title: _t('components.pagination-search.error.title'),
          desc: _t('components.pagination-search.error.desc')
        });
        this._content().html(errorView.render().el);
        this.addView(errorView);
      }
  
      if (state === 'show') {
        view = this._createContentView({
          hasOrganization: this._paginationSearchModel.get('q') === ''
        });
        this._content().html(view.render().el);
        this.addView(view);
      }
  
      if (state === 'no-results') {
        this._content().html(renderNoResults({
          icon: 'CDB-IconFont-defaultUser',
          title: _t('components.pagination-search.no-results.title'),
          desc: _t('components.pagination-search.no-results.desc')
        }));
      }
    },
  
    _focusSearchInput: function _focusSearchInput() {
      this._searchInput().focus().val();
    },
  
    _onSearchClick: function _onSearchClick(e) {
      this.killEvent(e);
      this._searchInput().focus();
    },
  
    _onCleanSearchClick: function _onCleanSearchClick(e) {
      this.killEvent(e);
      this._cleanSearch();
    },
  
    _onKeyDown: function _onKeyDown(e) {
      if (e.which === ENTER_KEY_CODE) {
        this.killEvent(e);
        this._submitSearch();
      } else if (e.which === ESCAPE_KEY_CODE) {
        if (this._paginationSearchModel.get('q')) {
          this.killEvent(e);
          this._cleanSearch();
        }
      }
    },
  
    _submitSearch: function _submitSearch(e) {
      this._makeNewSearch(Utils.stripHTML(this._searchInput().val().trim()));
    },
  
    _cleanSearch: function _cleanSearch() {
      this._searchInput().val('');
      this._makeNewSearch('');
    },
  
    _makeNewSearch: function _makeNewSearch(query) {
      this._paginationSearchModel.set({
        q: query,
        page: 1
      });
  
      this._paginationSearchModel.fetch();
    },
  
    _searchInput: function _searchInput() {
      return this.$('.js-search-input');
    },
  
    _cleanSearchBtn: function _cleanSearchBtn() {
      return this.$('.js-clean-search');
    },
  
    _content: function _content() {
      return this.$('.js-content');
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/pagination/pagination-model.js":
  /*!**********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/pagination/pagination-model.js ***!
    \**********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  /**
   * View model intended to be responsible for pagination logic, and to be used in conjunction with a Pagination view.
   */
  module.exports = Backbone.Model.extend({
    defaults: {
      total_count: 0,
      per_page: 10,
      current_page: 1,
      display_count: 5,
      extras_display_count: 1,
      url_to: undefined
    },
  
    pagesCount: function pagesCount() {
      return Math.max(Math.ceil(this.get('total_count') / this.get('per_page')), 1);
    },
  
    isCurrentPage: function isCurrentPage(page) {
      return this.get('current_page') === page;
    },
  
    shouldBeVisible: function shouldBeVisible() {
      var pagesCount = this.pagesCount();
      return this.get('total_count') > 0 && pagesCount > 1 && this.get('current_page') <= pagesCount;
    },
  
    urlTo: function urlTo(page) {
      if (this.hasUrl()) {
        return this.get('url_to')(page);
      }
    },
  
    hasUrl: function hasUrl() {
      return typeof this.get('url_to') === 'function';
    },
  
    /**
     * Get the pages that are expected to be displayed.
     * The current page will be in the middle of the returned sequence.
     *
     * @returns {number[]} a sequence of Numbers
     */
    pagesToDisplay: function pagesToDisplay() {
      var rangeStart;
  
      if (this._inLowRange()) {
        rangeStart = 1;
      } else if (this._inHighRange()) {
        rangeStart = this.get('current_page') - this._startOffset();
      } else {
        // Somewhere between the low and high boundary
        rangeStart = this.pagesCount() - this.get('display_count') + 1;
      }
      rangeStart = Math.max(rangeStart, 1);
  
      return this._withExtraPages(_.range(rangeStart, this._rangeEnd(rangeStart)));
    },
  
    _withExtraPages: function _withExtraPages(pagesRelativeToCurrentPage) {
      var lastPage = this.pagesCount();
      var extraCount = this.get('extras_display_count');
      var extraStartPages = _.range(1, extraCount + 1);
      var extraEndPages = _.range(lastPage - extraCount + 1, lastPage + 1);
  
      var startPagesDiff = pagesRelativeToCurrentPage[0] - extraStartPages.slice(-1)[0];
      if (startPagesDiff === 2) {
        // There is only one missing page in the gap, so add it
        extraStartPages.push(pagesRelativeToCurrentPage[0] - 1);
      } else if (startPagesDiff > 2) {
        // There are more hidden pages at low range, add padding at end
        extraStartPages.push(-1);
      }
  
      var endPagesDiff = extraEndPages[0] - pagesRelativeToCurrentPage.slice(-1);
      if (endPagesDiff === 2) {
        // There is only one missing page in the gap, so add it
        extraEndPages.unshift(extraEndPages[0] - 1);
      }if (endPagesDiff > 2) {
        // There are more hidden pages at high range, add padding at beginning
        extraEndPages.unshift(-2);
      }
  
      return _.union(extraStartPages, pagesRelativeToCurrentPage, extraEndPages);
    },
  
    _inLowRange: function _inLowRange() {
      return this.get('current_page') < this._startOffset();
    },
  
    _inHighRange: function _inHighRange() {
      return this.get('current_page') < this._highBoundary();
    },
  
    _highBoundary: function _highBoundary() {
      return this.pagesCount() - this._startOffset();
    },
  
    _startOffset: function _startOffset() {
      return Math.floor(this.get('display_count') / 2);
    },
  
    _rangeEnd: function _rangeEnd(rangeStart) {
      // If we are too close to the range end then cap to the pages count.
      return Math.min(rangeStart + this.get('display_count'), this.pagesCount() + 1);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/pagination/pagination-view.js":
  /*!*********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/pagination/pagination-view.js ***!
    \*********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var navigateThroughRouter = __webpack_require__(/*! builder/helpers/navigate-through-router */ "./lib/assets/javascripts/builder/helpers/navigate-through-router.js");
  var template = __webpack_require__(/*! ./pagination.tpl */ "./lib/assets/javascripts/builder/components/pagination/pagination.tpl");
  
  /**
   * Responsible for pagination.
   *
   * Expected to be created with a pagination model, see the model for available params, here we create w/ the minimum:
   *   new PaginationView({
   *     model: new PaginationModel({
   *       // Compulsory:
   *       urlTo:  function(page) { return '/?page='+ page },
  
           // Optional, to router clicks on <a> tags through router.navigate by default
   *       routerModel: new Router(...)
   *     })
   *   });
   */
  module.exports = CoreView.extend({
    className: 'Pagination',
  
    events: {
      'click .js-listItem': '_paginate'
    },
  
    initialize: function initialize(opts) {
      this._routerModel = opts.routerModel; // Optional
  
      if (this.router && !this.model.hasUrl()) {
        throw new Error('since router is set the model must have a url method set too');
      }
  
      this.template = opts.template || template;
      this.model.bind('change', this.render, this);
    },
  
    render: function render() {
      if (this.model.shouldBeVisible()) {
        this.$el.html(this.template({
          m: this.model,
          pagesCount: this.model.pagesCount(),
          currentPage: this.model.get('current_page')
        }));
        this.$el.addClass(this.className);
        this.delegateEvents();
      } else {
        this.$el.html('');
      }
  
      return this;
    },
  
    _paginate: function _paginate(ev) {
      if (this._routerModel) {
        navigateThroughRouter.apply(this, arguments);
      } else if (!this.model.hasUrl()) {
        this.killEvent(ev);
      }
  
      var page = $(ev.target).data('page');
      this.model.set('current_page', page);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/popup-manager.js":
  /*!********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/popup-manager.js ***!
    \********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  
  var MutationObserver = window.MutationObserver;
  
  var MARGINS = {
    top: 8,
    bottom: 8
  };
  
  var initObserver = function initObserver(popup, onChangeMutation) {
    var config = {
      childList: true,
      subtree: true
    };
  
    if (!MutationObserver) {
      return;
    }
  
    var observer = new MutationObserver(onChangeMutation);
    observer.observe(popup.get ? popup.get(0) : popup, config);
    return observer;
  };
  
  var initScroll = function initScroll(reference) {
    return reference.closest('.js-perfect-scroll');
  };
  
  var Manager = function Manager(id, reference, popup) {
    this.id = id;
    this.reference = reference;
    this.popup = popup;
    this.state = {
      position: 'bottom',
      scroll: 0
    };
  
    // to capture click events and avoid close the dialog
    popup.attr('data-cid', id);
    popup.attr('data-dialog', id);
  };
  
  Manager.prototype = {
    append: function append(mode) {
      this.mode = mode;
      var popup = this.popup.get(0);
      var ref = this.reference.get(0);
      if (mode === 'float') {
        document.body.appendChild(popup);
      } else {
        ref.appendChild(popup);
      }
    },
  
    track: function track() {
      if (this.mode !== 'float') {
        return;
      }
  
      // we need to watch when the dialog's height changes in order to reposition it again
      this.observer = initObserver(this.popup, this.onChangeMutation.bind(this));
      this.emitter = initScroll(this.reference);
      this.repositionBinded = _.throttle(this.reposition.bind(this), 15);
  
      if (this.emitter) {
        this.emitter.on('ps-scroll-x', this.repositionBinded).on('ps-scroll-y', this.repositionBinded);
      }
  
      this.reposition();
    },
  
    onChangeMutation: function onChangeMutation(mutations) {
      _.each(mutations, function (mutation) {
        var target = $(mutation.target);
        var id = target.attr('data-cid');
  
        if (!id) {
          id = target.closest('[data-cid]').attr('data-cid');
        }
  
        if (id === this.id) {
          this.repositionBinded();
        }
      }, this);
    },
  
    reposition: function reposition() {
      if (this.mode !== 'float' || !this.emitter) {
        return;
      }
  
      var scroll = this.emitter.get(0).scrollTop;
  
      var dh = $(window).height();
      var ref = this.reference;
      var popup = this.popup;
      var state = this.state;
  
      var refPosition = ref.offset();
      var ph = popup.outerHeight();
  
      var onBottom = refPosition.top + ref.outerHeight() + MARGINS.top;
      var onTop = refPosition.top - ph - MARGINS.bottom;
      var top;
  
      // If this condition matches, the dialog has changed its size
      if (state.scroll === scroll) {
        // We maintain position unless there is no space
        if (state.position === 'top') {
          if (onTop <= 0) {
            top = onBottom;
            state.position = 'bottom';
          } else {
            top = onTop;
          }
        } else {
          if (onBottom + ph + MARGINS.bottom >= dh) {
            top = onTop;
            state.position = 'top';
          } else {
            top = onBottom;
          }
        }
      } else {
        if (onBottom + ph + MARGINS.bottom >= dh) {
          top = onTop;
          state.position = 'top';
        } else {
          top = onBottom;
          state.position = 'bottom';
        }
      }
  
      // Boundries come from document height to avoid scroll
      if (top < 0) {
        top = MARGINS.top;
      } else {
        top = Math.min(top, dh - ph - MARGINS.bottom);
      }
  
      popup.css({
        top: top,
        left: refPosition.left
      });
  
      state.scroll = scroll;
    },
  
    untrack: function untrack() {
      this.observer && this.observer.disconnect();
      if (this.emitter) {
        this.emitter.off('ps-scroll-x', this.repositionBinded).off('ps-scroll-y', this.repositionBinded);
      }
    },
  
    destroy: function destroy() {
      this.untrack();
  
      var el = document.querySelector('[data-dialog=' + this.id + ']');
      if (el) {
        el.parentNode.removeChild(el);
      }
  
      this.emitter = null;
      this.reference = null;
      this.popup = null;
    }
  };
  
  module.exports = Manager;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/privacy-dropdown/password-dialog-view.js":
  /*!********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/privacy-dropdown/password-dialog-view.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./password-dialog.tpl */ "./lib/assets/javascripts/builder/components/privacy-dropdown/password-dialog.tpl");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  var REQUIRED_OPTS = ['onBack', 'onEdit'];
  
  var ESCAPE_KEY_CODE = 27;
  var ENTER_KEY_CODE = 13;
  
  module.exports = CoreView.extend({
    className: 'Editor-boxModal Editor-PrivacyDialog',
  
    events: {
      'click .js-back': '_onClickBack',
      'keyup .js-input': '_onKeyUpInput'
    },
  
    initialize: function initialize(opts) {
      _.each(REQUIRED_OPTS, function (item) {
        if (opts[item] === undefined) throw new Error(item + ' is required');
        this['_' + item] = opts[item];
      }, this);
    },
  
    render: function render() {
      this.$el.empty();
      this.$el.html(template());
      return this;
    },
  
    _onKeyUpInput: function _onKeyUpInput(e) {
      if (e.which === ESCAPE_KEY_CODE) {
        this._onBack();
      }
  
      if (e.which === ENTER_KEY_CODE) {
        this._onEdit && this._onEdit(this.getValue());
      }
    },
  
    _onClickBack: function _onClickBack() {
      this._onBack();
    },
  
    getValue: function getValue() {
      return this.$('.js-input').val();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/privacy-dropdown/privacy-dialog-view.js":
  /*!*******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/privacy-dropdown/privacy-dialog-view.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var CustomListView = __webpack_require__(/*! builder/components/custom-list/custom-list-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-view.js");
  var CustomListItemView = __webpack_require__(/*! builder/components/custom-list/custom-list-item-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item-view.js");
  var privacyCTATemplate = __webpack_require__(/*! ./privacy-cta.tpl */ "./lib/assets/javascripts/builder/components/privacy-dropdown/privacy-cta.tpl");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  var REQUIRED_OPTS = ['model', 'collection', 'userModel', 'configModel'];
  
  module.exports = CoreView.extend({
    className: 'Editor-boxModal Privacy-dialog',
  
    initialize: function initialize(opts) {
      _.each(REQUIRED_OPTS, function (item) {
        if (opts[item] === undefined) throw new Error(item + ' is required');
        this['_' + item] = opts[item];
      }, this);
    },
  
    render: function render() {
      this.$el.empty();
      this.clearSubViews();
      this._renderList();
      return this;
    },
  
    _renderList: function _renderList() {
      var disabledOptions = this._collection.where({ disabled: true });
      var customInstall = this._configModel.get('cartodb_com_hosted');
      var upgradeURL = this._configModel.get('upgrade_url');
  
      var listView = new CustomListView({
        model: this._model,
        collection: this._collection,
        itemView: CustomListItemView
      });
      this.$el.append(listView.render().el);
      this.addView(listView);
  
      if (disabledOptions.length > 0 && !customInstall && upgradeURL) {
        this.$el.append(privacyCTATemplate({
          upgradeURL: upgradeURL,
          showTrial: this._userModel.canStartTrial()
        }));
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/privacy-dropdown/privacy-dropdown-view.js":
  /*!*********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/privacy-dropdown/privacy-dropdown-view.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var PrivacyDialogView = __webpack_require__(/*! ./privacy-dialog-view */ "./lib/assets/javascripts/builder/components/privacy-dropdown/privacy-dialog-view.js");
  var PrivacyWarningView = __webpack_require__(/*! builder/components/modals/privacy-warning/privacy-warning-view */ "./lib/assets/javascripts/builder/components/modals/privacy-warning/privacy-warning-view.js");
  var PasswordDialogView = __webpack_require__(/*! ./password-dialog-view */ "./lib/assets/javascripts/builder/components/privacy-dropdown/password-dialog-view.js");
  var TabPaneView = __webpack_require__(/*! builder/components/tab-pane/tab-pane-view */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-view.js");
  var TabPaneCollection = __webpack_require__(/*! builder/components/tab-pane/tab-pane-collection */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-collection.js");
  var CustomListCollection = __webpack_require__(/*! builder/components/custom-list/custom-list-collection */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-collection.js");
  var ModalsServiceModel = __webpack_require__(/*! builder/components/modals/modals-service-model */ "./lib/assets/javascripts/builder/components/modals/modals-service-model.js");
  var template = __webpack_require__(/*! ./privacy-dropdown.tpl */ "./lib/assets/javascripts/builder/components/privacy-dropdown/privacy-dropdown.tpl");
  var templateTabPane = __webpack_require__(/*! ./tab-pane.tpl */ "./lib/assets/javascripts/builder/components/privacy-dropdown/tab-pane.tpl");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  var VisDefinitionModel = __webpack_require__(/*! builder/data/vis-definition-model */ "./lib/assets/javascripts/builder/data/vis-definition-model.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var ErrorDetailsView = __webpack_require__(/*! builder/components/background-importer/error-details-view */ "./lib/assets/javascripts/builder/components/background-importer/error-details-view.js");
  
  var ESCAPE_KEY_CODE = 27;
  
  var REQUIRED_OPTS = ['visDefinitionModel', 'userModel', 'privacyCollection', 'configModel', 'isOwner'];
  
  var PRIVACY_MAP = {
    public: 'green',
    link: 'orange',
    password: 'orange-dark',
    private: 'red'
  };
  
  module.exports = CoreView.extend({
  
    events: {
      'click .js-toggle': '_onToggleDialogClicked'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      if (this._visDefinitionModel.isVisualization() && !this.options.mapcapsCollection) {
        throw new Error('mapcapsCollection is required for visualizations');
      }
  
      this._triggerElementID = 'toggle' + this.cid;
  
      this._modals = new ModalsServiceModel();
      this.model = new Backbone.Model({
        privacy: opts.visDefinitionModel.get('privacy'),
        state: 'show'
      });
  
      this._onEscapePressed = this._onEscapePressed.bind(this);
      this._onDocumentElementClicked = this._onDocumentElementClicked.bind(this);
  
      if (this.options.ownerName) {
        this._ownerName = this.options.ownerName;
      }
  
      if (this.options.mapcapsCollection) {
        this._mapcapsCollection = this.options.mapcapsCollection;
      }
  
      this._configPrivacyCollection();
      this._configPanes();
      this._initBinds();
    },
  
    render: function render() {
      var privacy = this.model.get('privacy');
      if (this.model.get('state') === 'error') {
        privacy = this.options.visDefinitionModel.get('privacy');
      }
      var cssClass = PRIVACY_MAP[privacy.toLowerCase()];
      var canChangePrivacy = this._canChangePrivacy(privacy);
  
      this.clearSubViews();
      this._hideDialog();
      this.$el.html(template({
        privacy: privacy,
        cssClass: cssClass,
        isLoading: this.model.get('state') === 'loading',
        isOwner: this._isOwner,
        canChangePrivacy: canChangePrivacy
      }));
      this._initViews();
      return this;
    },
  
    _canChangePrivacy: function _canChangePrivacy(privacy) {
      var isIndividualUser = this.options.userModel.isIndividualUser();
      var isMap = this.options.visDefinitionModel.isVisualization();
      var hasRemainingPublicMaps = this.options.userModel.hasRemainingPublicMaps();
      if (isIndividualUser && isMap && !hasRemainingPublicMaps && privacy === 'PRIVATE') {
        return false;
      }
      return true;
    },
  
    _initBinds: function _initBinds() {
      this._customCollection.on('change:selected', function (menuItem) {
        if (menuItem.get('disabled')) {
          return;
        }
  
        if (menuItem.get('val') === 'password') {
          this._showPasswordDialog();
        } else {
          this._onToggleDialogClicked();
          this._setPrivacy(menuItem.get('val'));
        }
      }, this);
  
      this.add_related_model(this._customCollection);
  
      this.model.on('change:state', this.render, this);
      this.add_related_model(this.model); // explicit
    },
  
    _makePrivacyDialog: function _makePrivacyDialog() {
      return new PrivacyDialogView({
        model: this.model,
        collection: this._customCollection,
        userModel: this._userModel,
        configModel: this._configModel
      });
    },
  
    _makePasswordDialog: function _makePasswordDialog() {
      return new PasswordDialogView({
        onBack: this._showPrivacyDialog.bind(this),
        onEdit: this._setPassword.bind(this)
      });
    },
  
    _setPassword: function _setPassword(password) {
      if (password !== '') {
        this._privacyCollection.passwordOption().set({
          password: password
        });
  
        this.model.set({ password: password });
        this._setPrivacy('password');
      }
    },
  
    _setPrivacy: function _setPrivacy(privacyStatus) {
      var newPrivacyStatus = privacyStatus.toUpperCase();
  
      this.model.set({ privacy: newPrivacyStatus }, { silent: true });
  
      if (this._shouldShowPrivacyWarning(newPrivacyStatus)) {
        this._checkPrivacyChange(newPrivacyStatus, this._savePrivacy.bind(this), this._discardPrivacyChange.bind(this));
      } else {
        this._savePrivacy();
      }
    },
  
    _savePrivacy: function _savePrivacy() {
      var self = this;
      var vis = this._visDefinitionModel;
  
      this.model.set({ state: 'loading' });
  
      this._privacyCollection.searchByPrivacy(this.model.get('privacy')).saveToVis(vis, {
        success: function success() {
          self.model.set({ state: 'show' });
        },
        error: function error(req, resp) {
          if (resp.responseText.indexOf('over account public map quota') !== -1) {
            self._modals.create(function () {
              return new ErrorDetailsView({
                error: { errorCode: 8007 },
                userModel: self._userModel,
                configModel: self._configModel
              });
            });
          }
          self.model.set({ state: 'error' });
        }
      });
    },
  
    _checkPrivacyChange: function _checkPrivacyChange(newPrivacyStatus, confirmCallback, dismissCallback) {
      var self = this;
  
      this._modals.create(function (modalModel) {
        return new PrivacyWarningView({
          modalModel: modalModel,
          privacyType: newPrivacyStatus,
          type: self._visDefinitionModel.isVisualization() ? 'visualization' : 'dataset',
          onConfirm: confirmCallback,
          onDismiss: dismissCallback
        });
      });
    },
  
    _discardPrivacyChange: function _discardPrivacyChange() {
      var previousPrivacy = this.model.previous('privacy');
  
      this.model.set('privacy', previousPrivacy, { silent: true });
      this.model.set('state', 'show');
    },
  
    _shouldShowPrivacyWarning: function _shouldShowPrivacyWarning(privacyStatus) {
      if (!this._userModel.canSelectPremiumOptions(this._visDefinitionModel)) {
        return false;
      }
  
      var isPubliclyAvailable = VisDefinitionModel.isPubliclyAvailable(privacyStatus);
  
      if (this._visDefinitionModel.isVisualization()) {
        return !!this._mapcapsCollection.length && isPubliclyAvailable;
      }
  
      return isPubliclyAvailable;
    },
  
    _transformPrivacyOptions: function _transformPrivacyOptions() {
      return this._privacyCollection.map(function (item) {
        return {
          label: item.get('title'),
          val: item.get('privacy').toLowerCase(),
          disabled: item.get('disabled'),
          selected: item.get('selected'),
          renderOptions: {
            cssClass: item.get('cssClass')
          }
        };
      }).filter(Boolean);
    },
  
    _configPrivacyCollection: function _configPrivacyCollection() {
      var models = this._transformPrivacyOptions();
      this._customCollection = new CustomListCollection(models);
    },
  
    _configPanes: function _configPanes() {
      var self = this;
      var tabPaneTabs = [{
        createContentView: self._showNoneDialog
      }, {
        createContentView: self._makePrivacyDialog.bind(self)
      }, {
        createContentView: self._makePasswordDialog.bind(self)
      }];
  
      this._collectionPane = new TabPaneCollection(tabPaneTabs);
    },
  
    _showNoneDialog: function _showNoneDialog() {
      return false;
    },
  
    _showPasswordDialog: function _showPasswordDialog() {
      this._collectionPane.at(2).set({ selected: true });
    },
  
    _showPrivacyDialog: function _showPrivacyDialog() {
      this._customCollection.each(function (m) {
        m.set({ selected: false }, { silent: true });
      });
  
      this._collectionPane.at(1).set({ selected: true });
    },
  
    _onToggleDialogClicked: function _onToggleDialogClicked() {
      if (this._isDialogVisible()) {
        this._hideDialog();
      } else {
        this._onMouseClick();
        this._initDocumentBinds();
        this._showPrivacyDialog();
      }
    },
  
    _isDialogVisible: function _isDialogVisible() {
      return this._collectionPane.at(0).get('selected') === false;
    },
  
    _hideDialog: function _hideDialog() {
      this._destroyDocumentBinds();
      this._collectionPane.at(0).set({ selected: true });
    },
  
    _showDialog: function _showDialog() {
      this._showPrivacyDialog();
    },
  
    _initViews: function _initViews() {
      var view = new TabPaneView({
        collection: this._collectionPane,
        template: templateTabPane,
        mouseOverAction: this._onMouseClick.bind(this)
      });
      this.$('.js-dialog').append(view.render().$el);
      this.addView(view);
  
      this._privacyTooltip = new TipsyTooltipView({
        el: this.$('.js-tooltip'),
        gravity: 'w',
        html: true,
        title: function () {
          return this._getPrivacyInfo();
        }.bind(this)
      });
      this.addView(this._privacyTooltip);
    },
  
    _getPrivacyInfo: function _getPrivacyInfo() {
      var privacyInfo = _t('change-privacy');
  
      if (this._ownerName) {
        privacyInfo = _t('dataset.privacy.info', { name: this._ownerName });
      }
  
      return privacyInfo;
    },
  
    _initDocumentBinds: function _initDocumentBinds() {
      $(document).on('keydown', this._onEscapePressed);
      $(document).on('mousedown', this._onDocumentElementClicked);
    },
  
    _destroyDocumentBinds: function _destroyDocumentBinds() {
      $(document).off('keydown', this._onEscapePressed);
      $(document).off('mousedown', this._onDocumentElementClicked);
    },
  
    _onEscapePressed: function _onEscapePressed(ev) {
      if (ev.which === ESCAPE_KEY_CODE) {
        this._hideDialog();
      }
    },
  
    _onDocumentElementClicked: function _onDocumentElementClicked(ev) {
      var $el = $(ev.target);
      if ($el.closest(this.$el).length === 0 && $el.closest($('#' + this._triggerElementID)).length === 0) {
        this._hideDialog();
      }
    },
  
    _onMouseClick: function _onMouseClick() {
      this._privacyTooltip.hideTipsy();
    },
  
    clean: function clean() {
      this._destroyDocumentBinds();
      CoreView.prototype.clean.apply(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/scroll/scroll-view.js":
  /*!*************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/scroll/scroll-view.js ***!
    \*************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var Ps = __webpack_require__(/*! perfect-scrollbar */ "./node_modules/perfect-scrollbar/index.js");
  var template = __webpack_require__(/*! ./scroll.tpl */ "./lib/assets/javascripts/builder/components/scroll/scroll.tpl");
  var MutationObserver = window.MutationObserver;
  
  module.exports = CoreView.extend({
    tagName: 'div',
    className: 'ScrollView',
  
    initialize: function initialize(opts) {
      if (!opts.createContentView) throw new Error('A factory createContentView function is required');
      this.options = opts || {};
      this._type = opts.type || 'vertical'; // vertical or horizontal
      this._maxScroll = 0;
      this._bindedCheckShadows = this._checkShadows.bind(this);
    },
  
    render: function render() {
      this.clearSubViews();
      this._html();
  
      var view = this.options.createContentView.call(this);
      this._contentContainer().append(view.render().el);
      this.addView(view);
      this._applyScroll();
      this._updateScrollWhenExist();
      return this;
    },
  
    _html: function _html() {
      this.$el.html(template({
        type: this._type
      }));
  
      this._type === 'horizontal' && this.$el.addClass('ScrollView--horizontal');
    },
  
    _contentContainer: function _contentContainer() {
      return this.$('.js-content');
    },
  
    _wrapperContainer: function _wrapperContainer() {
      return this.$('.js-wrapper');
    },
  
    _updateScrollWhenExist: function _updateScrollWhenExist() {
      // Phantom doesn't provide this api for window.
      if (!MutationObserver) return;
  
      // even with the changes in PS, we need to check when this element is added to the dom
      // in order to trigger manually an update.
      var element = document.body;
      var self = this._wrapperContainer().get(0);
      var onMutationObserver = function onMutationObserver() {
        if (element.contains(self)) {
          Ps.update(self);
          observer.disconnect();
        }
      };
  
      var observer = new MutationObserver(onMutationObserver);
      onMutationObserver();
  
      var config = { subtree: true, childList: true };
      observer.observe(element, config);
    },
  
    _applyScroll: function _applyScroll() {
      Ps.initialize(this._wrapperContainer().get(0), {
        wheelSpeed: 2,
        wheelPropagation: true,
        stopPropagationOnClick: false,
        minScrollbarLength: 20,
        suppressScrollX: this._type === 'vertical',
        suppressScrollY: this._type === 'horizontal'
      });
  
      this._bindScroll();
    },
  
    _bindScroll: function _bindScroll() {
      this._wrapperContainer().on('ps-dom-change', this._bindedCheckShadows).on('ps-x-reach-start', this._bindedCheckShadows).on('ps-x-reach-end', this._bindedCheckShadows).on('ps-y-reach-start', this._bindedCheckShadows).on('ps-y-reach-end', this._bindedCheckShadows).on('ps-scroll-x', this._bindedCheckShadows).on('ps-scroll-y', this._bindedCheckShadows);
    },
  
    _unbindScroll: function _unbindScroll() {
      this._wrapperContainer().off('ps-dom-change', this._bindedCheckShadows).off('ps-x-reach-start', this._bindedCheckShadows).off('ps-x-reach-end', this._bindedCheckShadows).off('ps-y-reach-start', this._bindedCheckShadows).off('ps-y-reach-end', this._bindedCheckShadows).off('ps-scroll-x', this._bindedCheckShadows).off('ps-scroll-y', this._bindedCheckShadows);
    },
  
    _checkShadows: function _checkShadows() {
      var currentPos;
      var max;
      var width;
      var height;
      var maxPos;
  
      if (this._type === 'horizontal') {
        currentPos = this._wrapperContainer().scrollLeft();
        max = this._wrapperContainer().get(0).scrollWidth;
        width = this._wrapperContainer().outerWidth();
        maxPos = max - width;
  
        this.$('> .js-leftShadow').toggleClass('is-visible', currentPos > 0);
        this.$('> .js-rightShadow').toggleClass('is-visible', currentPos < maxPos);
      } else {
        currentPos = this._wrapperContainer().scrollTop();
        max = this._wrapperContainer().get(0).scrollHeight;
        height = this._wrapperContainer().outerHeight();
        maxPos = max - height;
  
        // We use the direct descendant selector to avoid affect others nested view with scroll
        this.$('> .js-topShadow').toggleClass('is-visible', currentPos > 0);
        this.$('> .js-bottomShadow').toggleClass('is-visible', currentPos < maxPos);
      }
    },
  
    destroyScroll: function destroyScroll() {
      if (this._wrapperContainer().length) {
        this._unbindScroll();
        Ps.destroy(this._wrapperContainer().get(0));
      }
    },
  
    clean: function clean() {
      this.destroyScroll();
      CoreView.prototype.clean.apply(this, arguments);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/stack-layout/stack-layout-model.js":
  /*!**************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/stack-layout/stack-layout-model.js ***!
    \**************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   *  Stack layout model checks and decides if next or previous
   *  positions are possible.
   */
  
  module.exports = Backbone.Model.extend({
  
    defaults: {
      position: 0
    },
  
    initialize: function initialize(attrs, opts) {
      this.stackLayoutItems = opts.stackLayoutItems;
    },
  
    goToStep: function goToStep(position) {
      var stackLayoutItemsSize = this.stackLayoutItems.size();
  
      if (position >= stackLayoutItemsSize) {
        throw new Error('There is no ' + position + ' stack view in the collection');
      } else {
        this.set({
          position: position
        }, {
          silent: true
        });
        this._rememberStep.apply(this, arguments);
        this._triggerPositionChanged(position, Array.prototype.slice.call(arguments, 1));
      }
    },
  
    nextStep: function nextStep() {
      var currentPos = this.get('position');
      var nextPosition = ++currentPos;
      this.goToStep.apply(this, Array.prototype.concat.apply([nextPosition], arguments));
    },
  
    prevStep: function prevStep() {
      var currentPos = this.get('position');
      var prevPosition = --currentPos;
      this.goToStep.apply(this, Array.prototype.concat.apply([prevPosition], arguments));
    },
  
    goBack: function goBack() {
      if (this._goBackToArguments) {
        this.goToStep.apply(this, this._goBackToArguments);
      }
    },
  
    _triggerPositionChanged: function _triggerPositionChanged(position, args) {
      this.trigger('positionChanged', position, Array.prototype.slice.call(args));
    },
  
    _rememberStep: function _rememberStep() {
      this._goBackToArguments = this._lastStepArguments || [0];
      this._lastStepArguments = arguments;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/stack-layout/stack-layout-view.js":
  /*!*************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/stack-layout/stack-layout-view.js ***!
    \*************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var StackLayoutModel = __webpack_require__(/*! ./stack-layout-model */ "./lib/assets/javascripts/builder/components/stack-layout/stack-layout-model.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  /**
   *  Stack layout view manages a "carousel" of views.
   *  They can go forward or backward.
   */
  
  module.exports = CoreView.extend({
    module: 'components:stack-layout:stack-layout-view',
  
    initialize: function initialize(opts) {
      if (!this.collection || !this.collection.size()) {
        throw new Error('A collection of stack views should be provided');
      }
      this.model = new StackLayoutModel({}, {
        stackLayoutItems: this.collection
      });
      this.model.bind('positionChanged', this._onPositionChange, this);
    },
  
    render: function render() {
      this.clearSubViews();
      this._genNewStackView();
      return this;
    },
  
    _onPositionChange: function _onPositionChange(newPos, opts) {
      this._removeOldStackView();
      this._genNewStackView(_.flatten(opts));
      this.trigger('positionChanged', this);
    },
  
    getCurrentPosition: function getCurrentPosition() {
      return this.model.get('position');
    },
  
    _removeOldStackView: function _removeOldStackView() {
      var oldView = this._getCurrentView();
      if (oldView) {
        oldView.clean();
        this.removeView(oldView);
      }
    },
  
    _getCurrentView: function _getCurrentView() {
      for (var key in this._subviews) {
        break;
      }return this._subviews[key];
    },
  
    _genNewStackView: function _genNewStackView() {
      var args = [this.model].concat([_.flatten(arguments)]);
      var nextView = this.collection.at(this.model.get('position')).get('createStackView').apply(this, args);
      this.addView(nextView);
  
      this.$el.html(nextView.render().el);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/tab-pane/create-mixed-labels-tab-pane.js":
  /*!********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/tab-pane/create-mixed-labels-tab-pane.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var TabPaneView = __webpack_require__(/*! ./tab-pane-view.js */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-view.js");
  var TabPaneCollection = __webpack_require__(/*! ./tab-pane-collection */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-collection.js");
  var MixedLabelView = __webpack_require__(/*! ./tab-pane-mixed-view */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-mixed-view.js");
  var ColorView = __webpack_require__(/*! ./tab-pane-color-view */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-color-view.js");
  
  /**
   * Creates a tab pane, where the menu consists of text labels.
   *
   * Example usage:
   * {
   *   label: 'My label',
   *   createContentView: CoreView(),
   *   selected: false
   * }
   *
   * @param {Array} paneItems
   * @param {Object} options
   * @return {Object} instance of CoreView
   */
  module.exports = function (paneItems, options) {
    options = options || {};
    var tabPaneItemLabelOptions = options.tabPaneItemLabelOptions;
  
    var items = paneItems.map(function (paneItem) {
      ['label', 'createContentView'].forEach(function (check) {
        if (!paneItem[check]) {
          throw new Error(check + ' should be provided');
        }
      });
  
      return {
        name: paneItem.name,
        selected: paneItem.selected,
        label: paneItem.label,
        color: paneItem.color,
        kind: paneItem.kind,
        selectedChild: paneItem.selectedChild,
        createButtonView: function createButtonView() {
          if (paneItem.type === 'color') {
            return new ColorView(_.extend({ model: this }, tabPaneItemLabelOptions));
          } else {
            return new MixedLabelView(_.extend({ model: this, type: paneItem.type }, tabPaneItemLabelOptions));
          }
        },
        createContentView: function createContentView() {
          return paneItem.createContentView && paneItem.createContentView() || new CoreView();
        }
      };
    });
  
    var collection = new TabPaneCollection(items);
  
    var tabPaneOptions = options.tabPaneOptions;
  
    return new TabPaneView(_.extend({ collection: collection }, tabPaneOptions));
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/tab-pane/create-radio-labels-tab-pane.js":
  /*!********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/tab-pane/create-radio-labels-tab-pane.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var TabPaneView = __webpack_require__(/*! ./tab-pane-view.js */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-view.js");
  var TabPaneCollection = __webpack_require__(/*! ./tab-pane-collection */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-collection.js");
  var RadioLabelView = __webpack_require__(/*! ./tab-pane-radio-label-view */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-radio-label-view.js");
  
  /**
   * Creates a tab pane, where the menu consists of radio inputs with labels.
   *
   * Example usage:
   * {
   *   label: 'My label',
   *   createContentView: CoreView(),
   *   selected: false
   * }
   *
   * @param {Array} paneItems
   * @param {Object} options
   * @return {Object} instance of CoreView
   */
  module.exports = function (paneItems, options) {
    options = options || {};
    var tabPaneItemLabelOptions = options.tabPaneItemLabelOptions;
  
    var items = paneItems.map(function (paneItem) {
      ['label', 'createContentView'].forEach(function (check) {
        if (!paneItem[check]) {
          throw new Error(check + ' should be provided');
        }
      });
  
      return {
        name: paneItem.name,
        selected: paneItem.selected,
        disabled: paneItem.disabled,
        tooltip: paneItem.tooltip,
        tooltipGravity: paneItem.tooltipGravity,
        label: paneItem.label,
        selectedChild: paneItem.selectedChild,
        createButtonView: function createButtonView() {
          return new RadioLabelView(_.extend({ model: this }, tabPaneItemLabelOptions));
        },
        createContentView: function createContentView() {
          return paneItem.createContentView && paneItem.createContentView() || new CoreView();
        }
      };
    });
  
    var collection = new TabPaneCollection(items);
  
    var tabPaneOptions = options.tabPaneOptions;
  
    return new TabPaneView(_.extend({ collection: collection }, tabPaneOptions));
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/tab-pane/create-text-labels-tab-pane.js":
  /*!*******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/tab-pane/create-text-labels-tab-pane.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var TabPaneView = __webpack_require__(/*! ./tab-pane-view.js */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-view.js");
  var TabPaneCollection = __webpack_require__(/*! ./tab-pane-collection */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-collection.js");
  var LabelView = __webpack_require__(/*! ./tab-pane-label-view */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-label-view.js");
  
  /**
   * Creates a tab pane, where the menu consists of text labels.
   *
   * Example usage:
   * {
   *   label: 'My label',
   *   createContentView: CoreView(),
   *   selected: false
   * }
   *
   * @param {Array} paneItems
   * @param {Object} options
   * @return {Object} instance of CoreView
   */
  module.exports = function (paneItems, options) {
    options = options || {};
    var tabPaneItemLabelOptions = options.tabPaneItemLabelOptions;
  
    var items = paneItems.map(function (paneItem) {
      ['label', 'createContentView'].forEach(function (check) {
        if (!paneItem[check]) {
          throw new Error(check + ' should be provided');
        }
      });
  
      return {
        name: paneItem.name,
        selected: paneItem.selected,
        disabled: paneItem.disabled,
        tooltip: paneItem.tooltip,
        label: paneItem.label,
        selectedChild: paneItem.selectedChild,
        createButtonView: function createButtonView() {
          return new LabelView(_.extend({ model: this }, tabPaneItemLabelOptions));
        },
        createContentView: function createContentView() {
          return paneItem.createContentView && paneItem.createContentView() || new CoreView();
        }
      };
    });
  
    var collection = new TabPaneCollection(items);
  
    var tabPaneOptions = options.tabPaneOptions;
  
    return new TabPaneView(_.extend({ collection: collection }, tabPaneOptions));
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-collection.js":
  /*!***********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/tab-pane/tab-pane-collection.js ***!
    \***********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  module.exports = Backbone.Collection.extend({
    constructor: function constructor(models, options) {
      options = _.extend(options || {}, { silent: false });
      Backbone.Collection.prototype.constructor.call(this, models, options);
    },
  
    initialize: function initialize(models, options) {
      this._disabledTabs = options.disabledTabs;
  
      this._initBinds();
  
      this._setSelected();
    },
  
    _initBinds: function _initBinds() {
      this.bind('reset', this._setSelected, this);
      this.bind('change:selected', this._onSelectedChange, this);
    },
  
    getSelected: function getSelected() {
      return this.find(function (model) {
        return model.get('selected');
      });
    },
  
    getDefault: function getDefault() {
      return this.find(function (model) {
        return model.get('name') === this.getDefaultName();
      }, this);
    },
  
    getDisabledTabs: function getDisabledTabs() {
      return this._disabledTabs || [];
    },
  
    getDefaultName: function getDefaultName() {
      return this._defaultTab;
    },
  
    isDisabledTab: function isDisabledTab(name) {
      var disabledTab = this.find(function (model) {
        return model.get('disabled') && model.get('name') === name;
      });
  
      return !!disabledTab;
    },
  
    _setSelected: function _setSelected() {
      var isSelected = this.getSelected();
  
      if (!isSelected && this.size() > 0) {
        this.at(0).set('selected', true);
      }
    },
  
    _onSelectedChange: function _onSelectedChange(itemModel, isSelected) {
      if (!isSelected) {
        return;
      }
  
      this.each(function (model) {
        if (model !== itemModel) {
          model.set('selected', false);
        }
      }, this);
    },
  
    select: function select(name, value) {
      var model = this.find(function (m) {
        return m.get(name) === value;
      }, this);
  
      if (model) {
        model.set('selected', true);
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-color-view.js":
  /*!***********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/tab-pane/tab-pane-color-view.js ***!
    \***********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./tab-pane-color.tpl */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-color.tpl");
  
  /**
   *  Label component
   */
  
  module.exports = CoreView.extend({
    className: 'Label',
  
    initialize: function initialize() {
      if (!this.model) {
        throw new Error('A model should be provided');
      }
      this.model.bind('change:label', this.render, this);
    },
  
    render: function render() {
      this.clearSubViews();
  
      this.$el.html(template({
        color: this.model.get('label'),
        selectedChild: this.model.get('selectedChild') || ''
      }));
      return this;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-item-view.js":
  /*!**********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/tab-pane/tab-pane-item-view.js ***!
    \**********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  
  /**
   *  TabPaneItem component
   */
  
  module.exports = CoreView.extend({
    module: 'components:tab-pane:tab-pane-item-view',
  
    tagName: 'button',
  
    className: function className() {
      var classes = [this.options.klassName];
  
      if (this.model.get('selected')) {
        classes.push('is-selected');
      }
  
      if (this.model.get('disabled')) {
        classes.push('is-disabled');
      }
  
      return classes.join(' ');
    },
  
    events: {
      'click': '_onButtonClicked'
    },
  
    initialize: function initialize() {
      if (!this.model) {
        throw new Error('A model should be provided');
      }
  
      this.model.bind('change:selected', this._onChangeSelected, this);
    },
  
    render: function render() {
      this.clearSubViews();
      this._initViews();
      return this;
    },
  
    _initViews: function _initViews() {
      this._initButton();
      this._initTooltip();
    },
  
    _initButton: function _initButton() {
      var view = this.model.get('createButtonView').call(this.model);
      this.addView(view);
      this.$el.append(view.render().$el);
    },
  
    _initTooltip: function _initTooltip() {
      var tooltip = this.model.get('tooltip');
      if (tooltip) {
        var buttonTooltip = new TipsyTooltipView({
          el: this.$el,
          title: function title() {
            return _t(tooltip);
          },
          gravity: this.model.get('tooltipGravity') || 'w'
        });
        this._buttonTooltip = buttonTooltip;
        this.addView(buttonTooltip);
      }
    },
  
    _onChangeSelected: function _onChangeSelected() {
      var isSelected = !!this.model.get('selected');
      if (!isSelected) {
        this._buttonTooltip && this._buttonTooltip.hideTipsy();
      }
      this.$el.toggleClass('is-selected', isSelected);
    },
  
    _onButtonClicked: function _onButtonClicked(event) {
      event.preventDefault();
      if (this.model.get('disabled')) return;
  
      this.model.set('selected', true);
      _.isFunction(this.model.get('onClick')) && this.model.get('onClick')();
    },
  
    clean: function clean() {
      this._buttonTooltip && this._buttonTooltip.clean();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-label-view.js":
  /*!***********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/tab-pane/tab-pane-label-view.js ***!
    \***********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./tab-pane-label.tpl */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-label.tpl");
  
  /**
   *  Label component
   */
  
  module.exports = CoreView.extend({
    className: 'Label',
  
    initialize: function initialize() {
      if (!this.model) {
        throw new Error('A model should be provided');
      }
  
      this.model.on('change:label', this.render, this);
    },
  
    render: function render() {
      this.$el.html(template({
        label: this.model.get('label'),
        selectedChild: this.model.get('selectedChild') || ''
      }));
      return this;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-mixed-view.js":
  /*!***********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/tab-pane/tab-pane-mixed-view.js ***!
    \***********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var template = __webpack_require__(/*! ./tab-pane-file.tpl */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-file.tpl");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var ImageLoaderView = __webpack_require__(/*! builder/components/img-loader-view */ "./lib/assets/javascripts/builder/components/img-loader-view.js");
  
  /**
   *  File component
   */
  
  module.exports = CoreView.extend({
    tagName: 'i',
  
    className: 'CDB-IconFont',
  
    initialize: function initialize(options) {
      if (!this.model) throw new Error('A model should be provided');
  
      this.model.bind('change:label', this.render, this);
      this.model.bind('change:color', this._updateColor, this);
    },
  
    render: function render() {
      this.clearSubViews();
  
      var labelType = this._getLabelType();
  
      this.$el.html(template({
        type: labelType,
        label: this.model.get('label'),
        kind: this.model.get('kind'),
        selectedChild: this.model.get('selectedChild') || ''
      }));
  
      if (labelType === 'file') {
        this._loadImages();
      }
  
      return this;
    },
  
    _loadImages: function _loadImages() {
      this.iconView = new ImageLoaderView({
        imageClass: 'Tab-paneLabelImage',
        imageUrl: this._getImageURL(),
        color: this.model.get('color')
      });
      this.addView(this.iconView);
      this.$('.js-image-container').append(this.iconView.render().el);
    },
  
    _updateColor: function _updateColor() {
      this.iconView && this.iconView.updateImageColor(this.model.get('color'));
    },
  
    _getLabelType: function _getLabelType() {
      var label = this.model.get('label');
      return label && label.match(/^http/) ? 'file' : 'text';
    },
  
    _getImageURL: function _getImageURL() {
      return this.model.get('label');
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-radio-label-view.js":
  /*!*****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/tab-pane/tab-pane-radio-label-view.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./tab-pane-radio-label.tpl */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-radio-label.tpl");
  
  /**
   *  Label component with a Radio button
   */
  
  module.exports = CoreView.extend({
    className: 'Label',
  
    initialize: function initialize() {
      if (!this.model) {
        throw new Error('A model should be provided');
      }
  
      this.model.on('change:label', this.render, this);
      this.model.on('change:selected', this.render, this);
    },
  
    render: function render() {
      this.$el.html(template({
        customId: this.model.cid + this.model.get('name'),
        label: this.model.get('label'),
        name: this.model.get('name'),
        help: this.model.get('help') || '',
        selected: this.model.get('selected'),
        selectedChild: this.model.get('selectedChild') || ''
      }));
      return this;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-view.js":
  /*!*****************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/tab-pane/tab-pane-view.js ***!
    \*****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var TabPaneItem = __webpack_require__(/*! ./tab-pane-item-view.js */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane-item-view.js");
  var Template = __webpack_require__(/*! ./tab-pane.tpl */ "./lib/assets/javascripts/builder/components/tab-pane/tab-pane.tpl");
  
  /**
   *  TabPane component
   */
  
  module.exports = CoreView.extend({
    className: 'Tab-pane',
  
    events: {
      'mouseover': '_onMouseOver'
    },
  
    initialize: function initialize(options) {
      if (!this.collection) {
        throw new Error('A TabPaneCollection should be provided');
      }
  
      this._tabPaneItemOptions = this.options.tabPaneItemOptions;
      this._createContentKey = this.options.createContentKey || 'createContentView';
      this.template = this.options.template || Template;
  
      if (this.options.mouseOverAction) {
        this._mouseOverAction = this.options.mouseOverAction;
      }
  
      this.collection.bind('change:selected', this._renderSelected, this);
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
  
      this.$el.html(this.template(this.options));
  
      this._renderCollection();
  
      var model = this.getSelectedTabPane();
  
      if (model) {
        this._renderSelected(model, true);
      }
  
      return this;
    },
  
    getTabPaneCollection: function getTabPaneCollection() {
      return this.collection;
    },
  
    getSelectedTabPane: function getSelectedTabPane() {
      return this.collection.getSelected();
    },
  
    getTabPane: function getTabPane(name) {
      return _.first(this.collection.where({ name: name }));
    },
  
    getSelectedTabPaneName: function getSelectedTabPaneName() {
      var selectedTab = this.getSelectedTabPane();
      return selectedTab ? selectedTab.get('name') : null;
    },
  
    setSelectedTabPaneByName: function setSelectedTabPaneByName(name) {
      return this.collection.select('name', name);
    },
  
    _renderSelected: function _renderSelected(model, isSelected) {
      if (isSelected) {
        if (this._selectedView) {
          this._selectedView.clean();
          this.removeView(this._selectedView);
        }
  
        this._selectedView = this._renderTabPaneContentView(model);
      }
    },
  
    _renderCollection: function _renderCollection() {
      this.collection.each(function (paneModel) {
        if (paneModel.get('createButtonView')) {
          this._renderTabPaneItemView(paneModel);
        }
      }, this);
    },
  
    _renderTabPaneItemView: function _renderTabPaneItemView(model) {
      var tabPaneItemView = new TabPaneItem(_.extend({ model: model }, this._tabPaneItemOptions));
      this.addView(tabPaneItemView);
      this.$('.js-menu').append(tabPaneItemView.render().el);
    },
  
    _renderTabPaneContentView: function _renderTabPaneContentView(model) {
      var tabPaneContentView = model.get(this._createContentKey).call(model);
      if (tabPaneContentView) {
        this.addView(tabPaneContentView);
        this.$('.js-content').append(tabPaneContentView.render().el);
        if (typeof tabPaneContentView.afterRender === 'function') {
          tabPaneContentView.afterRender();
        }
      }
      return tabPaneContentView;
    },
  
    changeStyleMenu: function changeStyleMenu(m) {
      this.$('.js-theme').toggleClass('is-dark', m.isEditing());
    },
  
    _onMouseOver: function _onMouseOver() {
      this._mouseOverAction && this._mouseOverAction();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/body/table-body-row-view.js":
  /*!*************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/body/table-body-row-view.js ***!
    \*************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var cellTemplate = __webpack_require__(/*! ./table-body-cell.tpl */ "./lib/assets/javascripts/builder/components/table/body/table-body-cell.tpl");
  var pointGeojsonParser = __webpack_require__(/*! builder/helpers/point-geojson-parser */ "./lib/assets/javascripts/builder/helpers/point-geojson-parser.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var FORMATTED_TYPE_VALUES = {
    'geometry': pointGeojsonParser
  };
  
  var REQUIRED_OPTS = ['columnsCollection', 'tableViewModel', 'canHideColumns'];
  
  /*
   *  Table body row view
   */
  
  module.exports = CoreView.extend({
  
    className: 'Table-row',
    tagName: 'tr',
  
    options: {
      simpleGeometry: ''
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this.el.setAttribute('data-model', this.model.cid);
  
      this._initBinds();
    },
  
    render: function render() {
      this.$el.empty();
      this._generateRowsHTML();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.model.bind('change', this.render, this);
      this.model.bind('destroy', this.remove, this);
    },
  
    _generateRowsHTML: function _generateRowsHTML() {
      var r = [];
  
      for (var i = 0, l = this._columnsCollection.size(); i < l; i++) {
        var model = this._columnsCollection.at(i);
        var columnName = model.get('name');
  
        if (!this._tableViewModel.isCustomQueryApplied() && columnName === 'the_geom_webmercator') {
          continue;
        }
  
        if (this._canHideColumns && columnName === 'center' && model.isGeometryColumn()) {
          continue;
        }
  
        r[i] = this._generateCellHTML(columnName);
      }
  
      this.el.innerHTML = r.join('');
    },
  
    _generateCellHTML: function _generateCellHTML(columnName) {
      var simpleGeometry = this.options.simpleGeometry;
      var columnModel = _.first(this._columnsCollection.where({ name: columnName }));
      var columnType = columnModel.get('type');
      var value = this.model.get(columnName);
      var formattedValue = value;
  
      if (columnType === 'geometry') {
        if (simpleGeometry === 'point') {
          formattedValue = FORMATTED_TYPE_VALUES[columnType](value);
        } else {
          formattedValue = simpleGeometry && simpleGeometry.charAt(0).toUpperCase() + simpleGeometry.slice(1);
        }
      } else if (FORMATTED_TYPE_VALUES[columnType]) {
        formattedValue = FORMATTED_TYPE_VALUES[columnType](value);
      }
  
      return cellTemplate({
        value: value,
        formattedValue: formattedValue,
        type: columnType,
        columnName: columnName,
        geometry: simpleGeometry
      });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/body/table-body-view.js":
  /*!*********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/body/table-body-view.js ***!
    \*********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Clipboard = __webpack_require__(/*! clipboard */ "./node_modules/clipboard/lib/clipboard.js");
  var TableBodyRowView = __webpack_require__(/*! ./table-body-row-view */ "./lib/assets/javascripts/builder/components/table/body/table-body-row-view.js");
  var ContextMenuView = __webpack_require__(/*! builder/components/context-menu/context-menu-view */ "./lib/assets/javascripts/builder/components/context-menu/context-menu-view.js");
  var CustomListCollection = __webpack_require__(/*! builder/components/custom-list/custom-list-collection */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-collection.js");
  var addTableRowOperation = __webpack_require__(/*! builder/components/table/operations/table-add-row */ "./lib/assets/javascripts/builder/components/table/operations/table-add-row.js");
  var removeTableRowOperation = __webpack_require__(/*! builder/components/table/operations/table-remove-row */ "./lib/assets/javascripts/builder/components/table/operations/table-remove-row.js");
  var editCellOperation = __webpack_require__(/*! builder/components/table/operations/table-edit-cell */ "./lib/assets/javascripts/builder/components/table/operations/table-edit-cell.js");
  var ConfirmationModalView = __webpack_require__(/*! builder/components/modals/confirmation/modal-confirmation-view */ "./lib/assets/javascripts/builder/components/modals/confirmation/modal-confirmation-view.js");
  var TablePaginatorView = __webpack_require__(/*! builder/components/table/paginator/table-paginator-view */ "./lib/assets/javascripts/builder/components/table/paginator/table-paginator-view.js");
  var tableBodyTemplate = __webpack_require__(/*! ./table-body.tpl */ "./lib/assets/javascripts/builder/components/table/body/table-body.tpl");
  var renderLoading = __webpack_require__(/*! builder/components/loading/render-loading */ "./lib/assets/javascripts/builder/components/loading/render-loading.js");
  var ErrorView = __webpack_require__(/*! builder/components/error/error-view */ "./lib/assets/javascripts/builder/components/error/error-view.js");
  var tableNoRowsTemplate = __webpack_require__(/*! ./table-no-rows.tpl */ "./lib/assets/javascripts/builder/components/table/body/table-no-rows.tpl");
  var EditorsServiceModel = __webpack_require__(/*! builder/components/table/editors/editors-service-model */ "./lib/assets/javascripts/builder/components/table/editors/editors-service-model.js");
  var EditorsModel = __webpack_require__(/*! builder/components/table/editors/types/editor-model */ "./lib/assets/javascripts/builder/components/table/editors/types/editor-model.js");
  var errorParser = __webpack_require__(/*! builder/helpers/error-parser */ "./lib/assets/javascripts/builder/helpers/error-parser.js");
  var magicPositioner = __webpack_require__(/*! builder/helpers/magic-positioner */ "./lib/assets/javascripts/builder/helpers/magic-positioner.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var EDITORS_MAP = {
    'string': __webpack_require__(/*! builder/components/table/editors/types/editor-string-view */ "./lib/assets/javascripts/builder/components/table/editors/types/editor-string-view.js"),
    'number': __webpack_require__(/*! builder/components/table/editors/types/editor-base-view */ "./lib/assets/javascripts/builder/components/table/editors/types/editor-base-view.js"),
    'boolean': __webpack_require__(/*! builder/components/table/editors/types/editor-boolean-view */ "./lib/assets/javascripts/builder/components/table/editors/types/editor-boolean-view.js"),
    'date': __webpack_require__(/*! builder/components/table/editors/types/editor-date-view */ "./lib/assets/javascripts/builder/components/table/editors/types/editor-date-view.js"),
    'default': __webpack_require__(/*! builder/components/table/editors/types/editor-string-view */ "./lib/assets/javascripts/builder/components/table/editors/types/editor-string-view.js")
  };
  
  var REQUIRED_OPTS = ['columnsCollection', 'modals', 'queryGeometryModel', 'querySchemaModel', 'rowsCollection', 'canHideColumns', 'tableViewModel'];
  
  /*
   *  Table body view
   */
  
  module.exports = CoreView.extend({
  
    className: 'Table-body',
    tagName: 'div',
  
    events: {
      'click': '_onClick',
      'dblclick': '_onDblClick'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this._editors = new EditorsServiceModel();
  
      this._closeEditor = this._closeEditor.bind(this);
      this._hideContextMenu = this._hideContextMenu.bind(this);
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this._destroyScrollBinding();
      this.$el.empty();
  
      // Render results when we have the schema and goemetry is not being fetched
      if (this._querySchemaModel.isFetched() && !this._queryGeometryModel.isFetching() && !this._rowsCollection.isFetching()) {
        if (!this._rowsCollection.size()) {
          this._renderNoRows();
        } else {
          this.$el.html(tableBodyTemplate());
          this._rowsCollection.each(this._renderBodyRow, this);
          this._initPaginator();
        }
      } else {
        this._renderQueryState();
      }
  
      this.$el.toggleClass('Table-body--relative', !!this._tableViewModel.get('relativePositionated'));
  
      return this;
    },
  
    _initBinds: function _initBinds() {
      this._queryGeometryModel.bind('change:status', this.render, this);
      this._querySchemaModel.bind('change:status', this.render, this);
      this._rowsCollection.bind('reset', _.debounce(this.render.bind(this), 20), this);
      this._rowsCollection.bind('add', function (model) {
        if (this._rowsCollection.size() === 1) {
          this.render();
        } else {
          this._renderBodyRow(model);
        }
      }, this);
      this._rowsCollection.bind('remove', this._onRemoveRow, this);
      this._rowsCollection.bind('fail', function (mdl, response) {
        if (!response || response && response.statusText !== 'abort') {
          this._renderError(errorParser(response));
        }
      }, this);
      this.add_related_model(this._queryGeometryModel);
      this.add_related_model(this._querySchemaModel);
      this.add_related_model(this._rowsCollection);
    },
  
    _renderQueryState: function _renderQueryState() {
      var querySchemaStatus = this._querySchemaModel.get('status');
      var nodeReady = this._querySchemaModel.get('ready');
      var geometryStatus = this._queryGeometryModel.get('status');
      var rowsCollectionStatus = this._rowsCollection.getStatusValue();
  
      if (nodeReady) {
        if (querySchemaStatus === 'unavailable' && geometryStatus === 'unavailable' || rowsCollectionStatus === 'unavailable') {
          this._renderError(this._querySchemaModel.get('query_errors'));
        } else {
          this._renderLoading();
        }
      } else {
        this._renderLoading();
      }
    },
  
    _renderLoading: function _renderLoading() {
      this.$el.html(renderLoading({
        title: _t('components.table.rows.loading.title')
      }));
    },
  
    _renderError: function _renderError(desc) {
      var view = new ErrorView({
        title: _t('components.table.rows.error.title'),
        desc: desc || _t('components.table.rows.error.desc')
      });
      this.addView(view);
      this.$el.html(view.render().el);
    },
  
    _renderNoRows: function _renderNoRows() {
      this.$el.html(tableNoRowsTemplate({
        page: this._tableViewModel.get('page'),
        customQuery: this._tableViewModel.isCustomQueryApplied()
      }));
    },
  
    _initPaginator: function _initPaginator() {
      var paginatorView = new TablePaginatorView({
        rowsCollection: this._rowsCollection,
        tableViewModel: this._tableViewModel,
        scrollToBottom: this._scrollToBottom.bind(this)
      });
  
      // Bug in Chrome with position:fixed :(, so we have to choose body as
      // parent
      var $el = $('body');
      // But if we have chosen relativePositionated, we should add close
      // to the table view
      if (this._tableViewModel.get('relativePositionated')) {
        $el = this.$el.closest('.Table').parent();
      }
  
      $el.append(paginatorView.render().el);
      this.addView(paginatorView);
    },
  
    _initScrollBinding: function _initScrollBinding() {
      $('.Table').scroll(this._hideContextMenu);
      this.$('.js-tbody').scroll(this._hideContextMenu);
    },
  
    _destroyScrollBinding: function _destroyScrollBinding() {
      $('.Table').off('scroll', this._hideContextMenu);
      this.$('.js-tbody').off('scroll', this._hideContextMenu);
    },
  
    _renderBodyRow: function _renderBodyRow(mdl) {
      var view = new TableBodyRowView({
        model: mdl,
        columnsCollection: this._columnsCollection,
        simpleGeometry: this._queryGeometryModel.get('simple_geom'),
        canHideColumns: this._canHideColumns,
        tableViewModel: this._tableViewModel
      });
      this.addView(view);
      this.$('.js-tbody').append(view.render().el);
    },
  
    _onRemoveRow: function _onRemoveRow() {
      if (!this._rowsCollection.size()) {
        this._rowsCollection.resetFetch();
        this._queryGeometryModel.resetFetch();
  
        var page = this._tableViewModel.get('page');
        if (page > 0) {
          this._tableViewModel.set('page', page - 1);
        } else {
          this.render();
        }
      }
    },
  
    _hasContextMenu: function _hasContextMenu() {
      return this._menuView;
    },
  
    _hideContextMenu: function _hideContextMenu() {
      this._unhighlightCell();
      this._destroyScrollBinding();
      this._menuView.collection.unbind(null, null, this);
      this.removeView(this._menuView);
      this._menuView.clean();
      delete this._menuView;
    },
  
    _highlightCell: function _highlightCell($tableCellItem, $tableRow) {
      $tableCellItem.addClass('is-highlighted');
      $tableRow.addClass('is-highlighted');
    },
  
    _unhighlightCell: function _unhighlightCell() {
      this.$('.Table-cellItem.is-highlighted, .Table-row.is-highlighted').removeClass('is-highlighted');
    },
  
    _showContextMenu: function _showContextMenu(ev) {
      var self = this;
      var position = { x: ev.clientX, y: ev.clientY };
      var $tableRow = $(ev.target).closest('.Table-row');
      var $tableCellItem = $(ev.target).closest('.Table-cellItem');
      var modelCID = $tableRow.data('model');
      var attribute = $tableCellItem.data('attribute');
      var rowModel = self._rowsCollection.get({ cid: modelCID });
      var menuItems = [];
  
      menuItems.push({
        label: _t('components.table.rows.options.copy'),
        val: 'copy',
        action: function action() {
          self._copyValue($tableCellItem);
        }
      });
  
      if (!this._tableViewModel.isDisabled()) {
        menuItems = [{
          label: _t('components.table.rows.options.edit'),
          val: 'edit',
          action: function action() {
            self._editCell(rowModel, attribute);
          }
        }, {
          label: _t('components.table.rows.options.create'),
          val: 'create',
          action: function action() {
            self._addRow();
          }
        }].concat(menuItems);
  
        menuItems.push({
          label: _t('components.table.rows.options.delete'),
          val: 'delete',
          destructive: true,
          action: function action() {
            self._removeRow(rowModel);
          }
        });
      }
  
      // No options?, don't open anything
      if (!menuItems.length) {
        return false;
      }
  
      var collection = new CustomListCollection(menuItems);
  
      this._menuView = new ContextMenuView({
        className: 'Table-rowMenu ' + ContextMenuView.prototype.className,
        collection: collection,
        triggerElementID: modelCID,
        position: position
      });
  
      this._menuView.$el.css(magicPositioner({
        parentView: $('body'),
        posX: position.x,
        posY: position.y
      }));
  
      collection.bind('change:selected', function (menuItem) {
        var action = menuItem.get('action');
        action && action();
      }, this);
  
      this._menuView.model.bind('change:visible', function (model, isContextMenuVisible) {
        if (this._hasContextMenu() && !isContextMenuVisible) {
          this._hideContextMenu();
        }
      }, this);
  
      this._menuView.show();
      this.addView(this._menuView);
  
      this._highlightCell($tableCellItem, $tableRow);
      this._initScrollBinding();
    },
  
    _onClick: function _onClick(ev) {
      var isCellOptions = $(ev.target).hasClass('js-cellOptions');
      if (isCellOptions) {
        if (this._hasContextMenu()) {
          this._hideContextMenu();
        } else {
          this._showContextMenu(ev);
        }
      }
    },
  
    _onDblClick: function _onDblClick(ev) {
      var $tableCellItem = $(ev.target).closest('.Table-cellItem');
      var isCellOptions = $(ev.target).hasClass('js-cellOptions');
  
      if ($tableCellItem && !isCellOptions) {
        var $tableRow = $tableCellItem.closest('.Table-row');
        var modelCID = $tableRow.data('model');
        var attribute = $tableCellItem.data('attribute');
        var rowModel = this._rowsCollection.get({ cid: modelCID });
  
        if (!this._tableViewModel.isDisabled() && rowModel && attribute && attribute !== 'cartodb_id') {
          this._editCell(rowModel, attribute);
        }
      }
    },
  
    _copyValue: function _copyValue($el) {
      // Work-around for Clipboard \o/
      this._clipboard = new Clipboard($el.get(0));
      $el.click();
      this._clipboard.destroy();
    },
  
    _addRow: function _addRow() {
      addTableRowOperation({
        rowsCollection: this._rowsCollection
      });
    },
  
    _initEditorScrollBinding: function _initEditorScrollBinding() {
      $('.Table').scroll(this._closeEditor);
      this.$('.js-tbody').scroll(this._closeEditor);
    },
  
    _destroyEditorScrollBinding: function _destroyEditorScrollBinding() {
      $('.Table').unbind('scroll', this._closeEditor);
      this.$('.js-tbody').unbind('scroll', this._closeEditor);
    },
  
    _closeEditor: function _closeEditor() {
      this._unhighlightCell();
      this._destroyEditorScrollBinding();
      this._editors.unbind(null, null, this);
      this._editors.destroy();
    },
  
    _saveValue: function _saveValue(rowModel, attribute, newValue) {
      if (rowModel.get(attribute) !== newValue) {
        editCellOperation({
          rowModel: rowModel,
          attribute: attribute,
          newValue: newValue
        });
      }
    },
  
    _doCellEdition: function _doCellEdition(rowModel, attribute) {
      var $tableRow = this.$('[data-model="' + rowModel.cid + '"]');
      var $tableCell = $tableRow.find('[data-attribute="' + attribute + '"]');
      var $options = $tableCell.find('.js-cellOptions');
      var columnModel = _.first(this._columnsCollection.where({ name: attribute }));
      var type = columnModel.get('type');
  
      this._highlightCell($tableCell, $tableRow);
      this._initEditorScrollBinding();
  
      var model = new EditorsModel({
        type: type,
        value: rowModel.get(attribute)
      });
  
      this._editors.bind('destroyedEditor', this._closeEditor, this);
      this._editors.bind('confirmedEditor', function () {
        if (model.isValid()) {
          this._saveValue(rowModel, attribute, model.get('value'));
        }
      }, this);
  
      var position = $options.offset();
  
      if ($tableCell.index() > 1) {
        position.right = window.innerWidth - position.left;
        delete position.left;
      }
  
      if (this._rowsCollection.size() > 4 && $tableRow.index() + 2 >= this._rowsCollection.size() - 1) {
        position.bottom = window.innerHeight - position.top;
        delete position.top;
      } else {
        position.top = position.top + 20;
      }
  
      var View = EDITORS_MAP[type];
  
      if (!View) {
        View = EDITORS_MAP['default'];
      }
  
      this._editors.create(function (editorModel) {
        return new View({
          editorModel: editorModel,
          model: model
        });
      }, position);
    },
  
    _editCell: function _editCell(rowModel, attribute) {
      var callback = this._doCellEdition.bind(this, rowModel, attribute);
      rowModel.fetchRowIfGeomIsNotLoaded(callback);
    },
  
    _removeRow: function _removeRow(rowModel) {
      var self = this;
  
      this._modals.create(function (modalModel) {
        return new ConfirmationModalView({
          modalModel: modalModel,
          template: __webpack_require__(/*! ./modals-templates/remove-table-row.tpl */ "./lib/assets/javascripts/builder/components/table/body/modals-templates/remove-table-row.tpl"),
          renderOpts: {
            cartodb_id: rowModel.get('cartodb_id')
          },
          loadingTitle: _t('components.table.rows.destroy.loading', {
            cartodb_id: rowModel.get('cartodb_id')
          }),
          runAction: function runAction() {
            removeTableRowOperation({
              tableViewModel: self._tableViewModel,
              rowModel: rowModel,
              onSuccess: function onSuccess() {
                modalModel.destroy();
              },
              onError: function onError(e) {
                modalModel.destroy();
              }
            });
          }
        });
      });
    },
  
    _scrollToBottom: function _scrollToBottom() {
      var tbodyHeight = this.$('.js-tbody').get(0).scrollHeight;
      this.$('.js-tbody').animate({
        scrollTop: tbodyHeight
      }, 'slow');
    },
  
    clean: function clean() {
      this._destroyScrollBinding();
      CoreView.prototype.clean.apply(this);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/editors/editor-view-model.js":
  /*!**************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/editors/editor-view-model.js ***!
    \**************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  /**
   * View model of an editor
   */
  module.exports = Backbone.Model.extend({
  
    defaults: {
      show: true,
      createContentView: function createContentView() {
        return new CoreView();
      }
    },
  
    createContentView: function createContentView() {
      return this.get('createContentView')(this);
    },
  
    show: function show() {
      this.set('show', true);
    },
  
    hide: function hide() {
      this.set('show', false);
    },
  
    isHidden: function isHidden() {
      return !this.get('show');
    },
  
    confirm: function confirm() {
      var args = Array.prototype.slice.call(arguments);
      this.trigger.apply(this, ['confirm'].concat(args));
    },
  
    /**
     * @override {Backbone.Model.prototype.destroy}
     */
    destroy: function destroy() {
      var args = Array.prototype.slice.call(arguments);
      this.trigger.apply(this, ['destroy'].concat(args));
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/editors/editor-view.js":
  /*!********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/editors/editor-view.js ***!
    \********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  module.exports = CoreView.extend({
    className: 'CDB-Box-modal Table-editor',
  
    initialize: function initialize() {
      this.listenTo(this.model, 'change:show', this._onShowChange);
      this.listenTo(this.model, 'destroy', this._onDestroy);
    },
  
    render: function render() {
      this.clearSubViews();
  
      var view = this.model.createContentView();
      this.addView(view);
      view.render();
      this.$el.append(view.el);
      this.$el.css(this.options.position);
  
      return this;
    },
  
    show: function show() {
      this.model.show();
    },
  
    hide: function hide() {
      this.model.hide();
    },
  
    destroy: function destroy() {
      this.model.destroy();
    },
  
    _onShowChange: function _onShowChange(m, show) {
      this.$el[show ? 'show' : 'hide']();
    },
  
    _onClose: function _onClose() {
      this.destroy();
    },
  
    _onDestroy: function _onDestroy() {
      this.hide();
      this.clean();
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/editors/editors-service-model.js":
  /*!******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/editors/editors-service-model.js ***!
    \******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var EditorView = __webpack_require__(/*! ./editor-view */ "./lib/assets/javascripts/builder/components/table/editors/editor-view.js");
  var EditorViewModel = __webpack_require__(/*! ./editor-view-model */ "./lib/assets/javascripts/builder/components/table/editors/editor-view-model.js");
  var ESC_KEY_CODE = 27;
  var DESTROYED_EDITOR_EVENT = 'destroyedEditor';
  var CONFIRMED_EDITOR_EVENT = 'confirmedEditor';
  
  /**
   * Top-level API to handle editor views.
   *
   * Example:
   * // In some entry-point:
   * table.editors = new EditorsServiceModel();
   *
   * // Later, in any view, calling create will create a new editor viewModel
   * var editorView = table.editors.create(fn);
   *
   * Same concept @viddo introduced with Modals.
   */
  module.exports = Backbone.Model.extend({
  
    /**
     * Creates a new editor view
     *
     * @param {Function} createContentView
     * @return {View} the new editor view
     */
    create: function create(createContentView, position) {
      if (!_.isFunction(createContentView)) throw new Error('createContentView is required');
      position = position || {
        left: '50%',
        top: '50%'
      };
  
      if (!this._editorView) {
        this._editorView = this._newEditorView(position);
        document.body.appendChild(this._editorView.el);
      }
  
      this._editorView.model.set('createContentView', createContentView);
      this._editorView.render();
  
      return this._editorView;
    },
  
    /**
     * Convenience method to add a listener when current editor is destroyed
     *
     * This is the same as doing
     * editors.create(function (model) {
     *   model.once('destroy', callback, context);
     *   return new MyView({  });
     * });
     *
     * @param {Function} callback
     * @param {Object} [context = undefined]
     */
  
    confirm: function confirm() {
      if (this._editorView) {
        this._editorView.model.confirm();
      }
    },
  
    destroy: function destroy() {
      if (this._editorView) {
        this._editorView.model.destroy();
      }
    },
  
    _newEditorView: function _newEditorView(position) {
      var viewModel = new EditorViewModel();
      this._destroyOnEsc(viewModel);
      this.listenToOnce(viewModel, 'destroy', function () {
        this._editorView = null;
        this.trigger.apply(this, [DESTROYED_EDITOR_EVENT].concat(Array.prototype.slice.call(arguments)));
        this.stopListening(viewModel);
      });
      this.listenToOnce(viewModel, 'confirm', function () {
        this.trigger.apply(this, [CONFIRMED_EDITOR_EVENT].concat(Array.prototype.slice.call(arguments)));
        this.destroy();
      });
      var view = new EditorView({
        model: viewModel,
        position: position
      });
      this._destroyOnClickOutside(view);
      return view;
    },
  
    _destroyOnClickOutside: function _destroyOnClickOutside(view) {
      var destroyOnClickOutside = function destroyOnClickOutside(ev) {
        if ($(ev.target).closest(view.el).length === 0) {
          view.model.confirm();
        }
      };
      document.addEventListener('click', destroyOnClickOutside);
      this.listenToOnce(view.model, 'destroy', function () {
        document.removeEventListener('click', destroyOnClickOutside);
      });
    },
  
    _destroyOnEsc: function _destroyOnEsc(viewModel) {
      var destroyOnEsc = function destroyOnEsc(ev) {
        if (ev.which === ESC_KEY_CODE) {
          viewModel.destroy();
        }
      };
      document.addEventListener('keydown', destroyOnEsc);
      this.listenToOnce(viewModel, 'destroy', function () {
        document.removeEventListener('keydown', destroyOnEsc);
      });
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/editors/types/editor-base-view.js":
  /*!*******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/editors/types/editor-base-view.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var ENTER_KEY_CODE = 13;
  
  module.exports = CoreView.extend({
  
    tagName: 'input',
    className: 'CDB-InputText CDB-Text',
  
    events: {
      'keyup': '_onValueChange',
      'change': '_onValueChange'
    },
  
    initialize: function initialize(opts) {
      if (!opts.editorModel) throw new Error('editorModel is required');
      this._editorModel = opts.editorModel;
      this._onKeyPressed = this._onKeyPressed.bind(this);
      this._onValueChange = this._onValueChange.bind(this);
    },
  
    render: function render() {
      this.$el.val(this.model.get('value'));
      this._setFocus();
      this._initDocumentBind();
      return this;
    },
  
    _setFocus: function _setFocus() {
      setTimeout(function () {
        this.$el.focus();
      }.bind(this), 100);
    },
  
    _initDocumentBind: function _initDocumentBind() {
      $(document).bind('keydown', this._onKeyPressed);
    },
  
    _destroyDocumentBind: function _destroyDocumentBind() {
      $(document).unbind('keydown', this._onKeyPressed);
    },
  
    _onKeyPressed: function _onKeyPressed(ev) {
      if (ev.which === ENTER_KEY_CODE) {
        if (this.model.isValid()) {
          this._editorModel.confirm();
        } else {
          return false;
        }
      }
    },
  
    _onValueChange: function _onValueChange() {
      this._setValue();
      this._checkValidity();
    },
  
    _setValue: function _setValue() {
      this.model.set('value', this.$el.val());
    },
  
    _checkValidity: function _checkValidity() {
      this.$el.toggleClass('has-error', !this.model.isValid());
    },
  
    clean: function clean() {
      this._destroyDocumentBind();
      CoreView.prototype.clean.apply(this);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/editors/types/editor-boolean-view.js":
  /*!**********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/editors/types/editor-boolean-view.js ***!
    \**********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var EditorBaseView = __webpack_require__(/*! ./editor-base-view */ "./lib/assets/javascripts/builder/components/table/editors/types/editor-base-view.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var template = __webpack_require__(/*! ./editor-boolean.tpl */ "./lib/assets/javascripts/builder/components/table/editors/types/editor-boolean.tpl");
  
  module.exports = EditorBaseView.extend({
  
    tagName: 'div',
    className: 'u-flex',
  
    events: {
      'change input:radio': '_onRadioChanged'
    },
  
    render: function render() {
      var value = this.model.get('value');
      this.$el.html(template({
        value: value !== null ? value.toString() : 'null'
      }));
      return this;
    },
  
    _onRadioChanged: function _onRadioChanged(ev) {
      var value = $(ev.target).val();
      switch (value) {
        case 'true':
          value = true;
          break;
        case 'false':
          value = false;
          break;
        default:
          value = null;
      }
      this.model.set('value', value);
      this._editorModel.confirm();
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/editors/types/editor-date-form-model.js":
  /*!*************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/editors/types/editor-date-form-model.js ***!
    \*************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var MONTHS = [{
    val: 0,
    label: _t('months.january')
  }, {
    val: 1,
    label: _t('months.february')
  }, {
    val: 2,
    label: _t('months.march')
  }, {
    val: 3,
    label: _t('months.april')
  }, {
    val: 4,
    label: _t('months.may')
  }, {
    val: 5,
    label: _t('months.june')
  }, {
    val: 6,
    label: _t('months.july')
  }, {
    val: 7,
    label: _t('months.august')
  }, {
    val: 8,
    label: _t('months.september')
  }, {
    val: 9,
    label: _t('months.october')
  }, {
    val: 10,
    label: _t('months.november')
  }, {
    val: 11,
    label: _t('months.december')
  }];
  
  module.exports = Backbone.Model.extend({
  
    parse: function parse(attrs) {
      var date;
  
      if (!attrs.date) {
        date = moment().utc();
      } else {
        date = moment(attrs.date).utc();
      }
  
      return {
        day: date.date(),
        month: date.month(),
        year: date.year(),
        time: date.format('HH:mm:ss'),
        utcOffset: date.utcOffset()
      };
    },
  
    initialize: function initialize() {
      this.schema = {
        day: {
          title: '',
          type: 'Text',
          validators: ['required', /^([12]?\d{0,1}|3[01]{0,2})$/, function (value, formValues) {
            var date = moment(Utils.formatDate(formValues));
            if (!date.isValid()) {
              return {
                type: 'date',
                message: _t('components.datepicker.invalid-date')
              };
            }
          }]
        },
        month: {
          type: 'Select',
          title: '',
          options: MONTHS
        },
        year: {
          title: '',
          type: 'Text',
          validators: ['required', /^([0-9]{0,4})$/]
        },
        time: {
          title: '',
          type: 'Text',
          validators: ['required', /^([01]{1}[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/]
        }
      };
    },
  
    getFormattedDate: function getFormattedDate() {
      return Utils.formatDate(this.toJSON());
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/editors/types/editor-date-view.js":
  /*!*******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/editors/types/editor-date-view.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var EditorBaseView = __webpack_require__(/*! ./editor-base-view */ "./lib/assets/javascripts/builder/components/table/editors/types/editor-base-view.js");
  var EditorDateFormModel = __webpack_require__(/*! ./editor-date-form-model */ "./lib/assets/javascripts/builder/components/table/editors/types/editor-date-form-model.js");
  __webpack_require__(/*! builder/components/form-components/index */ "./lib/assets/javascripts/builder/components/form-components/index.js");
  
  module.exports = EditorBaseView.extend({
  
    tagName: 'div',
    className: 'Table-editorDate',
  
    initialize: function initialize(opts) {
      EditorBaseView.prototype.initialize.apply(this, arguments);
  
      this._formModel = new EditorDateFormModel({
        date: this.model.get('value')
      }, {
        parse: true
      });
  
      this._setValue();
      this._formModel.bind('change', this._setValue, this);
      this.add_related_model(this._formModel);
    },
  
    render: function render() {
      this._formView = new Backbone.Form({
        model: this._formModel
      });
  
      this._formView.bind('change', function () {
        this.commit();
      });
  
      this.$el.html(this._formView.render().el);
  
      return this;
    },
  
    _setValue: function _setValue() {
      this.model.set('value', this._formModel.getFormattedDate());
    },
  
    clean: function clean() {
      this._formView.remove();
      EditorBaseView.prototype.clean.apply(this);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/editors/types/editor-model.js":
  /*!***************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/editors/types/editor-model.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  module.exports = Backbone.Model.extend({
  
    // Error labels will not be showed, not needed to be translated
    validate: function validate(attrs, opts) {
      if (attrs.type === 'number' && isNaN(attrs.value)) {
        return 'Number not valid';
      }
  
      if (attrs.type === 'boolean' && !_.isBoolean(attrs.value) && attrs.value !== null) {
        return 'Boolean not valid';
      }
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/editors/types/editor-string-view.js":
  /*!*********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/editors/types/editor-string-view.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var EditorBaseView = __webpack_require__(/*! ./editor-base-view */ "./lib/assets/javascripts/builder/components/table/editors/types/editor-base-view.js");
  var ENTER_KEY_CODE = 13;
  
  module.exports = EditorBaseView.extend({
  
    tagName: 'textarea',
    className: 'Table-editorTextarea CDB-Textarea CDB-Text',
  
    _onKeyPressed: function _onKeyPressed(ev) {
      if (!ev.shiftKey && ev.which === ENTER_KEY_CODE) {
        this._onValueChange();
        this._editorModel.confirm();
      }
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/head/table-head-item-view.js":
  /*!**************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/head/table-head-item-view.js ***!
    \**************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./table-head-item.tpl */ "./lib/assets/javascripts/builder/components/table/head/table-head-item.tpl");
  var ContextMenuView = __webpack_require__(/*! builder/components/context-menu/context-menu-view */ "./lib/assets/javascripts/builder/components/context-menu/context-menu-view.js");
  var CustomListCollection = __webpack_require__(/*! builder/components/custom-list/custom-list-collection */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-collection.js");
  var TableHeadOptionsItemView = __webpack_require__(/*! ./table-head-options-item-view */ "./lib/assets/javascripts/builder/components/table/head/table-head-options-item-view.js");
  var tableHeadOptionsItemTemplate = __webpack_require__(/*! ./table-head-options-item.tpl */ "./lib/assets/javascripts/builder/components/table/head/table-head-options-item.tpl");
  var ConfirmationModalView = __webpack_require__(/*! builder/components/modals/confirmation/modal-confirmation-view */ "./lib/assets/javascripts/builder/components/modals/confirmation/modal-confirmation-view.js");
  var QueryColumnModel = __webpack_require__(/*! builder/data/query-column-model */ "./lib/assets/javascripts/builder/data/query-column-model.js");
  var addColumnOperation = __webpack_require__(/*! builder/components/table/operations/table-add-column */ "./lib/assets/javascripts/builder/components/table/operations/table-add-column.js");
  var renameColumnOperation = __webpack_require__(/*! builder/components/table/operations/table-rename-column */ "./lib/assets/javascripts/builder/components/table/operations/table-rename-column.js");
  var changeColumnTypeOperation = __webpack_require__(/*! builder/components/table/operations/table-change-column-type */ "./lib/assets/javascripts/builder/components/table/operations/table-change-column-type.js");
  var removeTableColumnOperation = __webpack_require__(/*! builder/components/table/operations/table-remove-column */ "./lib/assets/javascripts/builder/components/table/operations/table-remove-column.js");
  
  var ENTER_KEY_CODE = 13;
  var ESC_KEY_CODE = 27;
  
  /*
   *  Main table view
   */
  
  module.exports = CoreView.extend({
  
    className: 'Table-headItem',
    tagName: 'th',
  
    events: {
      'dblclick .js-attribute': '_onAttributeDblClicked',
      'focusout .js-attribute': '_saveNewName',
      'click .js-columnOptions': '_showContextMenu'
    },
  
    initialize: function initialize(opts) {
      if (!opts.tableViewModel) throw new Error('tableViewModel is required');
      if (!opts.columnsCollection) throw new Error('columnsCollection is required');
      if (!opts.modals) throw new Error('modals is required');
  
      this._tableViewModel = opts.tableViewModel;
      this._columnsCollection = opts.columnsCollection;
      this._modals = opts.modals;
  
      this._hideContextMenu = this._hideContextMenu.bind(this);
      this._onKeyDown = this._onKeyDown.bind(this);
    },
  
    render: function render() {
      this.clearSubViews();
      var columnName = this.model.get('name');
      this.$el.html(template({
        name: columnName,
        type: this.model.get('type'),
        isOrderBy: this._tableViewModel.get('order_by') === columnName,
        sortBy: this._tableViewModel.get('sort_order'),
        geometry: this.options.simpleGeometry
      }));
      return this;
    },
  
    _hasContextMenu: function _hasContextMenu() {
      return this._menuView;
    },
  
    _hideContextMenu: function _hideContextMenu() {
      this._unhighlightHead();
      this._destroyScrollBinding();
      this._menuView.collection.unbind(null, null, this);
      this.removeView(this._menuView);
      this._menuView.clean();
      delete this._menuView;
    },
  
    _highlightHead: function _highlightHead() {
      this.$el.addClass('is-highlighted');
    },
  
    _unhighlightHead: function _unhighlightHead() {
      this.$el.removeClass('is-highlighted');
    },
  
    _initScrollBinding: function _initScrollBinding() {
      $('.Table').scroll(this._hideContextMenu);
    },
  
    _destroyScrollBinding: function _destroyScrollBinding() {
      $('.Table').off('scroll', this._hideContextMenu);
    },
  
    _showContextMenu: function _showContextMenu(ev) {
      var self = this;
      var position = { x: ev.clientX, y: ev.clientY };
      var elementIndex = this.$el.index();
      var modelCID = this.model.cid;
      var columnName = this.model.get('name');
  
      this._highlightHead();
  
      var menuItems = [{
        label: _t('components.table.columns.options.order'),
        val: 'order',
        isOrderBy: this._tableViewModel.get('order_by') === columnName,
        sortBy: this._tableViewModel.get('sort_order'),
        action: function action(model) {
          self._tableViewModel.set({
            sort_order: model.get('sort'),
            order_by: columnName
          });
        }
      }];
  
      if (!this._tableViewModel.isDisabled()) {
        if (!this.model.isCartoDBIDColumn() && !this.model.isGeometryColumn()) {
          menuItems = menuItems.concat([{
            label: _t('components.table.columns.options.rename'),
            val: 'rename',
            action: function action() {
              self._startEditing();
            }
          }, {
            label: _t('components.table.columns.options.change'),
            type: this.model.get('type'),
            isLastColumns: this._columnsCollection.size() - elementIndex < 3,
            val: 'change',
            action: function action(model) {
              self._changeColumnType(model.get('type'));
            }
          }]);
        }
  
        menuItems.push({
          label: _t('components.table.columns.options.create'),
          val: 'create',
          action: function action() {
            self._addColumn();
          }
        });
  
        if (!this.model.isCartoDBIDColumn() && !this.model.isGeometryColumn()) {
          menuItems.push({
            label: _t('components.table.columns.options.delete'),
            val: 'delete',
            destructive: true,
            action: function action() {
              self._removeColumn();
            }
          });
        }
      }
  
      var collection = new CustomListCollection(menuItems);
  
      this._menuView = new ContextMenuView({
        className: ContextMenuView.prototype.className + ' Table-columnMenu',
        collection: collection,
        itemTemplate: tableHeadOptionsItemTemplate,
        itemView: TableHeadOptionsItemView,
        triggerElementID: modelCID,
        position: position
      });
  
      collection.bind('change:selected', function (menuItem) {
        var action = menuItem.get('action');
        action && action(menuItem);
      }, this);
  
      this._menuView.model.bind('change:visible', function (model, isContextMenuVisible) {
        if (this._hasContextMenu() && !isContextMenuVisible) {
          this._hideContextMenu();
        }
      }, this);
  
      this._menuView.show();
      this.addView(this._menuView);
  
      this._initScrollBinding();
    },
  
    _addColumn: function _addColumn() {
      addColumnOperation({
        columnsCollection: this._columnsCollection
      });
    },
  
    _changeColumnType: function _changeColumnType(newType) {
      var self = this;
      var oldType = this.model.get('type');
      var isTypeChangeDestructive = QueryColumnModel.isTypeChangeDestructive(oldType, newType);
      if (!isTypeChangeDestructive) {
        changeColumnTypeOperation({
          columnModel: this.model,
          newType: newType
        });
      } else {
        this._modals.create(function (modalModel) {
          return new ConfirmationModalView({
            modalModel: modalModel,
            template: __webpack_require__(/*! ./modals-templates/change-table-column-type.tpl */ "./lib/assets/javascripts/builder/components/table/head/modals-templates/change-table-column-type.tpl"),
            renderOpts: {
              columnName: self.model.get('name'),
              newType: newType
            },
            loadingTitle: _t('components.table.columns.change-type.loading', {
              columnName: self.model.get('name')
            }),
            runAction: function runAction() {
              changeColumnTypeOperation({
                columnModel: self.model,
                newType: newType,
                onSuccess: function onSuccess() {
                  modalModel.destroy();
                },
                onError: function onError(e) {
                  modalModel.destroy();
                }
              });
            }
          });
        });
      }
    },
  
    _removeColumn: function _removeColumn() {
      var self = this;
      this._modals.create(function (modalModel) {
        return new ConfirmationModalView({
          modalModel: modalModel,
          template: __webpack_require__(/*! ./modals-templates/remove-table-column.tpl */ "./lib/assets/javascripts/builder/components/table/head/modals-templates/remove-table-column.tpl"),
          renderOpts: {
            name: self.model.get('name')
          },
          loadingTitle: _t('components.table.columns.destroy.loading', {
            columnName: self.model.get('name')
          }),
          runAction: function runAction() {
            removeTableColumnOperation({
              columnModel: self.model,
              onSuccess: function onSuccess() {
                modalModel.destroy();
              },
              onError: function onError(e) {
                modalModel.destroy();
              }
            });
          }
        });
      });
    },
  
    _onAttributeDblClicked: function _onAttributeDblClicked() {
      if (this.model.isEditable() && !this._tableViewModel.isDisabled()) {
        this._startEditing();
      }
    },
  
    _initRenameBinds: function _initRenameBinds() {
      $(document).bind('keydown', this._onKeyDown);
    },
  
    _destroyRenameBinds: function _destroyRenameBinds() {
      $(document).unbind('keydown', this._onKeyDown);
    },
  
    _onKeyDown: function _onKeyDown(ev) {
      var keyCode = ev.which;
      if (keyCode === ENTER_KEY_CODE) {
        this._saveNewName();
      } else if (keyCode === ESC_KEY_CODE) {
        this._finishEditing();
      }
    },
  
    _startEditing: function _startEditing() {
      this.$('.js-attribute').addClass('is-active').removeAttr('readonly');
  
      this._initRenameBinds();
    },
  
    _finishEditing: function _finishEditing() {
      this.$('.js-attribute').val(this.model.get('name')).removeClass('is-active').attr('readonly', '');
  
      this._destroyRenameBinds();
    },
  
    _saveNewName: function _saveNewName() {
      if (this.model.isEditable()) {
        var newName = this.$('.js-attribute').val();
        var columnModel = this.model;
        var oldName = columnModel.get('name');
  
        if (oldName !== newName && newName !== '') {
          this._modals.create(function (modalModel) {
            return new ConfirmationModalView({
              modalModel: modalModel,
              template: __webpack_require__(/*! ./modals-templates/rename-table-column.tpl */ "./lib/assets/javascripts/builder/components/table/head/modals-templates/rename-table-column.tpl"),
              renderOpts: {
                columnName: oldName,
                newName: newName
              },
              loadingTitle: _t('components.table.columns.rename.loading', {
                columnName: oldName,
                newName: newName
              }),
              runAction: function runAction() {
                renameColumnOperation({
                  columnModel: columnModel,
                  newName: newName,
                  onSuccess: function onSuccess() {
                    modalModel.destroy();
                  },
                  onError: function onError(e) {
                    modalModel.destroy();
                  }
                });
              }
            });
          });
        }
      }
  
      // Setting old name just in case user cancel it
      this._finishEditing();
    },
  
    focusInput: function focusInput() {
      this._startEditing();
      this.$('.js-attribute').select();
    },
  
    clean: function clean() {
      this._destroyRenameBinds();
      this._destroyScrollBinding();
      CoreView.prototype.clean.apply(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/head/table-head-options-item-view.js":
  /*!**********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/head/table-head-options-item-view.js ***!
    \**********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CustomListItemView = __webpack_require__(/*! builder/components/custom-list/custom-list-item-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item-view.js");
  var CustomListView = __webpack_require__(/*! builder/components/custom-list/custom-view */ "./lib/assets/javascripts/builder/components/custom-list/custom-view.js");
  var QueryColumnModel = __webpack_require__(/*! builder/data/query-column-model */ "./lib/assets/javascripts/builder/data/query-column-model.js");
  
  module.exports = CustomListItemView.extend({
  
    events: _.extend(CustomListItemView.prototype.events, {
      'click .js-desc': '_onDescClick',
      'click .js-asc': '_onAscClick',
      'click .js-order': 'killEvent'
    }),
  
    render: function render() {
      this.$el.empty();
      this.clearSubViews();
  
      this.$el.append(this.options.template({
        typeLabel: this.options.typeLabel,
        isSelected: this.model.get('selected'),
        isDisabled: this.model.get('disabled'),
        isDestructive: this.model.get('destructive'),
        isOrderBy: this.model.get('isOrderBy'),
        sortBy: this.model.get('sortBy'),
        name: this.model.getName(),
        val: this.model.getValue()
      }));
  
      this.$el.attr('data-val', this.model.getValue()).toggleClass('is-disabled', !!this.model.get('disabled'));
  
      return this;
    },
  
    _onClick: function _onClick(ev) {
      this.killEvent(ev);
  
      if (this.model.getValue() === 'change') {
        this._openSubContextMenu(ev);
      } else {
        this.model.set('selected', true);
      }
    },
  
    _hideSubContextMenu: function _hideSubContextMenu() {
      if (this._subContextMenu) {
        this._subContextMenu.clean();
        this.removeView(this._subContextMenu);
        delete this.collection;
        delete this._subContextMenu;
      }
    },
  
    _openSubContextMenu: function _openSubContextMenu(ev) {
      if (this._subContextMenu) {
        this._hideSubContextMenu();
      }
  
      var subContextClassName = 'Table-columnTypeMenu ';
      if (this.model.get('isLastColumns')) {
        subContextClassName += ' Table-columnTypeMenu--toLeft ';
      }
  
      this._subContextMenu = new CustomListView({
        className: subContextClassName + CustomListView.prototype.className,
        options: [{
          label: _t('components.table.columns.types.number'),
          disabled: !QueryColumnModel.isTypeChangeAllowed(this.model.get('type'), 'number'),
          val: 'number'
        }, {
          label: _t('components.table.columns.types.string'),
          disabled: !QueryColumnModel.isTypeChangeAllowed(this.model.get('type'), 'string'),
          val: 'string'
        }, {
          label: _t('components.table.columns.types.date'),
          disabled: !QueryColumnModel.isTypeChangeAllowed(this.model.get('type'), 'date'),
          val: 'date'
        }, {
          label: _t('components.table.columns.types.boolean'),
          disabled: !QueryColumnModel.isTypeChangeAllowed(this.model.get('type'), 'boolean'),
          val: 'boolean'
        }],
        showSearch: false,
        typeLabel: ''
      });
  
      this._subContextMenu.collection.bind('change:selected', function (menuItem) {
        if (!menuItem.get('disabled')) {
          this.model.set({
            type: menuItem.getValue(),
            selected: true
          });
        }
      }, this);
  
      this.$el.closest('.Table-columnMenu').append(this._subContextMenu.render().el);
      this._subContextMenu.show();
      this.addView(this._subContextMenu);
    },
  
    _onAscClick: function _onAscClick(ev) {
      this.killEvent(ev);
      this.model.set({
        sort: 'asc',
        selected: true
      });
    },
  
    _onDescClick: function _onDescClick(ev) {
      this.killEvent(ev);
      this.model.set({
        sort: 'desc',
        selected: true
      });
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/head/table-head-view.js":
  /*!*********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/head/table-head-view.js ***!
    \*********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var TableHeadItemView = __webpack_require__(/*! ./table-head-item-view */ "./lib/assets/javascripts/builder/components/table/head/table-head-item-view.js");
  var template = __webpack_require__(/*! ./table-head.tpl */ "./lib/assets/javascripts/builder/components/table/head/table-head.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['columnsCollection', 'tableViewModel', 'queryGeometryModel', 'canHideColumns', 'modals'];
  
  /*
   *  Main table head view
   */
  module.exports = CoreView.extend({
    className: 'Table-head',
    tagName: 'table',
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
      this._lastHeadItemView = null;
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      this.$el.append(template());
      this._columnsCollection.each(this._renderColumnHead, this);
      return this;
    },
  
    _initBinds: function _initBinds() {
      this._queryGeometryModel.bind('change:simple_geom', this.render, this);
      this.add_related_model(this._queryGeometryModel);
      this._tableViewModel.bind('change:sort_order change:order_by', this.render, this);
      this.add_related_model(this._tableViewModel);
      this._columnsCollection.bind('reset', function () {
        this.render();
  
        if (this._newColumn) {
          var scrollWidth = this.$el.get(0).scrollWidth;
  
          setTimeout(function () {
            this._scrollToLeft({
              pos: scrollWidth
            });
            this._focusLastHeadItem();
          }.bind(this), 500);
  
          delete this._newColumn;
        }
      }, this);
      this._columnsCollection.bind('add', function (model) {
        this._newColumn = model;
      }, this);
      this.add_related_model(this._columnsCollection);
    },
  
    _renderColumnHead: function _renderColumnHead(model) {
      var columnName = model.get('name');
  
      if (!this._tableViewModel.isCustomQueryApplied() && columnName === 'the_geom_webmercator') {
        return;
      }
  
      if (this._canHideColumns && columnName === 'center' && model.isGeometryColumn()) {
        return;
      }
  
      var view = new TableHeadItemView({
        model: model,
        modals: this._modals,
        columnsCollection: this._columnsCollection,
        tableViewModel: this._tableViewModel,
        simpleGeometry: this._queryGeometryModel.get('simple_geom')
      });
      this.$('.js-headRow').append(view.render().el);
      this.addView(view);
  
      this._lastHeadItemView = view;
    },
  
    _scrollToLeft: function _scrollToLeft(opts) {
      opts = opts || {};
      $('.Table').animate({
        scrollLeft: opts.pos || 0
      }, opts.speed || 'slow');
    },
  
    _focusLastHeadItem: function _focusLastHeadItem() {
      if (this._lastHeadItemView) {
        this._lastHeadItemView.focusInput();
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/operations/table-add-column.js":
  /*!****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/operations/table-add-column.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Notifier = __webpack_require__(/*! builder/components/notifier/notifier */ "./lib/assets/javascripts/builder/components/notifier/notifier.js");
  var errorParser = __webpack_require__(/*! builder/helpers/error-parser */ "./lib/assets/javascripts/builder/helpers/error-parser.js");
  
  module.exports = function (opts) {
    if (!opts.columnsCollection) throw new Error('columnsCollection is required');
  
    var columnsCollection = opts.columnsCollection;
    var successCallback = opts.onSuccess;
    var errorCallback = opts.onError;
    var notification = Notifier.addNotification({
      status: 'loading',
      info: _t('components.table.columns.create.loading'),
      closable: false
    });
  
    columnsCollection.addColumn({
      success: function success(model, attrs) {
        successCallback && successCallback(model, attrs);
        notification.set({
          status: 'success',
          info: _t('components.table.columns.create.success', { columnName: attrs.name }),
          closable: true
        });
      },
      error: function error(model, err) {
        errorCallback && errorCallback(model, err);
        notification.set({
          status: 'error',
          info: _t('components.table.columns.create.error', { error: errorParser(err) }),
          closable: true
        });
      }
    });
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/operations/table-add-row.js":
  /*!*************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/operations/table-add-row.js ***!
    \*************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Notifier = __webpack_require__(/*! builder/components/notifier/notifier */ "./lib/assets/javascripts/builder/components/notifier/notifier.js");
  var errorParser = __webpack_require__(/*! builder/helpers/error-parser */ "./lib/assets/javascripts/builder/helpers/error-parser.js");
  
  module.exports = function (opts) {
    if (!opts.rowsCollection) {
      throw new Error('rowsCollection is required');
    }
  
    var rowsCollection = opts.rowsCollection;
    var successCallback = opts.onSuccess;
    var errorCallback = opts.onError;
    var notification = Notifier.addNotification({
      status: 'loading',
      info: _t('components.table.rows.create.loading'),
      closable: false
    });
  
    rowsCollection.addRow({
      success: function success(model, attrs) {
        successCallback && successCallback(model, attrs);
        notification.set({
          status: 'success',
          info: _t('components.table.rows.create.success'),
          closable: true
        });
      },
      error: function error(model, err) {
        errorCallback && errorCallback(model, err);
        notification.set({
          status: 'error',
          info: _t('components.table.rows.create.error', { error: errorParser(err) }),
          closable: true
        });
      }
    });
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/operations/table-change-column-type.js":
  /*!************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/operations/table-change-column-type.js ***!
    \************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Notifier = __webpack_require__(/*! builder/components/notifier/notifier */ "./lib/assets/javascripts/builder/components/notifier/notifier.js");
  var errorParser = __webpack_require__(/*! builder/helpers/error-parser */ "./lib/assets/javascripts/builder/helpers/error-parser.js");
  
  module.exports = function (opts) {
    if (!opts.columnModel) {
      throw new Error('columnModel is required');
    }
    if (!opts.newType) {
      throw new Error('newType is required');
    }
  
    var columnModel = opts.columnModel;
    var newType = opts.newType;
  
    var successCallback = opts.onSuccess;
    var errorCallback = opts.onError;
  
    var notification = Notifier.addNotification({
      status: 'loading',
      info: _t('components.table.columns.change-type.loading', {
        columnName: columnModel.get('name')
      }),
      closable: false
    });
  
    columnModel.save({
      type: newType
    }, {
      wait: true,
      success: function success(model, attrs) {
        successCallback && successCallback(model, attrs);
        notification.set({
          status: 'success',
          info: _t('components.table.columns.change-type.success', {
            columnName: columnModel.get('name'),
            newType: newType
          }),
          closable: true
        });
      },
      error: function error(model, err) {
        errorCallback && errorCallback(model, err);
        notification.set({
          status: 'error',
          info: _t('components.table.columns.change-type.error', {
            columnName: columnModel.get('name'),
            newType: newType,
            error: errorParser(err)
          }),
          closable: true
        });
      }
    });
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/operations/table-edit-cell.js":
  /*!***************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/operations/table-edit-cell.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Notifier = __webpack_require__(/*! builder/components/notifier/notifier */ "./lib/assets/javascripts/builder/components/notifier/notifier.js");
  var errorParser = __webpack_require__(/*! builder/helpers/error-parser */ "./lib/assets/javascripts/builder/helpers/error-parser.js");
  
  module.exports = function (opts) {
    if (!opts.rowModel) throw new Error('rowModel is required');
    if (opts.newValue === undefined) throw new Error('newValue is required');
    if (!opts.attribute) throw new Error('attribute is required');
  
    var rowModel = opts.rowModel;
    var newValue = opts.newValue;
    var attribute = opts.attribute;
    var cartodbId = rowModel.get('cartodb_id');
    var successCallback = opts.onSuccess;
    var errorCallback = opts.onError;
    var notification = Notifier.addNotification({
      status: 'loading',
      info: _t('components.table.rows.edit.loading', {
        attribute: attribute,
        cartodbId: cartodbId
      }),
      closable: false
    });
  
    // In order to preserve "previous" attribute
    rowModel.set(attribute, newValue);
    rowModel.save(null, {
      success: function success(model, attrs) {
        successCallback && successCallback(model, attrs);
        notification.set({
          status: 'success',
          info: _t('components.table.rows.edit.success', {
            attribute: attribute,
            cartodbId: cartodbId
          }),
          closable: true
        });
      },
      error: function error(model, err) {
        errorCallback && errorCallback(model, err);
        notification.set({
          status: 'error',
          info: _t('components.table.rows.edit.error', {
            attribute: attribute,
            cartodbId: cartodbId,
            error: errorParser(err)
          }),
          closable: true
        });
      }
    });
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/operations/table-remove-column.js":
  /*!*******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/operations/table-remove-column.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Notifier = __webpack_require__(/*! builder/components/notifier/notifier */ "./lib/assets/javascripts/builder/components/notifier/notifier.js");
  var errorParser = __webpack_require__(/*! builder/helpers/error-parser */ "./lib/assets/javascripts/builder/helpers/error-parser.js");
  
  module.exports = function (opts) {
    if (!opts.columnModel) {
      throw new Error('columnModel is required');
    }
  
    var columnModel = opts.columnModel;
    var successCallback = opts.onSuccess;
    var errorCallback = opts.onError;
    var notification = Notifier.addNotification({
      status: 'loading',
      info: _t('components.table.columns.destroy.loading', { columnName: columnModel.get('name') }),
      closable: false
    });
  
    columnModel.destroy({
      wait: true,
      success: function success(model, attrs) {
        successCallback && successCallback(model, attrs);
        notification.set({
          status: 'success',
          info: _t('components.table.columns.destroy.success', { columnName: columnModel.get('name') }),
          closable: true
        });
      },
      error: function error(model, err) {
        errorCallback && errorCallback(model, err);
        notification.set({
          status: 'error',
          info: _t('components.table.columns.destroy.error', {
            columnName: columnModel.get('name'),
            error: errorParser(err)
          }),
          closable: true
        });
      }
    });
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/operations/table-remove-row.js":
  /*!****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/operations/table-remove-row.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Notifier = __webpack_require__(/*! builder/components/notifier/notifier */ "./lib/assets/javascripts/builder/components/notifier/notifier.js");
  var errorParser = __webpack_require__(/*! builder/helpers/error-parser */ "./lib/assets/javascripts/builder/helpers/error-parser.js");
  
  module.exports = function (opts) {
    if (!opts.rowModel) {
      throw new Error('rowModel is required');
    }
  
    var rowModel = opts.rowModel;
    var successCallback = opts.onSuccess;
    var errorCallback = opts.onError;
    var cartodbId = rowModel.get('cartodb_id');
    var notification = Notifier.addNotification({
      status: 'loading',
      info: _t('components.table.rows.destroy.loading', { cartodb_id: cartodbId }),
      closable: false
    });
  
    rowModel.destroy({
      wait: true,
      success: function success(model, attrs) {
        successCallback && successCallback(model, attrs);
        notification.set({
          status: 'success',
          info: _t('components.table.rows.destroy.success', { cartodb_id: cartodbId }),
          closable: true
        });
      },
      error: function error(model, err) {
        errorCallback && errorCallback(model, err);
        notification.set({
          status: 'error',
          info: _t('components.table.rows.destroy.error', { cartodb_id: cartodbId, error: errorParser(err) }),
          closable: true
        });
      }
    });
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/operations/table-rename-column.js":
  /*!*******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/operations/table-rename-column.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Notifier = __webpack_require__(/*! builder/components/notifier/notifier */ "./lib/assets/javascripts/builder/components/notifier/notifier.js");
  var errorParser = __webpack_require__(/*! builder/helpers/error-parser */ "./lib/assets/javascripts/builder/helpers/error-parser.js");
  
  module.exports = function (opts) {
    if (!opts.columnModel) {
      throw new Error('columnModel is required');
    }
    if (!opts.newName) {
      throw new Error('newName is required');
    }
  
    var columnModel = opts.columnModel;
    var oldName = columnModel.get('name');
    var newName = opts.newName;
  
    var successCallback = opts.onSuccess;
    var errorCallback = opts.onError;
  
    var notification = Notifier.addNotification({
      status: 'loading',
      info: _t('components.table.columns.rename.loading', { oldName: oldName, newName: newName }),
      closable: false
    });
  
    columnModel.save({
      new_name: newName,
      old_name: columnModel.get('name')
    }, {
      wait: true,
      success: function success(model, attrs) {
        successCallback && successCallback(model, attrs);
        notification.set({
          status: 'success',
          info: _t('components.table.columns.rename.success', {
            columnName: oldName,
            newName: newName
          }),
          closable: true
        });
      },
      error: function error(model, err) {
        errorCallback && errorCallback(model, err);
        notification.set({
          status: 'error',
          info: _t('components.table.columns.rename.error', {
            columnName: oldName,
            newName: newName,
            error: errorParser(err)
          }),
          closable: true
        });
      }
    });
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/paginator/table-paginator-view.js":
  /*!*******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/paginator/table-paginator-view.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./table-paginator.tpl */ "./lib/assets/javascripts/builder/components/table/paginator/table-paginator.tpl");
  var templateLoader = __webpack_require__(/*! ./table-paginator-loader.tpl */ "./lib/assets/javascripts/builder/components/table/paginator/table-paginator-loader.tpl");
  var Notifier = __webpack_require__(/*! builder/components/notifier/notifier */ "./lib/assets/javascripts/builder/components/notifier/notifier.js");
  var errorParser = __webpack_require__(/*! builder/helpers/error-parser */ "./lib/assets/javascripts/builder/helpers/error-parser.js");
  var QueryUtilsModel = __webpack_require__(/*! builder/helpers/query-utils-model */ "./lib/assets/javascripts/builder/helpers/query-utils-model.js");
  
  module.exports = CoreView.extend({
  
    tagName: 'div',
    className: 'Table-paginator js-tablePaginator',
  
    events: {
      'click .js-prev': '_onPrevPage',
      'click .js-next': '_onNextPage'
    },
  
    initialize: function initialize(opts) {
      if (!opts.rowsCollection) throw new Error('rowsCollection is required');
      if (!opts.tableViewModel) throw new Error('tableViewModel is required');
  
      this._tableViewModel = opts.tableViewModel;
      this._rowsCollection = opts.rowsCollection;
      this._scrollToBottom = opts.scrollToBottom;
      this._numRows = -1;
  
      this._queryUtilsModel = opts.queryUtilsModel || new QueryUtilsModel({
        subquery: this._rowsCollection._querySchemaModel.get('query'),
        configModel: this._rowsCollection._configModel
      });
  
      this._queryUtilsModel.fetchCount(function (numRows) {
        // Check total number of rows to evaluate
        // if there is a next page available
        this._numRows = numRows;
        this.render();
      }.bind(this));
  
      this._rowsCollection.bind('loading', function (item) {
        // Don't take into account row model loading triggers
        if (item.models) {
          this._isLoading = true;
        }
      }, this);
      this._rowsCollection.bind('add', this._onRowAdded, this);
      this._rowsCollection.bind('remove', this._onRowRemoved, this);
      this._tableViewModel.bind('change:page', this._onTablePageChange, this);
      this.add_related_model(this._tableViewModel);
      this.add_related_model(this._rowsCollection);
    },
  
    render: function render() {
      var rowsSize = this._rowsCollection.size();
      var page = this._tableViewModel.get('page');
      var maxRowsPerPage = this._rowsCollection.DEFAULT_FETCH_OPTIONS.rows_per_page;
  
      this.$el.html(template({
        page: this._tableViewModel.get('page'),
        size: rowsSize,
        isNextAvailable: this._numRows > (page + 1) * maxRowsPerPage,
        isPrevAvailable: page > 0
      }));
  
      this.$el.toggleClass('Table-paginator--relative', !!this._tableViewModel.get('relativePositionated'));
      return this;
    },
  
    _onRowAdded: function _onRowAdded() {
      this._queryUtilsModel.fetchCount(function (numRows) {
        if (numRows > -1) {
          // Go to the last page
          var maxRowsPerPage = this._rowsCollection.DEFAULT_FETCH_OPTIONS.rows_per_page;
          var lastPage = Math.ceil(numRows / maxRowsPerPage) - 1;
          if (lastPage !== this._tableViewModel.get('page')) {
            this._tableViewModel.set('page', lastPage);
          } else {
            this.render();
          }
          setTimeout(this._scrollToBottom, 200);
        }
      }.bind(this));
    },
  
    _onRowRemoved: function _onRowRemoved() {
      this._rowsCollection.fetch({
        data: this._getData()
      });
    },
  
    _onTablePageChange: function _onTablePageChange() {
      this._rowsCollection.fetch({
        data: this._getData(),
        error: function (mdl, response) {
          this._isLoading = false;
          this.render();
  
          Notifier.addNotification({
            status: 'error',
            info: _t('components.table.rows.paginator.error', { error: errorParser(response) }),
            closable: true
          });
        }.bind(this)
      });
    },
  
    _getData: function _getData() {
      return _.extend(this._tableViewModel.pick('page', 'order_by', 'sort_order'), {
        exclude: !this._tableViewModel.isCustomQueryApplied() ? ['the_geom_webmercator'] : []
      });
    },
  
    _onPrevPage: function _onPrevPage(ev) {
      if (!this._isLoading) {
        this.$('.js-prev').html(templateLoader());
        this._tableViewModel.set('page', this._tableViewModel.get('page') - 1);
      }
    },
  
    _onNextPage: function _onNextPage(ev) {
      if (!this._isLoading) {
        this.$('.js-next').html(templateLoader());
        this._tableViewModel.set('page', this._tableViewModel.get('page') + 1);
      }
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/table-manager.js":
  /*!**************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/table-manager.js ***!
    \**************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var TableView = __webpack_require__(/*! ./table-view */ "./lib/assets/javascripts/builder/components/table/table-view.js");
  var QueryColumnsCollection = __webpack_require__(/*! builder/data/query-columns-collection */ "./lib/assets/javascripts/builder/data/query-columns-collection.js");
  var TableNameUtils = __webpack_require__(/*! builder/helpers/table-name-utils */ "./lib/assets/javascripts/builder/helpers/table-name-utils.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['analysisDefinitionNodeModel', 'configModel', 'modals', 'userModel'];
  
  /**
   *  Table manager that generates necessary models/collections
   *  for the view
   *
   */
  
  module.exports = {
    create: function create(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      // Adds the owner username if it's in an organization and the table name is not already qualified
      var tableName = this._analysisDefinitionNodeModel.get('table_name');
      var userName = TableNameUtils.getUsername(tableName) || this._userModel.get('username');
      tableName = TableNameUtils.getQualifiedTableName(tableName, userName, this._userModel.isInsideOrg());
  
      var querySchemaModel = this._analysisDefinitionNodeModel.querySchemaModel;
  
      var columnsCollection = new QueryColumnsCollection(querySchemaModel.columnsCollection.toJSON(), {
        configModel: this._configModel,
        tableName: tableName,
        querySchemaModel: querySchemaModel
      });
  
      return new TableView({
        relativePositionated: opts.relativePositionated,
        modals: this._modals,
        analysisDefinitionNodeModel: this._analysisDefinitionNodeModel,
        columnsCollection: columnsCollection,
        tableName: tableName
      });
    },
  
    destroy: function destroy(tableView) {
      if (!tableView) throw new Error('tableView object is needed');
      tableView.clean();
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/table-view-model.js":
  /*!*****************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/table-view-model.js ***!
    \*****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   *  Table view model
   */
  
  module.exports = Backbone.Model.extend({
    defaults: {
      page: 0,
      order_by: '',
      sort_order: '',
      readonly: false,
      tableName: ''
    },
  
    initialize: function initialize(attrs, opts) {
      if (!opts.analysisDefinitionNodeModel) throw new Error('analysisDefinitionNodeModel is required');
      if (!opts.columnsCollection) throw new Error('columnsCollection is required');
  
      this._analysisDefinitionNodeModel = opts.analysisDefinitionNodeModel;
      this._columnsCollection = opts.columnsCollection;
  
      this._setOrderAndSort();
  
      this.listenTo(this._columnsCollection, 'reset', this._setOrderAndSort);
    },
  
    _setOrderAndSort: function _setOrderAndSort() {
      var hasCartodbId = this._columnsCollection.where({ name: 'cartodb_id' }).length;
  
      if (hasCartodbId && !this.isCustomQueryApplied()) {
        this.set({
          'order_by': 'cartodb_id',
          'sort_order': 'asc'
        }, {
          silent: true
        });
      }
    },
  
    resetFetchDefaults: function resetFetchDefaults() {
      this.set({
        page: this.defaults.page,
        order_by: '',
        sort_order: ''
      }, {
        silent: true
      });
    },
  
    isDisabled: function isDisabled() {
      return this._analysisDefinitionNodeModel.isReadOnly();
    },
  
    isCustomQueryApplied: function isCustomQueryApplied() {
      return this._analysisDefinitionNodeModel.isCustomQueryApplied();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/table/table-view.js":
  /*!***********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/table/table-view.js ***!
    \***********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var TableViewModel = __webpack_require__(/*! ./table-view-model.js */ "./lib/assets/javascripts/builder/components/table/table-view-model.js");
  var TableHeadView = __webpack_require__(/*! ./head/table-head-view */ "./lib/assets/javascripts/builder/components/table/head/table-head-view.js");
  var TableBodyView = __webpack_require__(/*! ./body/table-body-view */ "./lib/assets/javascripts/builder/components/table/body/table-body-view.js");
  var addTableRow = __webpack_require__(/*! ./operations/table-add-row */ "./lib/assets/javascripts/builder/components/table/operations/table-add-row.js");
  var addTableColumn = __webpack_require__(/*! ./operations/table-add-column */ "./lib/assets/javascripts/builder/components/table/operations/table-add-column.js");
  var SQLUtils = __webpack_require__(/*! builder/helpers/sql-utils */ "./lib/assets/javascripts/builder/helpers/sql-utils.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var _require = __webpack_require__(/*! builder/helpers/analysis-node-utils */ "./lib/assets/javascripts/builder/helpers/analysis-node-utils.js"),
      nodeHasTradeArea = _require.nodeHasTradeArea,
      nodeHasSQLFunction = _require.nodeHasSQLFunction;
  
  var REQUIRED_OPTS = ['analysisDefinitionNodeModel', 'columnsCollection', 'modals'];
  
  /*
   *  Main table view
   */
  
  module.exports = CoreView.extend({
  
    className: 'Table-wrapper',
    tagName: 'div',
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this._rowsCollection = this._analysisDefinitionNodeModel.queryRowsCollection;
      this._queryGeometryModel = this._analysisDefinitionNodeModel.queryGeometryModel;
      this._querySchemaModel = this._analysisDefinitionNodeModel.querySchemaModel;
      this._tableModel = this._analysisDefinitionNodeModel.isSourceType() && this._analysisDefinitionNodeModel.getTableModel();
  
      this._tableViewModel = new TableViewModel({
        relativePositionated: opts.relativePositionated,
        tableName: opts.tableName
      }, {
        analysisDefinitionNodeModel: this._analysisDefinitionNodeModel,
        columnsCollection: this._columnsCollection
      });
  
      this._initBinds();
  
      if (this._querySchemaModel.shouldFetch()) {
        this._querySchemaModel.fetch();
      } else if (this._rowsCollection.shouldFetch()) {
        this._fetchRowsData();
      }
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
      var tableElement = $('<div>').addClass('Table js-table');
      this.$el.append(tableElement);
      this._initViews();
  
      this.$('.js-table').toggleClass('Table--relative', !!this._tableViewModel.get('relativePositionated'));
      this._setDisableState();
      return this;
    },
  
    _initBinds: function _initBinds() {
      this._onChangeQueryOrStatus = this._onChangeQueryOrStatus.bind(this);
  
      this.listenTo(this._querySchemaModel, 'change:query change:status', _.debounce(this._onChangeQueryOrStatus, 100));
      this.listenTo(this._querySchemaModel, 'change:status', this._setDisableState);
      this.listenTo(this._querySchemaModel, 'change:query', this._onQueryChanged);
      this.listenTo(this._querySchemaModel, 'change:status', this._fetchRowsData);
      this.listenTo(this._tableViewModel, 'change:sort_order change:order_by', this._fetchRowsData);
  
      if (this._tableModel && this._tableModel.isSync()) {
        var syncModel = this._tableModel.getSyncModel();
        this.listenTo(syncModel, 'destroy', this.render);
      }
    },
  
    _setDisableState: function _setDisableState() {
      this.$('.js-table').toggleClass('is-disabled', !!this._tableViewModel.isDisabled());
    },
  
    _fetchRowsData: function _fetchRowsData(model) {
      var attrsChanged = model && _.keys(model.changed);
      var altersData = SQLUtils.altersData(this._querySchemaModel.get('query'));
      var isCustomQueryApplied = this._tableViewModel.isCustomQueryApplied();
      var changeComeFromSortOrOrder = false;
  
      if (attrsChanged && (_.contains(attrsChanged, 'sort_order') || _.contains(attrsChanged, 'order_by'))) {
        changeComeFromSortOrOrder = true;
      }
  
      if (this._querySchemaModel.isFetched() && !altersData) {
        this._rowsCollection.fetch({
          data: {
            page: this._tableViewModel.get('page'),
            order_by: !isCustomQueryApplied || changeComeFromSortOrOrder ? this._tableViewModel.get('order_by') : '',
            sort_order: !isCustomQueryApplied || changeComeFromSortOrOrder ? this._tableViewModel.get('sort_order') : '',
            exclude: !isCustomQueryApplied || changeComeFromSortOrOrder ? ['the_geom_webmercator'] : []
          }
        });
      }
    },
  
    _initViews: function _initViews() {
      var canHideColumns = nodeHasTradeArea(this._analysisDefinitionNodeModel) && !nodeHasSQLFunction(this._analysisDefinitionNodeModel);
  
      var tableHeadView = new TableHeadView({
        modals: this._modals,
        queryGeometryModel: this._queryGeometryModel,
        columnsCollection: this._columnsCollection,
        tableViewModel: this._tableViewModel,
        canHideColumns: canHideColumns
      });
  
      this.addView(tableHeadView);
      this.$('.js-table').append(tableHeadView.render().el);
  
      var tableBodyView = new TableBodyView({
        modals: this._modals,
        columnsCollection: this._columnsCollection,
        rowsCollection: this._rowsCollection,
        queryGeometryModel: this._queryGeometryModel,
        querySchemaModel: this._querySchemaModel,
        canHideColumns: canHideColumns,
        tableViewModel: this._tableViewModel
      });
  
      this.addView(tableBodyView);
      this.$('.js-table').append(tableBodyView.render().el);
    },
  
    _onChangeQueryOrStatus: function _onChangeQueryOrStatus() {
      var schemaStatus = this._querySchemaModel.get('status');
      var geometryStatus = this._queryGeometryModel.get('status');
  
      if (schemaStatus === 'unfetched' && this._querySchemaModel.canFetch()) {
        this._querySchemaModel.fetch();
      }
  
      if (geometryStatus === 'unfetched' && this._queryGeometryModel.canFetch()) {
        this._queryGeometryModel.fetch();
      }
    },
  
    addRow: function addRow() {
      addTableRow({
        rowsCollection: this._rowsCollection
      });
    },
  
    addColumn: function addColumn() {
      addTableColumn({
        columnsCollection: this._columnsCollection
      });
    },
  
    getColumnsCollection: function getColumnsCollection() {
      return this._columnsCollection;
    },
  
    _onQueryChanged: function _onQueryChanged() {
      this._tableViewModel.resetFetchDefaults();
    },
  
    // Remove elements that are not applied in the view
    remove: function remove() {
      $('.Table-paginator').remove();
      CoreView.prototype.remove.apply(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js":
  /*!*************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js ***!
    \*************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  __webpack_require__(/*! tipsy */ "./vendor/assets/javascripts/jquery.tipsy.js");
  
  /**
   *  Tipsy tooltip view.
   *
   *  - Needs an element to work.
   *  - Inits tipsy library.
   *  - Clean bastard tipsy bindings easily.
   *
   */
  
  module.exports = CoreView.extend({
    options: {
      gravity: 's',
      opacity: 1,
      fade: true
    },
  
    events: {
      'mouseenter': '_onMouseEnter',
      'mouseleave': '_onMouseLeave'
    },
  
    initialize: function initialize(opts) {
      if (!opts.el) throw new Error('Element is needed to have tipsy tooltip working');
  
      this._mouseEnterAction = opts.mouseEnterAction;
      this._mouseLeaveAction = opts.mouseLeaveAction;
      this._tipsyOpenedManually = opts.trigger === 'manual';
  
      this._initTipsy();
    },
  
    _initTipsy: function _initTipsy() {
      var options = _.clone(this.options);
  
      if (options.gravity === 'auto') {
        options.gravity = this.getOptimalGravity(options.gravityConfiguration && options.gravityConfiguration.preferredGravities || ['s', 'n', 'e', 'w'], options.gravityConfiguration && options.gravityConfiguration.margin || 0, window);
      }
  
      if (!options.title) {
        options.title = this.getTitleFromDataAttribute;
      }
  
      this.$el.tipsy(options);
      this.tipsy = this.$el.data('tipsy');
    },
  
    _onMouseEnter: function _onMouseEnter() {
      this._mouseEnterAction && this._mouseEnterAction();
    },
  
    _onMouseLeave: function _onMouseLeave() {
      this._mouseLeaveAction && this._mouseLeaveAction();
    },
  
    setOffset: function setOffset(offset) {
      this.tipsy.options.offset = offset;
    },
  
    showTipsy: function showTipsy() {
      this.$el.tipsy('show');
    },
  
    hideTipsy: function hideTipsy() {
      this.$el.tipsy('hide');
    },
  
    getElement: function getElement() {
      return this.el;
    },
  
    getOptimalGravity: function getOptimalGravity(preferredGravities, margin, browserWindow) {
      return function (tooltipElement) {
        if (!tooltipElement) {
          return preferredGravities[0] || 'n';
        }
  
        var tooltipContainer = this;
        var tooltipContainerBoundingRect = tooltipContainer.getBoundingClientRect();
        var gravityOptions = { n: 'bottom', s: 'top', w: 'right', e: 'left' };
  
        var viewportBoundaries = {
          top: browserWindow.pageYOffset + margin,
          right: browserWindow.innerWidth + browserWindow.pageXOffset - margin,
          bottom: browserWindow.innerHeight + browserWindow.pageYOffset - margin,
          left: browserWindow.pageXOffset + margin
        };
  
        var tooltipBoundaries = {
          top: tooltipContainerBoundingRect.top - tooltipElement.offsetHeight,
          right: tooltipContainerBoundingRect.left + tooltipContainerBoundingRect.width + tooltipElement.offsetWidth,
          bottom: tooltipContainerBoundingRect.top + tooltipContainerBoundingRect.height + tooltipElement.offsetHeight,
          left: tooltipContainerBoundingRect.left - tooltipElement.offsetWidth
        };
  
        var tooltipBodyGravity = '';
        var optimalGravity = _.find(preferredGravities, function (gravity) {
          var position = gravityOptions[gravity];
          var tooltipFitsPosition = isTooltipInsideViewport(position, viewportBoundaries[position], tooltipBoundaries[position]);
  
          if (tooltipFitsPosition && (position === 'top' || position === 'bottom')) {
            tooltipBodyGravity = getTooltipBodyGravity(gravityOptions, viewportBoundaries, tooltipBoundaries);
          }
  
          return tooltipFitsPosition;
        });
  
        return optimalGravity ? optimalGravity + tooltipBodyGravity : preferredGravities[0];
      };
    },
  
    getTitleFromDataAttribute: function getTitleFromDataAttribute() {
      return this.getAttribute('data-tooltip');
    },
  
    destroyTipsy: function destroyTipsy() {
      if (this.tipsy) {
        // tipsy does not return this
        this.tipsy.hide();
        this.$el.unbind('mouseleave mouseenter');
      }
  
      if (this._tipsyOpenedManually) {
        this.hideTipsy();
      }
  
      this.$el.removeData('tipsy');
      delete this.tipsy;
    },
  
    clean: function clean() {
      this.destroyTipsy();
    }
  });
  
  var isTooltipInsideViewport = function isTooltipInsideViewport(bound, viewportBound, tooltipBound) {
    if (bound === 'top' || bound === 'left') {
      return viewportBound <= tooltipBound;
    }
  
    if (bound === 'right' || bound === 'bottom') {
      return viewportBound >= tooltipBound;
    }
  };
  
  var getTooltipBodyGravity = function getTooltipBodyGravity(gravityOptions, viewportBoundaries, tooltipBoundaries) {
    var nonCollisioningEdges = _.filter(['e', 'w'], function (edge) {
      var bound = gravityOptions[edge];
      return isTooltipInsideViewport(bound, viewportBoundaries[bound], tooltipBoundaries[bound]);
    });
  
    if (nonCollisioningEdges.length === 1) {
      return nonCollisioningEdges[0];
    }
  
    return '';
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/toggler/toggler-view.js":
  /*!***************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/toggler/toggler-view.js ***!
    \***************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./toggler.tpl */ "./lib/assets/javascripts/builder/components/toggler/toggler.tpl");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  
  module.exports = CoreView.extend({
  
    className: 'Toggle',
  
    events: {
      'click .js-input': '_onClick'
    },
  
    initialize: function initialize(opts) {
      if (!opts.model) throw new Error('togglerModel should be provided');
  
      this.model = opts.model;
      this._onChange = this.model.get('onChange');
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
      this.$el.empty();
  
      this.$el.append(template({
        labels: this.model.get('labels'),
        checked: this.model.get('active'),
        disabled: this.model.get('disabled') && this.model.get('isDisableable')
      }));
  
      this._initViews();
  
      return this;
    },
  
    _initViews: function _initViews() {
      if (this.model.get('tooltip')) {
        var helpTooltip = new TipsyTooltipView({
          el: this.$('.js-input'),
          gravity: 's',
          offset: 0,
          title: function () {
            return this.model.get('tooltip');
          }.bind(this)
        });
        this.addView(helpTooltip);
      }
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this.model, 'change:active', this.render);
      this.listenTo(this.model, 'change:disabled', this.render);
    },
  
    _onClick: function _onClick() {
      this.model.set('active', !this.model.get('active'));
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/undo-redo/undo-redo-view.js":
  /*!*******************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/undo-redo/undo-redo-view.js ***!
    \*******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./undo-redo.tpl */ "./lib/assets/javascripts/builder/components/undo-redo/undo-redo.tpl");
  var TipsyTooltipView = __webpack_require__(/*! builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  
  module.exports = CoreView.extend({
    events: {
      'click .js-redo': '_onRedoClick',
      'click .js-undo': '_onUndoClick',
      'click .js-apply': '_onApplyClick',
      'click .js-clear': '_onClearClick'
    },
  
    options: {
      applyButton: false,
      cancelButton: false
    },
  
    initialize: function initialize(opts) {
      if (!opts.editorModel) throw new Error('editorModel is required');
      if (!opts.trackModel) throw new Error('trackModel is required');
  
      this._trackModel = opts.trackModel;
      this._editorModel = opts.editorModel;
      this._clearModel = opts.clearModel;
      this._applyStatusModel = opts.applyStatusModel;
      this._overlayModel = opts.overlayModel;
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
  
      var canClear = false;
      if (this._clearModel) {
        canClear = this._clearModel.get('visible') === true;
      }
  
      this.$el.html(template({
        canUndo: this._canUndo(),
        canRedo: this._canRedo(),
        canApply: this.options.applyButton && this._editorModel.isEditing(),
        canClear: canClear,
        isDisabled: this._isDisabled(),
        isLoading: this._applyStatusModel && this._applyStatusModel.get('loading')
      }));
  
      this._initViews();
      this._checkButtonsStyle();
  
      return this;
    },
  
    _initViews: function _initViews() {
      if (this._canUndo()) {
        var undoTooltip = new TipsyTooltipView({
          el: this.$('.js-undo'),
          gravity: 's',
          title: function title() {
            return _t('components.undo-redo.undo');
          }
        });
        this.addView(undoTooltip);
      }
  
      if (this._canRedo()) {
        var redoTooltip = new TipsyTooltipView({
          el: this.$('.js-redo'),
          gravity: 's',
          title: function title() {
            return _t('components.undo-redo.redo');
          }
        });
        this.addView(redoTooltip);
      }
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this._trackModel, 'undo redo', this.render);
      this.listenTo(this._trackModel, 'unredoChanged', this.render);
  
      this.listenTo(this._editorModel, 'change:edition', this._checkButtonsStyle);
  
      if (this._overlayModel) {
        this.listenTo(this._overlayModel, 'change:visible', this.render);
      }
  
      if (this._clearModel) {
        this.listenTo(this._clearModel, 'change', this.render);
      }
  
      if (this._applyStatusModel) {
        this.listenTo(this._applyStatusModel, 'change:loading', this._applyStatusChanged);
      }
    },
  
    _isDisabled: function _isDisabled() {
      return this._overlayModel && this._overlayModel.get('visible');
    },
  
    _canRedo: function _canRedo() {
      return this._trackModel.canRedo() && !this._isDisabled();
    },
  
    _canUndo: function _canUndo() {
      return this._trackModel.canUndo() && !this._isDisabled();
    },
  
    _onUndoClick: function _onUndoClick() {
      if (this._trackModel.canUndo()) {
        this._trackModel.undo();
      }
    },
  
    _onRedoClick: function _onRedoClick() {
      if (this._trackModel.canRedo()) {
        this._trackModel.redo();
      }
    },
  
    _onApplyClick: function _onApplyClick() {
      if (this.options.applyButton && this.options.onApplyClick && !this._isDisabled()) {
        this.options.onApplyClick();
      }
    },
  
    _onClearClick: function _onClearClick() {
      if (this.options.clearButton && this.options.onClearClick) {
        this.options.onClearClick();
      }
    },
  
    _checkButtonsStyle: function _checkButtonsStyle(m) {
      var editing = this._editorModel.isEditing();
      this._getIcons().toggleClass('u-actionTextColor', !editing);
      this._getIcons().toggleClass('u-whiteTextColor', editing);
    },
  
    _getIcons: function _getIcons() {
      return this.$('.js-theme');
    },
  
    _applyStatusChanged: function _applyStatusChanged() {
      this.render();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/view-factory.js":
  /*!*******************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/view-factory.js ***!
    \*******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  /**
   * Convenient factory to create views without having to create new files.
   */
  module.exports = {
  
    /**
     * @param {String} html e.g. '<div>whatever</div>'
     * @param {Object,undefined} viewOpts view options, .e.g {className: 'Whatever'}
     * @return {Object} instance of CoreView, which takes two params of template and templateData
     */
    createByHTML: function createByHTML(html, viewOpts) {
      var view = new CoreView(viewOpts);
      view.render = function () {
        this.$el.html(html);
        return this;
      };
  
      return view;
    },
  
    /**
     * @param {Function} template e.g. from a `require('-/my-template.tpl')`
     * @param {Object,undefined} templatedata
     * @param {Object,undefined} viewOpts view options, .e.g {className: 'Whatever'}
     * @return {Object} instance of CoreView, which takes two params of template and templateData
     */
    createByTemplate: function createByTemplate(template, templateData, viewOpts) {
      var view = new CoreView(viewOpts);
      view.render = function () {
        this.$el.html(template(templateData));
        return this;
      };
  
      return view;
    },
  
    /**
     * Creates an anonymous view to render a list of views as one.
     * Useful when wanting to interact with other components that requires a single view as content.
     *
     * @example
     *   var createViewList = [
     *     function() { return new HeaderView({}); },
     *     function() { return new ItemsView({}); },
     *     function() { return new FooterView({}); }
     *   ]
     *   viewFactory.createListView(createViewList, {className: 'jsdoc-example'})
     *
     * @param {Array} fns - list of functions, each which should return a view representing an item in the list
     * @param {Object} viewOpts
     * @return {Object} A view
     */
    createListView: function createListView(createViewFns, viewOpts) {
      if (!(createViewFns && createViewFns.forEach)) throw new Error('createViewFns is required as an iterable list');
      if (!_.all(createViewFns, _.isFunction)) throw new Error('createViewFns must only contain functions');
  
      var listView = new CoreView(viewOpts);
  
      listView.render = function () {
        this.clearSubViews();
  
        createViewFns.forEach(function (createItemView) {
          var view = createItemView();
          this.addView(view);
          this.$el.append(view.render().el);
        }, this);
  
        return this;
      };
  
      return listView;
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/components/view-options/panel-with-options-view.js":
  /*!*******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/components/view-options/panel-with-options-view.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./panel-with-options.tpl */ "./lib/assets/javascripts/builder/components/view-options/panel-with-options.tpl");
  var InfoboxView = __webpack_require__(/*! builder/components/infobox/infobox-view */ "./lib/assets/javascripts/builder/components/infobox/infobox-view.js");
  
  module.exports = CoreView.extend({
    initialize: function initialize(opts) {
      if (!opts.createContentView) throw new Error('createContentView factory function is mandatory');
      if (!opts.editorModel) throw new Error('editorModel is required');
  
      this.template = this.options.template || template;
  
      this._createContentView = opts.createContentView;
      this._editorModel = opts.editorModel;
      this._createControlView = opts.createControlView;
      this._createActionView = opts.createActionView;
      this._infoboxModel = opts.infoboxModel;
      this._infoboxCollection = opts.infoboxCollection;
  
      this._editorModel.on('change:edition', this._setStyleMenu, this);
      this.add_related_model(this._editorModel);
    },
  
    render: function render() {
      var contentView;
      var controlView;
      var actionView;
      var infoboxView;
  
      this.clearSubViews();
      this.$el.empty();
  
      this.$el.html(this.template());
  
      contentView = this._createContentView();
  
      this._content().html(contentView.render().el);
      this.addView(contentView);
  
      if (this._infoboxModel) {
        infoboxView = new InfoboxView({
          infoboxModel: this._infoboxModel,
          infoboxCollection: this._infoboxCollection
        });
  
        this._info().html(infoboxView.render().el);
        this.addView(infoboxView);
      }
  
      if (this._createControlView) {
        controlView = this._createControlView();
        this._controls().html(controlView.render().el);
        this.addView(controlView);
      }
  
      if (this._createActionView) {
        actionView = this._createActionView();
        this._actions().html(actionView.render().el);
        this.addView(actionView);
      }
  
      this._setStyleMenu();
  
      return this;
    },
  
    _content: function _content() {
      return this.$('.js-content');
    },
  
    _controls: function _controls() {
      return this.$('.js-controls');
    },
  
    _actions: function _actions() {
      return this.$('.js-actions');
    },
  
    _info: function _info() {
      return this.$('.js-info');
    },
  
    _setStyleMenu: function _setStyleMenu() {
      this.$('.js-theme').toggleClass('is-dark', this._editorModel.isEditing());
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/config/upload-config.js":
  /*!****************************************************************!*\
    !*** ./lib/assets/javascripts/builder/config/upload-config.js ***!
    \****************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  /**
   *  Default upload config
   */
  
  module.exports = {
    uploadStates: ['pending', 'enqueued', 'uploading', 'unpacking', 'importing', 'guessing', 'complete'],
    fileExtensions: ['bz2', 'csv', 'gpkg', 'geojson', 'gz', 'json', 'kml', 'kmz', 'gpx', 'ods', 'osm', 'rar', 'tar', 'tgz', 'tif', 'tiff', 'tsv', 'txt', 'xls', 'xlsx', 'zip'],
    // How big should the file be?
    fileTimesBigger: 3
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/acl-item-model.js":
  /*!***************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/acl-item-model.js ***!
    \***************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var PermissionModel = __webpack_require__(/*! ./permission-model */ "./lib/assets/javascripts/builder/data/permission-model.js");
  var OWN_ATTR_NAMES = ['id', 'username', 'avatar_url', 'name'];
  
  module.exports = Backbone.Model.extend({
    defaults: {
      access: 'r'
    },
  
    isOwn: function isOwn(model) {
      return model.id === this.get('entity').id;
    },
  
    validate: function validate(attrs, options) {
      if (attrs.access !== PermissionModel.READ_ONLY && attrs.access !== PermissionModel.READ_WRITE) {
        return "access can't take 'r' or 'rw' values";
      }
    },
  
    toJSON: function toJSON() {
      var entity = _.pick(this.get('entity').toJSON(), OWN_ATTR_NAMES);
      // translate name to username
      if (!entity.username) {
        entity.username = entity.name;
        delete entity.name;
      }
      return {
        type: this.get('type') || 'user',
        entity: entity,
        access: this.get('access')
      };
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/analysis-definition-node-model.js":
  /*!*******************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/analysis-definition-node-model.js ***!
    \*******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var camshaftReference = __webpack_require__(/*! ./camshaft-reference */ "./lib/assets/javascripts/builder/data/camshaft-reference.js");
  var QueryGeometryModel = __webpack_require__(/*! ./query-geometry-model */ "./lib/assets/javascripts/builder/data/query-geometry-model.js");
  var QuerySchemaModel = __webpack_require__(/*! ./query-schema-model */ "./lib/assets/javascripts/builder/data/query-schema-model.js");
  var nodeIds = __webpack_require__(/*! builder/value-objects/analysis-node-ids */ "./lib/assets/javascripts/builder/value-objects/analysis-node-ids.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var QueryRowsCollection = __webpack_require__(/*! ./query-rows-collection */ "./lib/assets/javascripts/builder/data/query-rows-collection.js");
  var fetchAllQueryObjects = __webpack_require__(/*! builder/helpers/fetch-all-query-objects */ "./lib/assets/javascripts/builder/helpers/fetch-all-query-objects.js");
  var layerColors = __webpack_require__(/*! builder/data/layer-colors */ "./lib/assets/javascripts/builder/data/layer-colors.js");
  
  var REQUIRED_OPTS = ['configModel'];
  
  /**
   *  Base model for an analysis definition node.
   *  May point to one or multiple nodes in turn (referenced by ids).
   *
   *
   *  Analysis-definition-node-model
   *    Query-Schema-Model
   *    Query-Geometry-Model
   *    Query-Rows-Collection
   */
  module.exports = Backbone.Model.extend({
  
    initialize: function initialize(attrs, opts) {
      if (!this.id) throw new Error('id is required');
  
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      var modelOpts = {
        configModel: this._configModel,
        userModel: opts.userModel
      };
  
      var simpleGeom = this.get('simple_geom');
  
      this.querySchemaModel = new QuerySchemaModel(undefined, modelOpts);
  
      this.queryGeometryModel = new QueryGeometryModel({
        simple_geom: simpleGeom,
        status: simpleGeom ? 'fetched' : 'unfetched'
      }, modelOpts);
  
      this.queryRowsCollection = new QueryRowsCollection([], {
        configModel: this._configModel,
        userModel: opts.userModel,
        tableName: '',
        querySchemaModel: this.querySchemaModel
      });
  
      this.listenTo(this.queryGeometryModel, 'change:simple_geom', this._onGeometryTypeChanged);
    },
  
    fetchQueryObjects: function fetchQueryObjects() {
      if (this.get('status') === 'ready' && !this.get('error')) {
        fetchAllQueryObjects({
          queryGeometryModel: this.queryGeometryModel,
          querySchemaModel: this.querySchemaModel,
          queryRowsCollection: this.queryRowsCollection
        });
      }
    },
  
    /**
     * @override {Backbone.prototype.parse}  flatten the provided analysis data and create source nodes if there are any.
     */
    parse: function parse(r, opts) {
      // Allow omitting type when merging into an existing node
      var sourceNames = !r.type && opts.merge ? [] : camshaftReference.getSourceNamesForAnalysisType(r.type);
  
      var parsedParams = _.reduce(r.params, function (memo, val, name) {
        var sourceName = sourceNames[sourceNames.indexOf(name)];
  
        if (sourceName) {
          this.collection.add(val, opts);
          memo[name] = val.id;
        } else {
          memo[name] = val;
        }
  
        return memo;
      }, {}, this);
  
      var parsedOptions = _.reduce(r.options, function (memo, val, name) {
        memo[name] = val;
        return memo;
      }, {}, this);
  
      return _.defaults(_.omit(r, 'params', 'options'), parsedOptions, parsedParams);
    },
  
    /**
     * @override {Backbone.prototype.toJSON} unflatten the internal structure to the expected nested JSON data structure.
     * @param {Object} options
     * @param {Boolean} options.skipOptions - Add or not analysis options to the definition
     */
    toJSON: function toJSON(options) {
      options = options || {};
  
      var analysisParams = [];
      var paramsforJSON = {};
      var paramsForType = camshaftReference.paramsForType(this.get('type'));
  
      // Undo the parsing of the params previously done in .parse() (when model was created)
      for (var name in paramsForType) {
        var param = paramsForType[name];
        var val = this.get(name);
        var includeParamInJSON = true;
  
        if (param.type === 'node') {
          var node = this.collection.get(val);
          if (node) {
            val = node.toJSON(options);
          } else if (param.optional) {
            // Node has no value but is optional. We don't serialize it.
            includeParamInJSON = false;
          } else {
            // Node has no value and is required. Throw error.
            throw new Error('no node found for param "' + name + '" with id "' + val + '" in node ' + JSON.stringify(this.attributes));
          }
        }
  
        if (includeParamInJSON) {
          paramsforJSON[name] = val;
          analysisParams.push(name);
        }
      }
  
      var json = {
        id: this.get('id'),
        type: this.get('type'),
        params: paramsforJSON
      };
  
      // style_history is not sent at all (neither inside params nor options). It is always set by the backend.
      var optionsAttrs = _.omit(this.attributes, analysisParams.concat('id', 'type', 'status', 'style_history'));
      if (!(options.skipOptions || _.isEmpty(optionsAttrs))) {
        json['options'] = optionsAttrs;
      }
  
      return json;
    },
  
    /**
     * @override {Backbone.prototype.isNew} for this.destroy() to work (not try to send DELETE request)
     */
    isNew: function isNew() {
      return true;
    },
  
    isReadOnly: function isReadOnly() {
      // By default, any node should be read only by default, except the source node (with exceptions)
      return true;
    },
  
    isCustomQueryApplied: function isCustomQueryApplied() {
      // By default, any node shouldn't have a custom query applied, except the source node
      return false;
    },
  
    canBeDeletedByUser: function canBeDeletedByUser() {
      return this.hasPrimarySource();
    },
  
    hasFailed: function hasFailed() {
      return this.get('status') === 'failed';
    },
  
    isDone: function isDone() {
      return this.get('status') === 'ready';
    },
  
    destroy: function destroy() {
      if (this.querySchemaModel) {
        this.querySchemaModel.destroy();
        this.querySchemaModel = null;
      }
  
      return Backbone.Model.prototype.destroy.apply(this, arguments);
    },
  
    /**
     * Creates a new node that have same params as the current node, with only the id differing.
     * @param {String} newId - e.g. 'b1'
     * @return {Object} instance of analysis-definition-node-model
     */
    clone: function clone(newId) {
      if (!newId) throw new Error('newId is required');
      if (!_.isString(newId) || newId.length < 2) throw new Error('newId is required as a non-empty string');
      if (newId === this.id) throw new Error('newId must be different from current id, ' + this.id);
  
      var attrs = this.toJSON();
      attrs.id = newId;
      return this.collection.add(attrs);
    },
  
    linkedListBySameLetter: function linkedListBySameLetter() {
      var list = [this];
      var prev = this;
      var letter = this.letter();
  
      while (true) {
        var current = prev.getPrimarySource();
        if (current && current.letter() === letter) {
          list.push(current);
          prev = current;
        } else {
          break;
        }
      }
  
      return list;
    },
  
    /**
     * @return {Boolean, null} null if the geoemtry type of this node is not known,
     *   this is to indicate that the query model is not ready yet, up to caller to make the call or not
     */
    isValidAsInputForType: function isValidAsInputForType(analysisType) {
      if (analysisType === 'source') return false;
  
      var geometry = this.queryGeometryModel.get('simple_geom');
      return geometry ? camshaftReference.isValidInputGeometryForType(geometry, analysisType) : null;
    },
  
    containsNode: function containsNode(other) {
      if (!other) return false;
      return this.id === other.id || this._sourcesContains(other);
    },
  
    hasPrimarySource: function hasPrimarySource() {
      return !!this.getPrimarySource();
    },
  
    hasSecondarySource: function hasSecondarySource() {
      return !!this.getSecondarySource();
    },
  
    getPrimarySource: function getPrimarySource() {
      return this.collection.get(this._getPrimarySourceId());
    },
  
    getSecondarySource: function getSecondarySource() {
      // Assumption: there are only 1-2 sources, so secondary is the one that's not the primary
      var primarySourceId = this._getPrimarySourceId();
      var secondarySourceId = _.find(this.sourceIds(), function (sourceId) {
        return sourceId !== primarySourceId;
      });
      return this.collection.get(secondarySourceId);
    },
  
    // Default query by default is the query already applied in the node.
    // For source node is totally different
    getDefaultQuery: function getDefaultQuery() {
      return this.get('query');
    },
  
    /**
     * @return {Array} e.g. ['c3', 'b2']
     */
    sourceIds: function sourceIds() {
      return _.map(this._sourceNames(), function (sourceName) {
        return this.get(sourceName);
      }, this);
    },
  
    changeSourceIds: function changeSourceIds(currentId, newId, silenty) {
      this._sourceNames().forEach(function (sourceName) {
        if (this.get(sourceName) === currentId) {
          this.set(sourceName, newId, { silent: silenty });
        }
      }, this);
    },
  
    isSourceType: function isSourceType() {
      return this.get('type') === 'source';
    },
  
    letter: function letter() {
      return nodeIds.letter(this.id);
    },
  
    getColor: function getColor() {
      var letter = nodeIds.letter(this.id);
      return layerColors.getColorForLetter(letter);
    },
  
    getStyleHistoryForLayer: function getStyleHistoryForLayer(layer_id) {
      var styleHistory = this.get('style_history');
      return styleHistory && styleHistory[layer_id];
    },
  
    // Private methods
  
    _sourcesContains: function _sourcesContains(other) {
      var primarySource = this.getPrimarySource();
      var secondarySource = this.getSecondarySource();
      return !!(primarySource && primarySource.containsNode(other) || secondarySource && secondarySource.containsNode(other));
    },
  
    _getPrimarySourceId: function _getPrimarySourceId() {
      var primarySourceName = this.get('primary_source_name') || this._sourceNames()[0];
      return this.get(primarySourceName);
    },
  
    /**
     * @return {Array} e.g. ['polygons_source', 'points_source']
     */
    _sourceNames: function _sourceNames() {
      return camshaftReference.getSourceNamesForAnalysisType(this.get('type'));
    },
  
    _onGeometryTypeChanged: function _onGeometryTypeChanged(model, value) {
      this.set('simple_geom', value);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/analysis-definition-node-source-model.js":
  /*!**************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/analysis-definition-node-source-model.js ***!
    \**************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var AnalysisDefinitionNodeModel = __webpack_require__(/*! ./analysis-definition-node-model */ "./lib/assets/javascripts/builder/data/analysis-definition-node-model.js");
  var TableModel = __webpack_require__(/*! ./table-model */ "./lib/assets/javascripts/builder/data/table-model.js");
  var SQLUtils = __webpack_require__(/*! builder/helpers/sql-utils */ "./lib/assets/javascripts/builder/helpers/sql-utils.js");
  
  /**
   *  Case of a node model representing a source node.
   *  - It should provide new info about if the node is read only or not.
   *
   *  Analysis-definition-node-source-model
   *    Query-Schema-Model
   *    Query-Geometry-Model
   *    Table-Model
   */
  module.exports = AnalysisDefinitionNodeModel.extend({
  
    defaults: {
      status: 'ready'
    },
  
    /**
     * @override AnalysisDefinitionNodeModel.prototype.initialize
     */
    initialize: function initialize(attrs, opts) {
      if (!opts.userModel) throw new Error('userModel is required');
  
      this._userModel = opts.userModel;
      AnalysisDefinitionNodeModel.prototype.initialize.apply(this, arguments);
  
      var query = this.get('query');
      this.querySchemaModel.set({
        query: query,
        ready: true
      }, { silent: true });
  
      this.queryGeometryModel.set({
        query: query,
        ready: true
      }, { silent: true });
  
      // TODO: we should check if it is necessary to check if we have to overwrite the whole
      //       initialize or with this change is enough.
      this.queryRowsCollection._tableName = this.get('table_name');
  
      var tableData = opts.tableData || { name: this.get('table_name') };
      this.tableModel = new TableModel(tableData, {
        configModel: opts.configModel,
        parse: true
      });
    },
  
    getDefaultQuery: function getDefaultQuery() {
      return SQLUtils.getDefaultSQL(this.get('table_name'), this.tableModel.getOwnerName(), this._userModel.isInsideOrg());
    },
  
    isCustomQueryApplied: function isCustomQueryApplied() {
      return !SQLUtils.isSameQuery(this.querySchemaModel.get('query'), this.getDefaultQuery());
    },
  
    isReadOnly: function isReadOnly() {
      var isTableReadOnly = this.tableModel.isReadOnly(this._userModel);
      var hasCustomQuery = this.isCustomQueryApplied();
      return isTableReadOnly || hasCustomQuery;
    },
  
    getTableModel: function getTableModel() {
      return this.tableModel;
    },
  
    fetchTable: function fetchTable() {
      if (!this.tableModel.get('id')) {
        this.tableModel.fetch();
      }
    },
  
    setTableName: function setTableName(name) {
      if (!name) throw new Error('name is required');
  
      this.set('table_name', name);
      this.tableModel.set('name', name);
      this.queryRowsCollection.setTableName(name);
      this.querySchemaModel.set({
        status: 'unfetched',
        query: this.getDefaultQuery()
      });
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/asset-model.js":
  /*!************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/asset-model.js ***!
    \************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  
  __webpack_require__(/*! backbone-model-file-upload */ "./node_modules/backbone-model-file-upload/backbone-model-file-upload.js");
  
  module.exports = Backbone.Model.extend({
    fileAttribute: 'filename',
  
    defaults: {
      type: '',
      filename: '',
      interval: 0,
      progress: 0,
      state: 'idle',
      option: ''
    },
  
    _initBinds: function _initBinds() {
      this.bind('progress', function (progress) {
        this.set({
          progress: progress * 100,
          state: 'uploading'
        });
      }, this);
  
      this.bind('change:filename change:url', function () {
        if (this.get('state') === 'error') {
          this.set({ state: 'idle' });
          this.unset('get_error_text', { silent: true });
        }
      }, this);
  
      this.bind('error invalid', function (m, d) {
        this.set({
          state: 'error',
          error_code: d && d.error_code || '',
          get_error_text: {
            title: _t('componentes.data.asset-model.invalid-import'),
            what_about: d && d.msg || ''
          }
        }, { silent: true });
        // We need this, if not validate will run again and again and again... :(
        this.trigger('change');
      }, this);
    },
  
    validate: function validate(attrs) {
      if (!attrs) {
        return;
      }
  
      if (attrs.type === 'filename') {
        // Number of files
        if (attrs.filename && attrs.filename.length) {
          return {
            msg: _t('componentes.data.asset-model.one-file-per-upload')
          };
        }
        // File extension
        var name = attrs.filename.name;
        var ext = name.substr(name.lastIndexOf('.') + 1);
  
        if (ext) {
          ext = ext.toLowerCase();
        }
  
        if (!_.contains(['jpg', 'png', 'gif', 'svg'], ext)) {
          return {
            msg: _t('componentes.data.asset-model.invalid-extension')
          };
        }
      }
  
      if (attrs.type === 'url') {
        // Valid URL?
        if (!Utils.isURL(attrs.url)) {
          return {
            msg: _t('componentes.data.asset-model.invalid-url')
          };
        }
      }
    },
  
    isValid: function isValid() {
      return (this.get('filename') || this.get('url')) && this.get('state') !== 'error';
    },
  
    upload: function upload() {
      var self = this;
  
      var options = {
        kind: this.get('kind')
      };
  
      if (this.get('type') === 'file') {
        options.filename = this.get('filename');
      } else if (this.get('type') === 'url') {
        options.filename = this.get('filename');
      }
  
      this.xhr = this.save(options, {
        success: function success(m) {
          m.set('state', 'uploaded');
        },
  
        error: function error(m, msg) {
          var response;
          var message = _t('componentes.data.asset-model.connection-error');
  
          if (msg && msg.status === 429) {
            response = JSON.parse(msg.responseText);
            message = response.error;
          } else if (msg && msg.status === 400) {
            response = JSON.parse(msg.responseText);
            message = response.error;
          }
  
          self.set({
            state: 'error',
            get_error_text: { title: _t('componentes.data.asset-model.error'), what_about: message }
          });
        },
  
        complete: function complete() {
          delete self.xhr;
        }
      });
    },
  
    stopUpload: function stopUpload() {
      if (this.xhr) this.xhr.abort();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/assets-collection.js":
  /*!******************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/assets-collection.js ***!
    \******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var AssetModel = __webpack_require__(/*! ./asset-model */ "./lib/assets/javascripts/builder/data/asset-model.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel', 'userModel'];
  
  module.exports = Backbone.Collection.extend({
    model: AssetModel,
  
    url: function url(method) {
      var baseUrl = this._configModel.get('base_url');
      var version = this._configModel.urlVersion('asset', method);
      return baseUrl + '/api/' + version + '/users/' + this._userModel.get('id') + '/assets';
    },
  
    initialize: function initialize(models, opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
    },
  
    parse: function parse(resp, xhr) {
      return resp.assets;
    },
  
    selectAll: function selectAll() {
      this.each(function (mdl) {
        mdl.set('state', 'selected');
      });
    },
  
    deselectAll: function deselectAll(m) {
      this.each(function (mdl) {
        if (mdl !== m && mdl.get('state') === 'selected') {
          mdl.set('state', '');
        }
      });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/backbone/network-interceptors/interceptor.js":
  /*!******************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/backbone/network-interceptors/interceptor.js ***!
    \******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  /**
   * Network Interceptors
   *
   * Tool to easily intercept network responses in order
   * to override or add behaviours on top of the usual ones
   */
  
  function NetworkResponseInterceptor() {
    this._originalAjax = $.ajax;
    this._successInterceptors = [];
    this._errorInterceptors = [];
    this._urlPatterns = [];
  }
  
  NetworkResponseInterceptor.prototype.start = function () {
    var onRequestStart = this._onRequestStart.bind(this);
  
    this._onRequestStart = onRequestStart;
    $.ajax = onRequestStart;
  };
  
  NetworkResponseInterceptor.prototype.stop = function () {
    $.ajax = this._originalAjax;
  };
  
  NetworkResponseInterceptor.prototype.addURLPattern = function (pattern) {
    this._urlPatterns.push(pattern);
  };
  
  NetworkResponseInterceptor.prototype.addSuccessInterceptor = function (interceptorFn) {
    this._successInterceptors.push(interceptorFn);
  };
  
  NetworkResponseInterceptor.prototype.addErrorInterceptor = function (interceptorFn) {
    this._errorInterceptors.push(interceptorFn);
  };
  
  NetworkResponseInterceptor.prototype._shouldListenToRequest = function (url) {
    var patternChecks = this._urlPatterns.map(function (pattern) {
      return url.indexOf(pattern) > -1;
    });
  
    return _.some(patternChecks);
  };
  
  NetworkResponseInterceptor.prototype._onRequestStart = function (url, options) {
    var requestUrl = null;
    var requestOptions = {};
  
    if (typeof url === 'string') {
      requestUrl = url;
    } else if ((typeof url === 'undefined' ? 'undefined' : _typeof(url)) === 'object' && url.url) {
      requestUrl = url.url;
    }
  
    if (options) {
      requestOptions = options;
    } else if ((typeof url === 'undefined' ? 'undefined' : _typeof(url)) === 'object') {
      requestOptions = url;
    }
  
    if (!this._shouldListenToRequest(requestUrl)) {
      return this._originalAjax.apply(this, arguments);
    }
  
    if (requestOptions.error || requestOptions.success) {
      var errorCallback = requestOptions.error;
      var successCallback = requestOptions.success;
  
      var interceptErrorFn = function interceptErrorFn() {
        this._applyErrorInterceptors.apply(this, arguments);
        errorCallback && errorCallback.apply(this, arguments);
      };
  
      var interceptSuccessFn = function interceptSuccessFn() {
        this._applySuccessInterceptors.apply(this, arguments);
        successCallback && successCallback.apply(this, arguments);
      };
  
      requestOptions.error = interceptErrorFn.bind(this);
      requestOptions.success = interceptSuccessFn.bind(this);
    }
  
    return this._originalAjax(requestUrl, requestOptions);
  };
  
  NetworkResponseInterceptor.prototype._applyErrorInterceptors = function (xhr, textStatus, errorThrown) {
    if (!this._errorInterceptors.length) {
      return;
    }
  
    this._errorInterceptors.map(function (interceptorFunction) {
      interceptorFunction(xhr, textStatus, errorThrown);
    });
  };
  
  NetworkResponseInterceptor.prototype._applySuccessInterceptors = function (response, textStatus, xhr) {
    if (!this._successInterceptors.length) {
      return;
    }
  
    this._successInterceptors.map(function (interceptorFunction) {
      interceptorFunction(response, textStatus, xhr);
    });
  };
  
  module.exports = new NetworkResponseInterceptor();
  module.exports.NetworkResponseInterceptor = NetworkResponseInterceptor;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/backbone/network-interceptors/interceptors/forbidden-403.js":
  /*!*********************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/backbone/network-interceptors/interceptors/forbidden-403.js ***!
    \*********************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _redirectRoutes;
  
  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  
  /**
   * 403 Forbidden Network Error Interceptor
   *
   * This interceptor redirects 403 errors
   * to their corresponding routes
   */
  
  var LOGIN_ROUTE = '/login?error=session_expired';
  var SESSION_EXPIRED = 'session_expired';
  var MFA_REQUIRED = 'mfa_required';
  var MFA_ROUTE = '/multifactor_authentication';
  var MAINTENANCE_MODE = 'maintenance_mode';
  var MAINTENANCE_MODE_ROUTE = '/maintenance_mode';
  var LOCKOUT = 'lockout';
  var LOCKOUT_ROUTE = '/lockout';
  
  var subdomainMatch = /https?:\/\/([^.]+)/;
  
  var redirectRoutes = (_redirectRoutes = {}, _defineProperty(_redirectRoutes, SESSION_EXPIRED, LOGIN_ROUTE), _defineProperty(_redirectRoutes, MFA_REQUIRED, MFA_ROUTE), _defineProperty(_redirectRoutes, MAINTENANCE_MODE, MAINTENANCE_MODE_ROUTE), _defineProperty(_redirectRoutes, LOCKOUT, LOCKOUT_ROUTE), _redirectRoutes);
  
  module.exports = function (username) {
    return function (xhr, textStatus, errorThrown) {
      if (xhr.status !== 403) return;
  
      var error = xhr.responseJSON && xhr.responseJSON.error;
      var redirectRoute = redirectRoutes[error];
  
      if (!redirectRoute) {
        return;
      }
  
      URLFunctions.redirectTo(URLFunctions.getRedirectURL(window.location.origin, redirectRoute, username));
    };
  };
  
  var URLFunctions = {
    getRedirectURL: function getRedirectURL(currentURLOrigin, route, username) {
      if (!username) {
        return currentURLOrigin + route;
      }
  
      var newURL = currentURLOrigin.replace(subdomainMatch, function () {
        return username;
      });
  
      return window.location.protocol + '//' + newURL + route;
    },
  
    redirectTo: function redirectTo(url) {
      window.location = url;
    }
  };
  
  module.exports.URLFunctions = URLFunctions;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/backbone/sync-abort.js":
  /*!********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/backbone/sync-abort.js ***!
    \********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   * Custom sync method to only allow a single request at a time,
   * any prev ongoing request at a time of a sync call will be aborted.
   *
   * @example
   *   var MyModel = Backbone.Model.extend({
   *     // 
   *     sync: syncAbort,
   */
  module.exports = function (method, self, opts) {
    if (this._xhr) {
      this._xhr.abort();
    }
  
    var xhr = this._xhr = Backbone.Model.prototype.sync.apply(this, arguments);
    xhr.always(function () {
      self._xhr = null;
    });
  
    return xhr;
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/background-importer/import-model-poller.js":
  /*!****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/background-importer/import-model-poller.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Poller = __webpack_require__(/*! ./poller */ "./lib/assets/javascripts/builder/data/background-importer/poller.js");
  
  var ImportModelPoller = function ImportModelPoller(model) {
    var POLLING_INTERVAL = 2000; // Interval time between poll checkings
    var POLLING_INTERVAL_MULTIPLIER = 2.5; // Multiply interval by this number
    var POLLING_REQUESTS_BEFORE_INTERVAL_CHANGE = 30; // Max tries until interval change
  
    var options = {
      interval: function interval(numberOfRequests) {
        if (numberOfRequests >= POLLING_REQUESTS_BEFORE_INTERVAL_CHANGE) {
          return POLLING_INTERVAL * POLLING_INTERVAL_MULTIPLIER;
        }
        return POLLING_INTERVAL;
      },
      stopWhen: function stopWhen(model) {
        var state = model.get('state');
        return state === 'complete' || state === 'failure';
      }
    };
  
    Poller.call(this, model, options);
  };
  
  ImportModelPoller.prototype = _.extend({}, Poller.prototype);
  
  module.exports = ImportModelPoller;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/background-importer/import-model.js":
  /*!*********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/background-importer/import-model.js ***!
    \*********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var ImportModelPoller = __webpack_require__(/*! ./import-model-poller */ "./lib/assets/javascripts/builder/data/background-importer/import-model-poller.js");
  var SynchronizationModel = __webpack_require__(/*! builder/data/synchronization-model */ "./lib/assets/javascripts/builder/data/synchronization-model.js");
  
  /**
   *  New import model that controls
   *  the state of an import
   *
   */
  module.exports = Backbone.Model.extend({
  
    idAttribute: 'item_queue_id',
  
    initialize: function initialize(attrs, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
  
      this._configModel = opts.configModel;
  
      this._initBinds();
      this.poller = new ImportModelPoller(this);
    },
  
    urlRoot: function urlRoot() {
      var version = this._configModel.urlVersion('import');
      var baseUrl = this._configModel.get('base_url');
  
      return baseUrl + '/api/' + version + '/imports';
    },
  
    _initBinds: function _initBinds() {
      this.bind('change:item_queue_id', this._checkQueueId, this);
    },
  
    createImport: function createImport(data) {
      var d = this._prepareData(data);
      this[d.interval === 0 ? '_createRegularImport' : '_createSyncImport'](d);
    },
  
    _checkQueueId: function _checkQueueId() {
      if (this.get('item_queue_id')) {
        this.pollCheck();
      }
    },
  
    _prepareData: function _prepareData(data) {
      var d = {
        create_vis: data.create_vis,
        privacy: data.privacy
      };
  
      var type = data.type;
  
      if (type !== 'remote') {
        _.extend(d, {
          type_guessing: data.type_guessing,
          content_guessing: data.content_guessing,
          interval: data.interval
        });
      }
  
      var service = data.service_name;
  
      if (type === 'url') {
        _.extend(d, {
          url: data.value
        });
      }
  
      if (type === 'remote') {
        _.extend(d, {
          type: 'remote',
          interval: null,
          remote_visualization_id: data.remote_visualization_id,
          create_vis: false,
          value: data.value
        });
      }
  
      if (type === 'sql') {
        _.extend(d, {
          table_name: data.table_name,
          sql: data.value
        });
      }
  
      if (type === 'duplication') {
        _.extend(d, {
          table_name: data.table_name,
          table_copy: data.value
        });
      }
  
      if (type === 'service') {
        // If service is Twitter, service_item_id should be
        // sent stringified
        var service_item_id = service === 'twitter_search' ? JSON.stringify(data.service_item_id) : data.service_item_id;
  
        if (data.user_defined_limits) {
          d.user_defined_limits = data.user_defined_limits;
        }
  
        _.extend(d, {
          value: data.value,
          service_name: data.service_name,
          service_item_id: service_item_id
        });
      }
  
      return d;
    },
  
    _createSyncImport: function _createSyncImport(d) {
      var self = this;
      this._synchronizationModel = new SynchronizationModel(d, {
        configModel: this._configModel
      });
  
      this._synchronizationModel.save(null, {
        success: function success(m) {
          self.set('item_queue_id', m.get('data_import').item_queue_id);
        },
        error: function error(mdl, r, opts) {
          self._setErrorState(r);
        }
      });
    },
  
    _createRegularImport: function _createRegularImport(d) {
      var self = this;
  
      this.save(d, {
        error: function error(mdl, r, opts) {
          self._setErrorState(r);
        }
      });
    },
  
    _setErrorState: function _setErrorState(r) {
      var msg;
      try {
        msg = r && JSON.parse(r.responseText).errors.imports;
      } catch (err) {
        msg = _t('data.import-model.error-starting-import');
      }
      this.set({
        state: 'failure',
        get_error_text: {
          title: _t('data.import-model.error-title'),
          what_about: msg
        }
      });
    },
  
    pollCheck: function pollCheck() {
      this.poller.start();
    },
  
    destroyCheck: function destroyCheck() {
      this.poller.stop();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/background-importer/imports-model.js":
  /*!**********************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/background-importer/imports-model.js ***!
    \**********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var ImportModel = __webpack_require__(/*! ./import-model */ "./lib/assets/javascripts/builder/data/background-importer/import-model.js");
  var UploadModel = __webpack_require__(/*! builder/data/upload-model */ "./lib/assets/javascripts/builder/data/upload-model.js");
  var VisDefinitionModel = __webpack_require__(/*! builder/data/vis-definition-model */ "./lib/assets/javascripts/builder/data/vis-definition-model.js");
  var PermissionModel = __webpack_require__(/*! builder/data/permission-model */ "./lib/assets/javascripts/builder/data/permission-model.js");
  
  /**
   *  Upload/import model
   *
   *  It takes the control of the upload and import,
   *  listening the change of any of these steps.
   *
   *  Steps:
   *  - upload
   *  - import
   *
   */
  
  module.exports = Backbone.Model.extend({
  
    defaults: {
      step: 'upload',
      state: ''
    },
  
    initialize: function initialize(attrs, opts) {
      if (!opts.userModel) throw new Error('userModel is required');
      if (!opts.configModel) throw new Error('configModel is required');
  
      this._userModel = opts.userModel;
      this._configModel = opts.configModel;
  
      this._uploadModel = new UploadModel(opts.upload, {
        userModel: this._userModel,
        configModel: this._configModel
      });
  
      if (_.isEmpty(opts)) {
        opts = {};
      }
  
      this._importModel = new ImportModel(opts.import, {
        configModel: this._configModel
      });
      this._initBinds();
      this._checkStatus();
    },
  
    _initBinds: function _initBinds() {
      this.bind('change:import', this._onImportChange, this);
      this.bind('change:upload', this._onUploadChange, this);
      this.bind('change:id', this._onIdChange, this);
  
      this._importModel.bind('change', function () {
        this.trigger('change:import', this);
        this.trigger('change', this);
      }, this);
  
      this._uploadModel.bind('change', function () {
        this.trigger('change:upload', this);
        this.trigger('change', this);
      }, this);
    },
  
    _destroyBinds: function _destroyBinds() {
      this._uploadModel.unbind(null, null, this);
      this._importModel.unbind(null, null, this);
    },
  
    _onIdChange: function _onIdChange() {
      var item_queue_id = this.get('id');
      if (item_queue_id) this._importModel.set('item_queue_id', item_queue_id);
      this.set('step', 'import');
    },
  
    _onUploadChange: function _onUploadChange(m, i) {
      if (this.get('step') === 'upload') {
        var item_queue_id = this._uploadModel.get('item_queue_id');
        var state = this._uploadModel.get('state');
  
        if (item_queue_id) this.set('id', item_queue_id);
        if (state) this.set('state', state);
      }
    },
  
    _onImportChange: function _onImportChange() {
      if (this.get('step') === 'import') {
        var state = this._importModel.get('state');
        if (state) this.set('state', state);
      }
    },
  
    _checkStatus: function _checkStatus() {
      if (!this.get('id') && !this._uploadModel.isValid()) {
        this.trigger('change:upload');
        return;
      }
  
      if (this._uploadModel.get('type') === 'file') {
        this._uploadModel.upload();
      } else if (this.get('id')) {
        this.set('step', 'import');
        this._importModel.set('item_queue_id', this.get('id'));
      } else if (!this._importModel.get('item_queue_id') && this._uploadModel.get('type') !== '') {
        this.set('step', 'import');
        this._importModel.createImport(this._uploadModel.toJSON());
      }
    },
  
    getImportModel: function getImportModel() {
      return this._importModel;
    },
  
    pause: function pause() {
      this.stopUpload();
      this.stopImport();
    },
  
    hasFailed: function hasFailed() {
      var state = this.get('state');
      var step = this.get('step');
  
      return step === 'import' && state === 'failure' || step === 'upload' && state === 'error';
    },
  
    hasCompleted: function hasCompleted() {
      return this.get('step') === 'import' && this._importModel && this._importModel.get('state') === 'complete';
    },
  
    getWarnings: function getWarnings() {
      return this.get('step') === 'import' ? this._importModel.get('warnings') : '';
    },
  
    getError: function getError() {
      if (this.hasFailed()) {
        var step = this.get('step');
        return _.extend({
          errorCode: this[step === 'upload' ? '_uploadModel' : '_importModel'].get('error_code'),
          itemQueueId: step === 'import' ? this._importModel.get('id') : '',
          originalUrl: step === 'import' ? this._importModel.get('original_url') : '',
          dataType: step === 'import' ? this._importModel.get('data_type') : '',
          httpResponseCode: step === 'import' ? this._importModel.get('http_response_code') : '',
          httpResponseCodeMessage: step === 'import' ? this._importModel.get('http_response_code_message') : ''
        }, this[step === 'upload' ? '_uploadModel' : '_importModel'].get('get_error_text'));
      }
  
      return {
        title: '',
        what_about: '',
        error_code: ''
      };
    },
  
    importedVis: function importedVis() {
      if (this.get('import').derived_visualization_id) {
        return this._getMapVis();
      } else {
        return this._getDatasetVis();
      }
    },
  
    getNumberOfTablesCreated: function getNumberOfTablesCreated() {
      return this._importModel.get('tables_created_count');
    },
  
    _getServiceName: function _getServiceName() {
      return this._importModel.get('service_name');
    },
  
    isTwitterImport: function isTwitterImport() {
      return this._getServiceName() === 'twitter_search';
    },
  
    isCartoImport: function isCartoImport() {
      return this._getDisplayName() && this._getDisplayName().match(/\.carto$/i);
    },
  
    _getDisplayName: function _getDisplayName() {
      return this._importModel.get('display_name');
    },
  
    _getMapVis: function _getMapVis() {
      var derivedVisId = this._importModel.get('derived_visualization_id');
  
      if (!derivedVisId) {
        return false;
      }
  
      return this._createVis({
        type: 'derived',
        id: derivedVisId
      });
    },
  
    _getDatasetVis: function _getDatasetVis() {
      var tableName = this._importModel.get('table_name');
  
      if (!tableName) {
        return false;
      }
  
      return this._createVis({
        type: 'table',
        table: {
          name: tableName
        }
      });
    },
  
    _createVis: function _createVis(attrs) {
      var vis = new VisDefinitionModel(attrs, {
        configModel: this._configModel
      });
  
      vis.permission = new PermissionModel({
        // TODO: check that this works in builder
        owner: this._userModel.attributes
      }, {
        configModel: this._configModel,
        userModel: this._userModel
      });
  
      return vis;
    },
  
    setError: function setError(opts) {
      var stepModel = this[this.get('step') === 'upload' ? '_uploadModel' : '_importModel'];
  
      this.stopUpload();
      this.stopImport();
  
      stepModel.set(opts);
  
      this.set('state', 'error');
    },
  
    stopUpload: function stopUpload() {
      this._uploadModel.stopUpload();
    },
  
    stopImport: function stopImport() {
      this._importModel.destroyCheck();
    },
  
    get: function get(attr) {
      if (attr === 'upload') {
        return this._uploadModel.toJSON();
      }
  
      if (attr === 'import') {
        return this._importModel.toJSON();
      }
  
      return Backbone.Model.prototype.get.call(this, attr);
    },
  
    getRedirectUrl: function getRedirectUrl(user) {
      var vis = this.importedVis();
      if (vis) {
        return encodeURI(vis.viewUrl(user).edit());
      }
    },
  
    toJSON: function toJSON() {
      return {
        step: this.get('step'),
        id: this.get('id'),
        state: this.get('state'),
        upload: this._uploadModel.toJSON(),
        import: this._importModel.toJSON()
      };
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/background-importer/poller.js":
  /*!***************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/background-importer/poller.js ***!
    \***************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  /*
   * Periodically fetches a model/collection. It waits for ongoing
   * fetch requests before trying to fetch again. A stop condition
   * can be specified.
   *
   * Usage example:
   *
   * var poller = new Poller(model, {
   *   interval: 1000,
   *   stopWhen: function (model) {
   *     return model.get('state') === 'completed';
   *   }
   * });
   *
   * poller.start();
   *
   * // ...
   *
   * poller.stop();
   *
   */
  var Poller = function Poller(model, opts) {
    this.model = model;
    this.numberOfRequests = 0;
    this.polling = false;
    this.interval = opts.interval;
    if (typeof this.interval !== 'function') {
      this.interval = function () {
        return opts.interval;
      };
    }
    this.stopWhen = opts.stopWhen;
    this.error = opts.error;
    this.autoStart = opts.autoStart;
  
    if (this.autoStart) {
      this.start();
    }
  };
  
  Poller.prototype.start = function () {
    if (this.timeout) {
      return;
    }
  
    this._scheduleFetch();
  };
  
  Poller.prototype._scheduleFetch = function () {
    this.timeout = setTimeout(this._fetch.bind(this), this.interval(this.numberOfRequests));
  };
  
  Poller.prototype._fetch = function () {
    var self = this;
    if (!self.polling) {
      self.polling = true;
      self.model.fetch({
        success: function success() {
          self.polling = false;
          self.numberOfRequests++;
          if (self._continuePolling()) {
            self._scheduleFetch();
          }
        },
        error: function error(e) {
          _.isFunction(self.error) && self.error(self.model);
        }
      });
    }
  };
  
  Poller.prototype._continuePolling = function () {
    return !this.stopWhen || _.isFunction(this.stopWhen) && !this.stopWhen(this.model);
  };
  
  Poller.prototype.stop = function () {
    this.polling = false;
    clearTimeout(this.timeout);
    delete this.timeout;
  };
  
  module.exports = Poller;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/camshaft-reference.js":
  /*!*******************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/camshaft-reference.js ***!
    \*******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var camshaftReference = __webpack_require__(/*! camshaft-reference */ "./node_modules/camshaft-reference/index.js").getVersion('latest');
  var DefaultCartography = __webpack_require__(/*! ./default-cartography.json */ "./lib/assets/javascripts/builder/data/default-cartography.json");
  
  var SOURCE_NAMES_MAP = {}; // string -> array, e.g. {'intersection': ['source', 'target']}
  var DEFAULT_MISSING_PARAM_VALUES = [undefined, null, '', NaN];
  
  module.exports = {
    hasType: function hasType(type) {
      return !!camshaftReference.analyses[type];
    },
  
    paramsForType: function paramsForType(type) {
      if (!this.hasType(type)) throw new Error('no analysis params found for type: ' + type);
  
      return _.clone(camshaftReference.analyses[type].params);
    },
  
    /**
     * Validate raw form attrs
     * @param {Object} formAttrs - e.g. {type: 'buffer', source: 'a0', radius: 'meh'}
     * @return {Object, undefined} returns an object with keys as faulty input, e.g. {radius: 'invalid-value'} for above
     */
    validate: function validate(formAttrs) {
      var errors = {};
  
      var parsedAttrs = this.parse(formAttrs);
      var params = this.paramsForType(formAttrs.type);
  
      for (var name in params) {
        var param = params[name];
        var val = parsedAttrs[name];
  
        if (!param.optional || val !== undefined) {
          switch (param.type) {
            case 'node':
              if (!val) {
                errors[name] = _t('data.analysis-definition-node-model.validation.invalid-source');
              }
              break;
            case 'number':
              if (isNaN(val)) {
                errors[name] = _t('data.analysis-definition-node-model.validation.invalid-value');
              }
              break;
            case 'enum':
              if (!_.contains(param.values, val)) {
                errors[name] = _t('data.analysis-definition-node-model.validation.invalid-enum', { expectedValues: JSON.stringify(param.values) });
              }
              break;
            default:
              if (val === null) {
                errors[name] = _t('data.analysis-definition-node-model.validation.missing-required');
              }
          }
        }
      }
  
      if (!_.isEmpty(errors)) {
        return errors;
      }
    },
  
    /**
     * Get type-parsed attrs from the raw form attrs
     * @param {Object} formAttrs - e.g. {type: 'buffer', source: 'a0 ', radius: '123', dissolved: 'false'}
     * @return {Object} e.g. {type: 'buffer', source: 'a0', radius: 123, dissolved: false}
     */
    parse: function parse(formAttrs) {
      var parsedAttrs = _.extend({}, formAttrs);
      var params = this.paramsForType(formAttrs.type);
  
      for (var name in params) {
        var param = params[name];
        var val = parsedAttrs[name];
  
        if (param.optional && _.contains(DEFAULT_MISSING_PARAM_VALUES, val)) {
          delete parsedAttrs[name];
        } else {
          switch (param.type) {
            case 'node':
              parsedAttrs[name] = (val || '').trim();
              break;
            case 'number':
              parsedAttrs[name] = parseFloat(val, 10);
              break;
            case 'boolean':
              parsedAttrs[name] = val === 'true' || val === true;
              break;
            default:
              if (_.contains(DEFAULT_MISSING_PARAM_VALUES, val)) {
                parsedAttrs[name] = null;
              } else if (_.isString(val)) {
                parsedAttrs[name] = val.trim();
              }
          }
        }
      }
  
      return parsedAttrs;
    },
  
    getSourceNamesForAnalysisType: function getSourceNamesForAnalysisType(type) {
      if (!SOURCE_NAMES_MAP[type]) {
        var sourceNames = [];
        var params = this.paramsForType(type);
  
        for (var name in params) {
          var param = params[name];
          if (param.type === 'node') {
            sourceNames.push(name);
          }
        }
  
        SOURCE_NAMES_MAP[type] = sourceNames;
      }
  
      return SOURCE_NAMES_MAP[type];
    },
  
    getDefaultCartoCSSForType: function getDefaultCartoCSSForType() {
      return _.template(["#layer['mapnik::geometry_type'=1] {", '  marker-width: <%= point.fill.size.fixed %>;', '  marker-fill: <%= point.fill.color.fixed %>;', '  marker-fill-opacity: <%= point.fill.color.opacity %>;', '  marker-line-color: <%= point.stroke.color.fixed %>;', '  marker-line-width: <%= point.stroke.size.fixed %>;', '  marker-line-opacity: <%= point.stroke.color.opacity %>;', '  marker-type: ellipse;', '  marker-allow-overlap: true;', '}', "#layer['mapnik::geometry_type'=2] {", '  line-color: <%= line.stroke.color.fixed %>;', '  line-width: <%= line.stroke.size.fixed %>;', '  line-opacity: 1;', '}', "#layer['mapnik::geometry_type'=3] {", '  polygon-fill: <%= polygon.fill.color.fixed %>;', '  polygon-opacity: <%= polygon.fill.color.opacity %>;', '  ::outline {', '    line-color: <%= polygon.stroke.color.fixed%>;', '    line-width: <%= polygon.stroke.size.fixed %>;', '    line-opacity: <%= polygon.stroke.color.opacity %>;', '  }', '}'].join('\n'))(DefaultCartography.simple);
    },
  
    isValidInputGeometryForType: function isValidInputGeometryForType(simpleGeometryType, analysisType) {
      var validGeometries = this.getValidInputGeometriesForType(analysisType);
      return _.contains(validGeometries, simpleGeometryType) || _.contains(validGeometries, '*');
    },
  
    getValidInputGeometriesForType: function getValidInputGeometriesForType(analysisType) {
      var params = this.paramsForType(analysisType);
  
      var geometries = [];
  
      for (var name in params) {
        var param = params[name];
        if (param.type === 'node') {
          geometries = _.union(geometries, param.geometry);
        }
      }
  
      return geometries;
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/column-model.js":
  /*!*************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/column-model.js ***!
    \*************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  module.exports = Backbone.Model.extend({
    idAttribute: 'name'
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/config-model.js":
  /*!*************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/config-model.js ***!
    \*************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  /**
   * Model for general frontend configuration.
   * Ported from old cdb.config, since we can't reuse the older model that's tied to v3 of cartodb.js
   *
   * Also, rather than putting it as a global object, it's intended to be instantiated at the entry point and passed as
   * a collaborator object the models that needs it, e.g.:
   * var myModel = new MyModel({ id: 123,  }, {
   *   configModel: configModel
   * })
   */
  module.exports = Backbone.Model.extend({
  
    defaults: {
      base_url: '/CHANGEME' // expected to be set when model is created
    },
  
    urlVersion: function urlVersion(modelName, method, defaultVersion) {
      method = method || '';
      var version = this.get(modelName + '_' + method + '_url_version');
      return version || defaultVersion || 'v1';
    },
  
    /**
     * @param {String} [version=v2] Version of API to use
     * @return {String} the full sql api url, including the api endpoint, e.g. http://user.carto.com/api/v2/sql
     */
    getSqlApiUrl: function getSqlApiUrl(version) {
      version = version || 'v2';
      return this._getSqlApiBaseUrl() + '/api/' + version + '/sql';
    },
  
    /**
     * @return {String} returns the base url to compose the final url, e.g. http://user.carto.com/
     */
    _getSqlApiBaseUrl: function _getSqlApiBaseUrl() {
      var url;
      if (this.get('sql_api_template')) {
        url = this.get('sql_api_template').replace('{user}', this.get('user_name'));
      } else {
        url = this.get('sql_api_protocol') + '://' + this.get('user_name') + '.' + this.get('sql_api_domain') + ':' + this.get('sql_api_port');
      }
      return url;
    },
  
    dataServiceEnabled: function dataServiceEnabled(name) {
      var dataServices = this.get('dataservices_enabled');
      if (!dataServices || !_.size(dataServices) || !name) {
        return false;
      }
      return !!dataServices[name];
    },
  
    dataLibraryEnabled: function dataLibraryEnabled() {
      return this.get('data_library_enabled');
    },
  
    isHosted: function isHosted() {
      return this.get('cartodb_com_hosted');
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/custom-baselayer-model.js":
  /*!***********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/custom-baselayer-model.js ***!
    \***********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  /* global Image */
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  module.exports = Backbone.Model.extend({
  
    getAttributes: function getAttributes() {
      return JSON.parse(JSON.stringify(this.attributes));
    },
  
    _generateClassName: function _generateClassName(urlTemplate) {
      if (urlTemplate) {
        return urlTemplate.replace(/\s+/g, '').replace(/[^a-zA-Z_0-9 ]/g, '').toLowerCase();
      } else return '';
    },
  
    parse: function parse(data) {
      var attrs = {};
  
      _.extend(attrs, data.options, {
        id: data.id,
        className: this._generateClassName(data.options.urlTemplate),
        type: 'Tiled',
        order: data.order,
        parent_id: data.parent_id
      });
  
      return attrs;
    },
  
    toJSON: function toJSON() {
      var layerOptions = _.clone(_.omit(this.attributes, ['order', 'id']));
      var json = {
        kind: 'tiled',
        options: layerOptions,
        order: this.get('order'),
        id: this.id
      };
  
      return json;
    },
  
    getValue: function getValue() {
      return this.get('val');
    },
  
    /**
     * validateTemplateURL - Validates current urlTemplate of layer.
     *
     * @param {Object} callbacks with success and error functions defined to be called depending on validation outcome.
     */
    validateTemplateURL: function validateTemplateURL(callbacks) {
      var subdomains = ['a', 'b', 'c'];
      var image = new Image();
      image.onload = callbacks.success;
      image.onerror = callbacks.error;
      image.src = this.get('urlTemplate').replace(/\{s\}/g, function () {
        return subdomains[Math.floor(Math.random() * 3)];
      }).replace(/\{x\}/g, '0').replace(/\{y\}/g, '0').replace(/\{z\}/g, '0');
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/custom-baselayers-collection.js":
  /*!*****************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/custom-baselayers-collection.js ***!
    \*****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CustomBaselayerModel = __webpack_require__(/*! ./custom-baselayer-model */ "./lib/assets/javascripts/builder/data/custom-baselayer-model.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel', 'currentUserId'];
  
  module.exports = Backbone.Collection.extend({
  
    model: function model(d, opts) {
      var self = opts.collection;
  
      var m = new CustomBaselayerModel(d, {
        parse: true,
        collection: self
      });
  
      return m;
    },
  
    url: function url() {
      var baseUrl = this._configModel.get('base_url');
      var version = this._configModel.urlVersion('user');
      return baseUrl + '/api/' + version + '/users/' + this._currentUserId + '/layers';
    },
  
    initialize: function initialize(models, opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
    },
  
    isCustomCategory: function isCustomCategory() {
      var custom = this.where(function (mdl) {
        return ['NASA', 'TileJSON', 'WMS', 'Mapbox', 'Custom', undefined].some(function (category) {
          return mdl.get('category') === category;
        });
      });
      return custom;
    },
  
    getSelected: function getSelected() {
      return this.findWhere({ selected: true });
    },
  
    hasCustomBaseLayer: function hasCustomBaseLayer(className) {
      if (!className) return;
  
      var customBaseLayer = this.where({ className: className });
  
      return customBaseLayer.length > 0;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/data-observatory/data-observatory-base-collection.js":
  /*!**************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/data-observatory/data-observatory-base-collection.js ***!
    \**************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var errorParse = __webpack_require__(/*! builder/helpers/error-parser */ "./lib/assets/javascripts/builder/helpers/error-parser.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var CustomListCollection = __webpack_require__(/*! builder/components/custom-list/custom-list-collection */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-collection.js");
  
  var REQUIRED_OPTS = ['configModel', 'nodeDefModel'];
  
  module.exports = CustomListCollection.extend({
    initialize: function initialize(models, options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
      this._querySchemaModel = this._nodeDefModel.querySchemaModel;
  
      var configModel = options.configModel;
      this.SQL = new cdb.SQL({
        user: configModel.get('user_name'),
        sql_api_template: configModel.get('sql_api_template'),
        api_key: configModel.get('api_key')
      });
  
      this.stateModel = new Backbone.Model({
        state: 'unfetched'
      });
  
      CustomListCollection.prototype.initialize.call(this, models, options);
    },
  
    _onSelectedChange: function _onSelectedChange(changedModel, isSelected) {
      if (this.type === 'multiple') {
        return;
      }
  
      if (isSelected) {
        this.each(function (m) {
          if (m.cid !== changedModel.cid) {
            m.set({ selected: false }, { silent: true });
          }
        }, this);
      }
    },
  
    buildQuery: function buildQuery() {
      throw new Error('subclasses of DataObservatoryBaseCollection must implement buildQuery');
    },
  
    fetch: function fetch(options) {
      this._success = options && options.success;
      this._error = options && options.error;
  
      var defaults = {
        filters: null,
        measurement: null,
        normalize: null,
        timespan: null,
        query: this._querySchemaModel.get('query')
      };
  
      this.deferred = $.Deferred();
      var queryOptions = _.defaults(options, defaults);
      var sqlQuery = this.buildQuery(queryOptions);
  
      this.stateModel.set('state', 'fetching');
      this.SQL.execute(sqlQuery, queryOptions, {
        success: function (data) {
          this._onFetchSuccess(data);
          this.stateModel.set('state', 'fetched');
          this.deferred.resolve();
          this._success && this._success();
        }.bind(this),
        error: function (err) {
          this.stateModel.set('state', 'error');
          this.deferred.reject();
          this._error && this._error(errorParse(err));
        }.bind(this)
      });
  
      return this.deferred.promise();
    },
  
    _onFetchSuccess: function _onFetchSuccess(data) {
      var models = data.rows;
      this.reset(models);
    },
  
    isFetching: function isFetching() {
      return this.getState() === 'fetching';
    },
  
    getState: function getState() {
      return this.stateModel.get('state');
    },
  
    getItem: function getItem(value) {
      return this.findWhere({ val: value });
    },
  
    isAsync: function isAsync() {
      return true;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/data-observatory/filters-collection.js":
  /*!************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/data-observatory/filters-collection.js ***!
    \************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var BaseCollection = __webpack_require__(/*! ./data-observatory-base-collection */ "./lib/assets/javascripts/builder/data/data-observatory/data-observatory-base-collection.js");
  var BaseModel = __webpack_require__(/*! builder/components/custom-list/custom-list-item-model */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item-model.js");
  
  var FILTERS_QUERY_WITH_REGION = "SELECT count(*) num_measurements, tag.key subsection_id, tag.value subsection_name FROM OBS_GetAvailableNumerators((SELECT ST_SetSRID(ST_Extent(the_geom), 4326) FROM ({{{ query }}}) q), {{{ region }}}) numers, Jsonb_Each(numers.numer_tags) tag WHERE tag.key like 'subsection%' GROUP BY tag.key, tag.value";
  
  module.exports = BaseCollection.extend({
    initialize: function initialize(models, options) {
      this.type = 'multiple';
  
      BaseCollection.prototype.initialize.call(this, models, options);
    },
  
    model: function model(attrs, opts) {
      // label and val to custom list compatibility
      var o = {};
      o.val = attrs.subsection_id;
      o.label = attrs.subsection_name;
      o.items = attrs.num_measurements;
  
      return new BaseModel(o);
    },
  
    setSelected: function setSelected(value) {
      var silentTrue = { silent: true };
  
      if (_.isArray(value)) {
        this.each(function (mdl) {
          if (_.contains(value, mdl.getValue())) {
            mdl.set({
              selected: true
            }, silentTrue);
          } else {
            mdl.set({
              selected: false
            }, silentTrue);
          }
        });
      } else {
        this.each(function (mdl) {
          if (mdl.getValue() === value) {
            mdl.set({
              selected: true
            }, silentTrue);
          } else {
            mdl.set({
              selected: false
            }, silentTrue);
          }
        });
      }
    },
  
    getSelected: function getSelected() {
      return this.filter(function (mdl) {
        return mdl.get('selected') === true;
      });
    },
  
    buildQuery: function buildQuery(options) {
      return FILTERS_QUERY_WITH_REGION;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/data-observatory/measurements-collection.js":
  /*!*****************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/data-observatory/measurements-collection.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var BaseCollection = __webpack_require__(/*! ./data-observatory-base-collection */ "./lib/assets/javascripts/builder/data/data-observatory/data-observatory-base-collection.js");
  var BaseModel = __webpack_require__(/*! builder/components/custom-list/custom-list-item-model */ "./lib/assets/javascripts/builder/components/custom-list/custom-list-item-model.js");
  
  var MEASUREMENTS_QUERY_WITH_REGION = 'SELECT numer_id, numer_name, numer_description, numer_type, numer_aggregate, numer_tags FROM _OBS_GetNumerators((SELECT ST_SetSRID(ST_Extent(the_geom), 4326) FROM ({{{ query }}}) q), section_tags => {{{ region }}}) ORDER BY numer_name ASC';
  
  var MEASUREMENTS_QUERY_WITH_FILTERS = 'SELECT numer_id, numer_name, numer_description, numer_type, numer_aggregate, numer_tags FROM _OBS_GetNumerators((SELECT ST_SetSRID(ST_Extent(the_geom), 4326) FROM ({{{ query }}}) q), section_tags => {{{ region }}}, subsection_tags => {{{ filters }}})';
  
  var MEASUREMENTS_QUERY_SEARCH = "SELECT numer_id, numer_name, numer_description, numer_type, numer_aggregate, numer_tags FROM _OBS_GetNumerators((SELECT ST_SetSRID(ST_Extent(the_geom), 4326) FROM ({{{ query }}}) q), section_tags => {{{ region }}}, name => '{{{ search }}}')";
  
  var MEASUREMENTS_QUERY_SEARCH_AND_FILTERS = "SELECT numer_id, numer_name, numer_description, numer_type, numer_aggregate, numer_tags FROM _OBS_GetNumerators((SELECT ST_SetSRID(ST_Extent(the_geom), 4326) FROM ({{{ query }}}) q), section_tags => {{{ region }}} , name => '{{{ search }}}', subsection_tags => {{{ filters }}})";
  
  module.exports = BaseCollection.extend({
    model: function model(attrs, opts) {
      return new BaseModel(attrs, opts);
    },
  
    _onFetchSuccess: function _onFetchSuccess(data) {
      var models = data.rows;
  
      models = _.map(models, function (model) {
        var o = {};
        // label and val to custom list compatibility
        o.val = model.numer_id;
        o.label = model.numer_name;
        o.description = model.numer_description;
        o.type = model.numer_type;
        o.aggregate = model.numer_aggregate;
        // a measurement can belong to more than one category (filter)
        o.filter = [];
        var tags = model.numer_tags;
        if (!_.isObject(tags)) {
          tags = JSON.parse(tags);
        }
  
        for (var key in tags) {
          if (/^subsection/.test(key)) {
            o.filter.push({
              id: key,
              name: tags[key]
            });
          }
  
          if (/^license/.test(key)) {
            o.license = tags[key];
          }
        }
  
        return o;
      }).filter(function (model) {
        return model.filter.length > 0;
      });
  
      this.reset(models);
    },
  
    buildQuery: function buildQuery(options) {
      if (options && options.search && options.filters) {
        return MEASUREMENTS_QUERY_SEARCH_AND_FILTERS;
      } else if (options && options.filters) {
        return MEASUREMENTS_QUERY_WITH_FILTERS;
      } else if (options && options.search) {
        return MEASUREMENTS_QUERY_SEARCH;
      } else {
        return MEASUREMENTS_QUERY_WITH_REGION;
      }
    },
  
    search: function search() {
      return this;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/editor-model.js":
  /*!*************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/editor-model.js ***!
    \*************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   * Model for general editor configuration.
   */
  module.exports = Backbone.Model.extend({
    defaults: {
      edition: false,
      disabled: false
    },
    isEditing: function isEditing() {
      return !!this.get('edition');
    },
    isDisabled: function isDisabled() {
      return !!this.get('disabled');
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/get-simple-geometry-type.js":
  /*!*************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/get-simple-geometry-type.js ***!
    \*************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var MAP = {
    'st_multipolygon': 'polygon',
    'st_polygon': 'polygon',
    'st_multilinestring': 'line',
    'st_linestring': 'line',
    'st_multipoint': 'point',
    'st_point': 'point'
  };
  
  /**
   * @param {String} val e.g. 'ST_MultiPoint'
   * @return {String} e.g. 'point'
   */
  module.exports = function (val) {
    return MAP[val.toLowerCase()];
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/grantables-collection.js":
  /*!**********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/grantables-collection.js ***!
    \**********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var syncAbort = __webpack_require__(/*! ./backbone/sync-abort */ "./lib/assets/javascripts/builder/data/backbone/sync-abort.js");
  var UserModel = __webpack_require__(/*! ./user-model */ "./lib/assets/javascripts/builder/data/user-model.js");
  var GroupModel = __webpack_require__(/*! ./group-model */ "./lib/assets/javascripts/builder/data/group-model.js");
  
  /**
   * A collection of Grantable objects.
   */
  module.exports = Backbone.Collection.extend({
  
    model: function model(attrs, options) {
      var type = attrs.type;
      var configModel = attrs.configModel;
      options = _.extend(options, {
        configModel: configModel
      });
  
      if (attrs.model) {
        attrs = _.extend({}, attrs, attrs.model);
      }
  
      if (type === 'user') {
        return new UserModel(_.omit(attrs, 'configModel'), options);
      } else if (type === 'group') {
        return new GroupModel(_.omit(attrs, 'configModel'), options);
      }
    },
  
    sync: syncAbort,
  
    url: function url(method) {
      var baseUrl = this.configModel.get('base_url');
      var version = this.configModel.urlVersion('organizationGrantables', method);
      return baseUrl + '/api/' + version + '/organization/' + this.organization.id + '/grantables';
    },
  
    initialize: function initialize(users, opts) {
      if (!opts.organization) throw new Error('Organization is required');
      if (!opts.currentUserId) throw new Error('currentUserId is required');
      if (!opts.configModel) throw new Error('configModel is required');
  
      this.configModel = opts.configModel;
      this.organization = opts.organization;
      this.currentUserId = opts.currentUserId;
    },
  
    parse: function parse(response) {
      this.trigger('fetched', this);
      this.total_entries = response.total_entries;
  
      return _.reduce(response.grantables, function (memo, m) {
        if (m.id === this.currentUserId) {
          this.total_entries--;
        } else {
          m.organization = this.organization;
          m.configModel = this.configModel;
          memo.push(m);
        }
        return memo;
      }, [], this);
    },
  
    fetch: function fetch(opts) {
      opts = opts || {};
      this.trigger('fetching', this);
      opts.error = function (model, response) {
        this.trigger('error', this);
      }.bind(this);
  
      return Backbone.Collection.prototype.fetch.call(this, opts);
    },
  
    totalCount: function totalCount() {
      return this.total_entries;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/group-model.js":
  /*!************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/group-model.js ***!
    \************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var UsersGroup = __webpack_require__(/*! ./users-group-collection */ "./lib/assets/javascripts/builder/data/users-group-collection.js");
  
  /**
   * Model representing a group.
   * Expected to be used in the context of a groups collection (e.g. OrganizationGroups),
   * which defines its API endpoint path.
   */
  
  module.exports = Backbone.Model.extend({
  
    defaults: {
      display_name: ''
    },
  
    initialize: function initialize(attrs, opts) {
      this.parse(attrs || {}, opts); // handle given attrs in the same way as for .fetch()
    },
  
    parse: function parse(attrs, opts) {
      this.users = new UsersGroup(attrs.users, {
        group: this,
        configModel: opts.configModel,
        organization: opts.organization
      });
  
      return attrs;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/infowindow-click-model.js":
  /*!***********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/infowindow-click-model.js ***!
    \***********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var InfowindowDefinitionModel = __webpack_require__(/*! ./infowindow-definition-model */ "./lib/assets/javascripts/builder/data/infowindow-definition-model.js");
  
  module.exports = InfowindowDefinitionModel.extend({
  
    defaults: {
      template_name: '',
      latlng: [0, 0],
      offset: [28, 0], // offset of the tip calculated from the bottom left corner
      maxHeight: 180, // max height of the content, not the whole infowindow
      autoPan: true,
      template: '',
      content: '',
      visibility: false,
      alternative_names: {},
      fields: null, // contains the fields displayed in the infowindow,
      width: 226,
      headerColor: {
        color: {
          fixed: '#35AAE5',
          opacity: 1
        }
      }
    },
  
    TEMPLATES: {
      infowindow_light: __webpack_require__(/*! builder/mustache-templates/infowindows/infowindow_light.jst.mustache */ "./lib/assets/javascripts/builder/mustache-templates/infowindows/infowindow_light.jst.mustache"),
      infowindow_dark: __webpack_require__(/*! builder/mustache-templates/infowindows/infowindow_dark.jst.mustache */ "./lib/assets/javascripts/builder/mustache-templates/infowindows/infowindow_dark.jst.mustache"),
      infowindow_color: __webpack_require__(/*! builder/mustache-templates/infowindows/infowindow_color.jst.mustache */ "./lib/assets/javascripts/builder/mustache-templates/infowindows/infowindow_color.jst.mustache"),
      infowindow_header_with_image: __webpack_require__(/*! builder/mustache-templates/infowindows/infowindow_header_with_image.jst.mustache */ "./lib/assets/javascripts/builder/mustache-templates/infowindows/infowindow_header_with_image.jst.mustache"),
      custom_infowindow_light: __webpack_require__(/*! builder/mustache-templates/infowindows_custom/infowindow_light.jst.mustache */ "./lib/assets/javascripts/builder/mustache-templates/infowindows_custom/infowindow_light.jst.mustache"),
      custom_infowindow_dark: __webpack_require__(/*! builder/mustache-templates/infowindows_custom/infowindow_dark.jst.mustache */ "./lib/assets/javascripts/builder/mustache-templates/infowindows_custom/infowindow_dark.jst.mustache"),
      custom_infowindow_color: __webpack_require__(/*! builder/mustache-templates/infowindows_custom/infowindow_color.jst.mustache */ "./lib/assets/javascripts/builder/mustache-templates/infowindows_custom/infowindow_color.jst.mustache"),
      custom_infowindow_header_with_image: __webpack_require__(/*! builder/mustache-templates/infowindows_custom/infowindow_header_with_image.jst.mustache */ "./lib/assets/javascripts/builder/mustache-templates/infowindows_custom/infowindow_header_with_image.jst.mustache")
    },
  
    _transformTemplate: function _transformTemplate(template) {
      var fixed = this.get('headerColor').color.fixed;
  
      return template.replace('background: #35AAE5', 'background: ' + fixed);
    },
  
    setTemplate: function setTemplate(templateName) {
      var template = typeof this.TEMPLATES[templateName] === 'undefined' ? '' : this.TEMPLATES[templateName];
  
      if (templateName === 'infowindow_color') {
        template = this._transformTemplate(template);
      }
  
      var attrs = {
        'template_name': templateName,
        'template': template,
        'template_type': 'mustache'
      };
  
      if (templateName === '') {
        attrs.fields = [];
      }
  
      this.set(attrs);
    },
  
    isEmptyTemplate: function isEmptyTemplate() {
      var isEmpty = this.fieldCount() === 0;
      return this.hasTemplate() && isEmpty;
    },
  
    setDefault: function setDefault() {
      this.setTemplate(this.defaults.template_name);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/infowindow-definition-model.js":
  /*!****************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/infowindow-definition-model.js ***!
    \****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  
  module.exports = Backbone.Model.extend({
  
    SYSTEM_COLUMNS: ['the_geom', 'the_geom_webmercator', 'created_at', 'updated_at', 'cartodb_id', 'cartodb_georef_status'],
  
    TEMPLATES: {},
  
    initialize: function initialize(attrs, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
  
      this._configModel = opts.configModel;
    },
  
    clearFields: function clearFields() {
      this.set({ 'fields': [] });
    },
  
    saveFields: function saveFields(where) {
      where = where || 'old_fields';
      this.set(where, _.clone(this.get('fields')));
    },
  
    fieldCount: function fieldCount() {
      var fields = this.get('fields');
      if (!fields) return 0;
      return fields.length;
    },
  
    restoreFields: function restoreFields(whiteList, from) {
      from = from || 'old_fields';
      var fields = this.get(from);
      if (whiteList) {
        fields = fields.filter(function (f) {
          return _.contains(whiteList, f.name);
        });
      }
      if (fields && fields.length) {
        this._setFields(fields);
      }
      this.unset(from);
    },
  
    containsField: function containsField(fieldName) {
      var fields = this.get('fields') || [];
      return _.contains(_(fields).pluck('name'), fieldName);
    },
  
    getFieldProperty: function getFieldProperty(fieldName, k) {
      if (this.containsField(fieldName)) {
        var fields = this.get('fields') || [];
        var idx = _.indexOf(_(fields).pluck('name'), fieldName);
        return fields[idx][k];
      }
      return null;
    },
  
    setFieldProperty: function setFieldProperty(fieldName, k, v) {
      if (this.containsField(fieldName)) {
        var fields = this._cloneFields() || [];
        var idx = _.indexOf(_(fields).pluck('name'), fieldName);
        fields[idx][k] = v;
        this._setFields(fields);
      }
      return this;
    },
  
    _cloneFields: function _cloneFields() {
      return _(this.get('fields')).map(function (v) {
        return _.clone(v);
      });
    },
  
    _setFields: function _setFields(f) {
      f.sort(function (a, b) {
        return a.position - b.position;
      });
      this.set({ 'fields': f });
    },
  
    sortFields: function sortFields() {
      this.get('fields').sort(function (a, b) {
        return a.position - b.position;
      });
    },
  
    _addField: function _addField(fieldName, at) {
      var dfd = $.Deferred();
      if (!this.containsField(fieldName)) {
        var fields = this.get('fields');
  
        if (fields) {
          at = at === undefined ? fields.length : at;
          fields.push({ name: fieldName, title: true, position: at });
        } else {
          at = at === undefined ? 0 : at;
          this.set('fields', [{ name: fieldName, title: true, position: at }], { silent: true });
        }
      }
      dfd.resolve();
      return dfd.promise();
    },
  
    addField: function addField(fieldName, at) {
      var self = this;
      $.when(this._addField(fieldName, at)).then(function () {
        self.sortFields();
        self.trigger('add:fields');
        self.trigger('change:fields', self, self.get('fields'));
        self.trigger('change', self);
      });
      return this;
    },
  
    removeField: function removeField(fieldName) {
      if (this.containsField(fieldName)) {
        var fields = this._cloneFields() || [];
        var idx = _.indexOf(_(fields).pluck('name'), fieldName);
        if (idx >= 0) {
          fields.splice(idx, 1);
        }
        this._setFields(fields);
        this.trigger('remove:fields');
      }
      return this;
    },
  
    getAlternativeName: function getAlternativeName(fieldName) {
      return this.get('alternative_names') && this.get('alternative_names')[fieldName];
    },
  
    setAlternativeName: function setAlternativeName(fieldName, alternativeName) {
      var alternativeNames = _.clone(this.get('alternative_names') || {});
  
      alternativeNames[fieldName] = alternativeName;
      this.set({ 'alternative_names': alternativeNames });
      this.trigger('change:alternative_names');
    },
  
    getFieldPos: function getFieldPos(fieldName) {
      var p = this.getFieldProperty(fieldName, 'position');
      if (p === undefined) {
        return Number.MAX_VALUE;
      }
      return p;
    },
  
    unsetTemplate: function unsetTemplate() {
      this.setTemplate('');
    },
  
    setTemplate: function setTemplate(templateName) {
      var template = typeof this.TEMPLATES[templateName] === 'undefined' ? '' : this.TEMPLATES[templateName];
  
      var attrs = {
        'template_name': templateName,
        'template': template,
        'template_type': 'mustache'
      };
  
      if (templateName === '') {
        attrs.fields = [];
      }
  
      this.set(attrs);
    },
  
    getTemplate: function getTemplate() {
      var template_name = this.get('template_name');
  
      if (template_name !== '') {
        return this.TEMPLATES['custom_' + template_name];
      } else {
        return this.get('template');
      }
    },
  
    hasTemplate: function hasTemplate() {
      return !!this.get('template_name') && this.TEMPLATES[this.get('template_name')];
    },
  
    isCustomTemplate: function isCustomTemplate() {
      return this.get('template_name') === '' && this.get('template') !== '';
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/infowindow-hover-model.js":
  /*!***********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/infowindow-hover-model.js ***!
    \***********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var InfowindowDefinitionModel = __webpack_require__(/*! ./infowindow-definition-model */ "./lib/assets/javascripts/builder/data/infowindow-definition-model.js");
  
  module.exports = InfowindowDefinitionModel.extend({
  
    defaults: {
      vertical_offset: 0,
      horizontal_offset: 0,
      position: 'top|center',
      template_name: '',
      template: ''
    },
  
    TEMPLATES: {
      tooltip_dark: __webpack_require__(/*! builder/mustache-templates/tooltips/tooltip_dark.jst.mustache */ "./lib/assets/javascripts/builder/mustache-templates/tooltips/tooltip_dark.jst.mustache"),
      tooltip_light: __webpack_require__(/*! builder/mustache-templates/tooltips/tooltip_light.jst.mustache */ "./lib/assets/javascripts/builder/mustache-templates/tooltips/tooltip_light.jst.mustache"),
      custom_tooltip_dark: __webpack_require__(/*! builder/mustache-templates/tooltips_custom/tooltip_dark.jst.mustache */ "./lib/assets/javascripts/builder/mustache-templates/tooltips_custom/tooltip_dark.jst.mustache"),
      custom_tooltip_light: __webpack_require__(/*! builder/mustache-templates/tooltips_custom/tooltip_light.jst.mustache */ "./lib/assets/javascripts/builder/mustache-templates/tooltips_custom/tooltip_light.jst.mustache")
    },
  
    setDefault: function setDefault() {
      this.setTemplate(this.defaults.template_name);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/layer-colors.js":
  /*!*************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/layer-colors.js ***!
    \*************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  module.exports = {
    COLORS: ['#11A579', '#E83f74', '#9F5DC8', '#EF8205', '#29B3B2', '#E54F3B', '#59BB12', '#EF57BA', '#E2AF00', '#12AADE'],
  
    /**
     * Returns a color given a letter
     * @param  {String} Letter. eg: 'a', 'b', 'c', etc.
     * @return {String} Hex color code: eg: '#7F3C8D'
     */
    getColorForLetter: function getColorForLetter(letter) {
      if (!letter) {
        return this.COLORS[0];
      }
  
      var letterNumber = letter.charCodeAt(0) - 97;
      var colorIndex = (letterNumber / this.COLORS.length % 1 * 10).toFixed();
      return this.COLORS[colorIndex] || this.COLORS[0];
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/layer-definition-model.js":
  /*!***********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/layer-definition-model.js ***!
    \***********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var syncAbort = __webpack_require__(/*! ./backbone/sync-abort */ "./lib/assets/javascripts/builder/data/backbone/sync-abort.js");
  var StyleDefinitionModel = __webpack_require__(/*! builder/editor/style/style-definition-model */ "./lib/assets/javascripts/builder/editor/style/style-definition-model.js");
  var StyleCartoCSSModel = __webpack_require__(/*! builder/editor/style/style-cartocss-model */ "./lib/assets/javascripts/builder/editor/style/style-cartocss-model.js");
  var DataSQLModel = __webpack_require__(/*! builder/editor/layers/layer-content-views/data/data-sql-model */ "./lib/assets/javascripts/builder/editor/layers/layer-content-views/data/data-sql-model.js");
  var layerTypesAndKinds = __webpack_require__(/*! ./layer-types-and-kinds */ "./lib/assets/javascripts/builder/data/layer-types-and-kinds.js");
  var InfowindowModel = __webpack_require__(/*! ./infowindow-click-model */ "./lib/assets/javascripts/builder/data/infowindow-click-model.js");
  var TooltipModel = __webpack_require__(/*! ./infowindow-hover-model */ "./lib/assets/javascripts/builder/data/infowindow-hover-model.js");
  var TableNameUtils = __webpack_require__(/*! builder/helpers/table-name-utils */ "./lib/assets/javascripts/builder/helpers/table-name-utils.js");
  var layerColors = __webpack_require__(/*! ./layer-colors */ "./lib/assets/javascripts/builder/data/layer-colors.js");
  
  // from_layer_id and from_letter are not attributes for the model, but are sent to the layer creation
  // endpoint when creating a layer from an existing analysis node (see user-actions)
  var ATTR_NAMES = ['id', 'order', 'infowindow', 'tooltip', 'error', 'from_layer_id', 'from_letter'];
  
  /**
   * Model to edit a layer definition.
   * Should always exist as part of a LayerDefinitionsCollection, so its URL is given from there.
   */
  module.exports = Backbone.Model.extend({
  
    /**
     * @override {Backbone.prototype.sync} abort ongoing request if there is any
     */
    sync: syncAbort,
  
    parse: function parse(response, opts) {
      response.options = response.options || {};
  
      // Flatten the attrs, to avoid having this.get('options').foobar internally
      var attrs = _.defaults(_.pick(response, ATTR_NAMES), _.omit(response.options, ['query', 'tile_style']));
  
      // Only use type on the frontend, it will be mapped back when the model is serialized (see .toJSON)
      attrs.type = attrs.type || layerTypesAndKinds.getType(response.kind);
  
      // Map API endpoint attrs to the new names used client-side (cartodb.js in particular)
      if (response.options.tile_style) {
        attrs.cartocss = response.options.tile_style;
      }
      if (response.options.query) {
        attrs.sql = response.options.query;
      }
  
      if (response.infowindow) {
        if (!this.infowindowModel) {
          this.infowindowModel = new InfowindowModel(response.infowindow, {
            configModel: opts.configModel || this._configModel
          });
        }
      }
      if (response.tooltip) {
        if (!this.tooltipModel) {
          this.tooltipModel = new TooltipModel(response.tooltip, {
            configModel: opts.configModel || this._configModel
          });
        }
      }
      if (response.options.table_name) {
        // Set autostyle as false if it doesn't contain any id
        attrs.autoStyle = attrs.autoStyle || false;
  
        if (!this.styleModel) {
          this.styleModel = new StyleDefinitionModel(response.options.style_properties, {
            parse: true
          });
  
          this.cartocssModel = new StyleCartoCSSModel({
            content: attrs.cartocss
          }, {
            history: response.options.cartocss_history || response.options.tile_style_history
          });
        }
  
        if (!this.sqlModel) {
          this.sqlModel = new DataSQLModel({
            content: attrs.sql
          }, {
            history: response.options.sql_history
          });
        }
      }
  
      // Flatten the rest of the attributes
      return attrs;
    },
  
    initialize: function initialize(attrs, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
  
      this._configModel = opts.configModel;
  
      this.on('change:source change:sql', this._onPosibleLayerSchemaChanged, this);
  
      if (this.styleModel) {
        this.styleModel.bind('change:type change:animated', function () {
          if (this.styleModel.isAggregatedType() || this.styleModel.isAnimation()) {
            // setTemplate will clear fields
            this.infowindowModel && this.infowindowModel.unsetTemplate();
            this.tooltipModel && this.tooltipModel.unsetTemplate();
          }
        }, this);
      }
    },
  
    save: function save(attrs, options) {
      attrs = attrs || {};
      options = options || {};
  
      // We assume that if the layer is saved, we have to disable autostyle
      var autoStyleAttrs = {
        autoStyle: false
      };
  
      // But if the layer is saved with shouldPreserveAutoStyle option, we should preserve autostyle
      if (options && options.shouldPreserveAutoStyle) {
        delete autoStyleAttrs.autoStyle;
      } else if (this.get('autoStyle')) {
        this.styleModel && this.styleModel.resetPropertiesFromAutoStyle();
      }
  
      attrs = _.extend({}, autoStyleAttrs, attrs);
  
      return Backbone.Model.prototype.save.call(this, attrs, options);
    },
  
    toJSON: function toJSON() {
      // Un-flatten the internal attrs to the datastructure that's expected by the API endpoint
      var options = _.omit(this.attributes, ATTR_NAMES.concat(['cartocss', 'sql', 'autoStyle']));
  
      // Map back internal attrs to the expected attrs names by the API endpoint
      var cartocss = this.get('cartocss');
  
      if (cartocss) {
        options.tile_style = cartocss;
      }
      var sql = this.get('sql');
      if (sql) {
        options.query = sql;
      }
  
      var defaultAttributes = {
        kind: layerTypesAndKinds.getKind(this.get('type')),
        options: options
      };
  
      var infowindowData = this.infowindowModel && this.infowindowModel.toJSON();
      if (!_.isEmpty(infowindowData)) {
        defaultAttributes.infowindow = this.infowindowModel.toJSON();
      }
  
      var tooltipData = this.tooltipModel && this.tooltipModel.toJSON();
      if (!_.isEmpty(tooltipData)) {
        defaultAttributes.tooltip = this.tooltipModel.toJSON();
      }
  
      if (this.styleModel && !this.styleModel.isAutogenerated()) {
        defaultAttributes.options.style_properties = this.styleModel.toJSON();
      }
  
      if (this.cartocssModel) {
        defaultAttributes.options.cartocss_history = this.cartocssModel.getHistory();
      }
  
      if (this.sqlModel) {
        defaultAttributes.options.sql_history = this.sqlModel.getHistory();
      }
  
      var attributes = _.omit(this.attributes, 'infowindow', 'tooltip', 'options', 'error', 'autoStyle');
  
      return _.defaults(defaultAttributes, _.pick(attributes, ATTR_NAMES));
    },
  
    canBeDeletedByUser: function canBeDeletedByUser() {
      return this.collection.getNumberOfDataLayers() > 1 && this.isDataLayer() && (this._canBeFoldedUnderAnotherLayer() || !this._isAllDataLayersDependingOnAnyAnalysisOfThisLayer());
    },
  
    isOwnerOfAnalysisNode: function isOwnerOfAnalysisNode(nodeModel) {
      return nodeModel && nodeModel.letter() === this.get('letter');
    },
  
    ownedPrimaryAnalysisNodes: function ownedPrimaryAnalysisNodes() {
      var nodeDefModel = this.getAnalysisDefinitionNodeModel();
      return this.isOwnerOfAnalysisNode(nodeDefModel) ? nodeDefModel.linkedListBySameLetter() : [];
    },
  
    getName: function getName() {
      return this.get('name') || this.get('table_name_alias') || this.get('table_name');
    },
  
    getTableName: function getTableName() {
      return this.get('table_name') || '';
    },
  
    getColor: function getColor() {
      return layerColors.getColorForLetter(this.get('letter'));
    },
  
    containsNode: function containsNode(other) {
      var nodeDefModel = this.getAnalysisDefinitionNodeModel();
      return nodeDefModel && nodeDefModel.containsNode(other);
    },
  
    getAnalysisDefinitionNodeModel: function getAnalysisDefinitionNodeModel() {
      return this.findAnalysisDefinitionNodeModel(this.get('source'));
    },
  
    findAnalysisDefinitionNodeModel: function findAnalysisDefinitionNodeModel(id) {
      return this.collection && this.collection.findAnalysisDefinitionNodeModel(id);
    },
  
    _onPosibleLayerSchemaChanged: function _onPosibleLayerSchemaChanged(eventName, attrs, options) {
      // Used to avoid resetting styles on source_id changes when we have saved styles for the node
      if (options && options.ignoreSchemaChange) {
        return;
      }
  
      if (this.infowindowModel) {
        this.infowindowModel.clearFields();
      }
      if (this.tooltipModel) {
        this.tooltipModel.clearFields();
      }
      if (this.styleModel) {
        this.styleModel.resetStyles();
      }
    },
  
    toggleVisible: function toggleVisible() {
      this.set('visible', !this.get('visible'));
    },
  
    toggleCollapse: function toggleCollapse() {
      this.set('collapsed', !this.get('collapsed'));
    },
  
    hasAnalyses: function hasAnalyses() {
      return this.getNumberOfAnalyses() > 0;
    },
  
    hasAggregatedStyles: function hasAggregatedStyles() {
      return this.styleModel && this.styleModel.isAggregatedType();
    },
  
    getNumberOfAnalyses: function getNumberOfAnalyses() {
      var analysisNode = this.getAnalysisDefinitionNodeModel();
      var count = 0;
  
      while (analysisNode && this.isOwnerOfAnalysisNode(analysisNode)) {
        analysisNode = analysisNode.getPrimarySource();
  
        if (analysisNode) {
          count += 1;
        }
      }
  
      return count;
    },
  
    getQualifiedTableName: function getQualifiedTableName() {
      var userName = this.get('user_name') || this.collection.userModel.get('username');
      return TableNameUtils.getQualifiedTableName(this.getTableName(), userName, this.collection.userModel.isInsideOrg());
    },
  
    getColumnNamesFromSchema: function getColumnNamesFromSchema() {
      return this._getQuerySchemaModel().getColumnNames();
    },
  
    _getQuerySchemaModel: function _getQuerySchemaModel() {
      var nodeDefModel = this.getAnalysisDefinitionNodeModel();
      return nodeDefModel.querySchemaModel;
    },
  
    isDataLayer: function isDataLayer() {
      var layerType = this.get('type');
      return layerTypesAndKinds.isCartoDBType(layerType) || layerTypesAndKinds.isTorqueType(layerType);
    },
  
    isTorqueLayer: function isTorqueLayer() {
      return this.get('type') === 'torque';
    },
  
    isAutoStyleApplied: function isAutoStyleApplied() {
      var autoStyle = this.get('autoStyle');
      return autoStyle != null && autoStyle !== false;
    },
  
    _canBeFoldedUnderAnotherLayer: function _canBeFoldedUnderAnotherLayer() {
      var thisNodeDefModel = this.getAnalysisDefinitionNodeModel();
  
      return this.collection.any(function (m) {
        if (m !== this && m.isDataLayer()) {
          var otherNodeDefModel = m.getAnalysisDefinitionNodeModel();
          if (otherNodeDefModel === thisNodeDefModel) return true;
  
          var lastNode = _.last(otherNodeDefModel.linkedListBySameLetter());
          return lastNode.getPrimarySource() === thisNodeDefModel;
        }
      }, this);
    },
  
    _isAllDataLayersDependingOnAnyAnalysisOfThisLayer: function _isAllDataLayersDependingOnAnyAnalysisOfThisLayer() {
      var nodeDefModel = this.getAnalysisDefinitionNodeModel();
      if (!nodeDefModel) return false;
      if (!this.isOwnerOfAnalysisNode(nodeDefModel)) return false;
  
      var linkedNodesList = nodeDefModel.linkedListBySameLetter();
  
      return this.collection.chain().filter(function (m) {
        return m !== this && !!m.get('source');
      }, this).all(function (m) {
        return _.any(linkedNodesList, function (node) {
          return m.containsNode(node);
        });
      }, this).value();
    },
  
    getAllDependentLayers: function getAllDependentLayers() {
      var self = this;
      var layersCount = 0;
  
      var layerDefinitionsCollectionModels = self.collection.models;
  
      for (var i = 0; i < layerDefinitionsCollectionModels.length; i++) {
        var layer = layerDefinitionsCollectionModels[i];
        var dependentAnalysis = false;
  
        if (layer !== self) {
          var analysisNode = layer.getAnalysisDefinitionNodeModel();
  
          while (analysisNode) {
            if (self.isOwnerOfAnalysisNode(analysisNode)) {
              dependentAnalysis = true;
            }
            analysisNode = analysisNode.getPrimarySource();
          }
  
          if (dependentAnalysis) {
            layersCount += 1;
          }
        }
      }
      return layersCount;
    },
  
    matchesAttrs: function matchesAttrs(otherAttrs) {
      if (this.get('type') !== otherAttrs.type) {
        return false;
      }
  
      if (layerTypesAndKinds.isTiledType(otherAttrs.type)) {
        return this.get('name') === otherAttrs.name && this.get('urlTemplate') === otherAttrs.urlTemplate;
      }
  
      if (layerTypesAndKinds.isGMapsBase(otherAttrs.type)) {
        return this.get('name') === otherAttrs.name && this.get('baseType') === otherAttrs.baseType && this.get('style') === otherAttrs.style;
      }
  
      if (layerTypesAndKinds.isPlainType(otherAttrs.type)) {
        return this.get('color') === otherAttrs.color;
      }
  
      return false;
    },
  
    hasGeocodingAnalysisApplied: function hasGeocodingAnalysisApplied() {
      var analysisNode = this.getAnalysisDefinitionNodeModel();
  
      if (analysisNode && analysisNode.get('type') === 'geocoding') {
        return true;
      }
  
      while (analysisNode && this.isOwnerOfAnalysisNode(analysisNode)) {
        analysisNode = analysisNode.getPrimarySource();
  
        if (analysisNode && analysisNode.get('type') === 'geocoding') {
          return true;
        }
      }
  
      return false;
    },
  
    _hasAnyAnalysisApplied: function _hasAnyAnalysisApplied() {
      var analysisNode = this.getAnalysisDefinitionNodeModel();
  
      return analysisNode.get('type') !== 'source';
    },
  
    isEmpty: function isEmpty() {
      throw new Error('LayerDefinitionModel.isEmpty() is an async operation. Use `.isEmptyAsync` instead.');
    },
  
    isEmptyAsync: function isEmptyAsync() {
      var nodeModel = this.getAnalysisDefinitionNodeModel();
      var hasAnyAnalysisApplied = this._hasAnyAnalysisApplied();
      var hasCustomQueryApplied = nodeModel.isCustomQueryApplied();
  
      return new Promise(function (resolve, reject) {
        nodeModel.queryRowsCollection.isEmptyAsync().then(function (isEmpty) {
          resolve(!hasAnyAnalysisApplied && !hasCustomQueryApplied && isEmpty);
        });
      });
    },
  
    isDataFiltered: function isDataFiltered() {
      var nodeModel = this.getAnalysisDefinitionNodeModel();
      var hasAnyAnalysisApplied = this._hasAnyAnalysisApplied();
      var hasCustomQueryApplied = nodeModel.isCustomQueryApplied();
      return new Promise(function (resolve, reject) {
        nodeModel.queryRowsCollection.isEmptyAsync().then(function (isEmpty) {
          resolve((hasAnyAnalysisApplied || hasCustomQueryApplied) && isEmpty);
        });
      });
    },
  
    isDone: function isDone() {
      var nodeModel = this.getAnalysisDefinitionNodeModel();
      return nodeModel.queryRowsCollection.isDone() && nodeModel.queryGeometryModel.isDone() && nodeModel.querySchemaModel.isDone();
    },
  
    canBeGeoreferenced: function canBeGeoreferenced() {
      var self = this;
      var analysisDefinitionNodeModel = this.getAnalysisDefinitionNodeModel();
      var emptyPromise = self.isEmptyAsync();
      var geomPromise = analysisDefinitionNodeModel.queryGeometryModel.hasValueAsync();
  
      return Promise.all([emptyPromise, geomPromise]).then(function (values) {
        var isEmpty = values[0];
        var hasGeom = values[1];
  
        var canBeGeoreferenced = !isEmpty && !hasGeom && !self.hasGeocodingAnalysisApplied() && !self._hasAnyAnalysisApplied() && !analysisDefinitionNodeModel.isCustomQueryApplied();
  
        return canBeGeoreferenced;
      });
    },
  
    fetchQueryRowsIfRequired: function fetchQueryRowsIfRequired() {
      var self = this;
      var analysisDefinitionNodeModel = this.getAnalysisDefinitionNodeModel();
  
      analysisDefinitionNodeModel.queryGeometryModel.hasValueAsync().then(function (geomHasValue) {
        if (!self.hasGeocodingAnalysisApplied() && !geomHasValue && !analysisDefinitionNodeModel.isCustomQueryApplied() && analysisDefinitionNodeModel.queryRowsCollection.isUnavailable()) {
          analysisDefinitionNodeModel.queryRowsCollection.fetch();
        }
      });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/layer-types-and-kinds.js":
  /*!**********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/layer-types-and-kinds.js ***!
    \**********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  // Types
  var PLAIN = 'Plain';
  var CARTODB = 'CartoDB';
  var TILED = 'Tiled';
  var TORQUE = 'torque';
  var GMAPSBASE = 'GMapsBase';
  var WMS = 'WMS';
  
  // Values of `kind` attribute that the backend/DB knows about
  var KIND_TO_TYPE_MAP = {
    'background': PLAIN,
    'carto': CARTODB,
    'gmapsbase': GMAPSBASE,
    'tiled': TILED,
    'torque': TORQUE,
    'wms': WMS
  };
  
  module.exports = {
    getType: function getType(kind) {
      var type = KIND_TO_TYPE_MAP[kind];
  
      if (!type) {
        throw new Error('no type found for given kind ' + kind);
      }
  
      return type;
    },
  
    getKind: function getKind(type) {
      if (!type) {
        throw new Error('no kind found for given type ' + type);
      }
  
      var kind;
      for (kind in KIND_TO_TYPE_MAP) {
        if (KIND_TO_TYPE_MAP[kind] === type) {
          break;
        }
      }
  
      return kind;
    },
  
    isKindDataLayer: function isKindDataLayer(kind) {
      var type = KIND_TO_TYPE_MAP[kind];
      return this.isTypeDataLayer(type);
    },
  
    isTypeDataLayer: function isTypeDataLayer(type) {
      return this.isCartoDBType(type) || this.isTorqueType(type);
    },
  
    isCartoDBType: function isCartoDBType(type) {
      return type === CARTODB;
    },
  
    isTorqueType: function isTorqueType(type) {
      return type === TORQUE;
    },
  
    isTiledType: function isTiledType(type) {
      return type === TILED;
    },
  
    isPlainType: function isPlainType(type) {
      return type === PLAIN;
    },
  
    isGMapsBase: function isGMapsBase(type) {
      return type === GMAPSBASE;
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/legends/legends-metadata.js":
  /*!*************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/legends/legends-metadata.js ***!
    \*************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var LEGENDS_METADATA = {
    bubble: {
      legendType: 'size'
    },
    category: {
      legendType: 'color'
    },
    choropleth: {
      legendType: 'color'
    },
    custom: {
      legendType: 'color'
    },
    custom_choropleth: {
      legendType: 'color'
    }
  };
  
  module.exports = LEGENDS_METADATA;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/mapcaps-collection.js":
  /*!*******************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/mapcaps-collection.js ***!
    \*******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  module.exports = Backbone.Collection.extend({
  
    initialize: function initialize(models, opts) {
      if (!opts.visDefinitionModel) throw new Error('visDefinitionModel is required');
      this.url = opts.visDefinitionModel.mapcapsURL();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/organization-assets-collection.js":
  /*!*******************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/organization-assets-collection.js ***!
    \*******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var AssetModel = __webpack_require__(/*! ./asset-model */ "./lib/assets/javascripts/builder/data/asset-model.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel', 'orgId'];
  
  module.exports = Backbone.Collection.extend({
    model: AssetModel,
  
    url: function url(method) {
      var baseUrl = this._configModel.get('base_url');
      var version = this._configModel.urlVersion('organization-assets', method);
      return baseUrl + '/api/' + version + '/organization/' + this._orgId + '/assets';
    },
  
    initialize: function initialize(models, opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
    },
  
    deselectAll: function deselectAll(m) {
      this.each(function (mdl) {
        if (mdl !== m && mdl.get('state') === 'selected') {
          mdl.set('state', '');
        }
      });
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/organization-model.js":
  /*!*******************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/organization-model.js ***!
    \*******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  /**
   *  Organization info model
   *
   */
  module.exports = Backbone.Model.extend({
  
    url: function url() {
      var baseUrl = this._configModel.get('base_url');
      return baseUrl + '/api/v1/org';
    },
  
    initialize: function initialize(attrs, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
  
      this._configModel = opts.configModel;
  
      if (!_.isEmpty(this.get('owner'))) {
        this._ownerModel = new Backbone.Model(_.omit(this.get('owner'), 'organization'));
      }
    },
  
    getOwnerId: function getOwnerId() {
      return this._ownerModel && this._ownerModel.get('id');
    },
  
    getOwnerEmail: function getOwnerEmail() {
      return this._ownerModel && this._ownerModel.get('email');
    },
  
    isOrgAdmin: function isOrgAdmin(user) {
      return this.getOwnerId() === user.get('id') || !!_.find(this.get('admins'), function (u) {
        return u.id === user.get('id');
      });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/permission-model.js":
  /*!*****************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/permission-model.js ***!
    \*****************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var UserModel = __webpack_require__(/*! ./user-model */ "./lib/assets/javascripts/builder/data/user-model.js");
  var OrganizationModel = __webpack_require__(/*! ./organization-model */ "./lib/assets/javascripts/builder/data/organization-model.js");
  var GroupModel = __webpack_require__(/*! ./group-model */ "./lib/assets/javascripts/builder/data/group-model.js");
  var ACLItemModel = __webpack_require__(/*! ./acl-item-model */ "./lib/assets/javascripts/builder/data/acl-item-model.js");
  var READ_ONLY = 'r';
  var READ_WRITE = 'rw';
  
  /**
   * manages a cartodb permission object, it contains:
   * - owner: an UserModel instance
   * - acl: a collection which includes the user and their permission.
   *
   *   see https://github.com/Vizzuality/cartodb-management/wiki/multiuser-REST-API#permissions-object
   *
   *   this object is not created to work alone, it should be a member of
   *   an object like visualization table
   *
   */
  var PermissionModel = module.exports = Backbone.Model.extend({
    urlRoot: function urlRoot() {
      var baseUrl = this._configModel.get('base_url');
      var version = this._configModel.urlVersion('perm');
      return baseUrl + '/api/' + version + '/perm';
    },
  
    initialize: function initialize(attrs, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
  
      this._configModel = opts.configModel;
      this.acl = new Backbone.Collection();
      this.owner = opts._userModel;
      this._generateOwner();
      this._generateAcl();
      this._initBinds();
    },
  
    _initBinds: function _initBinds() {
      this.bind('change:owner', this._generateOwner, this);
      this.bind('change:acl', this._generateAcl, this);
    },
  
    _generateOwner: function _generateOwner() {
      if (!this.owner) {
        this.owner = new UserModel(null, {
          configModel: this._configModel
        });
      }
      this.owner.set(this.get('owner'));
    },
  
    getOwner: function getOwner() {
      return this.owner;
    },
  
    _generateAcl: function _generateAcl() {
      var self = this;
      this.acl.reset([], { silent: true });
      _.each(this.get('acl'), function (aclItem) {
        var model;
        switch (aclItem.type) {
          case 'user':
            model = new UserModel(aclItem.entity, {
              configModel: self._configModel
            });
            break;
          case 'org':
            model = new OrganizationModel(aclItem.entity, {
              configModel: self._configModel
            });
            break;
          case 'group':
            model = new GroupModel(aclItem.entity, {
              configModel: self._configModel
            });
            break;
          default:
            throw new Error('Unknown ACL item type: ' + aclItem.type);
        }
        this._grantAccess(model, aclItem.access);
      }, this);
    },
  
    cleanPermissions: function cleanPermissions() {
      this.acl.reset();
    },
  
    hasAccess: function hasAccess(model) {
      // Having at least read access is the same as having any access
      return this.hasReadAccess(model);
    },
  
    hasReadAccess: function hasReadAccess(model) {
      // If there is a representable ACL item it must be one of at least READ_ONLY access
      return !!this.findRepresentableAclItem(model);
    },
  
    hasWriteAccess: function hasWriteAccess(model) {
      var access = Utils.result(this.findRepresentableAclItem(model), 'get', 'access');
      return access === READ_WRITE;
    },
  
    canChangeReadAccess: function canChangeReadAccess(model) {
      return this._canChangeAccess(model);
    },
  
    canChangeWriteAccess: function canChangeWriteAccess(model) {
      return (!model.isBuilder || model.isBuilder()) && this._canChangeAccess(model, function (representableAclItem) {
        return Utils.result(representableAclItem, 'get', 'access') !== READ_WRITE;
      });
    },
  
    _canChangeAccess: function _canChangeAccess(model) {
      var representableAclItem = this.findRepresentableAclItem(model);
      return this.isOwner(model) || !representableAclItem || representableAclItem === this._ownAclItem(model) || Utils.result(arguments, 1, representableAclItem) || false;
    },
  
    grantWriteAccess: function grantWriteAccess(model) {
      this._grantAccess(model, READ_WRITE);
    },
  
    grantReadAccess: function grantReadAccess(model) {
      this._grantAccess(model, READ_ONLY);
    },
  
    revokeWriteAccess: function revokeWriteAccess(model) {
      // Effectively "downgrades" to READ_ONLY
      this.grantReadAccess(model);
    },
  
    /**
     * Revokes access to a set of items
     * @param {Object} model A single model or an array of models
     */
    revokeAccess: function revokeAccess(model) {
      var aclItem = this._ownAclItem(model);
      if (aclItem) {
        this.acl.remove(aclItem);
      }
    },
  
    isOwner: function isOwner(model) {
      return _.result(this.owner, 'id') === _.result(model, 'id');
    },
  
    toJSON: function toJSON() {
      return {
        entity: this.get('entity'),
        acl: this.acl.toJSON()
      };
    },
  
    getUsersWithAnyPermission: function getUsersWithAnyPermission() {
      return this.acl.chain().filter(this._hasTypeUser).map(this._getEntity).value();
    },
  
    isSharedWithOrganization: function isSharedWithOrganization() {
      return this.acl.any(this._hasTypeOrg);
    },
  
    clone: function clone() {
      var attrs = _.clone(this.attributes);
      delete attrs.id;
      return new PermissionModel(attrs, {
        configModel: this._configModel
      });
    },
  
    /**
     * Overwrite this ACL list from other permission object
     * @param otherPermission {Object} instance of PermissionModel
     */
    overwriteAcl: function overwriteAcl(otherPermission) {
      this.acl.reset(otherPermission.acl.models);
    },
  
    // Note that this may return an inherited ACL item
    // use ._ownAclItem instead if only model's own is wanted (if there is any)
    findRepresentableAclItem: function findRepresentableAclItem(model) {
      if (this.isOwner(model)) {
        return this._newAclItem(model, READ_WRITE);
      } else {
        var checkList = ['_ownAclItem', '_organizationAclItem', '_mostPrivilegedGroupAclItem'];
  
        return this._findMostPrivilegedAclItem(checkList, function (fnName) {
          return this[fnName](model);
        });
      }
    },
  
    _hasTypeUser: function _hasTypeUser(m) {
      return m.get('type') === 'user';
    },
  
    _getEntity: function _getEntity(m) {
      return m.get('entity');
    },
  
    _hasTypeOrg: function _hasTypeOrg(m) {
      return m.get('type') === 'org';
    },
  
    _isOrganization: function _isOrganization(object) {
      return object instanceof OrganizationModel;
    },
  
    _ownAclItem: function _ownAclItem(model) {
      if (!model || !_.isFunction(model.isNew)) {
        console.log('model is required to find an ACL item');
      }
  
      if (!model.isNew()) {
        return this.acl.find(function (aclItem) {
          return aclItem.get('entity').id === model.id;
        });
      }
    },
  
    _organizationAclItem: function _organizationAclItem(m) {
      // try to get the organization from the user groups collection,
      // then from the user model (Editor),
      // and finally from the user model (Builder)
      var org = _.result(m.collection, 'organization') || m.organization || m._organizationModel;
  
      if (org) {
        return this._ownAclItem(org);
      }
    },
  
    _mostPrivilegedGroupAclItem: function _mostPrivilegedGroupAclItem(m) {
      var groups = _.result(m.groups, 'models');
  
      if (groups) {
        return this._findMostPrivilegedAclItem(groups, this._ownAclItem);
      }
    },
  
    /**
     * Iterates over a items in given list using the iteratee, stops and returns when found the ACL item with best access (i.e. READ_WRITE), or the
     * list is completed.
     * @param {Array} list
     * @param {Function} iteratee that takes an item from list and returns an access
     *   iteratee is called in context of this model.
     * @Return {String} 'r', 'rw', or undefined if there were no access for given item
     */
    _findMostPrivilegedAclItem: function _findMostPrivilegedAclItem(list, iteratee) {
      var aclItem;
      for (var i = 0, x = list[i]; x && Utils.result(aclItem, 'get', 'access') !== READ_WRITE; x = list[++i]) {
        // Keep last ACL item if iteratee returns nothing
        aclItem = iteratee.call(this, x) || aclItem;
      }
      return aclItem;
    },
  
    /**
     * Grants access to a set of items
     * @param {Object} model
     * @param {String} access can take the following values:
     * - 'r': read only
     * - 'rw': read and write permission
     */
    _grantAccess: function _grantAccess(model, access) {
      var aclItem = this._ownAclItem(model);
      if (aclItem) {
        aclItem.set('access', access);
      } else {
        aclItem = this._newAclItem(model, access);
        if (aclItem.isValid()) {
          this.acl.add(aclItem);
        } else {
          throw new Error(access + ' is not a valid ACL access');
        }
      }
    },
  
    _newAclItem: function _newAclItem(model, access) {
      var type;
      if (model instanceof UserModel) {
        type = 'user';
      } else if (model instanceof GroupModel) {
        type = 'group';
      } else if (this._isOrganization(model)) {
        type = 'org';
      } else {
        throw new Error('model not recognized as a valid ACL entity ' + model);
      }
  
      return new ACLItemModel({
        type: type,
        entity: model,
        access: access
      });
    }
  });
  
  exports.READ_ONLY = READ_ONLY;
  exports.READ_WRITE = READ_WRITE;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/query-base-model.js":
  /*!*****************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/query-base-model.js ***!
    \*****************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var syncAbort = __webpack_require__(/*! ./backbone/sync-abort */ "./lib/assets/javascripts/builder/data/backbone/sync-abort.js");
  var STATUS = __webpack_require__(/*! ./query-base-status */ "./lib/assets/javascripts/builder/data/query-base-status.js");
  var MAX_GET_LENGTH = 1024;
  var MAX_REPEATED_ERRORS = 3;
  
  module.exports = Backbone.Model.extend({
    initialize: function initialize(attrs, options) {
      this.repeatedErrors = 0;
  
      this.listenTo(this, 'change:status', this._onStatusChanged);
      this.listenTo(this, 'change:ready', this._onReadyChanged);
    },
  
    /**
     * @override {Backbone.prototype.sync} abort ongoing request if there is any
     */
    sync: syncAbort,
  
    getStatusValue: function getStatusValue() {
      return this.get('status');
    },
  
    isInInitialStatus: function isInInitialStatus() {
      return this.get('status') === STATUS.initial;
    },
  
    isFetched: function isFetched() {
      return this.get('status') === STATUS.fetched;
    },
  
    isFetching: function isFetching() {
      return this.get('status') === STATUS.fetching;
    },
  
    isErrored: function isErrored() {
      return this.get('status') === STATUS.errored;
    },
  
    isUnavailable: function isUnavailable() {
      return this.get('status') === STATUS.unavailable;
    },
  
    isDone: function isDone() {
      return this.isFetched() || this.isErrored();
    },
  
    isInFinalStatus: function isInFinalStatus() {
      var finalStatuses = [STATUS.unavailable, STATUS.fetched, STATUS.errored];
      return _.contains(finalStatuses, this.get('status'));
    },
  
    canFetch: function canFetch() {
      var hasQuery = this.hasQuery();
      var isReady = this.get('ready');
  
      return hasQuery && isReady;
    },
  
    hasQuery: function hasQuery() {
      return !!this.get('query');
    },
  
    shouldFetch: function shouldFetch() {
      return this.canFetch() && !this.isFetched() && !this.isFetching() && !this.isErrored();
    },
  
    resetFetch: function resetFetch() {
      this.set('status', STATUS.unfetched);
    },
  
    /**
     * @override {Backbone.prototype.isNew} for this.destroy() to work (not try to send DELETE request)
     */
    isNew: function isNew() {
      return true;
    },
  
    hasRepeatedErrors: function hasRepeatedErrors() {
      return this.repeatedErrors >= MAX_REPEATED_ERRORS;
    },
  
    _onStatusChanged: function _onStatusChanged() {
      if (this.isInFinalStatus()) {
        this.trigger('inFinalStatus');
      }
    },
  
    _addChangeListener: function _addChangeListener() {
      this.bind('change', this._onChange, this);
    },
  
    _removeChangeListener: function _removeChangeListener() {
      this.unbind('change', this._onChange, this);
    },
  
    _httpMethod: function _httpMethod() {
      return this._getSqlApiQueryParam().length > MAX_GET_LENGTH ? 'POST' : 'GET';
    },
  
    _incrementRepeatedError: function _incrementRepeatedError() {
      this.repeatedErrors++;
    },
  
    _resetRepeatedError: function _resetRepeatedError() {
      this.repeatedErrors = 0;
    },
  
    _onReadyChanged: function _onReadyChanged() {
      if (this.get('ready') && this.shouldFetch()) {
        this.fetch();
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/query-base-status.js":
  /*!******************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/query-base-status.js ***!
    \******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  module.exports = {
    initial: 'initial',
    unavailable: 'unavailable',
    unfetched: 'unfetched',
    fetching: 'fetching',
    fetched: 'fetched',
    errored: 'errored'
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/query-column-model.js":
  /*!*******************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/query-column-model.js ***!
    \*******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var DEACTIVATE_MATRIX = {
    'number': ['date'],
    'boolean': ['date'],
    'date': ['boolean']
  };
  var DESTRUCTIVE_MATRIX = {
    'string': {
      'string': false,
      'number': true,
      'date': true,
      'boolean': true
    },
    'number': {
      'string': false,
      'number': false,
      'date': true,
      'boolean': true
    },
    'date': {
      'string': false,
      'number': true,
      'date': false,
      'boolean': true
    },
    'boolean': {
      'string': false,
      'number': false,
      'date': true,
      'boolean': false
    }
  };
  var NON_EDITABLE_ATTRIBUTES = ['the_geom_webmercator', 'cartodb_id', 'the_geom'];
  
  module.exports = Backbone.Model.extend({
  
    url: function url() {
      if (this._tableName) {
        var baseUrl = this._configModel.get('base_url');
        var version = this._configModel.urlVersion('column');
        var url = baseUrl + '/api/' + version + '/tables/' + this._tableName + '/columns/';
  
        if (!this.isNew()) {
          // If name changes, we should point to the "old" name
          // in order to make the correct call
          url += this.previous('name') || this.get('name');
        }
  
        return url;
      }
  
      return false;
    },
  
    parse: function parse(attrs) {
      return {
        name: attrs.name,
        type: attrs.cartodb_type || attrs.type,
        isNew: false
      };
    },
  
    initialize: function initialize(models, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
  
      this._tableName = opts.tableName;
      this._configModel = opts.configModel;
    },
  
    isNew: function isNew() {
      return this.get('isNew');
    },
  
    isEditable: function isEditable() {
      return !_.contains(NON_EDITABLE_ATTRIBUTES, this.get('name'));
    },
  
    // This is relative becuase we could set any value to cartodb_id
    isCartoDBIDColumn: function isCartoDBIDColumn() {
      return this.get('name') === 'cartodb_id' && this.get('type') === 'number';
    },
  
    isGeometryColumn: function isGeometryColumn() {
      return this.get('type') === 'geometry';
    }
  }, {
    isTypeChangeDestructive: function isTypeChangeDestructive(type, newType) {
      return DESTRUCTIVE_MATRIX[type][newType];
    },
  
    isTypeChangeAllowed: function isTypeChangeAllowed(type, newType) {
      var deactivated = DEACTIVATE_MATRIX[type] || [];
      deactivated = deactivated.concat([type]);
      return !_.contains(deactivated, newType);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/query-columns-collection.js":
  /*!*************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/query-columns-collection.js ***!
    \*************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var QueryColumnModel = __webpack_require__(/*! ./query-column-model */ "./lib/assets/javascripts/builder/data/query-column-model.js");
  
  module.exports = Backbone.Collection.extend({
  
    model: function model(attrs, opts) {
      var self = opts.collection;
      return new QueryColumnModel(attrs, {
        configModel: self._configModel,
        tableName: self._tableName
      });
    },
  
    url: function url() {
      if (this._tableName) {
        var baseUrl = this._configModel.get('base_url');
        var version = this._configModel.urlVersion('column');
        return baseUrl + '/api/' + version + '/tables/' + this._tableName + '/columns';
      }
  
      return false;
    },
  
    initialize: function initialize(models, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
      if (!opts.querySchemaModel) throw new Error('querySchemaModel is required');
  
      this._tableName = opts.tableName;
      this._querySchemaModel = opts.querySchemaModel;
      this._configModel = opts.configModel;
      this._initBinds();
    },
  
    _initBinds: function _initBinds() {
      this.bind('add remove change:type change:name', function () {
        this.reset();
        this._querySchemaModel.set('status', 'unfetched');
        this._querySchemaModel.fetch();
      }, this);
      this._querySchemaModel.bind('change:status', function (mdl, status) {
        if (status === 'fetched') {
          this.reset(this._querySchemaModel.columnsCollection.toJSON());
        }
      }, this);
    },
  
    setTableName: function setTableName(name) {
      if (!name) return;
  
      if (this._tableName) {
        this._tableName = name;
  
        this.each(function (columnModel) {
          columnModel._tableName = name;
        });
      }
    },
  
    addColumn: function addColumn(opts) {
      opts = opts || {};
      this.create({
        name: 'column_' + new Date().getTime(),
        type: 'string',
        isNew: true
      }, _.extend(opts, {
        wait: true,
        parse: false
      }));
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/query-geometry-model.js":
  /*!*********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/query-geometry-model.js ***!
    \*********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var BaseModel = __webpack_require__(/*! ./query-base-model */ "./lib/assets/javascripts/builder/data/query-base-model.js");
  var STATUS = __webpack_require__(/*! ./query-base-status */ "./lib/assets/javascripts/builder/data/query-base-status.js");
  /* eslint-disable */
  var template = _.template("" + "SELECT CASE LOWER(ST_GeometryType(<%= geom_column %>)) " + "     WHEN 'st_polygon' THEN 'polygon' " + "     WHEN 'st_multipolygon' THEN 'polygon' " + "     WHEN 'st_multilinestring' THEN 'line' " + "     WHEN 'st_linestring' THEN 'line' " + "     WHEN 'st_multipoint' THEN 'point' " + "     WHEN 'st_point' THEN 'point' " + "     ELSE '' " + "  END AS the_geom FROM (<%= sql %>) __wrapped WHERE <%= geom_column %> IS NOT NULL"
  /* eslint-enable */
  );
  
  var THE_GEOM_NOT_FOUND_ERROR = 'column \"the_geom\" does not exist';
  var PARAMS = {
    sort_order: 'asc',
    rows_per_page: 40,
    page: 0
  };
  var GEOMETRIES = {
    LINE: 'line',
    POINT: 'point',
    POLYGON: 'polygon'
  };
  
  /**
   * Model to represent a schema of a SQL query.
   */
  module.exports = BaseModel.extend({
  
    defaults: {
      query: '',
      status: STATUS.initial,
      simple_geom: '', // , 'point', 'polygon', 'line'
      ready: false // until true there's no data available on the table(s) used in the query
    },
  
    initialize: function initialize(attrs, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
      BaseModel.prototype.initialize.call(this, attrs, opts);
  
      this._configModel = opts.configModel;
  
      this._addChangeListener();
    },
  
    url: function url() {
      return this._configModel.getSqlApiUrl();
    },
  
    fetch: function fetch(opts) {
      if (!this.canFetch()) return;
  
      this.set('status', STATUS.fetching);
  
      opts = opts || {};
      opts.errorCallback = opts && (opts.originalError || opts.error);
      var successCallback = opts && (opts.success || opts.complete);
  
      opts.data = _.extend(opts.data || {}, {
        api_key: this._configModel.get('api_key'),
        q: this._getSqlApiQueryParam(opts.geomColumnName)
      }, PARAMS);
  
      opts.method = this._httpMethod();
  
      opts.success = function (model, response) {
        this._resetRepeatedError();
        if (successCallback) {
          successCallback(response);
        }
      }.bind(this);
  
      opts.error = function (model, response) {
        if (response && response.statusText !== 'abort') {
          var error = response.responseText ? JSON.parse(response.responseText).error : [];
          // in case we get an error of the_geom does not exists try with the_geom_webmercator to get the geometry type
          if (error.length === 1 && error[0] === THE_GEOM_NOT_FOUND_ERROR) {
            this.fetch(_.extend({}, _.omit(opts, 'success'), { originalError: opts.errorCallback, geomColumnName: 'the_geom_webmercator' }));
          } else {
            this._incrementRepeatedError();
  
            this.set({
              simple_geom: '',
              query_errors: error,
              status: this.hasRepeatedErrors() ? STATUS.errored : STATUS.unavailable
            });
  
            if (opts.errorCallback) {
              opts.errorCallback({
                status: response.status || 'Unknown',
                error: error
              });
            }
          }
        }
      }.bind(this);
  
      return Backbone.Model.prototype.fetch.call(this, opts);
    },
  
    parse: function parse(r) {
      var simpleGeom;
  
      _.some(r.rows, function (row) {
        return !!(simpleGeom = row.the_geom); // to stop when found a valid simple geom
      });
  
      return {
        status: STATUS.fetched,
        simple_geom: simpleGeom || ''
      };
    },
  
    hasValue: function hasValue() {
      throw new Error('QueryGeometryModel.hasValue() is an async operation. Use `.hasValueAsync` instead.');
    },
  
    hasValueAsync: function hasValueAsync() {
      var self = this;
      if (this.isFetched()) {
        return Promise.resolve(!!this.get('simple_geom'));
      } else {
        return new Promise(function (resolve) {
          self.listenToOnce(self, 'inFinalStatus', function () {
            resolve(!!self.get('simple_geom'));
          });
        });
      }
    },
  
    _onChange: function _onChange() {
      this._removeChangeListener();
  
      if (!this.hasChanged('status') && this.get('status') === STATUS.fetching) {
        // If it is already fetching just redo the fetch with latest attrs
        // in case the query has changed
        if (this.hasChanged('query')) {
          this.fetch();
        }
      } else if (this.hasChanged('query') || this.hasChanged('ready')) {
        this.set('status', this.get('query') ? STATUS.unfetched : STATUS.unavailable, { silent: true });
      }
  
      this._addChangeListener();
    },
  
    _getSqlApiQueryParam: function _getSqlApiQueryParam(geomColumnName) {
      return template({
        geom_column: geomColumnName || 'the_geom',
        sql: this.get('query')
      });
    },
  
    isPolygon: function isPolygon() {
      return this.get('simple_geom') === GEOMETRIES.POLYGON;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/query-row-model.js":
  /*!****************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/query-row-model.js ***!
    \****************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  module.exports = Backbone.Model.extend({
  
    // In case that there is already an id attribute
    idAttribute: '__id',
  
    url: function url() {
      if (this._tableName && this._configModel) {
        var baseUrl = this._configModel.get('base_url');
        var version = this._configModel.urlVersion('record');
        var url = baseUrl + '/api/' + version + '/tables/';
  
        if (this.hasWriteAccess(this._userModel) && !this.isOwner(this._userModel)) {
          var owner = this._permissionModel.getOwner();
          var ownerUsername = owner.get('username');
  
          url += ownerUsername + '.' + this._tableName + '/records';
        } else {
          url += this._tableName + '/records';
        }
  
        if (!this.isNew()) {
          url += '/' + this.get('cartodb_id');
        }
  
        return url;
      }
  
      return false;
    },
  
    initialize: function initialize(attrs, opts) {
      this.collection = this.collection || {};
  
      this._tableName = opts.tableName || this.collection._tableName;
      this._configModel = opts.configModel || this.collection._configModel;
      this._permissionModel = opts.permissionModel || this.collection._permissionModel;
      this._userModel = opts.userModel || this.collection._userModel;
  
      this._initBinds();
    },
  
    _initBinds: function _initBinds() {
      this.bind('error', this._onError, this);
    },
  
    hasWriteAccess: function hasWriteAccess(userModel) {
      if (!userModel || !this._permissionModel) {
        return false;
      }
      return this._permissionModel.hasWriteAccess(userModel);
    },
  
    isOwner: function isOwner(userModel) {
      if (!userModel || !this._permissionModel) {
        return false;
      }
      return this._permissionModel.isOwner(userModel);
    },
  
    isNew: function isNew() {
      return !this.has('cartodb_id');
    },
  
    isGeomLoaded: function isGeomLoaded() {
      try {
        JSON.parse(this.get('the_geom'));
        return true;
      } catch (e) {
        return false;
      }
    },
  
    fetchRowIfGeomIsNotLoaded: function fetchRowIfGeomIsNotLoaded(callback) {
      if (this.isGeomLoaded()) {
        callback();
        return;
      }
  
      this.fetch({
        success: callback
      });
    },
  
    _onError: function _onError() {
      this.set(this.previousAttributes());
    },
  
    sync: function sync() {
      this.trigger('loading', this);
      Backbone.Model.prototype.sync.apply(this, arguments);
    },
  
    parse: function parse(attrs) {
      if (!attrs.__id) {
        attrs.__id = _.uniqueId();
      }
      return attrs;
    },
  
    toJSON: function toJSON() {
      return _.omit(this.attributes, '__id', 'the_geom_webmercator');
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/query-rows-collection.js":
  /*!**********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/query-rows-collection.js ***!
    \**********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var QueryRowModel = __webpack_require__(/*! ./query-row-model */ "./lib/assets/javascripts/builder/data/query-row-model.js");
  var syncAbort = __webpack_require__(/*! ./backbone/sync-abort */ "./lib/assets/javascripts/builder/data/backbone/sync-abort.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var STATUS = __webpack_require__(/*! ./query-base-status */ "./lib/assets/javascripts/builder/data/query-base-status.js");
  
  var MAX_GET_LENGTH = 1024;
  var WRAP_SQL_TEMPLATE = 'select <%= selectedColumns %> from (<%= sql %>) __wrapped';
  var MAX_REPEATED_ERRORS = 3;
  
  module.exports = Backbone.Collection.extend({
    defaults: {
      empty: true
    },
  
    DEFAULT_FETCH_OPTIONS: {
      rows_per_page: 40,
      sort_order: 'asc',
      page: 0
    },
  
    // Due to a problem how Backbone checks if there is a duplicated model
    // or not, we can't create the model with a function + its necessary options
    model: QueryRowModel,
  
    sync: syncAbort,
  
    url: function url() {
      return this._configModel.getSqlApiUrl();
    },
  
    initialize: function initialize(models, opts) {
      opts = opts || {};
  
      this._repeatedErrors = 0;
      this._tableName = opts.tableName;
      this._querySchemaModel = opts.querySchemaModel;
      this._configModel = opts.configModel;
  
      this.statusModel = new Backbone.Model({
        status: STATUS.initial
      });
  
      this._initBinds();
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this._querySchemaModel, 'change:query', this._onQuerySchemaQueryChange);
  
      if (this._querySchemaModel && this._querySchemaModel.columnsCollection) {
        this.listenTo(this._querySchemaModel.columnsCollection, 'reset', this._onColumnsCollectionReset);
      }
  
      this.listenTo(this.statusModel, 'change:status', this._onStatusChanged);
    },
  
    _onColumnsCollectionReset: function _onColumnsCollectionReset() {
      this._onQuerySchemaQueryChange();
  
      if (this.shouldFetch()) {
        this.fetch();
      }
    },
  
    getStatusValue: function getStatusValue() {
      return this.statusModel.get('status');
    },
  
    isInInitialStatus: function isInInitialStatus() {
      return this.getStatusValue() === STATUS.initial;
    },
  
    isFetched: function isFetched() {
      return this.getStatusValue() === STATUS.fetched;
    },
  
    isErrored: function isErrored() {
      return this.getStatusValue() === STATUS.errored;
    },
  
    isFetching: function isFetching() {
      return this.getStatusValue() === STATUS.fetching;
    },
  
    isDone: function isDone() {
      return this.isFetched() || this.isErrored();
    },
  
    isInFinalStatus: function isInFinalStatus() {
      var finalStatuses = [STATUS.unavailable, STATUS.fetched, STATUS.errored];
      return _.contains(finalStatuses, this.getStatusValue());
    },
  
    isUnavailable: function isUnavailable() {
      return this.getStatusValue() === STATUS.unavailable;
    },
  
    canFetch: function canFetch() {
      var hasQuery = !!this._querySchemaModel.get('query');
      var isReady = this._querySchemaModel.get('ready');
      var isFetched = this._querySchemaModel.isFetched();
      var isErrored = this._querySchemaModel.isErrored();
  
      return hasQuery && isReady && isFetched && !isErrored;
    },
  
    shouldFetch: function shouldFetch() {
      return !this.isFetched() && !this.isFetching() && this.canFetch() && !this.isErrored();
    },
  
    resetFetch: function resetFetch() {
      this.statusModel.set('status', STATUS.unfetched);
    },
  
    isEmpty: function isEmpty() {
      throw new Error('QueryRowsCollection.isEmpty() is an async operation. Use `.isEmptyAsync` instead.');
    },
  
    isEmptyAsync: function isEmptyAsync() {
      if (this.isInFinalStatus()) {
        return Promise.resolve(this.size() === 0);
      } else {
        return new Promise(function (resolve) {
          this.listenToOnce(this, 'inFinalStatus', function () {
            resolve(this.size() === 0);
          });
        }.bind(this));
      }
    },
  
    _onStatusChanged: function _onStatusChanged() {
      if (this.isInFinalStatus()) {
        this.trigger('inFinalStatus');
      }
    },
  
    _onQuerySchemaQueryChange: function _onQuerySchemaQueryChange() {
      this.statusModel.set('status', 'unfetched');
      this.reset([], { silent: true });
    },
  
    _geometryColumnSQL: function _geometryColumnSQL(column) {
      /* eslint-disable */
      return ["CASE", "WHEN GeometryType(" + column + ") = 'POINT' THEN", "ST_AsGeoJSON(" + column + ",8)", "WHEN (" + column + " IS NULL) THEN", "NULL", "ELSE", "GeometryType(" + column + ")", "END " + column].join(' ');
      /* eslint-enable */
    },
  
    // return wrapped SQL removing the_geom and the_geom_webmercator
    // to avoid fetching those columns.
    // So for a sql like
    // select * from table the returned value is
    // select column1, column2, column3... from table
    _getWrappedSQL: function _getWrappedSQL(excludeColumns) {
      var self = this;
      var schema = this._querySchemaModel.columnsCollection.toJSON();
  
      var selectedColumns = _.chain(schema).omit(function (item) {
        return _.contains(excludeColumns, item.name);
      }).map(function (item, index) {
        if (item.type === 'geometry') {
          return self._geometryColumnSQL(item.name);
        }
        return '"' + item.name + '"';
      }).value().join(',');
  
      return _.template(WRAP_SQL_TEMPLATE)({
        selectedColumns: selectedColumns,
        sql: this._querySchemaModel.get('query')
      });
    },
  
    _httpMethod: function _httpMethod() {
      return this._querySchemaModel.get('query').length > MAX_GET_LENGTH ? 'POST' : 'GET';
    },
  
    _incrementRepeatedError: function _incrementRepeatedError() {
      this._repeatedErrors++;
    },
  
    _resetRepeatedError: function _resetRepeatedError() {
      this._repeatedErrors = 0;
    },
  
    hasRepeatedErrors: function hasRepeatedErrors() {
      return this._repeatedErrors >= MAX_REPEATED_ERRORS;
    },
  
    fetch: function fetch(opts) {
      opts = opts || {};
  
      var previousStatus = this.getStatusValue();
      this.statusModel.set('status', STATUS.fetching);
  
      var excludeColumns = opts.data && opts.data.exclude || [];
  
      opts = opts || {};
      opts.data = _.extend({}, this.DEFAULT_FETCH_OPTIONS, opts.data && _.omit(opts.data, 'exclude') || {}, {
        api_key: this._configModel.get('api_key'),
        q: this._getWrappedSQL(excludeColumns)
      });
  
      opts.method = this._httpMethod();
      var errorCallback = opts.error;
      opts.error = function (coll, resp) {
        if (previousStatus === STATUS.unavailable) {
          this._incrementRepeatedError();
        }
  
        if (resp && resp.error) {
          this._querySchemaModel.setError(resp.error);
        }
  
        this.trigger('fail', coll, resp);
        this.statusModel.set('status', this.hasRepeatedErrors() ? STATUS.errored : STATUS.unavailable);
        errorCallback && errorCallback(coll, resp);
      }.bind(this);
  
      var successCallback = opts.success;
      opts.success = function (coll, resp, options) {
        if (resp && resp.error) {
          return opts.error.apply(this, arguments);
        }
  
        this._resetRepeatedError();
        this.statusModel.set('status', STATUS.fetched);
        successCallback && successCallback(coll, resp);
      }.bind(this);
  
      // Needed to reset the whole collection when a fetch is done
      opts.reset = true;
  
      return Backbone.Collection.prototype.fetch.call(this, opts);
    },
  
    parse: function parse(r) {
      return this._parseWithID(r.rows);
    },
  
    reset: function reset(result, opts) {
      var items = [];
  
      if (result && result.rows) {
        // If reset comes from a fetch, we need to parse the rows
        items = result.rows;
      } else {
        // If it comes directly from a simple reset function
        items = result;
      }
  
      Backbone.Collection.prototype.reset.apply(this, [this._parseWithID(items)]);
    },
  
    _parseWithID: function _parseWithID(array) {
      return _.map(array, function (attrs) {
        attrs.__id = _.uniqueId();
        return attrs;
      });
    },
  
    addRow: function addRow(opts) {
      opts = opts || {};
      this.create({
        __id: _.uniqueId()
      }, _.extend(opts, {
        wait: true,
        parse: true
      }));
    },
  
    setTableName: function setTableName(name) {
      if (!name) return;
  
      if (this._tableName) {
        this._tableName = name;
  
        this.each(function (rowModel) {
          rowModel._tableName = name;
        });
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/query-schema-model.js":
  /*!*******************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/query-schema-model.js ***!
    \*******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var BaseModel = __webpack_require__(/*! ./query-base-model */ "./lib/assets/javascripts/builder/data/query-base-model.js");
  var QueryRowsCollection = __webpack_require__(/*! ./query-rows-collection */ "./lib/assets/javascripts/builder/data/query-rows-collection.js");
  var SQLUtils = __webpack_require__(/*! builder/helpers/sql-utils */ "./lib/assets/javascripts/builder/helpers/sql-utils.js");
  var STATUS = __webpack_require__(/*! ./query-base-status */ "./lib/assets/javascripts/builder/data/query-base-status.js");
  
  var DEFAULT_TABLE_QUERY_TEMPLATE = _.template('SELECT * FROM <%= tableName %>');
  var WRAPPED_SQL_QUERY_TEMPLATE = _.template('SELECT * FROM (<%= sql %>) __wrapped');
  
  /**
   * Model to represent a schema of a SQL query.
   */
  module.exports = BaseModel.extend({
  
    defaults: {
      query: '',
      sort_order: 'asc',
      rows_per_page: 0,
      page: 0,
      status: STATUS.initial,
      ready: false // until true there's no data available on the table(s) used in the query
    },
  
    initialize: function initialize(attrs, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
      BaseModel.prototype.initialize.call(this, attrs, opts);
  
      this._configModel = opts.configModel;
      this.columnsCollection = new Backbone.Collection([]);
      this.rowsCollection = new QueryRowsCollection([]);
  
      if (this.get('status') === STATUS.initial) {
        this._setStatusPerQueryValue();
      }
  
      this._addChangeListener();
    },
  
    url: function url() {
      return this._configModel.getSqlApiUrl();
    },
  
    fetch: function fetch(opts) {
      if (!this.canFetch()) return;
  
      this.set('status', STATUS.fetching);
  
      opts = opts || {};
      opts.errorCallback = opts && (opts.originalError || opts.error);
      var successCallback = opts && (opts.success || opts.complete);
  
      opts.data = _.extend(opts.data || {}, {
        sort_order: this.get('sort_order'),
        rows_per_page: this.get('rows_per_page'),
        page: this.get('page'),
        api_key: this._configModel.get('api_key'),
        q: this._getSqlApiQueryParam()
      });
  
      opts.method = this._httpMethod();
  
      opts.success = function (model, response) {
        this._resetRepeatedError();
        successCallback && successCallback(response);
      }.bind(this);
  
      opts.error = function (model, response) {
        if (response && response.statusText !== 'abort') {
          var error = response.responseText ? JSON.parse(response.responseText).error : [];
  
          this._incrementRepeatedError();
  
          this.set({
            query_errors: error,
            status: this.hasRepeatedErrors() ? STATUS.errored : STATUS.unavailable
          });
  
          opts.errorCallback && opts.errorCallback({
            status: response.status || 'Unknown',
            error: error
          });
        }
      }.bind(this);
  
      return Backbone.Model.prototype.fetch.call(this, opts);
    },
  
    parse: function parse(r) {
      this.rowsCollection.reset(r.rows);
  
      this.columnsCollection.reset(_.map(r.fields, function (d, name) {
        return {
          name: name,
          type: d.type
        };
      }));
  
      return { status: STATUS.fetched };
    },
  
    hasDefaultQueryFor: function hasDefaultQueryFor(tableName) {
      if (!this.hasQuery()) {
        return false;
      }
      var defaultQueryForTableName = DEFAULT_TABLE_QUERY_TEMPLATE({ tableName: tableName });
      return SQLUtils.isSameQuery(this.get('query'), defaultQueryForTableName);
    },
  
    getColumnNames: function getColumnNames() {
      return this.columnsCollection.pluck('name');
    },
  
    getColumnType: function getColumnType(columnName) {
      return this.isFetched() ? this.columnsCollection.findWhere({ name: columnName }).get('type') : undefined;
    },
  
    _onChange: function _onChange() {
      this._removeChangeListener();
  
      if (!this.hasChanged('status') && this.get('status') === STATUS.fetching) {
        this.fetch(); // If is already fetching just redo the fetch with latest attrs
      } else {
        if (this.hasChanged('query')) {
          this.columnsCollection.reset();
          this._setStatusPerQueryValue();
        }
      }
  
      this._addChangeListener();
    },
  
    _setStatusPerQueryValue: function _setStatusPerQueryValue() {
      this.set('status', this.get('query') ? STATUS.unfetched : STATUS.unavailable, { silent: true });
    },
  
    setError: function setError(error) {
      var queryErrors = this.get('query_errors');
      if (queryErrors && queryErrors.length) {
        return;
      }
  
      this._incrementRepeatedError();
  
      this.set({
        query_errors: error,
        status: this.hasRepeatedErrors() ? STATUS.errored : STATUS.unavailable
      });
    },
  
    // Basically checks if an schema is different than the current one
    hasDifferentSchemaThan: function hasDifferentSchemaThan(schemaArray) {
      return !_.every(schemaArray, function (columnObj) {
        var columnModel = this.columnsCollection.findWhere({ name: columnObj.name });
        return columnModel && (columnModel.get('type') === columnObj.type || columnObj.type == null);
      }, this);
    },
  
    resetDueToAlteredData: function resetDueToAlteredData() {
      this.set('status', STATUS.unfetched);
      this.trigger('resetDueToAlteredData');
      this.fetch();
    },
  
    _getSqlApiQueryParam: function _getSqlApiQueryParam() {
      return WRAPPED_SQL_QUERY_TEMPLATE({
        sql: this.get('query')
      });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/static-asset-model.js":
  /*!*******************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/static-asset-model.js ***!
    \*******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var AssetModel = __webpack_require__(/*! ./asset-model */ "./lib/assets/javascripts/builder/data/asset-model.js");
  
  module.exports = AssetModel.extend({
  
    defaults: {
      ext: 'svg',
      folder: 'maki-icons',
      host: 'https://s3.amazonaws.com',
      bucket: 'com.cartodb.users-assets.production',
      kind: 'marker',
      name: '',
      public_url: '',
      size: '18',
      state: 'idle'
    },
  
    getURLFor: function getURLFor(name) {
      var url = this.get('host') + '/' + this.get('bucket') + '/' + this.get('folder') + '/' + name;
      var size = this.get('size') ? '-' + this.get('size') : '';
      return url + size + '.' + this.get('ext');
    },
  
    toJSON: function toJSON() {
      var attributes = _.clone(this.attributes);
  
      attributes['public_url'] = this.getURLFor(attributes['icon']);
      return attributes;
    },
  
    get: function get(attributeName) {
      var attribute = this.attributes[attributeName];
  
      if (attributeName === 'public_url') {
        attribute = this.getURLFor(this.attributes['icon']);
      }
  
      return attribute;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/static-assets-collection.js":
  /*!*************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/static-assets-collection.js ***!
    \*************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var StaticAssetModel = __webpack_require__(/*! ./static-asset-model */ "./lib/assets/javascripts/builder/data/static-asset-model.js");
  var AssetsCollection = __webpack_require__(/*! ./assets-collection */ "./lib/assets/javascripts/builder/data/assets-collection.js");
  
  module.exports = AssetsCollection.extend({
    model: StaticAssetModel,
  
    url: function url() {
      return '';
    },
  
    initialize: function initialize(models, opts) {},
  
    parse: function parse(resp, xhr) {
      return [];
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/synchronization-model.js":
  /*!**********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/synchronization-model.js ***!
    \**********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var MULTIPLIER = 1.2; // Multiply current interval for this number
  var INTERVAL = 1500; // Interval time between poll checkings
  var SYNC_GAP = 900000; // Gap (in ms) necessary to perform next synchronization
  var POLLING_GAP = 15000; // Gap (in seconds) necessary to start polling and checking synchronization
  
  /**
   *  Synced table model
   */
  
  module.exports = Backbone.Model.extend({
    defaults: {
      name: '',
      url: '',
      state: '',
      run_at: 0,
      ran_at: 0,
      retried_times: 0,
      interval: 0,
      error_code: 0,
      error_message: '',
      service_name: '',
      service_item_id: '',
      content_guessing: true,
      type_guessing: true
    },
  
    urlRoot: function urlRoot() {
      var version = this._configModel.urlVersion('synchronizations');
      var baseUrl = this._configModel.get('base_url');
      return baseUrl + '/api/' + version + '/synchronizations/';
    },
  
    initialize: function initialize(attrs, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
      this._configModel = opts.configModel;
  
      this.bind('destroy', function () {
        this.unset('id');
      });
  
      this._checkState();
  
      this.bind('change:error_code change:error_message change:state', this._checkState, this);
    },
  
    toJSON: function toJSON() {
      var c = _.clone(this.attributes);
  
      var d = {
        url: c.url,
        interval: c.interval,
        content_guessing: c.content_guessing,
        type_guessing: c.type_guessing,
        create_vis: c.create_vis
      };
  
      if (c.type === 'remote') {
        _.extend(d, {
          remote_visualization_id: c.remote_visualization_id,
          create_vis: false,
          value: c.value
        });
      }
  
      if (c.id !== undefined) {
        d.id = c.id;
      }
  
      // Comes from a service?
      if (c.service_name) {
        d.service_name = c.service_name;
        d.service_item_id = c.service_item_id;
      }
  
      return d;
    },
  
    _checkState: function _checkState() {
      if (this.get('error_code') || this.get('error_message')) {
        this.set('state', 'failure');
      }
    },
  
    syncNow: function syncNow(callback) {
      if (!callback) throw new Error('callback is required');
  
      $.ajax({
        url: this.url() + '/sync_now',
        type: 'PUT'
      }).always(callback);
    },
  
    // Checks for poll to finish
    pollCheck: function pollCheck(i) {
      var self = this;
      var interval = INTERVAL;
  
      this.pollTimer = setInterval(request, interval);
  
      function request() {
        self.destroyCheck();
  
        self.fetch({
          error: function error(m, e) {
            self.set({
              error_message: e.statusText || '',
              state: 'failure'
            });
          }
        });
  
        interval = interval * MULTIPLIER;
  
        self.pollTimer = setInterval(request, interval);
      }
    },
  
    destroyCheck: function destroyCheck() {
      clearInterval(this.pollTimer);
    },
  
    isSync: function isSync() {
      return !this.isNew() && this.get('interval') > 0;
    },
  
    isSyncing: function isSyncing() {
      return this.get('state') === 'syncing' || this.get('state') === 'queued';
    },
  
    canSyncNow: function canSyncNow() {
      var ranAt = new Date(this.get('ran_at'));
      var now = new Date();
      var gap = SYNC_GAP; // Importer needs some time to perform the next sync, set 15 min as default.
  
      if (this.isSyncing()) {
        return false;
      }
  
      return now.getTime() - ranAt.getTime() > gap;
    },
  
    linkToTable: function linkToTable(tableModel) {
      var self = this;
      if (tableModel.has('synchronization')) {
        this.set(tableModel.get('synchronization'));
      }
  
      tableModel.bind('change:synchronization', function () {
        self.set(tableModel.get('synchronization'));
      }, tableModel);
  
      tableModel.bind('destroy', function destroy() {
        self.unbind(null, null, tableModel);
        self.destroy();
      }, tableModel);
    }
  }, {
    SYNC_GAP: SYNC_GAP,
    POLLING_GAP: POLLING_GAP
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/table-columns-collection.js":
  /*!*************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/table-columns-collection.js ***!
    \*************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var ColumnModel = __webpack_require__(/*! ./column-model */ "./lib/assets/javascripts/builder/data/column-model.js");
  
  /**
   * A collection of table columns
   */
  module.exports = Backbone.Collection.extend({
  
    model: ColumnModel,
  
    initialize: function initialize(models, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
      if (!opts.tableModel) throw new Error('tableModel is required');
  
      this._configModel = opts.configModel;
      this._tableModel = opts.tableModel;
    },
  
    url: function url() {
      var baseUrl = this._configModel.get('base_url');
      var version = this._configModel.urlVersion('column');
      return baseUrl + '/api/' + version + '/tables/' + this._tableModel.get('name') + '/columns';
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/table-model.js":
  /*!************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/table-model.js ***!
    \************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var TableColumnsCollection = __webpack_require__(/*! ./table-columns-collection */ "./lib/assets/javascripts/builder/data/table-columns-collection.js");
  var getSimpleGeometryType = __webpack_require__(/*! ./get-simple-geometry-type */ "./lib/assets/javascripts/builder/data/get-simple-geometry-type.js");
  var PermissionModel = __webpack_require__(/*! ./permission-model */ "./lib/assets/javascripts/builder/data/permission-model.js");
  var SyncModel = __webpack_require__(/*! ./synchronization-model */ "./lib/assets/javascripts/builder/data/synchronization-model.js");
  var TableNameUtils = __webpack_require__(/*! builder/helpers/table-name-utils */ "./lib/assets/javascripts/builder/helpers/table-name-utils.js");
  
  /**
   * Model representing a table.
   */
  module.exports = Backbone.Model.extend({
  
    idAttribute: 'name',
  
    defaults: {
      // always not fetched to begin with, since the only way to currently get table data is by an individual request
      fetched: false,
      schema: []
    },
  
    initialize: function initialize(attrs, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
  
      this._configModel = opts.configModel;
    },
  
    urlRoot: function urlRoot() {
      var baseUrl = this._configModel.get('base_url');
      var version = this._configModel.urlVersion('table');
      return baseUrl + '/api/' + version + '/tables';
    },
  
    parse: function parse(r, opts) {
      var configModel = opts && opts.configModel || this._configModel;
  
      // "Sometimes" table presenter returns the needed data within table_visualization
      // attribute, because it returns the canonical visualization data. So we have to take
      // the data from there.
      if (r.table_visualization && !_.isEmpty(r.table_visualization)) {
        r = _.extend({}, r.table_visualization, {
          geometry_types: r.geometry_types
        });
      }
  
      if (r.synchronization) {
        if (!this._syncModel) {
          this._syncModel = new SyncModel(r.synchronization, {
            configModel: configModel
          });
        } else {
          this._syncModel.set(r.synchronization);
        }
      }
  
      if (r.permission) {
        if (!this._permissionModel) {
          this._permissionModel = new PermissionModel(r.permission, {
            configModel: configModel
          });
        } else {
          this._permissionModel.set(r.permission);
        }
      }
  
      var attrs = _.defaults({
        fetched: true
      }, r);
  
      var columnsAttrs = _.map(r.schema, function (d) {
        return {
          name: d[0],
          type: d[1]
        };
      }, this);
  
      if (!this.columnsCollection) {
        this.columnsCollection = new TableColumnsCollection(columnsAttrs, {
          configModel: configModel,
          tableModel: this
        });
      } else {
        this.columnsCollection.reset(columnsAttrs);
      }
  
      return attrs;
    },
  
    isOwner: function isOwner(userModel) {
      if (!userModel || !this._permissionModel) {
        return false;
      }
      return this._permissionModel.isOwner(userModel);
    },
  
    getUnqualifiedName: function getUnqualifiedName() {
      return TableNameUtils.getUnqualifiedName(this.get('name'));
    },
  
    getOwnerName: function getOwnerName() {
      var name = this.get('name');
      if (!name) return null;
      var tk = name.split('.');
      if (tk.length === 2) {
        return tk[0].replace(/"/g, '');
      } else if (this._permissionModel) {
        var ownerModel = this._permissionModel.getOwner();
        return ownerModel.get('username');
      } else {
        return '';
      }
    },
  
    // "user".table -> user.table
    getUnquotedName: function getUnquotedName() {
      var name = this.get('name');
      return name && name.replace(/"/g, '');
    },
  
    getGeometryType: function getGeometryType() {
      var types = this.get('geometry_types');
      var geomTypes = [];
      if (!_.isArray(types)) {
        return [];
      }
  
      for (var t in types) {
        var type = types[t];
        // when there are rows with no geo type null is returned as geotype
        if (type) {
          var a = getSimpleGeometryType(type.toLowerCase());
          if (a) {
            geomTypes.push(a);
          }
        }
      }
  
      return _.uniq(geomTypes);
    },
  
    getPermissionModel: function getPermissionModel() {
      return this._permissionModel;
    },
  
    isReadOnly: function isReadOnly(userModel) {
      return this.isSync() || !this.hasWriteAccess(userModel);
    },
  
    isSync: function isSync() {
      var syncModel = this.getSyncModel();
      var isSync = syncModel && syncModel.get('id');
  
      return !!isSync;
    },
  
    hasWriteAccess: function hasWriteAccess(userModel) {
      if (!userModel || !this._permissionModel) {
        return false;
      }
      return this._permissionModel.hasWriteAccess(userModel);
    },
  
    getSyncModel: function getSyncModel() {
      return this._syncModel;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/undo-manager.js":
  /*!*************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/undo-manager.js ***!
    \*************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var BackboneUndo = __webpack_require__(/*! backbone-undo */ "./node_modules/backbone-undo/Backbone.Undo.js");
  var MAXIMUM_STACK_LENGTH = 30;
  
  module.exports = {
    init: function init(model, opts) {
      if (!model) throw new Error('model is required to initialize undoManager');
  
      opts = opts || {};
      this.model = model;
  
      this.model._undoManager = this.undoManager = new BackboneUndo({
        maximumStackLength: opts.maximumStackLength || MAXIMUM_STACK_LENGTH,
        register: this.model,
        track: opts.track
      });
  
      this._trackEvents();
      this._addMethods();
  
      if (!_.isEmpty(opts.history)) {
        opts.track && this.undoManager.stopTracking();
        this._addHistory(opts.history);
        opts.track && this.undoManager.startTracking();
      }
    },
  
    _trackEvents: function _trackEvents() {
      _.each(['undo', 'redo'], function (eventType) {
        this.undoManager.bind(eventType, function () {
          this.trigger(eventType, this.changed, this);
        }, this.model);
      }, this);
  
      this.undoManager.stack.bind('add remove reset', function () {
        this.trigger('unredoChanged', this.changed, this);
      }, this.model);
    },
  
    _addHistory: function _addHistory(history) {
      var stack = this.undoManager.stack;
  
      _.each(history, function (attrs, i) {
        if (history[i + 1]) {
          stack.add({
            after: history[i + 1],
            before: attrs,
            type: 'change',
            undoTypes: this.undoManager.undoTypes,
            object: this.model,
            magicFusionIndex: 0
          });
        }
      }, this);
  
      stack.pointer = stack.length - 1;
    },
  
    _addMethods: function _addMethods() {
      _.extend(this.model, {
        undo: function undo() {
          this._undoManager.undo();
        },
  
        redo: function redo() {
          this._undoManager.redo();
        },
  
        canUndo: function canUndo() {
          return this._undoManager.isAvailable('undo');
        },
  
        canRedo: function canRedo() {
          return this._undoManager.isAvailable('redo');
        },
  
        getUndoHistory: function getUndoHistory() {
          var list = this._undoManager.stack.toJSON();
          var data = _.reduce(list, function (memo, attrs, i) {
            memo.push(attrs.before);
            return memo;
          }, [], this);
          data.push(this.attributes);
          return data;
        }
      });
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/upload-model.js":
  /*!*************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/upload-model.js ***!
    \*************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var UploadConfig = __webpack_require__(/*! builder/config/upload-config */ "./lib/assets/javascripts/builder/config/upload-config.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils.js */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  __webpack_require__(/*! backbone-model-file-upload */ "./node_modules/backbone-model-file-upload/backbone-model-file-upload.js");
  
  /**
   * Model that allows uploading files to CartoDB endpoints.
   *
   * NOTE: this model extends Backbone.Model instead of Backbone.Model, because
   * it's required for the vendor/backbone-model-file-upload.
   */
  module.exports = Backbone.Model.extend({
    url: function url() {
      var baseUrl = this._configModel.get('base_url');
      return baseUrl + '/api/v1/imports';
    },
  
    fileAttribute: 'filename',
  
    defaults: {
      type: '',
      value: '',
      interval: 0,
      privacy: '',
      progress: 0,
      state: 'idle',
      service_item_id: '',
      service_name: '',
      option: '',
      content_guessing: true,
      type_guessing: true,
      create_vis: true
    },
  
    initialize: function initialize(attrs, opts) {
      if (!opts.userModel) throw new Error('userModel is required');
      if (!opts.configModel) throw new Error('configModel is required');
  
      this._userModel = opts.userModel;
      this._configModel = opts.configModel;
      this._initBinds();
      // We need to validate entry attributes
      this._validate(this.attributes, { validate: true });
    },
  
    setUpload: function setUpload(d) {
      this.set(d, {
        validate: true
      });
    },
  
    isValidToUpload: function isValidToUpload() {
      return this.get('value') && this.get('state') !== 'error';
    },
  
    setFresh: function setFresh(d) {
      if (d && !_.isEmpty(d)) {
        // Set upload properties except create_vis (defined when created)
        this.set(_.omit(d, 'create_vis'));
      } else {
        this.clear();
      }
    },
  
    _initBinds: function _initBinds() {
      this.bind('progress', function (progress) {
        this.set({
          progress: progress * 100,
          state: 'uploading'
        });
      }, this);
  
      this.bind('change:value', function () {
        if (this.get('state') === 'error') {
          this.set({ state: 'idle' });
          this.unset('get_error_text', { silent: true });
        }
      }, this);
  
      this.bind('error invalid', function (m, d) {
        this.set({
          state: 'error',
          error_code: d && d.error_code || '',
          get_error_text: {
            title: _t('data.upload-model.invalid-import'),
            what_about: d && d.msg || ''
          }
        });
      }, this);
    },
  
    validate: function validate(attrs) {
      if (!attrs) return;
  
      if (attrs.type === 'file') {
        // Number of files
        if (attrs.value && attrs.value.length) {
          return {
            msg: _t('data.upload-model.one-file')
          };
        }
  
        // File name
        var name = attrs.value.name;
        if (!name) {
          return {
            msg: _t('data.upload-model.file-defined')
          };
        }
  
        // File extension
        var ext = name.substr(name.lastIndexOf('.') + 1);
        if (ext) {
          ext = ext.toLowerCase();
        }
        if (!_.contains(UploadConfig.fileExtensions, ext)) {
          return {
            msg: _t('data.upload-model.file-extension')
          };
        }
        // File size
        if (this._userModel.get('remaining_byte_quota') * UploadConfig.fileTimesBigger < attrs.value.size) {
          return {
            msg: _t('data.upload-model.file-size'),
            error_code: 8001
          };
        }
      }
  
      if (attrs.type === 'remote') {
        // Valid remote visualization id?
        if (!attrs.remote_visualization_id) {
          return {
            msg: _t('data.upload-model.visualization-id')
          };
        }
        // Remote size?
        if (attrs.size && this._userModel.get('remaining_byte_quota') * UploadConfig.fileTimesBigger < attrs.size) {
          return {
            msg: _t('data.upload-model.remote-file-size'),
            error_code: 8001
          };
        }
      }
  
      if (attrs.type === 'url') {
        // Valid URL?
        if (!Utils.isURL(attrs.value)) {
          return {
            msg: _t('data.upload-model.url-invalid')
          };
        }
      }
  
      if (attrs.type === 'sql') {
        if (!attrs.value) {
          return {
            msg: _t('data.upload-model.query-undefined')
          };
        }
      }
  
      if (attrs.type === 'duplication') {
        if (!attrs.value) {
          return {
            msg: _t('data.upload-model.dataset-copy-undefined')
          };
        }
      }
  
      if (attrs.type === 'service' && attrs.service_name === 'twitter_search') {
        var service_item_id = attrs.service_item_id;
  
        // Empty?
        if (!service_item_id || _.isEmpty(service_item_id)) {
          return {
            msg: _t('data.upload-model.twitter-data')
          };
        }
  
        // Categories?
        if (_.isEmpty(service_item_id.categories)) {
          return {
            msg: _t('data.upload-model.twitter-categories-invalid')
          };
        }
  
        // Dates?
        var dates = service_item_id.dates;
        if (!dates || _.isEmpty(dates)) {
          return {
            msg: _t('data.upload-model.twitter-dates-empty')
          };
        }
        var isToDateValid = moment(dates.fromDate) <= moment(new Date());
        if (!dates.fromDate || !dates.toDate || !isToDateValid) {
          return {
            msg: _t('data.upload-model.twitter-dates-invalid')
          };
        }
      }
    },
  
    isValid: function isValid() {
      return this.get('value') && this.get('state') !== 'error';
    },
  
    upload: function upload() {
      if (this.get('type') === 'file') {
        var self = this;
        this.xhr = this.save({
          filename: this.get('value')
        }, {
          success: function success(m) {
            m.set('state', 'uploaded');
          },
          error: function error(m, msg) {
            var message = _t('data.upload-model.connection-error');
  
            if (msg && msg.status === 429) {
              var response = JSON.parse(msg.responseText);
              message = response.errors.imports;
            }
  
            self.set({
              state: 'error',
              get_error_text: {
                title: _t('data.upload-model.error-happened'),
                what_about: message
              }
            });
          },
          complete: function complete() {
            delete self.xhr;
          }
        });
      }
    },
  
    stopUpload: function stopUpload() {
      if (this.xhr) this.xhr.abort();
    },
  
    setGuessing: function setGuessing(val) {
      this.set({
        type_guessing: val,
        content_guessing: val
      });
    },
  
    setPrivacy: function setPrivacy(val) {
      this.set('privacy', val);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/user-groups-collection.js":
  /*!***********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/user-groups-collection.js ***!
    \***********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var GroupModel = __webpack_require__(/*! ./group-model */ "./lib/assets/javascripts/builder/data/group-model.js");
  
  /**
   * Collection of a User's groups.
   */
  module.exports = Backbone.Collection.extend({
    model: GroupModel,
  
    initialize: function initialize(models, opts) {
      this.organization = opts.organization;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/user-model.js":
  /*!***********************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/user-model.js ***!
    \***********************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var OrganizationModel = __webpack_require__(/*! ./organization-model */ "./lib/assets/javascripts/builder/data/organization-model.js");
  var UserGroups = __webpack_require__(/*! ./user-groups-collection */ "./lib/assets/javascripts/builder/data/user-groups-collection.js");
  var CustomBaselayersCollection = __webpack_require__(/*! ./custom-baselayers-collection */ "./lib/assets/javascripts/builder/data/custom-baselayers-collection.js");
  /**
   *  User model
   *
   */
  
  var UserModel = Backbone.Model.extend({
    urlRoot: function urlRoot() {
      var baseUrl = this._configModel.get('base_url');
      return baseUrl + '/api/v1/users';
    },
  
    defaults: {
      avatar_url: 'http://cartodb.s3.amazonaws.com/static/public_dashboard_default_avatar.png',
      username: '',
      email: ''
    },
  
    initialize: function initialize(attrs, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
      this._configModel = opts.configModel;
      attrs = attrs || {};
  
      if (!_.isEmpty(this.get('organization'))) {
        this._organizationModel = new OrganizationModel(this.get('organization'), {
          configModel: this._configModel,
          currentUserId: this.id
        });
      }
  
      if (this.get('layers')) {
        this.layers = new CustomBaselayersCollection(this.get('layers'), {
          configModel: this._configModel,
          currentUserId: this.id
        });
      }
  
      this.groups = new UserGroups(attrs.groups, {
        organization: this._organizationModel
      });
    },
  
    isViewer: function isViewer() {
      return this.get('viewer') === true;
    },
  
    isBuilder: function isBuilder() {
      return !this.isViewer();
    },
  
    canCreateDatasets: function canCreateDatasets() {
      if (this.hasRemainingByteQuota() && this.hasRemainingTableCount()) {
        return true;
      }
      return false;
    },
  
    hasRemainingByteQuota: function hasRemainingByteQuota() {
      return !(!this.get('remaining_byte_quota') || this.get('remaining_byte_quota') <= 0);
    },
  
    isIndividualUser: function isIndividualUser() {
      var proUsers = ['Individual', 'Annual Individual'];
      return proUsers.indexOf(this.get('account_type')) > -1;
    },
  
    hasRemainingTableCount: function hasRemainingTableCount() {
      if (this.isIndividualUser()) {
        return !(!this.get('table_count') || this.get('table_count') >= this.get('table_quota'));
      }
      return true;
    },
  
    updateTableCount: function updateTableCount() {
      var currentTableCount = this.get('table_count');
      if (currentTableCount) {
        this.set('table_count', currentTableCount + 1);
      }
    },
  
    hasCreateMapsFeature: function hasCreateMapsFeature() {
      return this.isBuilder();
    },
  
    hasRemainingPublicMaps: function hasRemainingPublicMaps() {
      if (this.isIndividualUser()) {
        return this.get('public_map_quota') > this.getTotalPublicMapsCount();
      }
      return true;
    },
  
    getTotalPublicMapsCount: function getTotalPublicMapsCount() {
      var totalPublicPrivacyMapsCount = this.get('public_privacy_map_count') || 0;
      var totalPasswordPrivacyMapsCount = this.get('password_privacy_map_count') || 0;
      var totalLinkPrivacyMapsCount = this.get('link_privacy_map_count') || 0;
  
      return totalPublicPrivacyMapsCount + totalPasswordPrivacyMapsCount + totalLinkPrivacyMapsCount;
    },
  
    canCreateTwitterDataset: function canCreateTwitterDataset() {
      var twitter = this.get('twitter');
      return !(twitter.quota - twitter.monthly_use) <= 0 && twitter.hard_limit;
    },
  
    hasOwnTwitterCredentials: function hasOwnTwitterCredentials() {
      var twitter = this.get('twitter');
      return twitter && twitter.customized_config || false;
    },
  
    canSelectPremiumOptions: function canSelectPremiumOptions(visModel) {
      return this.get('actions')[visModel.isVisualization() ? 'private_maps' : 'private_tables'];
    },
  
    canStartTrial: function canStartTrial() {
      return !this.isInsideOrg() && this.get('account_type') === 'FREE' && this.get('table_count') > 0;
    },
  
    isActionEnabled: function isActionEnabled(action) {
      return this.get('actions') && this.get('actions')[action];
    },
  
    canCreatePrivateDatasets: function canCreatePrivateDatasets() {
      var actions = this.get('actions');
      return actions && actions.private_tables;
    },
  
    isInsideOrg: function isInsideOrg() {
      if (this._organizationModel) {
        return !!this._organizationModel.id || this.isOrgOwner();
      }
      return false;
    },
  
    isOrgOwner: function isOrgOwner() {
      if (this._organizationModel) {
        return this._organizationModel.getOwnerId() === this.get('id');
      }
      return false;
    },
  
    isOrgAdmin: function isOrgAdmin() {
      if (this._organizationModel) {
        return this._organizationModel.isOrgAdmin(this);
      }
      return false;
    },
  
    hasAccountType: function hasAccountType(accountType) {
      return this.get('account_type') === accountType;
    },
  
    featureEnabled: function featureEnabled(name) {
      var featureFlags = this.get('feature_flags');
      if (!featureFlags || featureFlags.length === 0 || !name) {
        return false;
      }
      return _.contains(featureFlags, name);
    },
  
    upgradeContactEmail: function upgradeContactEmail() {
      if (this.isInsideOrg()) {
        if (this.isOrgOwner()) {
          return 'enterprise-support@carto.com';
        } else {
          return this._organizationModel.getOwnerEmail();
        }
      } else {
        return 'support@carto.com';
      }
    },
  
    nameOrUsername: function nameOrUsername() {
      return this.fullName() || this.get('username');
    },
  
    fullName: function fullName() {
      var name = this.get('name') || '';
      var lastName = this.get('last_name') || '';
      if (name || lastName) {
        return name + (name && lastName ? ' ' : '') + lastName;
      }
      return '';
    },
  
    getMaxConcurrentImports: function getMaxConcurrentImports() {
      return this.get('limits') && this.get('limits').concurrent_imports || 1;
    },
  
    getSchemaName: function getSchemaName() {
      return this.isInsideOrg() ? this.get('username') : 'public';
    },
  
    renderData: function renderData(currentUser) {
      var name = this.get('username');
      if (currentUser && currentUser.id === this.id) {
        name = _t('user.you');
      }
      return {
        username: name,
        avatar_url: this.get('avatar_url')
      };
    },
  
    clone: function clone() {
      var attrs = _.clone(this.attributes);
      delete attrs.id;
      return new UserModel(attrs, {
        configModel: this._configModel
      });
    },
  
    getOrganization: function getOrganization() {
      return this._organizationModel;
    }
  });
  
  module.exports = UserModel;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/users-group-collection.js":
  /*!***********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/users-group-collection.js ***!
    \***********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var syncAbort = __webpack_require__(/*! ./backbone/sync-abort */ "./lib/assets/javascripts/builder/data/backbone/sync-abort.js");
  
  /**
   * A collection representing a set of users in a group.
   */
  module.exports = Backbone.Collection.extend({
  
    sync: syncAbort,
  
    initialize: function initialize(models, opts) {
      if (!opts.group) throw new Error('group is required');
      this.group = opts.group;
      this.configModel = opts.configModel;
      this.organization = opts.organization;
    },
  
    url: function url(method) {
      var baseUrl = this.configModel.get('base_url');
      var version = this.configModel.urlVersion('organizationGroups', method);
      return baseUrl + '/api/' + version + '/organization/' + this.organization.id + '/groups/' + this.group.id + '/users';
    },
  
    parse: function parse(response) {
      this.total_entries = response.total_entries;
      this.total_user_entries = response.total_user_entries;
  
      return response.users;
    },
  
    totalCount: function totalCount() {
      return this.total_user_entries;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/users-group-fetcher.js":
  /*!********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/users-group-fetcher.js ***!
    \********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var UsersGroup = __webpack_require__(/*! ./users-group-collection */ "./lib/assets/javascripts/builder/data/users-group-collection.js");
  
  // This module fetch the user for every group present
  // in the ACL permission collection. The vizjson doesn't
  // provide and we need it for the sharing stats in the header.
  
  module.exports = {
    track: function track(opts) {
      this.acl = opts.acl;
      this.configModel = opts.configModel;
      this.userModel = opts.userModel;
  
      this.acl.on('reset', this.fetchUsers, this);
      this.fetchUsers();
    },
  
    fetchUsers: function fetchUsers() {
      var self = this;
      var promises = [];
  
      promises = _.map(this.acl.where({ type: 'group' }), function (group) {
        var entity = group.get('entity');
        var deferred = new $.Deferred();
  
        if (!entity.users || entity.users.length === 0) {
          entity.users = new UsersGroup([], {
            group: entity,
            configModel: self.configModel,
            organization: self.userModel.getOrganization()
          });
  
          entity.users.fetch({
            success: function success() {
              deferred.resolve();
            }
          });
        } else {
          deferred.resolve();
        }
  
        return deferred.promise();
      }, this);
  
      $.when.apply($, promises).done(function () {
        self.acl.trigger('fetch');
      });
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/vis-definition-model.js":
  /*!*********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/vis-definition-model.js ***!
    \*********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var PermissionModel = __webpack_require__(/*! ./permission-model */ "./lib/assets/javascripts/builder/data/permission-model.js");
  
  /**
   * Model that represents a visualization (v3)
   *
   * Even though a table might be represented as a Visualization in some cases, please use TableModel if you want to work
   * with the table data instead of adding table-specific methods here.
   */
  
  var PRIVACY_OPTIONS = {
    public: 'PUBLIC',
    link: 'LINK',
    private: 'PRIVATE',
    password: 'PASSWORD'
  };
  
  module.exports = Backbone.Model.extend({
    defaults: {
      visChanges: 0
    },
  
    initialize: function initialize(attrs, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
  
      this._configModel = opts.configModel;
  
      if (this.get('permission')) {
        this._permissionModel = new PermissionModel(this.get('permission'), {
          configModel: opts.configModel
        });
        this.unset('permission');
      }
    },
  
    urlRoot: function urlRoot() {
      var baseUrl = this._configModel.get('base_url');
      var version = this._configModel.urlVersion('visualization');
      return baseUrl + '/api/' + version + '/viz';
    },
  
    mapcapsURL: function mapcapsURL() {
      var baseUrl = this._configModel.get('base_url');
      return baseUrl + '/api/v3/viz/' + this.id + '/mapcaps';
    },
  
    embedURL: function embedURL() {
      var baseUrl = this._configModel.get('base_url');
      return baseUrl + '/builder/' + this.id + '/embed';
    },
  
    builderURL: function builderURL() {
      var baseUrl = this._configModel.get('base_url');
      return baseUrl + '/builder/' + this.id + '/';
    },
  
    vizjsonURL: function vizjsonURL() {
      var baseUrl = this._configModel.get('base_url');
      var version = this._configModel.urlVersion('vizjson', 'read', 'v3');
      return baseUrl + '/api/' + version + '/viz/' + this.id + '/viz.json';
    },
  
    stateURL: function stateURL() {
      var baseUrl = this._configModel.get('base_url');
      return baseUrl + '/api/v3/viz/' + this.id + '/state';
    },
  
    isVisualization: function isVisualization() {
      return this.get('type') === 'derived';
    },
  
    privacyOptions: function privacyOptions() {
      return _.values(PRIVACY_OPTIONS);
    },
  
    recordChange: function recordChange() {
      var visChanges = this.get('visChanges');
      this.set('visChanges', visChanges + 1);
    },
  
    resetChanges: function resetChanges() {
      this.set('visChanges', 0);
    },
  
    getPermissionModel: function getPermissionModel() {
      return this._permissionModel;
    }
  }, {
    isPubliclyAvailable: function isPubliclyAvailable(privacyStatus) {
      return privacyStatus === PRIVACY_OPTIONS.password || privacyStatus === PRIVACY_OPTIONS.link || privacyStatus === PRIVACY_OPTIONS.public;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/vis-metadata-model.js":
  /*!*******************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/vis-metadata-model.js ***!
    \*******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   *  Edit vis metadata dialog model
   *  to control if name and metadata
   *  are editable or not.
   *
   */
  
  module.exports = Backbone.Model.extend({
  
    defaults: {
      name: ''
    },
  
    validate: function validate(attrs) {
      if (!attrs) return;
      if (!attrs.name) {
        return _t('components.modals.maps-metadata.validation.error.name');
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/visualization-table-model.js":
  /*!**************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/visualization-table-model.js ***!
    \**************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var TableModel = __webpack_require__(/*! ./table-model */ "./lib/assets/javascripts/builder/data/table-model.js");
  var PermissionModel = __webpack_require__(/*! ./permission-model */ "./lib/assets/javascripts/builder/data/permission-model.js");
  var SynchronizationModel = __webpack_require__(/*! ./synchronization-model */ "./lib/assets/javascripts/builder/data/synchronization-model.js");
  
  /**
   * Model that represents a table visualization (v3)
   *
   */
  
  var PRIVACY_OPTIONS = ['PUBLIC', 'LINK', 'PRIVATE'];
  
  module.exports = Backbone.Model.extend({
  
    urlRoot: function urlRoot() {
      var baseUrl = this._configModel.get('base_url');
      var version = this._configModel.urlVersion('visualization');
      return baseUrl + '/api/' + version + '/viz';
    },
  
    initialize: function initialize(attrs, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
      this._configModel = opts.configModel;
  
      this._initModels();
    },
  
    _initModels: function _initModels() {
      var d = this.get('table');
      if (!_.isEmpty(this.get('external_source'))) {
        d = this.get('external_source');
      }
      this._tableModel = new TableModel(d, {
        configModel: this._configModel,
        parse: true
      });
  
      if (this.get('permission')) {
        this._permissionModel = new PermissionModel(this.get('permission'), {
          configModel: this._configModel
        });
        this.unset('permission');
      }
  
      if (this.get('synchronization')) {
        this._synchronizationModel = new SynchronizationModel(this.get('synchronization'), {
          configModel: this._configModel
        });
        this._synchronizationModel.linkToTable(this._tableModel);
      }
    },
  
    isVisualization: function isVisualization() {
      return false;
    },
  
    getTableModel: function getTableModel() {
      return this._tableModel;
    },
  
    getPermissionModel: function getPermissionModel() {
      return this._permissionModel;
    },
  
    getSynchronizationModel: function getSynchronizationModel() {
      return this._synchronizationModel;
    },
  
    vizjsonURL: function vizjsonURL() {
      var baseUrl = this._configModel.get('base_url');
      var version = this._configModel.urlVersion('vizjson', 'read', 'v3');
      return baseUrl + '/api/' + version + '/viz/' + this.id + '/viz.json';
    },
  
    isRaster: function isRaster() {
      return this.get('kind') === 'raster';
    },
  
    datasetURL: function datasetURL() {
      var baseUrl = this._configModel.get('base_url');
      var tableName = this.getTableModel().getUnquotedName();
      return baseUrl + '/dataset/' + tableName;
    },
  
    privacyOptions: function privacyOptions() {
      return PRIVACY_OPTIONS;
    },
  
    toJSON: function toJSON() {
      return _.omit(this.attributes, 'synchronization', 'stats', 'table');
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/visualizations-collection.js":
  /*!**************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/visualizations-collection.js ***!
    \**************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var VisualizationTableModel = __webpack_require__(/*! ./visualization-table-model */ "./lib/assets/javascripts/builder/data/visualization-table-model.js");
  var VisualizationModel = __webpack_require__(/*! ./vis-definition-model */ "./lib/assets/javascripts/builder/data/vis-definition-model.js");
  
  /**
   * A collection that holds visualization models
   */
  module.exports = Backbone.Collection.extend({
  
    DEFAULT_FETCH_OPTIONS: {
      type: 'table',
      order: 'updated_at',
      page: 1,
      per_page: 20,
      exclude_shared: false,
      exclude_raster: true,
      tags: '',
      q: ''
    },
  
    model: function model(d, opts) {
      var configModel = opts.collection._configModel;
      var Klass;
  
      if (d.type !== 'derived') {
        Klass = VisualizationTableModel;
      } else {
        Klass = VisualizationModel;
      }
  
      return new Klass(d, {
        configModel: configModel
      });
    },
  
    initialize: function initialize(models, opts) {
      if (!opts.configModel) throw new Error('configModel is required');
      this._configModel = opts.configModel;
  
      // this.DEFAULT_FETCH_OPTIONS = _.extendOwn(this.DEFAULT_FETCH_OPTIONS, opts);
      this._stats = {};
    },
  
    url: function url() {
      var version = this._configModel.urlVersion('visualization');
      var baseUrl = this._configModel.get('base_url');
      return baseUrl + '/api/' + version + '/viz';
    },
  
    // Overrides the default fetch, to use the internal methods to construct parmas
    fetch: function fetch(opts) {
      this.trigger('loading', this);
      opts = opts || {
        data: {
          // If reaches this code path it's because there were no opts given, i.e. should do a 'full fetch'
          // Since there is no current way to really do a full fetch let's just set a really high number to get all
          // TODO this is obviously bad for organization users, how can we do this differently
          per_page: 1000
        }
      };
      opts.data = _.extend({}, this.DEFAULT_FETCH_OPTIONS, opts.data);
      return Backbone.Collection.prototype.fetch.call(this, opts);
    },
  
    getDefaultParam: function getDefaultParam(param) {
      return this.DEFAULT_FETCH_OPTIONS[param];
    },
  
    getTotalStat: function getTotalStat(attribute) {
      return this._stats[attribute] || 0;
    },
  
    parse: function parse(res) {
      this._stats = _.omit(res, 'visualizations');
      return res.visualizations;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/data/visualizations-fetch-model.js":
  /*!***************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/data/visualizations-fetch-model.js ***!
    \***************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   * Model that encapsulates params for fetching data in a cdb.admin.Visualizations collection.
   */
  module.exports = Backbone.Model.extend({
    defaults: {
      content_type: '',
      page: 1,
      q: '',
      tag: '',
      category: '',
      shared: 'no',
      locked: false,
      liked: false,
      library: false,
      order: 'updated_at',
      deepInsights: false
    },
  
    isSearching: function isSearching() {
      return this.get('q') || this.get('tag');
    },
  
    isDatasets: function isDatasets() {
      return this.get('content_type') === 'datasets';
    },
  
    isMaps: function isMaps() {
      return this.get('content_type') === 'maps';
    },
  
    isDeepInsights: function isDeepInsights() {
      return this.isMaps() && this.get('deepInsights');
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/editor/editor-hints/factory-hints.js":
  /*!*****************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/editor/editor-hints/factory-hints.js ***!
    \*****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var TableNameUtils = __webpack_require__(/*! builder/helpers/table-name-utils */ "./lib/assets/javascripts/builder/helpers/table-name-utils.js");
  
  var memo = {};
  
  var OPTIONAL_OPTS = ['querySchemaModel', 'layerDefinitionModel', 'tokens'];
  
  var defaults = {
    tableName: true,
    columnsName: true,
    keywords: true
  };
  
  module.exports = {
    init: function init(opts) {
      if (!opts) throw new Error('options are required for hints');
  
      this.options = _.defaults(_.pick(opts, ['tableName', 'columnsName', 'keywords']), defaults);
  
      _.each(OPTIONAL_OPTS, function (item) {
        this['_' + item] = opts[item];
      }, this);
    },
  
    hints: function hints() {
      // array of objects {text, type}
      return this.hints;
    },
  
    reset: function reset() {
      this.hints = _.union(this._getTableName(), this._getColumns(), this._getKeywords());
      return this;
    },
  
    _getKeywords: function _getKeywords() {
      if (this.options.keywords) {
        return this._tokens && this._memo(this._tokens);
      } else {
        return [];
      }
    },
  
    _getColumns: function _getColumns() {
      if (!this.options.columnsName) {
        return [];
      }
  
      var columns = this._querySchemaModel.columnsCollection;
      return columns.map(function (mdl) {
        var columnName = mdl.get('name');
        return {
          text: columnName,
          type: 'Column_name'
        };
      });
    },
  
    _getTableName: function _getTableName() {
      if (!this.options.tableName) {
        return [];
      }
  
      var tableName = this._layerDefinitionModel.getTableName();
      tableName = TableNameUtils.getUnqualifiedName(tableName);
      return [{
        text: tableName,
        type: 'Table_name'
      }];
    },
  
    _memo: function _memo(str, type) {
      if (str in memo) {
        return memo[str];
      } else {
        return memo[str] = this._make(str, type);
      }
    },
  
    _make: function _make(str, type) {
      return _.chain(str).map(function (set) {
        return set.keywords.split(' ').map(function (item) {
          return {
            text: item,
            type: set.type
          };
        });
      }).flatten().value();
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/editor/editor-hints/sql-hints.js":
  /*!*************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/editor/editor-hints/sql-hints.js ***!
    \*************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  module.exports = [{
    keywords: 'alter and as asc between by count create delete desc distinct drop from group having in insert into is join like not on or order select set table union update values where limit',
    type: 'Sql'
  }, {
    keywords: 'ST_GeometryType ST_polygon ST_multipolygon ST_multilinestring ST_linestring ST_multipoint ST_point',
    type: 'Postgis'
  }];
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/editor/layers/layer-content-views/data/data-sql-model.js":
  /*!*************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/editor/layers/layer-content-views/data/data-sql-model.js ***!
    \*************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var UndoManager = __webpack_require__(/*! builder/data/undo-manager.js */ "./lib/assets/javascripts/builder/data/undo-manager.js");
  
  /**
   *  Data SQL Undo-redo model
   */
  module.exports = Backbone.Model.extend({
  
    defaults: {
      content: ''
    },
  
    initialize: function initialize(attrs, opts) {
      this._history = this._generateHistory(opts && opts.history);
  
      UndoManager.init(this, {
        track: true,
        history: this._history
      });
    },
  
    _generateHistory: function _generateHistory(history) {
      if (history && history.length) {
        var data = _.reduce(history, function (memo, sql) {
          memo.push({
            content: sql
          });
          return memo;
        }, [], this);
        return data;
      }
  
      return false;
    },
  
    getHistory: function getHistory() {
      return _.pluck(this.getUndoHistory(), 'content');
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/editor/style/style-cartocss-model.js":
  /*!*****************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/editor/style/style-cartocss-model.js ***!
    \*****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var UndoManager = __webpack_require__(/*! builder/data/undo-manager.js */ "./lib/assets/javascripts/builder/data/undo-manager.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  /**
   *  CartoCSS Undo-redo model
   */
  module.exports = Backbone.Model.extend({
  
    defaults: {
      content: ''
    },
  
    initialize: function initialize(attrs, opts) {
      this._history = this._generateHistory(opts && opts.history);
  
      UndoManager.init(this, {
        track: true,
        history: this._history
      });
    },
  
    _generateHistory: function _generateHistory(history) {
      if (history && history.length) {
        var data = _.reduce(history, function (memo, cartocss) {
          memo.push({
            content: cartocss
          });
          return memo;
        }, [], this);
        return data;
      }
  
      return false;
    },
  
    getHistory: function getHistory() {
      return _.pluck(this.getUndoHistory(), 'content');
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/editor/style/style-defaults/animation-style-defaults.js":
  /*!************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/editor/style/style-defaults/animation-style-defaults.js ***!
    \************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var SimpleStyleDefaults = __webpack_require__(/*! ./simple-style-defaults */ "./lib/assets/javascripts/builder/editor/style/style-defaults/simple-style-defaults.js");
  
  module.exports = _.defaults({
  
    generateAttributes: function generateAttributes(geometryType) {
      return _.extend(this._getStyleTypeAttrs(), this._getFillAttrs(geometryType), this._getStrokeAttrs(geometryType), {
        blending: 'lighter'
      }, this._getAggrAttrs(geometryType), this._getAnimatedAttrs(geometryType));
    },
  
    _getStyleTypeAttrs: function _getStyleTypeAttrs() {
      return {
        style: 'simple'
      };
    },
  
    _getAnimatedAttrs: function _getAnimatedAttrs(geometryType) {
      return {
        animated: {
          attribute: null,
          overlap: false,
          duration: 30,
          steps: 256,
          trails: 2,
          resolution: 4
        }
      };
    },
  
    _getAggrAttrs: function _getAggrAttrs(geometryType) {
      return {
        aggregation: {}
      };
    }
  }, SimpleStyleDefaults);
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/editor/style/style-defaults/heatmap-style-defaults.js":
  /*!**********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/editor/style/style-defaults/heatmap-style-defaults.js ***!
    \**********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var SimpleStyleDefaults = __webpack_require__(/*! ./simple-style-defaults */ "./lib/assets/javascripts/builder/editor/style/style-defaults/simple-style-defaults.js");
  var rampList = __webpack_require__(/*! cartocolor */ "./node_modules/cartocolor/index.js");
  
  module.exports = _.defaults({
  
    generateAttributes: function generateAttributes(geometryType) {
      return _.extend(this._getFillAttrs(geometryType), this._getAggrAttrs(), this._getAnimatedAttrs(), this._getLabelsAttrs());
    },
  
    _getFillAttrs: function _getFillAttrs(geometryType) {
      var attrs = {
        fill: {
          'size': {
            fixed: 45
          },
          'color': {
            attribute: 'cartodb_id',
            range: rampList.ag_Sunset[7],
            bins: 6
          }
        }
      };
  
      return attrs;
    },
  
    _getAggrAttrs: function _getAggrAttrs() {
      return {
        aggregation: {}
      };
    },
  
    _getAnimatedAttrs: function _getAnimatedAttrs(geometryType) {
      return {
        animated: {
          attribute: 'cartodb_id',
          overlap: false,
          duration: 30,
          steps: 1,
          trails: 0,
          resolution: 4
        }
      };
    },
  
    _getLabelsAttrs: function _getLabelsAttrs() {
      return {
        labels: {}
      };
    }
  
  }, SimpleStyleDefaults);
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/editor/style/style-defaults/hexabins-aggregation-style-defaults.js":
  /*!***********************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/editor/style/style-defaults/hexabins-aggregation-style-defaults.js ***!
    \***********************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var SimpleStyleDefaults = __webpack_require__(/*! ./simple-style-defaults */ "./lib/assets/javascripts/builder/editor/style/style-defaults/simple-style-defaults.js");
  var DefaultFormValues = __webpack_require__(/*! builder/data/default-form-styles.json */ "./lib/assets/javascripts/builder/data/default-form-styles.json");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var rampList = __webpack_require__(/*! cartocolor */ "./node_modules/cartocolor/index.js");
  
  module.exports = _.defaults({
  
    _getAggrAttrs: function _getAggrAttrs(geometryType) {
      return {
        aggregation: {
          size: 10,
          value: {
            operator: 'count',
            attribute: ''
          }
        }
      };
    },
  
    _getStrokeAttrs: function _getStrokeAttrs(geometryType) {
      var strokeAttrs = DefaultFormValues['stroke'];
      return {
        stroke: Utils.cloneObject(strokeAttrs)
      };
    },
  
    _getFillAttrs: function _getFillAttrs(geometryType) {
      var colors = rampList['ag_GrnYl'][5];
      return {
        fill: {
          'color': {
            attribute: 'agg_value',
            bins: '5',
            quantification: 'quantiles',
            // TODO: flip the ramp when basemap is black
            // range: rampList.ag_GrnYl[5].reverse()
            range: Utils.cloneObject(colors)
          }
        }
      };
    }
  
  }, SimpleStyleDefaults);
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/editor/style/style-defaults/regions-aggregation-style-defaults.js":
  /*!**********************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/editor/style/style-defaults/regions-aggregation-style-defaults.js ***!
    \**********************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var SimpleStyleDefaults = __webpack_require__(/*! ./simple-style-defaults */ "./lib/assets/javascripts/builder/editor/style/style-defaults/simple-style-defaults.js");
  var rampList = __webpack_require__(/*! cartocolor */ "./node_modules/cartocolor/index.js");
  
  module.exports = _.defaults({
    _getAggrAttrs: function _getAggrAttrs(geometryType) {
      return {
        aggregation: {
          dataset: 'countries',
          change: 'manual',
          value: {
            operator: 'count',
            attribute: ''
          }
        }
      };
    },
  
    _getFillAttrs: function _getFillAttrs(geometryType) {
      return {
        fill: {
          'color': {
            attribute: 'agg_value_density',
            bins: '5',
            quantification: 'quantiles',
            range: _.clone(rampList.Emrld[5])
          }
        }
      };
    }
  
  }, SimpleStyleDefaults);
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/editor/style/style-defaults/simple-style-defaults.js":
  /*!*********************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/editor/style/style-defaults/simple-style-defaults.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var StyleDefaults = __webpack_require__(/*! ./style-defaults */ "./lib/assets/javascripts/builder/editor/style/style-defaults/style-defaults.js");
  var DefaultCartography = __webpack_require__(/*! builder/data/default-cartography.json */ "./lib/assets/javascripts/builder/data/default-cartography.json");
  var DefaultFormValues = __webpack_require__(/*! builder/data/default-form-styles.json */ "./lib/assets/javascripts/builder/data/default-form-styles.json");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  
  module.exports = _.defaults({
  
    generateAttributes: function generateAttributes(geometryType) {
      return _.extend({}, this._getFillAttrs(geometryType), this._getStrokeAttrs(geometryType), {
        blending: DefaultFormValues['blending']
      }, this._getAggrAttrs(geometryType), this._getLabelsAttrs());
    },
  
    _getFillAttrs: function _getFillAttrs(geometryType) {
      var fillAttrs = DefaultCartography['simple'][geometryType]['fill'];
      return {
        fill: Utils.cloneObject(fillAttrs)
      };
    },
  
    _getStrokeAttrs: function _getStrokeAttrs(geometryType) {
      var strokeAttrs = DefaultCartography['simple'][geometryType]['stroke'];
      return {
        stroke: Utils.cloneObject(strokeAttrs)
      };
    },
  
    _getAggrAttrs: function _getAggrAttrs() {
      var aggrAttrs = DefaultFormValues['aggregation'];
      return {
        aggregation: Utils.cloneObject(aggrAttrs)
      };
    },
  
    _getLabelsAttrs: function _getLabelsAttrs() {
      var labelsAttrs = DefaultFormValues['labels'];
      return {
        labels: Utils.cloneObject(labelsAttrs)
      };
    }
  }, StyleDefaults);
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/editor/style/style-defaults/squares-aggregation-style-defaults.js":
  /*!**********************************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/editor/style/style-defaults/squares-aggregation-style-defaults.js ***!
    \**********************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var HexabinsAggregationDefaults = __webpack_require__(/*! ./hexabins-aggregation-style-defaults */ "./lib/assets/javascripts/builder/editor/style/style-defaults/hexabins-aggregation-style-defaults.js");
  
  module.exports = _.defaults({
  
    _getAggrAttrs: function _getAggrAttrs(geometryType) {
      return {
        aggregation: {
          size: 12,
          value: {
            operator: 'count',
            attribute: ''
          }
        }
      };
    }
  
  }, HexabinsAggregationDefaults);
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/editor/style/style-defaults/style-defaults.js":
  /*!**************************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/editor/style/style-defaults/style-defaults.js ***!
    \**************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  module.exports = {
    generateAttributes: function generateAttributes(geometryType) {
      return {
        fill: null,
        stroke: null,
        blending: null,
        aggregation: {},
        labels: {}
      };
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/editor/style/style-definition-model.js":
  /*!*******************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/editor/style/style-definition-model.js ***!
    \*******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var StylesFactory = __webpack_require__(/*! ./styles-factory */ "./lib/assets/javascripts/builder/editor/style/styles-factory.js");
  var StyleConstants = __webpack_require__(/*! builder/components/form-components/_constants/_style */ "./lib/assets/javascripts/builder/components/form-components/_constants/_style.js");
  var UndoManager = __webpack_require__(/*! builder/data/undo-manager */ "./lib/assets/javascripts/builder/data/undo-manager.js");
  
  module.exports = Backbone.Model.extend({
  
    parse: function parse(r) {
      r = r || {};
      return _.extend({
        type: r.type,
        autogenerated: r && r.autogenerated
      }, r.properties);
    },
  
    initialize: function initialize(attrs, opts) {
      if (!this.get('type')) {
        this.setDefaultPropertiesByType(StyleConstants.Type.SIMPLE, 'point' /* geometryType */);
      }
  
      UndoManager.init(this, { track: true });
    },
  
    resetPropertiesFromAutoStyle: function resetPropertiesFromAutoStyle() {
      if (this._stylesPreAutoStyle) {
        delete this.attributes.autoStyle;
        this.set(this._stylesPreAutoStyle);
        this.removeStylesPreAutoStyle();
      }
    },
  
    removeStylesPreAutoStyle: function removeStylesPreAutoStyle() {
      delete this._stylesPreAutoStyle;
    },
  
    setPropertiesFromAutoStyle: function setPropertiesFromAutoStyle(params) {
      if (!params.definition) throw new Error('definition is required');
      if (!params.geometryType) throw new Error('geometryType is required');
      if (!params.widgetId) throw new Error('widgetId is required');
  
      if (!this._stylesPreAutoStyle) {
        this._stylesPreAutoStyle = JSON.parse(JSON.stringify(this.attributes));
      }
  
      // In order to trigger a proper change at the end of this function, we have
      // to make a clear change in the attributes, like delete the autoStyle property.
      delete this.attributes.autoStyle;
  
      var extendAutoStyleProperties = function (attribute, newProperties) {
        var properties = this.get(attribute);
        // Check domain quotes
        if (newProperties.color && newProperties.color.domain) {
          var quotedDomain = _.compact(_.map(newProperties.color.domain, function (name) {
            if (name && name !== true) {
              return '"' + name.toString().replace(/"/g, '\\"').replace(/\n/g, '\\n') + '"';
            } else {
              return name;
            }
          }));
          newProperties.color.static = true;
          newProperties.color.domain = quotedDomain;
          newProperties.color.quantification = 'category';
          newProperties.color.attribute_type = 'string';
        } else {
          newProperties.color.bins = newProperties.color.range.length;
          newProperties.color.quantification = 'quantiles';
          newProperties.color.attribute_type = 'number';
        }
  
        properties = _.extend(properties, newProperties);
  
        return properties;
      }.bind(this);
  
      var currentAttrs = JSON.parse(JSON.stringify(this.attributes));
      var geometryType = params.geometryType;
      var definition = params.definition[geometryType];
  
      if (definition) {
        if (geometryType === 'line') {
          currentAttrs.stroke = extendAutoStyleProperties('stroke', definition);
        } else {
          currentAttrs.fill = extendAutoStyleProperties('fill', definition);
        }
      }
  
      this.set(_.extend({
        type: StyleConstants.Type.SIMPLE,
        autoStyle: params.widgetId
      }, currentAttrs));
    },
  
    setDefaultPropertiesByType: function setDefaultPropertiesByType(styleType, geometryType, silently) {
      // Get default aggregation and properties from factory and apply them
      this.set(_.extend({
        type: styleType
      }, StylesFactory.getDefaultStyleAttrsByType(styleType, geometryType)), {
        silently: !!silently
      });
  
      // Although we want to make the change silently, we have several places listening
      // for style changes, so we trigger this custom event
      if (silently) {
        this.trigger('style:update');
      }
    },
  
    setFill: function setFill(type) {
      var simpleFill = StylesFactory.getDefaultStyleAttrsByType(type, 'point');
      this.set('fill', simpleFill.fill);
    },
  
    applyLastState: function applyLastState() {
      this._undoManager.stopTracking();
      this.trigger('change');
      this._undoManager.startTracking();
    },
  
    resetStyles: function resetStyles() {
      this.setDefaultPropertiesByType(StyleConstants.Type.NONE, '');
    },
  
    // Backend will migrate current wizard properties to style properties,
    // providing a flag which indicates if it is generated by them
    isAutogenerated: function isAutogenerated() {
      return this.get('autogenerated');
    },
  
    isAggregatedType: function isAggregatedType() {
      return _.contains(StylesFactory.getAggregationTypes(), this.get('type'));
    },
  
    isAnimation: function isAnimation() {
      return this.get('type') === StyleConstants.Type.ANIMATION;
    },
  
    isHeatmap: function isHeatmap() {
      return this.get('type') === StyleConstants.Type.HEATMAP;
    },
  
    hasNoneStyles: function hasNoneStyles() {
      return this.get('type') === StyleConstants.Type.NONE;
    },
  
    canApplyAutoStyle: function canApplyAutoStyle() {
      return this.get('type') === StyleConstants.Type.SIMPLE;
    },
  
    getColumnsUsedForStyle: function getColumnsUsedForStyle() {
      var fillColumns = this._getFillColumns();
      var strokeColumns = this._getStrokeColumns();
      var labelColumns = this._getLabelColumns();
      var aggregationColumns = this._getAggregationColumns();
  
      return [].concat(fillColumns, strokeColumns, labelColumns, aggregationColumns);
    },
  
    // Unflatten attributes
    toJSON: function toJSON() {
      return {
        type: this.get('type'),
        properties: _.omit(this.attributes, 'type', 'autogenerated')
      };
    },
  
    _getFillColumns: function _getFillColumns() {
      var columns = [];
  
      var fill = this.get('fill');
      if (fill && fill.color && fill.color.attribute) {
        columns.push({
          name: fill.color.attribute,
          type: fill.color.attribute_type || 'string'
        });
      }
  
      if (fill && fill.size && fill.size.attribute) {
        columns.push({
          name: fill.size.attribute,
          type: 'number'
        });
      }
  
      return columns;
    },
  
    _getStrokeColumns: function _getStrokeColumns() {
      var columns = [];
  
      var stroke = this.get('stroke');
      if (stroke && stroke.color && stroke.color.attribute) {
        columns.push({
          name: stroke.color.attribute,
          type: stroke.color.attribute_type || 'string'
        });
      }
      if (stroke && stroke.size && stroke.size.attribute) {
        columns.push({
          name: stroke.size.attribute,
          type: 'number'
        });
      }
  
      return columns;
    },
  
    _getLabelColumns: function _getLabelColumns() {
      var columns = [];
  
      // Labels
      var labels = this.get('labels');
      if (labels && labels.attribute && labels.enabled) {
        columns.push({
          name: labels.attribute
        });
      }
  
      return columns;
    },
  
    _getAggregationColumns: function _getAggregationColumns() {
      var columns = [];
  
      var aggregation = this.get('aggregation');
      if (aggregation && aggregation.value && aggregation.value.attribute) {
        columns.push({
          name: aggregation.value.attribute,
          type: aggregation.value.attribute_type || 'string'
        });
      }
  
      return columns;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/editor/style/styles-factory.js":
  /*!***********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/editor/style/styles-factory.js ***!
    \***********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var StyleDefaults = __webpack_require__(/*! ./style-defaults/style-defaults */ "./lib/assets/javascripts/builder/editor/style/style-defaults/style-defaults.js");
  var SimpleStyleDefaults = __webpack_require__(/*! ./style-defaults/simple-style-defaults */ "./lib/assets/javascripts/builder/editor/style/style-defaults/simple-style-defaults.js");
  var HeatmapDefaults = __webpack_require__(/*! ./style-defaults/heatmap-style-defaults */ "./lib/assets/javascripts/builder/editor/style/style-defaults/heatmap-style-defaults.js");
  var AnimationDefaults = __webpack_require__(/*! ./style-defaults/animation-style-defaults */ "./lib/assets/javascripts/builder/editor/style/style-defaults/animation-style-defaults.js");
  var SquareAggregationDefaults = __webpack_require__(/*! ./style-defaults/squares-aggregation-style-defaults */ "./lib/assets/javascripts/builder/editor/style/style-defaults/squares-aggregation-style-defaults.js");
  var HexabinsAggregationDefaults = __webpack_require__(/*! ./style-defaults/hexabins-aggregation-style-defaults */ "./lib/assets/javascripts/builder/editor/style/style-defaults/hexabins-aggregation-style-defaults.js");
  var RegionsAggregationDefaults = __webpack_require__(/*! ./style-defaults/regions-aggregation-style-defaults */ "./lib/assets/javascripts/builder/editor/style/style-defaults/regions-aggregation-style-defaults.js");
  
  var STYLE_MAP = {
    'none': {
      tooltipTranslationKey: 'editor.style.tooltip.none',
      labelTranslationKey: 'editor.style.types.none',
      checkIfValid: function checkIfValid(geometryType) {
        return !geometryType;
      },
      defaultStyles: StyleDefaults
    },
    'simple': {
      tooltipTranslationKey: 'editor.style.style-form.aggregation.tooltips.simple',
      labelTranslationKey: 'editor.style.types.simple',
      iconTemplate: __webpack_require__(/*! ./style-icons/points.tpl */ "./lib/assets/javascripts/builder/editor/style/style-icons/points.tpl"),
      checkIfValid: function checkIfValid(geometryType) {
        return !!geometryType;
      },
      defaultStyles: SimpleStyleDefaults
    },
    'squares': {
      tooltipTranslationKey: 'editor.style.style-form.aggregation.tooltips.squares',
      labelTranslationKey: 'editor.style.types.squares',
      iconTemplate: __webpack_require__(/*! ./style-icons/squares.tpl */ "./lib/assets/javascripts/builder/editor/style/style-icons/squares.tpl"),
      checkIfValid: function checkIfValid(geometryType) {
        return geometryType === 'point';
      },
      defaultStyles: SquareAggregationDefaults
    },
    'hexabins': {
      tooltipTranslationKey: 'editor.style.style-form.aggregation.tooltips.hexabins',
      labelTranslationKey: 'editor.style.types.hexabins',
      iconTemplate: __webpack_require__(/*! ./style-icons/hexabins.tpl */ "./lib/assets/javascripts/builder/editor/style/style-icons/hexabins.tpl"),
      checkIfValid: function checkIfValid(geometryType) {
        return geometryType === 'point';
      },
      defaultStyles: HexabinsAggregationDefaults
    },
    'regions': {
      tooltipTranslationKey: 'editor.style.style-form.aggregation.tooltips.regions',
      labelTranslationKey: 'editor.style.types.regions',
      iconTemplate: __webpack_require__(/*! ./style-icons/regions.tpl */ "./lib/assets/javascripts/builder/editor/style/style-icons/regions.tpl"),
      checkIfValid: function checkIfValid(geometryType) {
        return geometryType === 'point';
      },
      defaultStyles: RegionsAggregationDefaults
    },
    'animation': {
      tooltipTranslationKey: 'editor.style.style-form.aggregation.tooltips.animation',
      labelTranslationKey: 'editor.style.types.animation',
      iconTemplate: __webpack_require__(/*! ./style-icons/animated.tpl */ "./lib/assets/javascripts/builder/editor/style/style-icons/animated.tpl"),
      checkIfValid: function checkIfValid(geometryType) {
        return geometryType === 'point';
      },
      defaultStyles: AnimationDefaults
    },
    'heatmap': {
      tooltipTranslationKey: 'editor.style.style-form.aggregation.tooltips.heatmap',
      labelTranslationKey: 'editor.style.types.heatmap',
      iconTemplate: __webpack_require__(/*! ./style-icons/heatmap.tpl */ "./lib/assets/javascripts/builder/editor/style/style-icons/heatmap.tpl"),
      checkIfValid: function checkIfValid(geometryType) {
        return geometryType === 'point';
      },
      defaultStyles: HeatmapDefaults
    }
  };
  
  module.exports = {
    getDefaultStyleAttrsByType: function getDefaultStyleAttrsByType(styleType, geometryType) {
      var StyleDefaultsKlass = STYLE_MAP[styleType].defaultStyles;
      return StyleDefaultsKlass.generateAttributes(geometryType);
    },
  
    getStyleTypes: function getStyleTypes(currentType, geometryType) {
      return _.reduce(STYLE_MAP, function (memo, val, key) {
        if (currentType === key || (val.checkIfValid ? val.checkIfValid(geometryType) : true)) {
          memo.push({
            value: key,
            label: _t(val.labelTranslationKey),
            tooltip: _t(val.tooltipTranslationKey),
            iconTemplate: val.iconTemplate
          });
        }
        return memo;
      }, []);
    },
  
    getFormTemplateByType: function getFormTemplateByType(styleType) {
      return STYLE_MAP[styleType].formTemplate;
    },
  
    getAggregationTypes: function getAggregationTypes() {
      return ['squares', 'hexabins', 'regions'];
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/helpers/analysis-node-utils.js":
  /*!***********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/helpers/analysis-node-utils.js ***!
    \***********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  // Get the source node from an analysis node
  function getSourceNode(nodeModel) {
    var source;
    if (nodeModel.get('type') === 'source') {
      source = nodeModel;
    } else {
      var primarySource = nodeModel.getPrimarySource && nodeModel.getPrimarySource();
      if (primarySource && primarySource.get('type') === 'source') {
        source = primarySource;
      } else {
        source = getSourceNode(primarySource);
      }
    }
  
    return source;
  }
  
  // Evaluates predicate for the analysis chain from nodeModel
  function someNode(nodeModel, predicate) {
    if (predicate(nodeModel)) {
      return nodeModel;
    }
  
    if (nodeModel.get('type') !== 'source') {
      var source = nodeModel.getPrimarySource && nodeModel.getPrimarySource();
  
      if (source) {
        return someNode(source, predicate);
      }
    }
  
    return false;
  }
  
  function hasAnalysisType(type) {
    return function (node) {
      return node.get('type') === type;
    };
  }
  
  var hasTradeArea = hasAnalysisType('trade-area');
  var hasSQLFunction = hasAnalysisType('deprecated-sql-function');
  
  module.exports = {
    nodeHasTradeArea: function nodeHasTradeArea(node) {
      return someNode(node, hasTradeArea);
    },
    nodeHasSQLFunction: function nodeHasSQLFunction(node) {
      return someNode(node, hasSQLFunction);
    },
  
    // These are defined outside because they're recursive
    getSourceNode: getSourceNode,
    someNode: someNode
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/helpers/browser-detect.js":
  /*!******************************************************************!*\
    !*** ./lib/assets/javascripts/builder/helpers/browser-detect.js ***!
    \******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  /**
   * Just provide info about the current browser
   */
  
  module.exports = function () {
    var ua = navigator.userAgent;
    var tem;
    var M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if (/trident/i.test(M[1])) {
      tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
      return {
        name: 'IE ',
        version: tem[1] || ''
      };
    }
    if (M[1] === 'Chrome') {
      tem = ua.match(/\bOPR\/(\d+)/);
      if (tem != null) {
        return {
          name: 'Opera',
          version: tem[1]
        };
      }
    }
    M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
    if ((tem = ua.match(/version\/(\d+)/i)) != null) {
      M.splice(1, 1, tem[1]);
    }
  
    return {
      name: M[0],
      version: M[1]
    };
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/helpers/carto-color.js":
  /*!***************************************************************!*\
    !*** ./lib/assets/javascripts/builder/helpers/carto-color.js ***!
    \***************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CartoColors = __webpack_require__(/*! cartocolor */ "./node_modules/cartocolor/index.js");
  
  var Tags = {
    COLORBLIND: 'colorblind',
    DIVERGING: 'diverging',
    QUALITATIVE: 'qualitative',
    QUANTITATIVE: 'quantitative'
  };
  
  module.exports = {
    getColorRamps: function getColorRamps(colorsNumber) {
      if (!colorsNumber) {
        throw new Error('Number of colors per ramp is required');
      }
  
      var rampColors = [];
  
      _.each(CartoColors, function (color) {
        if (color && color[colorsNumber]) {
          rampColors.push(color[colorsNumber]);
        }
      });
  
      return rampColors;
    },
  
    getColorRampsByTag: function getColorRampsByTag(colorsNumber, tag) {
      if (!colorsNumber) {
        throw new Error('Number of colors per ramp is required');
      }
  
      var rampColors = [];
  
      _.each(CartoColors, function (color) {
        if (color && color[colorsNumber] && _.contains(color.tags, tag)) {
          rampColors.push(color[colorsNumber]);
        }
      });
  
      return rampColors;
    },
  
    getColorblindRamps: function getColorblindRamps(colorsNumber) {
      return this.getColorRampsByTag(colorsNumber, Tags.COLORBLIND);
    },
  
    getDivergingRamps: function getDivergingRamps(colorsNumber) {
      return this.getColorRampsByTag(colorsNumber, Tags.DIVERGING);
    },
  
    getQualitativeRamps: function getQualitativeRamps(colorsNumber) {
      return this.getColorRampsByTag(colorsNumber, Tags.QUALITATIVE);
    },
  
    getQuantitativeRamps: function getQuantitativeRamps(colorsNumber) {
      return this.getColorRampsByTag(colorsNumber, Tags.QUANTITATIVE);
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/helpers/color-keywords.js":
  /*!******************************************************************!*\
    !*** ./lib/assets/javascripts/builder/helpers/color-keywords.js ***!
    \******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  module.exports = ['aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige', 'bisque', 'black', 'blanchedalmond', 'blue', 'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse', 'chocolate', 'coral', 'cornflowerblue', 'cornsilk', 'crimson', 'cyan', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray', 'darkgreen', 'darkkhaki', 'darkmagenta', 'darkolivegreen', 'darkorange', 'darkorchid', 'darkred', 'darksalmon', 'darkseagreen', 'darkslateblue', 'darkslategray', 'darkturquoise', 'darkviolet', 'deeppink', 'deepskyblue', 'dimgray', 'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen', 'fuchsia', 'gainsboro', 'ghostwhite', 'gold', 'goldenrod', 'gray', 'grey', 'green', 'greenyellow', 'honeydew', 'hotpink', 'indianred', 'indigo', 'ivory', 'khaki', 'lavender', 'lavenderblush', 'lawngreen', 'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan', 'lightgoldenrodyellow', 'lightgray', 'lightgreen', 'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue', 'lightslategray', 'lightsteelblue', 'lightyellow', 'lime', 'limegreen', 'linen', 'magenta', 'maroon', 'mediumaquamarine', 'mediumblue', 'mediumorchid', 'mediumpurple', 'mediumseagreen', 'mediumslateblue', 'mediumspringgreen', 'mediumturquoise', 'mediumvioletred', 'midnightblue', 'mintcream', 'mistyrose', 'moccasin', 'navajowhite', 'navy', 'oldlace', 'olive', 'olivedrab', 'orange', 'orangered', 'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise', 'palevioletred', 'papayawhip', 'peachpuff', 'peru', 'pink', 'plum', 'powderblue', 'purple', 'red', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon', 'sandybrown', 'seagreen', 'seashell', 'sienna', 'silver', 'skyblue', 'slateblue', 'slategray', 'snow', 'springgreen', 'steelblue', 'tan', 'teal', 'thistle', 'tomato', 'turquoise', 'violet', 'wheat', 'white', 'whitesmoke', 'yellow', 'yellowgreen'];
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/helpers/error-parser.js":
  /*!****************************************************************!*\
    !*** ./lib/assets/javascripts/builder/helpers/error-parser.js ***!
    \****************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var DEFAULT_ERROR_MSG = '';
  
  /**
   *  Return error message when backend request fails
   *  It tries to get responseText > errors and error arrays, if not gets `statusText`.
   */
  
  module.exports = function (e) {
    if (!e) {
      throw new Error('error is required');
    }
  
    try {
      var responseText = e.responseText && e.responseText.trim() && JSON.parse(e.responseText);
      var errorMessage = e.statusText || DEFAULT_ERROR_MSG;
  
      if (responseText) {
        var errors = _.compact(_.map(['errors', 'error'], function (type) {
          return responseText[type] && responseText[type].join(', ');
        }));
        errorMessage = errors.join(', ');
      }
  
      return errorMessage;
    } catch (err) {
      return DEFAULT_ERROR_MSG;
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/helpers/fetch-all-query-objects.js":
  /*!***************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/helpers/fetch-all-query-objects.js ***!
    \***************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  /**
   *  Fetch all query objects (querySchemaModel, queryGeometryModel, queryRowsCollection)
   *  if necessary
   */
  
  module.exports = function (params) {
    if (!params) throw new Error('all query objects are required');
    if (!params.querySchemaModel) throw new Error('querySchemaModel is required');
    if (!params.queryGeometryModel) throw new Error('queryGeometryModel is required');
    if (!params.queryRowsCollection) throw new Error('queryRowsCollection is required');
  
    function fetchModel(model) {
      return new Promise(function (resolve, reject) {
        var subscribeToFinalStatus = false;
  
        if (model.shouldFetch()) {
          model.fetch();
          subscribeToFinalStatus = true;
        } else if (!model.isInFinalStatus()) {
          subscribeToFinalStatus = true;
        } else {
          resolve();
        }
  
        if (subscribeToFinalStatus) {
          model.once('inFinalStatus', function () {
            resolve();
          });
        }
      });
    }
  
    var schemaModelPromise = fetchModel(params.querySchemaModel);
    var geometryModelPromise = fetchModel(params.queryGeometryModel);
  
    return Promise.all([schemaModelPromise, geometryModelPromise]).then(function () {
      return fetchModel(params.queryRowsCollection); // rows collection depends on schema
    });
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/helpers/magic-positioner.js":
  /*!********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/helpers/magic-positioner.js ***!
    \********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var DEFAULT_VALUES = {
    top: 0,
    left: 0
  };
  var MIN_GAP = 10;
  var MIN_HEIGHT = 205;
  var MIN_WIDTH = 244;
  
  /**
   * Would you like to know where to open a context menu?
   * Just provide:
   * @param {Object} options.parentView               Parent element view
   * @param {Number} options.posX                     Position X of the context menu
   * @param {Number} options.posY                     Position Y of the context menu
   * @param {Number} options.elementWidth (optional)  Context menu width
   * @param {Number} options.elementHeight (optional) Context menu height
   * @param {Number} options.offsetX (optional)       Context menu offsetX
   * @param {Number} options.offsetY (optional)       Context menu offsetY
   *
   * By default, it will try to positionate to the right (inside) and to
   * the top (below).
   */
  
  var MagicPositioner = function MagicPositioner(params) {
    if (!params.parentView) throw new Error('parentView within params is required');
    if (!_.isNumber(params.posX)) throw new Error('posX within params is required');
    if (!_.isNumber(params.posY)) throw new Error('posY within params is required');
  
    var $parentView = params.parentView;
    var parentViewHeight = $parentView.outerHeight();
    var parentViewWidth = $parentView.outerWidth();
    var posX = params.posX;
    var posY = params.posY;
    var offsetX = params.offsetX || 0;
    var offsetY = params.offsetY || 0;
    var elementWidth = params.elementWidth || MIN_WIDTH;
    var elementHeight = params.elementHeight || MIN_HEIGHT;
    var cssProps = DEFAULT_VALUES;
  
    if (posX - elementWidth > MIN_GAP) {
      cssProps.left = 'auto';
      cssProps.right = parentViewWidth - posX + offsetX + 'px';
    } else if (posX + elementWidth > elementWidth) {
      cssProps.right = 'auto';
      cssProps.left = posX + offsetX + 'px';
    }
  
    if (posY + elementHeight < parentViewHeight) {
      cssProps.bottom = 'auto';
      cssProps.top = posY + offsetY + 'px';
    } else if (posY + elementHeight > parentViewHeight) {
      cssProps.top = 'auto';
      cssProps.bottom = parentViewHeight - posY + offsetY + 'px';
    }
  
    return cssProps;
  };
  
  module.exports = MagicPositioner;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/helpers/navigate-through-router.js":
  /*!***************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/helpers/navigate-through-router.js ***!
    \***************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  
  /**
   * Check if Linux user used right/middle click at the time of the event
   *
   * @param ev {Event}
   * @returns {boolean}
   */
  function isLinuxMiddleOrRightClick(ev) {
    return ev.which === 2 || ev.which === 3;
  }
  
  /**
   * Check if Mac user used CMD key at the time of the event Mac user used CMD key at the time of the event.
   *
   * @param ev {Event}
   * @returns {boolean}
   */
  function isMacCmdKeyPressed(ev) {
    return ev.metaKey;
  }
  
  function isCtrlKeyPressed(ev) {
    return ev.ctrlKey;
  }
  
  /**
   * Click handler for a cartodb.js view, to navigate event target's href URL through the view's router.navigate method.
   *
   * The default behavior is:
   * Unless cmd/ctrl keys are pressed it will cancel the default link behavior and instead navigate to the URL set in the
   * target's href attribute.
   *
   * Prerequisities:
   *  - view has a this.router instance.
   *
   * Example of how to use:
   *   - In a template:
   *     <a href="/some/uri" id="#my-link" ...
   *     <a href="/special/uri" id="#my-special-link" ...
   *
   *   - In the view file:
   *     var navigateThroughRouter = require('--/--/common/view_helpers/navigateThroughRouter');
   *     module.exports = new CoreView.extend({
   *       events: {
   *         'click a#my-link': navigateThroughRouter
   *         'click a#my-special-link': this._myCustomRoute
   *       }
   *
   *       _myCustomRoute: function(ev) {
   *         // Here you can do you custom logic before/after the routing, e.g.:
   *         console.log('before changing route');
   *         navigateThroughRouter.apply(this, arguments);
   *         console.log('after changing route');
   *       }
   *
   * @param ev {Event}
   */
  module.exports = function (ev) {
    // We always kill the default behaviour of the event, since container around view might have other click behavior.
    // In case of a cmd/ctrl click by an user.
    this.killEvent(ev);
    var url = $(ev.target).closest('a').attr('href');
  
    if (!url) {
      return false;
    }
  
    if (!isLinuxMiddleOrRightClick(ev) && !isMacCmdKeyPressed(ev)) {
      var routerModel = this.routerModel || this.options.routerModel || this.options.router;
      if (!routerModel) {
        throw new Error('routerModel is required');
      }
  
      routerModel.navigate(url, { trigger: true });
    } else if (isCtrlKeyPressed(ev) || isMacCmdKeyPressed(ev)) {
      window.open(url, '_blank');
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/helpers/point-geojson-parser.js":
  /*!************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/helpers/point-geojson-parser.js ***!
    \************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  // Get coordinates from a GeoJSON
  
  module.exports = function (geometry) {
    try {
      var geojson = JSON.parse(geometry);
      return geojson.coordinates.join(', ');
    } catch (e) {
      return false;
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/helpers/query-utils-model.js":
  /*!*********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/helpers/query-utils-model.js ***!
    \*********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  var COUNT_SQL_TEMPLATE = 'select count(*) from (<%= subquery %>) st';
  
  module.exports = Backbone.Collection.extend({
  
    url: function url() {
      return this._configModel.getSqlApiUrl();
    },
  
    initialize: function initialize(opts) {
      opts = opts || {};
  
      this._subquery = opts.subquery;
      this._configModel = opts.configModel;
    },
  
    fetchCount: function fetchCount(callback) {
      var opts = {};
      var count = -1;
  
      opts.data = {
        api_key: this._configModel.get('api_key'),
        q: this._getCountSQL()
      };
      opts.method = this._httpMethod();
      opts.error = function (coll, resp) {
        callback && callback(count);
      };
      opts.success = function (coll, resp, options) {
        if (resp.rows && resp.rows.length) {
          count = resp.rows[0].count;
        }
        callback && callback(count);
      };
  
      return Backbone.Collection.prototype.fetch.call(this, opts);
    },
  
    _getCountSQL: function _getCountSQL(excludeColumns) {
      return _.template(COUNT_SQL_TEMPLATE)({
        subquery: this._subquery
      });
    },
  
    _httpMethod: function _httpMethod() {
      return 'GET';
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/helpers/required-opts.js":
  /*!*****************************************************************!*\
    !*** ./lib/assets/javascripts/builder/helpers/required-opts.js ***!
    \*****************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  module.exports = function checkAndBuildRequiredOpts(actualOpts, requiredOpts, context) {
    if (requiredOpts === void 0) {
      throw new Error('Opts are required');
    }
  
    _.each(requiredOpts, function (item) {
      if (actualOpts === void 0 || actualOpts[item] === void 0) throw new Error(item + ' is required');
      context['_' + item] = actualOpts[item];
    }, context);
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/helpers/sql-utils.js":
  /*!*************************************************************!*\
    !*** ./lib/assets/javascripts/builder/helpers/sql-utils.js ***!
    \*************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  /**
   *  Checks properties from a SQL
   */
  
  var TableNameUtils = __webpack_require__(/*! ./table-name-utils */ "./lib/assets/javascripts/builder/helpers/table-name-utils.js");
  
  module.exports = {
    isSameQuery: function isSameQuery(originalQuery, customQuery) {
      if (originalQuery == null || customQuery == null) {
        // eslint-disable-line
        throw new Error('Needed parameters not provided');
      }
  
      var parseQuery = function parseQuery(query) {
        return query.toLowerCase().replace(/\"/g, '') // Remove quoted things like "pepe".tableName
        .replace(/;/g, '');
      };
  
      return parseQuery(originalQuery) === parseQuery(customQuery);
    },
  
    // return true if the sql query alters table schema in some way
    altersSchema: function altersSchema(sql) {
      if (!sql) {
        return false;
      }
  
      // Remove all line breaks in order to prevent
      // search pattern problems
      sql = this._removeLineBreaks(sql.trim());
  
      return sql.search(/alter\s+[\w\."]+\s+/i) !== -1 || sql.search(/drop\s+[\w\.\"]+/i) !== -1 || sql.search(/^vacuum\s+[\w\.\"]+/i) !== -1 || sql.search(/^create\s+[\w\.\"]+/i) !== -1 || sql.search(/^reindex\s+[\w\.\"]+/i) !== -1 || sql.search(/^grant\s+[\w\.\"]+/i) !== -1 || sql.search(/^revoke\s+[\w\.\"]+/i) !== -1 || sql.search(/^cluster\s+[\w\.\"]+/i) !== -1 || sql.search(/^comment\s+on\s+[\w\.\"]+/i) !== -1 || sql.search(/^explain\s+[\w\.\"]+/i) !== -1;
    },
  
    // return true if the sql query alters table data
    altersData: function altersData(sql) {
      if (!sql) {
        return false;
      }
  
      // Remove all line breaks in order to prevent
      // search pattern problems
      sql = this._removeLineBreaks(sql.trim());
  
      return this.altersSchema(sql) || sql.search(/^refresh\s+materialized\s+view\s+[\w\.\"]+/i) !== -1 || sql.search(/^truncate\s+[\w\.\"]+/i) !== -1 || sql.search(/insert\s+into/i) !== -1 || sql.search(/update\s+[\w\.\-"]+\s+.*set/i) !== -1 || sql.search(/delete\s+from/i) !== -1;
    },
  
    _removeLineBreaks: function _removeLineBreaks(sql) {
      return sql.replace(/\r?\n|\r/g, ' ');
    },
  
    getDefaultSQL: function getDefaultSQL(tableName, userName, inOrganization) {
      return this.getDefaultSQLFromTableName(TableNameUtils.getQualifiedTableName(tableName, userName, inOrganization));
    },
  
    getDefaultSQLFromTableName: function getDefaultSQLFromTableName(tableName) {
      return 'SELECT * FROM ' + tableName;
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/helpers/table-name-utils.js":
  /*!********************************************************************!*\
    !*** ./lib/assets/javascripts/builder/helpers/table-name-utils.js ***!
    \********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  /**
   *  Functions to work with SQL table names
   */
  
  module.exports = {
    getUnqualifiedName: function getUnqualifiedName(tablename) {
      if (!tablename) return null;
      var tk = tablename.split('.');
      if (tk.length === 2) {
        return this._getUnquotedName(tk[1]);
      }
      return this._getUnquotedName(tablename);
    },
  
    getUsername: function getUsername(tablename) {
      if (!tablename) return null;
      var tk = tablename.split('.');
      if (tk.length === 2) {
        return this._getUnquotedName(tk[0]);
      }
      return '';
    },
  
    _getUnquotedName: function _getUnquotedName(tablename) {
      return tablename && tablename.replace(/"/g, '');
    },
  
    _quoteIfNeeded: function _quoteIfNeeded(name) {
      var VALID_IDENTIFIER = /^[a-zA-Z_][a-zA-Z0-9_$]*$/;
      name = this._getUnquotedName(name);
      if (!VALID_IDENTIFIER.test(name)) {
        name = '"' + name + '"';
      }
      return name;
    },
  
    getQualifiedTableName: function getQualifiedTableName(tableName, userName, inOrganization) {
      var schemaPrefix = inOrganization && userName ? this._quoteIfNeeded(userName) + '.' : '';
      return schemaPrefix + this._quoteIfNeeded(this.getUnqualifiedName(tableName));
    },
  
    isSameTableName: function isSameTableName(firstTableName, secondTableName, ownerUsername) {
      var firstParts = this._getTableNameParts(firstTableName, ownerUsername);
      var secondParts = this._getTableNameParts(secondTableName, ownerUsername);
  
      return firstParts[0] === secondParts[0] && firstParts[1] === secondParts[1];
    },
  
    _getTableNameParts: function _getTableNameParts(tableName, ownerUsername) {
      var table = this.getUnqualifiedName(tableName);
      var username = this.getUsername(tableName) || ownerUsername;
  
      return [username, table];
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/helpers/utils.js":
  /*!*********************************************************!*\
    !*** ./lib/assets/javascripts/builder/helpers/utils.js ***!
    \*********************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  
  /*
   *  Util functions
   */
  
  module.exports = {
    /*
     *  Simple regex to check if string is an url/ftp
     *  input ->  string with input text (example: 'https://carto.com')
     *
     *  return -> true
     */
    isURL: function isURL(input) {
      var urlregex = /^((http|https|ftp)\:\/\/)/g;
      if (input) {
        return urlregex.test(input);
      } else {
        return false;
      }
    },
  
    /*
     *  check if string is blank (i.e.: str === "")
     *  input ->  string with input text
     *
     * @return a boolean
     */
    isBlank: function isBlank(str) {
      return !str || /^\s*$/.test(str);
    },
    /*
     *  Transform bytes to a readable format, like MB, GB
     *  input ->  34234244
     *
     *  return -> 3 MB
     */
    readablizeBytes: function readablizeBytes(bytes, round) {
      if (!bytes || isNaN(bytes)) {
        return 0;
      }
      var s = ['bytes', 'kB', 'MB', 'GB', 'TB', 'PB'];
      var e = Math.floor(Math.log(bytes) / Math.log(1024));
      var value = (bytes / Math.pow(1024, Math.floor(e))).toFixed(2);
  
      if (round) {
        value = parseInt(value, 10);
      }
  
      return value + ' ' + s[e];
    },
  
    /**
     *  Convert long numbers to
     *  readizable numbers.
     *
     */
    readizableNumber: function readizableNumber(num) {
      if (num >= 1000000000) return (num / 1000000000).toFixed(1) + 'G';
      if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
      if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
      return num;
    },
  
    /*
     * formatNumber: adds thousands separators
     * @return a string
     *
     */
    formatNumber: function formatNumber(x) {
      if (!x) return '0';
      var parts = x.toString().split('.');
      parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
      return parts.join('.');
    },
  
    /**
     * Similar to _.result, but also allows passing arbitrary arguments to the property if it's function.
     * This makes code more terse  when one just wants to use a value if it's available, no if-checks required.
     *
     * @example Expected output
     *   model.set('something', 'yay');
     *   cdb.Utils.result(model, 'get', 'something') // => 'yay'
     *   cdb.Utils.result(model, 'nonexisting', 'else') // => undefined
     *   cdb.Utils.result(undefinedVar, 'get') // => null
     *
     * @example Of usage
     *  return cdb.Utils.result(model, 'get', 'mightNotExist') === 'OK'
     *
     * @param {*} maybeFn
     * @return {*} Result from called maybeFn if a function, null otherwise
     */
    result: function result(object, property) {
      if (object == null) return null;
      var value = object[property];
      return _.isFunction(value) ? value.apply(object, Array.prototype.slice.call(arguments, 2)) : value;
    },
  
    /**
     *  Get the extension of a string
     *
     */
    getFileExtension: function getFileExtension(str) {
      if (!str) return '';
      return str.substr(str.lastIndexOf('.') + 1);
    },
  
    /**
     *  Add leading zeros to numbers
     *
     */
    pad: function pad(num, size) {
      var s = num + '';
      while (s.length < size) {
        s = '0' + s;
      }return s;
    },
  
    formatDate: function formatDate(opts) {
      if (!opts.time) throw new Error();
      if (opts.month === undefined) throw new Error();
      if (opts.year === undefined) throw new Error();
      if (!opts.day) throw new Error();
  
      // Month in Date format should be specified as an index
      var month = parseInt(opts.month + 1, 10);
      var padZero = function padZero(digit) {
        digit = String(digit);
        if (digit < 10 && digit.length === 1) {
          return '0' + digit;
        }
        return digit;
      };
  
      return '' + opts.year + '-' + padZero(month) + '-' + padZero(opts.day) + 'T' + opts.time + 'Z';
      // Not adding any info about timezone
    },
  
    /*
     * rgbToHex
     *
     */
    rgbToHex: function rgbToHex(r, g, b) {
      function componentToHex(c) {
        var hex = c.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }
  
      return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b);
    },
  
    /*
     *  Returns true if the hex color passed as an input is valid
     *  input -> hex (#FF00FF)
     *  output -> true
     *
     * @return a boolean
     */
    isValidHex: function isValidHex(hex) {
      return !!hex.match(/(^#?[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i);
    },
  
    /*
     * Returns #FFFFFF in case the input is not a valid HEX number
     */
    sanitizeHex: function sanitizeHex(hex) {
      if (!this.isValidHex(hex)) {
        return '#FFFFFF';
      }
      return hex;
    },
  
    /*
     *  Transforms an hex color into its RGB representation
     *  input ->  hex (#FF00FF)
     *  output ->  { r: 255, g: 0, b: 255 }
     *
     * @return a hash
     */
    hexToRGB: function hexToRGB(hex) {
      if (!hex) {
        hex = '#FFFFFF';
      }
  
      var shortRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  
      hex = hex.replace(shortRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
      });
  
      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    },
    /*
     *  Transforms an hex color an a opacity value to a rgba string
     *  input ->  hex (#FF00FF) and opacity (0.4)
     *  output -> 'rgba(255,0,255,0.4)'
     *
     * @return a string
     */
    hexToRGBA: function hexToRGBA(hex, opacity) {
      function roundToTwo(num) {
        return +(Math.round(num + 'e+2') + 'e-2');
      }
  
      var rgb = this.hexToRGB(hex);
      opacity = opacity != null ? roundToTwo(opacity) : 1;
      if (rgb) {
        return 'rgba(' + [rgb.r, rgb.g, rgb.b, opacity].join(', ') + ')';
      } else {
        return hex;
      }
    },
  
    /*
     *  Strip html tags from a value.
     *  input ->  string with input text (example: '<a href="#whoknows">Jamon</a> </br> <p>Vamos</p>')
     *  allowed -> allowed html tags in the result (example: '<a>')
     *
     *  return -> '<a href="#whoknows">Jamon</a> Vamos'
     */
    stripHTML: function stripHTML(input, allowed) {
      allowed = (((allowed || '') + '').toLowerCase().match(/<[a-z][a-z0-9]*>/g) || []).join('');
      var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi;
      if (!input || typeof input !== 'string') return '';
      return input.replace(tags, function ($0, $1) {
        return allowed.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';
      });
    },
  
    /**
     *  Replace all HTML characters to display HTML content in HTML
     *  <h1>Hello</h1> -> &lt;h1&gt;Hello&lt;/h1&gt; displays '<h1>Hello</h1>'
     *
     */
    escapeHTML: function escapeHTML(str) {
      return _.escape(str);
    },
  
    /**
     *  Remove all non-common characters like spaces, quotes, accents, etc. and
     *  joins strings with underscore symbols
     *
     */
    sanitizeString: function sanitizeString(str) {
      return str.replace(/[^a-z0-9\s]/gi, '').replace(/[_\s]/g, '_');
    },
  
    /**
     *  Returns true is value is a valid number. Based on jQuery isNumeric
     */
    isNumeric: function isNumeric(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    },
  
    /**
     * Formats a number that to include up to 2 decimal positions if less than 10
     * and up to 1 if greater than 10.
     */
    formatDecimalPositions: function formatDecimalPositions(value) {
      // we are using here the unary operator because parseInt fails to handle exponential number
      var converted = +value;
      var p = 0;
      var abs_v;
  
      if (isNaN(converted) || converted === 0) {
        return value;
      }
  
      abs_v = Math.abs(converted);
  
      if (abs_v > 10) {
        p = 1;
      } else if (abs_v > 0.01) {
        p = Math.min(Math.ceil(Math.abs(Math.log(abs_v) / Math.log(10))) + 2, 2);
      }
  
      value = value.toFixed(p);
      var m = value.match(/(\.0+)$/);
      if (m) {
        value = value.replace(m[0], '');
      }
  
      return value;
    },
  
    /**
     *  Remove new lines from string
     *
     */
    removeNewLines: function removeNewLines(str) {
      return str.replace(/(\r\n|\n|\r)/gm, '');
    },
  
    replaceLastSpaceWithNbsp: function replaceLastSpaceWithNbsp(string) {
      var nbsp = '\xA0';
      var lastSpace = string.lastIndexOf(' ');
  
      return string.substr(0, lastSpace) + nbsp + string.substr(lastSpace + 1);
    },
  
    /**
     * Returns true if the string ends with provided suffix
     */
    endsWith: function endsWith(str, suffix) {
      return str.indexOf(suffix, str.length - suffix.length) !== -1;
    },
  
    cloneObject: function cloneObject(obj) {
      if (!obj) {
        return obj;
      }
      return JSON.parse(JSON.stringify(obj));
    },
  
    /**
     *  Capitalize first letter of string
     *
     */
    capitalize: function capitalize(str) {
      if (!str) {
        return str;
      }
      return str.charAt(0).toUpperCase() + str.slice(1);
    },
  
    sanitizeHtml: function sanitizeHtml(text) {
      return cdb.core.sanitize.sanitize(text || '');
    },
  
    /**
     *  Returns true if the value is present
     *
     */
  
    hasValue: function hasValue(value) {
      return value !== null && value !== undefined && value !== '' && !(typeof value === 'number' && isNaN(value));
    },
  
    isValidEmail: function isValidEmail(email) {
      var EMAIL_REGEX = /^([^@]+)@([^@]+)\.([^@\.]+)$/i;
  
      return EMAIL_REGEX.test(email);
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/sql-notifications.js":
  /*!*************************************************************!*\
    !*** ./lib/assets/javascripts/builder/sql-notifications.js ***!
    \*************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Notifier = __webpack_require__(/*! builder/components/notifier/notifier */ "./lib/assets/javascripts/builder/components/notifier/notifier.js");
  
  var NOTIFICATION_ERROR_TEMPLATE = _.template("<span class='CDB-Text u-errorTextColor'><%- title %></span>");
  var NOTIFICATION_PREFIX = 'sql-notifications';
  
  var SQLNotifications = {
    track: function track(view) {
      // In order to not bloat the notification center we will create
      // only one notification, and update it along the way
      this._notificationId = NOTIFICATION_PREFIX;
    },
  
    removeNotification: function removeNotification() {
      Notifier.removeNotification(this._notificationId);
    },
  
    showNotification: function showNotification(attrs) {
      this._addOrUpdateNotification(this._notificationId, attrs);
    },
  
    showErrorNotification: function showErrorNotification(errors) {
      var notificationAttrs = {
        status: 'error',
        info: _t('notifications.sql.error.body', {
          body: NOTIFICATION_ERROR_TEMPLATE({
            title: _t('notifications.sql.error.title')
          }),
          error: this._transformErrors(errors)
        }),
        closable: false
      };
  
      this._addOrUpdateNotification(this._notificationId, notificationAttrs);
    },
  
    _transformErrors: function _transformErrors(errors) {
      return _.map(errors, function (err) {
        return err.message;
      }, this).join('. ');
    },
  
    _addOrUpdateNotification: function _addOrUpdateNotification(notificationId, notificationAttrs) {
      var notification = this._getNotification(notificationId);
      if (notification) {
        notification.set(notificationAttrs);
      } else {
        this._addNotification(notificationId, notificationAttrs);
      }
    },
  
    _addNotification: function _addNotification(notificationId, notificationAttrs) {
      notificationAttrs = _.extend({
        id: notificationId
      }, notificationAttrs);
      Notifier.addNotification(notificationAttrs);
    },
  
    _getNotification: function _getNotification(notificationId) {
      return Notifier.getNotification(notificationId);
    }
  };
  
  module.exports = SQLNotifications;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/builder/value-objects/analysis-node-ids.js":
  /*!***************************************************************************!*\
    !*** ./lib/assets/javascripts/builder/value-objects/analysis-node-ids.js ***!
    \***************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  var SOURCE_ID_REGEX = /^([a-z]+)(\d*)$/; // matches a string with one or more letters + numbers, e.g. 'b2'
  
  var newId = function newId(id, seqChange) {
    if (!id || !id.match) throw new Error('invalid id');
  
    var matches = id.match(SOURCE_ID_REGEX);
    matches[2] = matches[2] || -1;
  
    if (matches && matches.length === 3) {
      // letter + next number
      var letter = matches[1];
      var seq = parseInt(matches[2], 10) + seqChange;
      return letter + Math.max(seq, 0);
    } else {
      throw new Error('invalid id');
    }
  };
  
  /**
   * Encapsulates logic related to the nodes' IDs.
   */
  module.exports = {
  
    /**
     * Get next id in sequence of given source id.
     * @param {String} id, e.g. 'c2'
     * @return {String} e.g. 'c3'
     */
    next: function next(id) {
      return newId(id, 1);
    },
  
    prev: function prev(id) {
      return newId(id, -1);
    },
  
    /**
     * Get the letter representation.
     * @param {String, Object} sourceId or backbone model that have id. e.g. 'c2'
     * @return {String} e.g. 'c' or an empty string if there is no letter in the given id
     */
    letter: function letter(sourceId) {
      if (!sourceId || !_.isString(sourceId)) return '';
      var match = sourceId.match(/^([a-z]+)/);
      return _.isArray(match) && match[0] || '';
    },
  
    /**
     * Get the sequence representation.
     * @param {String, Object} sourceId or backbone model that have id. e.g. 'c2'
     * @return {Number} e.g. 2 or undefined if there is no sequence
     */
    sequence: function sequence(sourceId) {
      if (!sourceId || !_.isString(sourceId)) return;
      var match = sourceId.match(/(\d+$)/);
      return _.isArray(match) && match[0] || undefined;
    },
  
    changeLetter: function changeLetter(id, newLetter) {
      var seq = id.match(/(\d+)$/)[0];
      return newLetter + seq;
    }
  
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/carto-node/index.js":
  /*!****************************************************!*\
    !*** ./lib/assets/javascripts/carto-node/index.js ***!
    \****************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  module.exports = exports = {
    PublicClient: __webpack_require__(/*! ./lib/clients/public */ "./lib/assets/javascripts/carto-node/lib/clients/public.js"),
    AuthenticatedClient: __webpack_require__(/*! ./lib/clients/authenticated */ "./lib/assets/javascripts/carto-node/lib/clients/authenticated.js")
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/carto-node/lib/clients/authenticated.js":
  /*!************************************************************************!*\
    !*** ./lib/assets/javascripts/carto-node/lib/clients/authenticated.js ***!
    \************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
  
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  
  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
  
  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
  
  var PublicClient = __webpack_require__(/*! ./public.js */ "./lib/assets/javascripts/carto-node/lib/clients/public.js");
  
  var AuthenticatedClient = function (_PublicClient) {
    _inherits(AuthenticatedClient, _PublicClient);
  
    function AuthenticatedClient() {
      _classCallCheck(this, AuthenticatedClient);
  
      return _possibleConstructorReturn(this, (AuthenticatedClient.__proto__ || Object.getPrototypeOf(AuthenticatedClient)).apply(this, arguments));
    }
  
    _createClass(AuthenticatedClient, [{
      key: 'getConfig',
      value: function getConfig(callback) {
        var CONFIG_PATH = 'api/v3/me';
  
        return this.get([CONFIG_PATH], callback);
      }
    }, {
      key: 'getVisualization',
      value: function getVisualization(vizUrl, params, callback) {
        var VIZ_API_PATH = 'api/v1/viz';
        var uriParams = this.paramsToURI(params);
  
        return this.get([VIZ_API_PATH, vizUrl, uriParams], callback);
      }
    }, {
      key: 'getDerivedVisualizations',
      value: function getDerivedVisualizations(options, callback) {
        var VIZ_API_PATH = 'api/v1/viz';
        var params = Object.assign({
          type: 'derived',
          privacy: 'public'
        }, options);
  
        var uriParams = this.paramsToURI(params);
  
        return this.get([VIZ_API_PATH, uriParams], callback);
      }
    }, {
      key: 'getMap',
      value: function getMap(mapId, callback) {
        var MAPS_API_PATH = 'api/v1/maps';
  
        return this.get([MAPS_API_PATH, mapId], callback);
      }
    }, {
      key: 'putConfig',
      value: function putConfig(payload, callback) {
        var CONFIG_PATH = 'api/v3/me';
        var opts = {
          data: JSON.stringify(payload),
          dataType: 'json'
        };
        return this.put([CONFIG_PATH], opts, callback);
      }
    }, {
      key: 'deleteUser',
      value: function deleteUser(payload, callback) {
        var CONFIG_PATH = 'api/v3/me';
        var opts = {
          data: JSON.stringify(payload),
          dataType: 'json'
        };
        return this.delete([CONFIG_PATH], opts, callback);
      }
    }, {
      key: 'like',
      value: function like(itemId, callback) {
        var CONFIG_PATH = 'api/v1/viz';
        var opts = {
          dataType: 'json'
        };
        return this.post([CONFIG_PATH, itemId, 'like'], opts, callback);
      }
    }, {
      key: 'deleteLike',
      value: function deleteLike(itemId, callback) {
        var CONFIG_PATH = 'api/v1/viz';
        var opts = {
          dataType: 'json'
        };
        return this.delete([CONFIG_PATH, itemId, 'like'], opts, callback);
      }
    }, {
      key: 'updateNotification',
      value: function updateNotification(userId, apiKey, notification, callback) {
        var CONFIG_PATH = ['/api/v3/users/' + userId + '/notifications/' + notification.id + '?api_key=' + apiKey];
        var opts = {
          data: JSON.stringify({
            notification: notification
          }),
          dataType: 'json'
        };
  
        return this.put(CONFIG_PATH, opts, callback);
      }
    }, {
      key: 'getTags',
      value: function getTags(options, callback) {
        var URIParts = ['api/v3/tags'];
        var URLParameters = {
          q: options.q,
          page: options.page || 1,
          per_page: options.perPage || 6,
          types: options.types || 'derived,table',
          include_shared: options.include_shared || false
        };
  
        var queryOptions = {
          data: URLParameters
        };
  
        return this.get(URIParts, queryOptions, callback);
      }
    }, {
      key: 'previewSearch',
      value: function previewSearch(query, callback) {
        var URIParts = ['api/v3/search_preview'];
        var URLParameters = {
          types: 'derived,table,tag',
          limit: 4
        };
  
        var queryOptions = {
          data: URLParameters
        };
  
        return this.get([URIParts, encodeURIComponent(query)], queryOptions, callback);
      }
    }, {
      key: 'getApiKeys',
      value: function getApiKeys(type, callback) {
        var URIParts = ['api/v3/api_keys'];
        var URLParameters = {
          type: type
        };
  
        var queryOptions = {
          data: URLParameters
        };
  
        return this.get(URIParts, queryOptions, callback);
      }
    }, {
      key: 'getOAuthApps',
      value: function getOAuthApps(apiKey, callback) {
        var CONFIG_PATH = ['api/v4/oauth_apps?api_key=' + apiKey];
  
        return this.get(CONFIG_PATH, callback);
      }
    }, {
      key: 'createApp',
      value: function createApp(apiKey, app, callback) {
        var CONFIG_PATH = ['api/v4/oauth_apps?api_key=' + apiKey];
        var opts = {
          data: JSON.stringify(app),
          dataType: 'json'
        };
        return this.post(CONFIG_PATH, opts, callback);
      }
    }, {
      key: 'updateApp',
      value: function updateApp(apiKey, app, callback) {
        var CONFIG_PATH = ['api/v4/oauth_apps/' + app.id + '?api_key=' + apiKey];
        var opts = {
          data: JSON.stringify(app),
          dataType: 'json'
        };
        return this.put(CONFIG_PATH, opts, callback);
      }
    }, {
      key: 'deleteApp',
      value: function deleteApp(apiKey, app, callback) {
        var CONFIG_PATH = ['api/v4/oauth_apps/' + app.id + '?api_key=' + apiKey];
        var opts = {
          data: JSON.stringify(app),
          dataType: 'json'
        };
        return this.delete(CONFIG_PATH, opts, callback);
      }
    }, {
      key: 'regenerateClientSecret',
      value: function regenerateClientSecret(apiKey, app, callback) {
        var CONFIG_PATH = ['api/v4/oauth_apps/' + app.id + '/regenerate_secret?api_key=' + apiKey];
        var opts = {
          data: JSON.stringify(app),
          dataType: 'json'
        };
        return this.post(CONFIG_PATH, opts, callback);
      }
    }, {
      key: 'uploadLogo',
      value: function uploadLogo(apiKey, userId, filename, callback) {
        var CONFIG_PATH = ['api/v1/users/' + userId + '/assets?api_key=' + apiKey];
  
        var data = new FormData();
        data.append('kind', 'orgavatar');
        data.append('filename', filename);
  
        var opts = {
          data: data,
          doNoSetDefaultContentType: true,
          processData: false
        };
  
        return this.post(CONFIG_PATH, opts, callback);
      }
    }, {
      key: 'getConnectedApps',
      value: function getConnectedApps(apiKey, callback) {
        var CONFIG_PATH = ['api/v4/granted_oauth_apps?api_key=' + apiKey];
  
        return this.get(CONFIG_PATH, callback);
      }
    }, {
      key: 'revokeOAuthApp',
      value: function revokeOAuthApp(apiKey, app, callback) {
        var CONFIG_PATH = ['api/v4/oauth_apps/' + app.id + '/revoke?api_key=' + apiKey];
        var opts = {
          data: JSON.stringify(app),
          dataType: 'json'
        };
        return this.post(CONFIG_PATH, opts, callback);
      }
    }]);
  
    return AuthenticatedClient;
  }(PublicClient);
  
  module.exports = AuthenticatedClient;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/carto-node/lib/clients/public.js":
  /*!*****************************************************************!*\
    !*** ./lib/assets/javascripts/carto-node/lib/clients/public.js ***!
    \*****************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
  
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  
  window.StaticConfig = window.StaticConfig || {};
  
  var PublicClient = function () {
    function PublicClient() {
      var apiURI = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  
      _classCallCheck(this, PublicClient);
  
      this.apiURI = apiURI;
    }
  
    _createClass(PublicClient, [{
      key: 'get',
      value: function get() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
  
        return this.request.apply(this, ['get'].concat(args));
      }
    }, {
      key: 'put',
      value: function put() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
  
        return this.request.apply(this, ['put'].concat(args));
      }
    }, {
      key: 'post',
      value: function post() {
        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
  
        return this.request.apply(this, ['post'].concat(args));
      }
    }, {
      key: 'delete',
      value: function _delete() {
        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
  
        return this.request.apply(this, ['delete'].concat(args));
      }
    }, {
      key: 'addHeaders',
      value: function addHeaders(obj, additional) {
        return Object.assign({}, obj.headers, additional);
      }
    }, {
      key: 'paramsToURI',
      value: function paramsToURI(params) {
        var DEFAULT_PARAMS = '';
  
        return this.checkParams(params) ? '?' + Object.keys(params).map(function (key) {
          return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);
        }).join('&') : DEFAULT_PARAMS;
      }
    }, {
      key: 'checkParams',
      value: function checkParams(params) {
        var OBJECT_TYPE = '[object Object]';
  
        return params && Object.prototype.toString.call(params) === OBJECT_TYPE && Object.keys(params).length;
      }
    }, {
      key: 'makeRelativeURI',
      value: function makeRelativeURI(parts) {
        return '/' + parts.join('/');
      }
    }, {
      key: 'makeAbsoluteURI',
      value: function makeAbsoluteURI(relativeURI) {
        return '' + this.apiURI + relativeURI;
      }
    }, {
      key: 'successCallback',
      value: function successCallback(callback) {
        return function (data, textStatus, jqXHR) {
          try {
            data = JSON.parse(JSON.stringify(data));
          } catch (e) {
            data = null;
          }
  
          callback(null, textStatus, data);
        };
      }
    }, {
      key: 'errorCallback',
      value: function errorCallback(callback) {
        return function (jqXHR, textStatus, errorThrown) {
          var err = errorThrown || new Error('Failed to fetch');
          callback(err, textStatus, jqXHR);
        };
      }
    }, {
      key: 'getAssetsBaseUrl',
      value: function getAssetsBaseUrl() {
        var _window$location = window.location,
            host = _window$location.host,
            protocol = _window$location.protocol;
  
  
        var regExp = window.location.href.match(/(\/(u|user)\/[a-z0-9\-]+)\//);
        var path = regExp && regExp[1] || '';
  
        return window.StaticConfig.baseUrl || protocol + '//' + host + path;
      }
    }, {
      key: 'request',
      value: function request(method, uriParts) {
        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var callback = arguments[3];
  
        if (!callback && typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
  
        var contentType = opts.doNoSetDefaultContentType ? false : 'application/json; charset=utf-8';
  
        Object.assign(opts, {
          contentType: contentType,
          method: method.toUpperCase()
        });
  
        this.addHeaders(opts);
  
        var baseUrl = opts.baseUrl || this.getAssetsBaseUrl();
        var url = uriParts.length !== 0 ? this.makeAbsoluteURI(this.makeRelativeURI(uriParts)) : '';
  
        var requestOptions = Object.assign({}, opts, {
          success: this.successCallback(callback),
          error: this.errorCallback(callback)
        });
  
        $.ajax('' + baseUrl + url, requestOptions);
      }
    }]);
  
    return PublicClient;
  }();
  
  module.exports = exports = PublicClient;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/common/upload-config.js":
  /*!******************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/common/upload-config.js ***!
    \******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  /**
   *  Default upload config
   *
   */
  
  module.exports = {
    uploadStates: ['enqueued', 'pending', 'importing', 'uploading', 'guessing', 'unpacking', 'getting', 'creating', 'complete'],
    fileExtensions: ['csv', 'xls', 'xlsx', 'zip', 'kml', 'geojson', 'json', 'ods', 'kmz', 'tsv', 'gpx', 'tar', 'gz', 'tgz', 'osm', 'bz2', 'tif', 'tiff', 'txt', 'sql', 'rar', 'carto', 'gpkg'],
    // How big should file be?
    fileTimesBigger: 3
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/common/wkt.js":
  /*!********************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/common/wkt.js ***!
    \********************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  module.exports = {
    types: ['POINT', 'LINESTRING', 'POLYGON', 'MULTIPOINT', 'MULTILINESTRING', 'MULTIPOLYGON']
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/avatar-selector/avatar-selector-view.js":
  /*!*********************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/avatar-selector/avatar-selector-view.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var IconSelectorView = __webpack_require__(/*! dashboard/components/icon-selector/icon-selector-view */ "./lib/assets/javascripts/dashboard/components/icon-selector/icon-selector-view.js");
  var template = __webpack_require__(/*! ./avatar-selector.tpl */ "./lib/assets/javascripts/dashboard/components/avatar-selector/avatar-selector.tpl");
  
  module.exports = IconSelectorView.extend({
    options: {
      acceptedExtensions: ['jpeg', 'jpg', 'png', 'gif'],
      imageKind: 'orgavatar',
      imageURLAttribute: 'avatar_url'
    },
  
    render: function render() {
      this._destroyFileInput();
      this.clearSubViews();
  
      this.$el.html(template({
        state: this._model.get('state'),
        name: this._renderModel.get('name'),
        inputName: this._renderModel.get('inputName'),
        avatarURL: this._renderModel.get('avatar_url'),
        username: this._renderModel.get('username'),
        avatarAcceptedExtensions: this._formatAcceptedExtensions(this.options.acceptedExtensions)
      }));
  
      this._renderFileInput();
      return this;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/create-fallback-map.js":
  /*!****************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/create-fallback-map.js ***!
    \****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  /* global google */
  var L = __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js");
  var NEW_YORK = [40.7127837, -74.0059413];
  
  /**
   * Creates a default fallback map, to be used when an user doesn't have a public map.
   *
   * @param opts {Object} config
   *   el: {HTMLElement} an HTMLElement node where to draw the map
   */
  module.exports = function (opts) {
    if (opts.basemap.urlTemplate) {
      var map = L.map(opts.el, {
        zoomControl: false,
        minZoom: 6,
        maxZoom: 6,
        scrollWheelZoom: false
      });
  
      map.setView(NEW_YORK, 6);
  
      map.dragging.disable();
      map.touchZoom.disable();
      map.doubleClickZoom.disable();
  
      map.attributionControl.setPrefix('');
  
      var url = opts.basemap.urlTemplate;
  
      if (window.devicePixelRatio > 1) {
        url = opts.basemap.urlTemplate2x || url;
      }
  
      L.tileLayer(url, {
        attribution: opts.basemap.attribution
      }).addTo(map);
    } else if (opts.basemap.className === 'googlemaps' && google.maps !== undefined) {
      var _map = new google.maps.Map(opts.el, { // eslint-disable-line
        center: { lat: NEW_YORK[0], lng: NEW_YORK[1] },
        zoom: 6,
        draggable: false,
        scrollwheel: false,
        panControl: false,
        zoomControl: false,
        streetViewControl: false,
        maxZoom: 6,
        minZoom: 6,
        mapTypeControl: false,
        mapTypeId: opts.basemap.baseType || google.maps.MapTypeId.ROADMAP,
        styles: [{
          featureType: 'all',
          elementType: 'labels',
          stylers: [{ visibility: 'off' }]
        }, {
          featureType: 'road',
          elementType: 'geometry',
          stylers: [{ visibility: 'off' }]
        }, {
          featureType: 'administrative',
          elementType: 'geometry.stroke',
          stylers: [{ visibility: 'off' }]
        }]
      });
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/dashboard-header-view.js":
  /*!******************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/dashboard-header-view.js ***!
    \******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var logoTemplate = __webpack_require__(/*! ./dashboard-header/logo.tpl */ "./lib/assets/javascripts/dashboard/components/dashboard-header/logo.tpl");
  var dropdownLinkTemplate = __webpack_require__(/*! ./dashboard-header/breadcrumbs/dropdown-link.tpl */ "./lib/assets/javascripts/dashboard/components/dashboard-header/breadcrumbs/dropdown-link.tpl");
  var SettingsDropdownView = __webpack_require__(/*! ./dashboard-header/settings-dropdown-view */ "./lib/assets/javascripts/dashboard/components/dashboard-header/settings-dropdown-view.js");
  var BreadcrumbsDropdown = __webpack_require__(/*! ./dashboard-header/breadcrumbs/dropdown-view */ "./lib/assets/javascripts/dashboard/components/dashboard-header/breadcrumbs/dropdown-view.js");
  var UserNotificationsView = __webpack_require__(/*! ./dashboard-header/notifications/user-notifications-view */ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/user-notifications-view.js");
  
  var REQUIRED_OPTS = ['viewModel', 'configModel'];
  
  /**
   * Responsible for the header part of the layout.
   * It's currently pre-rendered server-side, why the header element is required to be given when instantiating the view.
   */
  module.exports = CoreView.extend({
    events: {
      'click .js-breadcrumb-dropdown': '_createBreadcrumbsDropdown',
      'click .js-settings-dropdown': '_createSettingsDropdown'
    },
  
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      if (!this.options.el) {
        throw new Error('el element is required');
      }
  
      this.router = this.options.router;
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
  
      this._renderBreadcrumbsDropdownLink();
      this._renderNotifications();
      this._renderLogoLink();
  
      return this;
    },
  
    _initBinds: function _initBinds() {
      this._viewModel.bind('change', this._renderBreadcrumbsDropdownLink, this);
      this.listenTo(this._viewModel, 'change', this._renderBreadcrumbsDropdownLink);
  
      if (this.router) {
        this.listenTo(this.router.model, 'change', this._onRouterChange);
      }
      if (this.collection) {
        this.listenTo(this.collection, 'reset', this._stopLogoAnimation);
        this.listenTo(this.collection, 'error', this._onCollectionError);
      }
    },
  
    _onCollectionError: function _onCollectionError(col, e, opts) {
      // Old requests can be stopped, so aborted requests are not
      // considered as an error
      if (!e || e && e.statusText !== 'abort') {
        this._stopLogoAnimation();
      }
    },
  
    // TODO: Not sure if the changes made here are correct, because of backbone version changes
    _onRouterChange: function _onRouterChange(m, c) {
      if (m.changed && !m.changed.content_type && this.collection.total_user_entries > 0) {
        this._startLogoAnimation();
      }
    },
  
    _startLogoAnimation: function _startLogoAnimation() {
      this.$('.Logo').addClass('is-loading');
    },
  
    _stopLogoAnimation: function _stopLogoAnimation() {
      this.$('.Logo').removeClass('is-loading');
    },
  
    _renderBreadcrumbsDropdownLink: function _renderBreadcrumbsDropdownLink() {
      this.$('.js-breadcrumb-dropdown').html(dropdownLinkTemplate({
        title: this._viewModel.breadcrumbTitle(),
        dropdownEnabled: this._viewModel.isBreadcrumbDropdownEnabled()
      }));
    },
  
    _renderNotifications: function _renderNotifications() {
      var userNotifications = new UserNotificationsView({
        user: this.model,
        configModel: this._configModel,
        organizationNotifications: this.options.organizationNotifications
      });
  
      this.$('.js-user-notifications').html(userNotifications.render().el);
      this.addView(userNotifications);
    },
  
    _renderLogoLink: function _renderLogoLink() {
      this.$('.js-logo').html(logoTemplate({
        homeUrl: this.model.viewUrl().dashboard(),
        googleEnabled: this.model.featureEnabled('google_maps')
      }));
    },
  
    _createSettingsDropdown: function _createSettingsDropdown(event) {
      this.killEvent(event);
  
      this._setupDropdown(new SettingsDropdownView({
        target: $(event.target),
        model: this.model, // a user model
        configModel: this._configModel,
        horizontalOffset: 15
      }));
    },
  
    _createBreadcrumbsDropdown: function _createBreadcrumbsDropdown(ev) {
      if (this._viewModel.isBreadcrumbDropdownEnabled()) {
        this.killEvent(ev);
        this._setupDropdown(new BreadcrumbsDropdown({
          target: $(ev.target),
          model: this.model,
          viewModel: this._viewModel,
          router: this.router, // optional
          tick: 'center',
          template: __webpack_require__(/*! dashboard/components/dashboard-header/breadcrumbs/dropdown.tpl */ "./lib/assets/javascripts/dashboard/components/dashboard-header/breadcrumbs/dropdown.tpl"),
          horizontalOffset: this.options.breadcrumbsDropdownOffset
        }));
      }
    },
  
    _setupDropdown: function _setupDropdown(dropdownView) {
      this._closeAnyOtherOpenDialogs();
      this._previousDropDown = dropdownView;
      this.addView(dropdownView);
  
      dropdownView.on('onDropdownHidden', function () {
        dropdownView.clean();
      }, this);
  
      dropdownView.render();
      dropdownView.open();
    },
  
    _closeAnyOtherOpenDialogs: function _closeAnyOtherOpenDialogs() {
      // TODO: This is not how it used to work, it used to listen to a global event
      if (this._previousDropDown) {
        this._previousDropDown.hide();
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/dashboard-header/breadcrumbs/dropdown-view.js":
  /*!***************************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/dashboard-header/breadcrumbs/dropdown-view.js ***!
    \***************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var navigateThroughRouter = __webpack_require__(/*! builder/helpers/navigate-through-router */ "./lib/assets/javascripts/builder/helpers/navigate-through-router.js");
  var AdminDropdownMenu = __webpack_require__(/*! dashboard/components/dropdown/dropdown-admin-view */ "./lib/assets/javascripts/dashboard/components/dropdown/dropdown-admin-view.js");
  
  var REQUIRED_OPTS = ['viewModel'];
  
  /**
   * The content of the dropdown menu opened by the link at the end of the breadcrumbs menu, e.g.
   *   username > [Maps]
   *          ______/\____
   *         |            |
   *         |    this    |
   *         |____________|
   */
  
  module.exports = AdminDropdownMenu.extend({
    className: 'Dropdown BreadcrumbsDropdown',
  
    events: {
      'click a': '_navigateToLinksHref'
    },
  
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
      AdminDropdownMenu.prototype.initialize.apply(this, arguments);
    },
  
    render: function render() {
      var dashboardUrl = this.model.viewUrl().dashboard();
      var datasetsUrl = dashboardUrl.datasets();
      var deepInsightsUrl = dashboardUrl.deepInsights();
      var mapsUrl = dashboardUrl.maps();
  
      this.$el.html(this.template({
        avatarUrl: this.model.get('avatar_url'),
        userName: this.model.get('username'),
        mapsUrl: mapsUrl,
        datasetsUrl: datasetsUrl,
        deepInsightsUrl: deepInsightsUrl,
        lockedDatasetsUrl: datasetsUrl.lockedItems(),
        lockedMapsUrl: mapsUrl.lockedItems(),
        isDeepInsights: this._viewModel.isDisplayingDeepInsights(),
        isDatasets: this._viewModel.isDisplayingDatasets(),
        isMaps: this._viewModel.isDisplayingMaps(),
        isLocked: this._viewModel.isDisplayingLockedItems()
      }));
  
      // Necessary to hide dialog on click outside popup, for example.
      // TODO: Handle this
      // cdb.god.bind('closeDialogs', this.hide, this);
  
      // TODO: taken from existing code, how should dropdowns really be added to the DOM?
      $('body').append(this.el);
  
      return this;
    },
  
    _navigateToLinksHref: function _navigateToLinksHref() {
      this.hide(); // Hide must be called before routing for proper deconstruct of dropdown
  
      if (this.options.router) {
        navigateThroughRouter.apply(this, arguments);
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/dropdown-view.js":
  /*!*****************************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/dropdown-view.js ***!
    \*****************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var ScrollView = __webpack_require__(/*! builder/components/scroll/scroll-view */ "./lib/assets/javascripts/builder/components/scroll/scroll-view.js");
  var ViewFactory = __webpack_require__(/*! builder/components/view-factory */ "./lib/assets/javascripts/builder/components/view-factory.js");
  var AdminDropdownMenu = __webpack_require__(/*! dashboard/components/dropdown/dropdown-admin-view */ "./lib/assets/javascripts/dashboard/components/dropdown/dropdown-admin-view.js");
  var template = __webpack_require__(/*! ./templates/dropdown-content.tpl */ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/templates/dropdown-content.tpl");
  
  /**
   * User notifications dropdown, rendering notifications
   * from the collection
   */
  
  module.exports = AdminDropdownMenu.extend({
    className: 'Dropdown',
  
    initialize: function initialize(options) {
      AdminDropdownMenu.prototype.initialize.apply(this, arguments);
  
      this._initBinds();
    },
  
    render: function render() {
      this.clearSubViews();
  
      this.$el.html(this.template());
      this._renderDropdown();
      this._checkScroll();
  
      $('body').append(this.el);
  
      return this;
    },
  
    _renderDropdown: function _renderDropdown() {
      this.dropdown_content = ViewFactory.createByTemplate(template, {
        items: this.collection.toJSON(),
        unreadItems: this.collection.filter(function (item) {
          return !item.get('opened');
        }).length
      });
      this.addView(this.dropdown_content);
  
      this.$('.js-content').html(this.dropdown_content.render().el);
    },
  
    _checkScroll: function _checkScroll() {
      // we need to wait until dropdown has appeared,
      // then if it is taller than 300px we wrap the content in a ScrollView,
      // this is a fix for IE11, which needs a fixed height when using flex in a child element
      setTimeout(function () {
        if (this.$el.height() >= 300) {
          var view = new ScrollView({
            createContentView: function () {
              return this.dropdown_content;
            }.bind(this)
          });
          this.addView(view);
  
          this.$el.addClass('Dropdown--withScroll');
          this.$('.js-content').html(view.render().el);
        }
      }.bind(this), 301);
    },
  
    _initBinds: function _initBinds() {
      // TODO: Handle event
      // cdb.god.bind('closeDialogs', this.hide, this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/notifications-collection.js":
  /*!****************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/notifications-collection.js ***!
    \****************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var UserNotificationModel = __webpack_require__(/*! ./user-notification-model */ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/user-notification-model.js");
  var OrganizationNotificationModel = __webpack_require__(/*! ./organization-notification-model */ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/organization-notification-model.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel'];
  
  /**
   *  User notification default collection, it will
   *  require the user notification model
   */
  
  module.exports = Backbone.Collection.extend({
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
    },
  
    model: function model(attrs, options) {
      return attrs.type === 'org_notification' ? new OrganizationNotificationModel(attrs, _extends({}, options, {
        configModel: options.collection._configModel
      })) : new UserNotificationModel(attrs);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/organization-notification-model.js":
  /*!***********************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/organization-notification-model.js ***!
    \***********************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var UserNotificationModel = __webpack_require__(/*! ./user-notification-model */ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/user-notification-model.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['userId', 'configModel', 'apiKey'];
  
  /**
   *  User notification default model
   */
  
  module.exports = UserNotificationModel.extend({
    url: function url() {
      return '/api/v3/users/' + this._userId + '/notifications/' + this.id + '?api_key=' + this._apiKey;
    },
  
    initialize: function initialize(attrs, opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
    },
  
    markAsRead: function markAsRead() {
      this.save({
        notification: {
          read_at: new Date()
        }
      });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/user-notification-model.js":
  /*!***************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/user-notification-model.js ***!
    \***************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   *  User notification default model
   */
  
  module.exports = Backbone.Model.extend({
    defaults: {
      type: '',
      message: '',
      opened: false
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/user-notifications-view.js":
  /*!***************************************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/user-notifications-view.js ***!
    \***************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var UserNotificationsCollection = __webpack_require__(/*! ./notifications-collection */ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/notifications-collection.js");
  var NotificationsDropdown = __webpack_require__(/*! ./dropdown-view */ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/dropdown-view.js");
  var template = __webpack_require__(/*! ./templates/user-notifications.tpl */ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/templates/user-notifications.tpl");
  var dropdownTemplate = __webpack_require__(/*! ./templates/dropdown.tpl */ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/templates/dropdown.tpl");
  var LocalStorage = __webpack_require__(/*! ../../../helpers/local-storage */ "./lib/assets/javascripts/dashboard/helpers/local-storage.js");
  var checkAndBuildOpts = __webpack_require__(/*! ../../../../builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var TEMPLATES = {
    tryTrial: __webpack_require__(/*! ./templates/try-trial.tpl */ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/templates/try-trial.tpl"),
    limitsExceeded: __webpack_require__(/*! ./templates/limits-exceeded.tpl */ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/templates/limits-exceeded.tpl"),
    closeLimits: __webpack_require__(/*! ./templates/close-limits.tpl */ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/templates/close-limits.tpl"),
    upgradedMessage: __webpack_require__(/*! ./templates/upgraded-message.tpl */ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/templates/upgraded-message.tpl"),
    trialEndsSoon: __webpack_require__(/*! ./templates/trial-ends-soon.tpl */ "./lib/assets/javascripts/dashboard/components/dashboard-header/notifications/templates/trial-ends-soon.tpl")
  };
  
  var REQUIRED_OPTS = ['configModel', 'user'];
  
  /**
   *  User notifactions view used to show alerts from the application
   *
   *  In storage we will check these attributes, managed by a collection:
   *
   *  try_trial       -> trial_end_at is null && user is not paid user
   *  limits_exceeded -> check table quota size
   *  close_limits    -> check table quota size < 80%
   *  upgraded        -> check upgraded_at less than one week
   *  trial_ends_soon -> trial_end_at is not null and it is close to be finished
   *  new_dashboard   -> new dashboard
   *  notification    -> check notification
   *
   */
  
  module.exports = CoreView.extend({
  
    attributes: {
      href: '#/notifications'
    },
  
    tagName: 'a',
    className: 'UserNotifications',
  
    events: {
      'click': '_openNotifications'
    },
  
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      this.localStorage = new LocalStorage();
      this.collection = new UserNotificationsCollection({
        configModel: options.configModel
      });
      this.collection.reset(this._generateCollection(), {
        userId: this._user.get('id'),
        apiKey: this._user.get('api_key'),
        silent: true
      });
  
      this._initBinds();
    },
  
    render: function render() {
      var notificationsCount = this.collection.filter(function (item) {
        return !item.get('opened');
      }).length;
  
      this.$el.html(template({
        notificationsCount: notificationsCount
      }));
  
      this.$el.toggleClass('has--alerts', notificationsCount > 0);
  
      return this;
    },
  
    _initBinds: function _initBinds() {
      this._user.bind('change', this._onUserChange, this);
      this.collection.bind('reset', this.render, this);
      this.collection.bind('remove', this.render, this);
      this.add_related_model(this._user);
      this.add_related_model(this.collection);
    },
  
    _onUserChange: function _onUserChange() {
      // When api is ready, we will make a valid fetch :)
      this.collection.reset(this._generateCollection(), {
        userId: this._user.get('id'),
        apiKey: this._user.get('api_key')
      });
      this.render();
    },
  
    // This method will check notifications and create a collection with them
    // Also it will check if those have been opened or not with Local Storage.
    _generateCollection: function _generateCollection() {
      var arr = [];
      var data = {}; // data
      var userUrl = this._user.viewUrl();
      var comHosted = this._configModel.get('cartodb_com_hosted');
  
      data.isInsideOrg = this._user.isInsideOrg();
      data.isOrgOwner = this._user.isOrgOwner();
      data.accountType = this._user.get('account_type').toLowerCase();
      data.remainingQuota = this._user.get('remaining_byte_quota');
      data.publicProfileUrl = userUrl.publicProfile();
      data.bytesQuota = this._user.get('quota_in_bytes');
      data.userType = 'regular';
      data.upgradeUrl = window.upgrade_url || '';
      data.upgradeContactEmail = this._user.upgradeContactEmail();
      data.trialEnd = this._user.get('trial_ends_at') && moment(this._user.get('trial_ends_at')).format('YYYY-MM-DD');
      data.userName = this._user.get('name') || this._user.get('username');
  
      // Get user type
      if (data.isInsideOrg && !data.isOrgOwner) {
        data.userType = 'org';
      } else if (data.isOrgOwner) {
        data.userType = 'admin';
      } else if (data.accountType === 'internal' || data.accountType === 'partner' || data.accountType === 'ambassador') {
        data.userType = 'internal';
      }
  
      // try_trial -> trial_end_at is null && user is not paid user
      if (!comHosted && !data.isInsideOrg && data.accountType === 'free' && this._user.get('table_count') > 0) {
        arr.push({
          iconFont: 'CDB-IconFont-gift',
          severity: 'NotificationsDropdown-itemIcon--positive',
          type: 'try_trial',
          msg: TEMPLATES.tryTrial(data),
          opened: this.localStorage.get('notification.try_trial')
        });
      } else {
        this.localStorage.remove('notification.try_trial');
      }
  
      // limits_exceeded -> check table quota size
      if (!comHosted && data.bytesQuota > 0 && data.remainingQuota <= 0) {
        arr.push({
          iconFont: 'CDB-IconFont-barometer',
          severity: 'NotificationsDropdown-itemIcon--negative',
          type: 'limits_exceeded',
          msg: TEMPLATES.limitsExceeded(data),
          opened: this.localStorage.get('notification.limits_exceeded')
        });
      } else {
        this.localStorage.remove('notification.limits_exceeded');
      }
  
      // close_limits -> check table quota size < 80%
      if (!comHosted && data.bytesQuota > 0 && data.remainingQuota * 100 / data.bytesQuota < 20) {
        arr.push({
          iconFont: 'CDB-IconFont-barometer',
          severity: 'NotificationsDropdown-itemIcon--alert',
          type: 'close_limits',
          msg: TEMPLATES.closeLimits(data),
          opened: this.localStorage.get('notification.close_limits')
        });
      } else {
        this.localStorage.remove('notification.close_limits');
      }
  
      // upgraded -> check upgraded_at less than ... one week?
      if (!comHosted && this._user.get('show_upgraded_message')) {
        arr.push({
          iconFont: 'CDB-IconFont-heartFill',
          severity: 'NotificationsDropdown-itemIcon--positive',
          type: 'upgraded_message',
          msg: TEMPLATES.upgradedMessage(data),
          opened: this.localStorage.get('notification.upgraded_message')
        });
      } else {
        this.localStorage.remove('notification.upgraded_message');
      }
  
      // trial_ends_soon -> show_trial_reminder flag
      if (this._user.get('show_trial_reminder')) {
        arr.push({
          iconFont: 'CDB-IconFont-clock',
          severity: 'NotificationsDropdown-itemIcon--alert',
          type: 'trial_ends_soon',
          msg: TEMPLATES.trialEndsSoon(data),
          opened: this.localStorage.get('notification.trial_ends_soon')
        });
      } else {
        this.localStorage.remove('notification.trial_ends_soon');
      }
  
      var organizationNotifications = window.organization_notifications || this.options.organizationNotifications;
  
      if (organizationNotifications) {
        for (var n = 0; n < organizationNotifications.length; n++) {
          var notification = organizationNotifications[n];
          var icon = notification.icon ? 'CDB-IconFont-' + notification.icon : 'CDB-IconFont-alert';
  
          arr.push({
            iconFont: icon,
            severity: 'NotificationsDropdown-itemIcon--alert',
            id: notification.id,
            msg: notification.html_body,
            read_at: notification.read_at,
            type: 'org_notification'
          });
        }
      }
  
      return arr;
    },
  
    _openNotifications: function _openNotifications(event) {
      var _this = this;
  
      if (event) this.killEvent(event);
  
      if (this.notification) {
        this.notification.hide();
        delete this.notification;
        return this;
      }
  
      var view = this.notification = new NotificationsDropdown({
        target: this.$el,
        collection: this.collection,
        horizontal_offset: 5,
        vertical_offset: -5,
        template: dropdownTemplate
      });
  
      $(view.options.target).unbind('click', view._handleClick);
      this._closeAnyOtherOpenDialogs();
  
      view.on('onDropdownHidden', function () {
        return _this._onDropdownHidden(view);
      });
  
      view.render();
      view.open();
  
      this.addView(view);
    },
  
    _onDropdownHidden: function _onDropdownHidden(view) {
      var _this2 = this;
  
      // All notifications have been seen, opened -> true
      this.collection.each(function (notification) {
        var notificationType = notification.get('type');
  
        if (notificationType === 'org_notification') {
          notification.markAsRead();
        } else if (notificationType) {
          notification.set('opened', true);
          _this2.localStorage.set(_defineProperty({}, 'notification.' + notificationType, true));
        }
      });
  
      // Clean collection because all notifications should
      // removed from the collection
      this.collection.reset();
  
      // Clean dropdown
      view.clean();
      // Remove it from subviews
      this.removeView(view);
      // Remove count
      this.$el.removeClass('has--alerts');
      // No local notification set
      delete this.notification;
    },
  
    _closeAnyOtherOpenDialogs: function _closeAnyOtherOpenDialogs() {
      // cdb.god.trigger("closeDialogs"); TODO: handle event
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/dashboard-header/settings-dropdown-view.js":
  /*!************************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/dashboard-header/settings-dropdown-view.js ***!
    \************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var DropdownAdminView = __webpack_require__(/*! dashboard/components/dropdown/dropdown-admin-view */ "./lib/assets/javascripts/dashboard/components/dropdown/dropdown-admin-view.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var template = __webpack_require__(/*! ./settings-dropdown.tpl */ "./lib/assets/javascripts/dashboard/components/dashboard-header/settings-dropdown.tpl");
  
  var REQUIRED_OPTS = ['model', 'configModel'];
  
  /**
   * The content of the dropdown menu opened by the user avatar in the top-right of the header, e.g.:
   *   Explore, Learn, 
   *             ______/\____
   *            |            |
   *            |    this    |
   *            |____________|
   */
  
  module.exports = DropdownAdminView.extend({
    className: 'Dropdown',
  
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
      DropdownAdminView.prototype.initialize.apply(this, arguments);
    },
  
    shortDisplayName: function shortDisplayName(user) {
      // This changes should also be done in Central, ./app/assets/javascripts/dashboard/users/views/user_avatar.js
      var accountTypeDisplayName = user.get('account_type_display_name');
      var displayName = _.isUndefined(accountTypeDisplayName) ? user.get('account_type') : accountTypeDisplayName;
  
      if (_.isUndefined(displayName)) {
        return displayName;
      }
  
      displayName = displayName.toLowerCase();
  
      if (displayName === 'organization user') {
        return 'org. user';
      } else {
        return displayName.replace(/lump-sum/gi, '- A').replace(/academic/gi, 'aca.').replace(/ - Monthly/i, ' - M').replace(/ - Annual/i, ' - A').replace(/Non-Profit/i, 'NP').replace(/On-premises/i, 'OP').replace(/Internal use engine/i, 'engine').replace(/Lite/i, 'L').replace(/Cloud Engine &/i, 'C. Engine &').replace(/& Enterprise Builder/i, '& E. Builder').replace(/CARTO for /i, '').replace(/CARTO /i, '');
      }
    },
  
    render: function render() {
      var user = this.model;
      var usedDataBytes = user.get('db_size_in_bytes');
      var quotaInBytes = user.get('quota_in_bytes');
      var usedDataPct = Math.round(usedDataBytes / quotaInBytes * 100);
      var progressBarClass = '';
  
      if (usedDataPct > 80 && usedDataPct < 90) {
        progressBarClass = 'is--inAlert';
      } else if (usedDataPct > 89) {
        progressBarClass = 'is--inDanger';
      }
  
      var accountType = this.shortDisplayName(user);
  
      var userUrl = this.model.viewUrl();
      var upgradeUrl = window.upgrade_url || this._configModel.get('upgrade_url') || '';
  
      this.$el.html(template({
        name: user.fullName() || user.get('username'),
        email: user.get('email'),
        accountType: accountType,
        isOrgAdmin: user.isOrgAdmin(),
        usedDataStr: Utils.readablizeBytes(usedDataBytes),
        usedDataPct: usedDataPct,
        progressBarClass: progressBarClass,
        availableDataStr: Utils.readablizeBytes(quotaInBytes),
        showUpgradeLink: upgradeUrl && (user.isOrgOwner() || !user.isInsideOrg()) && !this._configModel.get('cartodb_com_hosted'),
        upgradeUrl: upgradeUrl,
        publicProfileUrl: userUrl.publicProfile(),
        apiKeysUrl: userUrl.apiKeys(),
        organizationUrl: userUrl.organization(),
        accountProfileUrl: userUrl.accountProfile(),
        logoutUrl: userUrl.logout(),
        isViewer: user.isViewer(),
        isBuilder: user.isBuilder(),
        orgDisplayEmail: user.isInsideOrg() ? user.organization.display_email : null,
        engineEnabled: user.get('actions').engine_enabled,
        mobileAppsEnabled: user.get('actions').mobile_sdk_enabled
      }));
  
      // Necessary to hide dialog on click outside popup, for example.
      // TODO: Handle closeDialogs
      // cdb.god.bind('closeDialogs', this.hide, this);
  
      // TODO: taken from existing code, how should dropdowns really be added to the DOM?
      $('body').append(this.el);
  
      return this;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/delete-account/delete-account-view.js":
  /*!*******************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/delete-account/delete-account-view.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./delete-account.tpl */ "./lib/assets/javascripts/dashboard/components/delete-account/delete-account.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['modalModel', 'userModel', 'client'];
  
  /**
   *  When user wants to delete his own account
   */
  
  module.exports = CoreView.extend({
    events: {
      'click .js-ok': '_onClickDelete',
      'click .js-cancel': '_closeDialog',
      'submit .js-form': '_closeDialog'
    },
  
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
      CoreView.prototype.initialize.apply(this);
  
      this._onError = options.onError;
      this._error = '';
  
      this._isLoading = false;
    },
  
    render: function render() {
      this.$el.html(template({
        passwordNeeded: !!this._userModel.get('needs_password_confirmation'),
        isLoading: this._isLoading,
        error: this._error
      }));
  
      return this;
    },
  
    _onClickDelete: function _onClickDelete(event) {
      var _this = this;
  
      this.killEvent(event);
  
      var params = {
        deletion_password_confirmation: this.$('#deletion_password_confirmation').val()
      };
  
      this._isLoading = true;
      this._error = '';
  
      this.render();
  
      this._client.deleteUser(params, function (errors, response, data) {
        _this._isLoading = false;
        _this.render();
  
        if (errors) {
          _this._handleError(data, errors);
        } else {
          _this._onSuccess(data);
        }
      });
    },
  
    _handleError: function _handleError(data, errors) {
      if (this._onError) {
        this._closeDialog();
        this._onError(data, errors);
      } else {
        var jsonData = data && data.responseJSON || {};
  
        this._error = jsonData.message;
        this.render();
      }
    },
  
    _setHref: function _setHref(href) {
      window.location.href = href;
    },
  
    _onSuccess: function _onSuccess(data) {
      this._setHref(data.logout_url);
      this._closeDialog();
    },
  
    _onFormError: function _onFormError(data, errors) {
      this._onError(data, errors);
      this._closeDialog();
    },
  
    _closeDialog: function _closeDialog() {
      this._modalModel.destroy();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/dropdown/dropdown-admin-view.js":
  /*!*************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/dropdown/dropdown-admin-view.js ***!
    \*************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var DropdownBaseView = __webpack_require__(/*! ./dropdown-base-view */ "./lib/assets/javascripts/dashboard/components/dropdown/dropdown-base-view.js");
  
  module.exports = DropdownBaseView.extend({
  
    show: function show() {
      var dfd = $.Deferred();
      var self = this;
      // sometimes this dialog is child of a node that is removed
      // for that reason we link again DOM events just in case
      this.delegateEvents();
      this.$el.css({
        marginTop: self.options.verticalPosition === 'down' ? '-10px' : '10px',
        opacity: 0,
        display: 'block'
      }).animate({
        margin: '0',
        opacity: 1
      }, {
        'duration': this.options.speedIn,
        'complete': function complete() {
          dfd.resolve();
        }
      });
      this.trigger('onDropdownShown', this.el);
  
      return dfd.promise();
    },
  
    /**
     * open the dialog at x, y
     */
    openAt: function openAt(x, y) {
      var dfd = $.Deferred();
  
      this.$el.css({
        top: y,
        left: x,
        width: this.options.width
      }).addClass((this.options.verticalPosition === 'up' ? 'vertical_top' : 'vertical_bottom') + ' ' + (this.options.horizontalPosition === 'right' ? 'horizontal_right' : 'horizontal_left') + ' ' +
      // Add tick class
      'tick_' + this.options.tick);
  
      this.modelView.set({ open: true });
  
      // Show
      $.when(this.show()).done(function () {
        dfd.resolve();
      });
      // xabel: I've add the deferred to make it easily testable
  
      return dfd.promise();
    },
  
    hide: function hide(done) {
      // don't attempt to hide the dropdown if it's already hidden
      if (!this.isOpen) {
        done && done();return;
      }
  
      var self = this;
  
      this.$el.animate({
        marginTop: self.options.verticalPosition === 'down' ? '10px' : '-10px',
        opacity: 0
      }, this.options.speedOut, function () {
        // Remove selected class
        $(self.options.target).removeClass('selected');
  
        // And hide it
        self.$el.hide();
        done && done();
  
        self.trigger('onDropdownHidden', self.el);
      });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/dropdown/dropdown-base-view.js":
  /*!************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/dropdown/dropdown-base-view.js ***!
    \************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  var DEFAULTS = {
    width: 160,
    speedIn: 150,
    speedOut: 300,
    verticalPosition: 'down',
    horizontalPosition: 'right',
    tick: 'right',
    verticalOffset: 0,
    horizontalOffset: 0
  };
  
  module.exports = CoreView.extend({
    className: 'dropdown',
  
    initialize: function initialize(options) {
      _.bindAll(this, 'open', 'hide', '_handleClick', '_keydown', '_onDocumentClick');
  
      this.options = {};
      // Extend options
      _.defaults(this.options, options, DEFAULTS);
  
      if (options.template) {
        this.template = options.template;
      }
  
      // Bind to target
      $(options.target).on('click', this._handleClick);
      $(document).on('keydown', this._keydown);
      $(document).on('click', this._onDocumentClick);
  
      this.modelView = new Backbone.Model({
        open: false
      });
  
      this.modelView.on('change:open', function (model, isOpen) {
        isOpen ? this.hide() : this.open();
      }, this);
    },
  
    render: function render() {
      // Render
      var $el = this.$el;
      $el.html(this.template && this.template(this.options)).css({
        width: this.options.width
      });
      return this;
    },
  
    _handleClick: function _handleClick(event) {
      if (event) {
        event.preventDefault();
      }
  
      var isOpen = this.modelView.get('open');
      this.modelView.set('open', !isOpen);
    },
  
    _onDocumentClick: function _onDocumentClick(e) {
      var $el = $(e.target);
      var $target = $(this.options.target);
      var isTarget = $el.get(0) === $target.get(0);
      if (!isTarget && $el.closest('.Dropdown').length === 0) {
        this.modelView.set({ open: false }, { silent: true });
        this.hide();
      }
    },
  
    _keydown: function _keydown(event) {
      if (event.keyCode === 27) {
        this.modelView.set('open', false);
      }
    },
  
    hide: function hide() {
      this.$el.hide();
    },
  
    show: function show() {
      this.$el.css({
        display: 'block',
        opacity: 1
      });
    },
  
    open: function open(event, target) {
      // Target
      var $target = target && $(target) || this.options.target;
      this.options.target = $target;
  
      // Positionate
      var targetPos = $target[this.options.position || 'offset']();
      var targetWidth = $target.outerWidth();
      var targetHeight = $target.outerHeight();
      var elementWidth = this.$el.outerWidth();
      var elementHeight = this.$el.outerHeight();
      var verticalPosition = this.options.verticalPosition;
      var verticalOffset = this.options.verticalOffset;
      var horizontalPosition = this.options.horizontalPosition;
      var horizontalOffset = this.options.horizontalOffset;
  
      this.$el.css({
        top: targetPos.top + parseInt(verticalPosition === 'up' ? -elementHeight - 10 - verticalOffset : targetHeight + 10 - verticalOffset),
        left: targetPos.left + parseInt(horizontalPosition === 'left' ? horizontalOffset - 15 : targetWidth - elementWidth + 15 - horizontalOffset)
      }).addClass(
      // Add vertical and horizontal position class
      (verticalPosition === 'up' ? 'vertical_top' : 'vertical_bottom') + ' ' + (horizontalPosition === 'right' ? 'horizontal_right' : 'horizontal_left') + ' ' +
      // Add tick class
      'tick_' + this.options.tick);
  
      this.show();
    },
  
    isOpen: function isOpen() {
      return this.modelView.get('open');
    },
  
    clean: function clean() {
      var target = $(this.options.target);
      this.options.target && target.off('click', this._handleClick);
      $(document).off('keydown', this._keydown);
      $(document).off('click', this._onDocumentClick);
      CoreView.prototype.clean.apply(this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/flash-message/flash-message-view.js":
  /*!*****************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/flash-message/flash-message-view.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./flash-message.tpl */ "./lib/assets/javascripts/dashboard/components/flash-message/flash-message.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['model'];
  
  /**
   * View for a flash message to be displayed at the header.
   */
  module.exports = CoreView.extend({
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      this.listenTo(this.model, 'change', this.render);
    },
  
    render: function render() {
      this.$el.toggle(this.model.shouldDisplay());
  
      this.$el.html(template({
        str: this.model.get('msg'),
        type: this.model.get('type')
      }));
  
      return this;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/icon-selector/icon-selector-view.js":
  /*!*****************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/icon-selector/icon-selector-view.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./icon-selector.tpl */ "./lib/assets/javascripts/dashboard/components/icon-selector/icon-selector.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  __webpack_require__(/*! filestyle */ "./vendor/assets/javascripts/filestyle.js");
  
  var AssetModel = __webpack_require__(/*! dashboard/data/asset-model.js */ "./lib/assets/javascripts/dashboard/data/asset-model.js");
  
  var REQUIRED_OPTS = ['configModel', 'renderModel'];
  
  /**
   *  Change and preview new mobile app icon
   *
   */
  
  module.exports = CoreView.extend({
    options: {
      acceptedExtensions: ['jpeg', 'jpg', 'png', 'gif'],
      imageKind: 'mobileAppIcon',
      imageURLAttribute: 'icon_url'
    },
  
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      this._model = new Backbone.Model({ state: 'idle' });
      this._initBinds();
    },
  
    render: function render() {
      this._destroyFileInput();
      this.clearSubViews();
  
      this.$el.html(template({
        state: this._model.get('state'),
        name: this._renderModel.get('name'),
        inputName: this._renderModel.get('inputName'),
        iconURL: this._renderModel.get('icon_url'),
        iconAcceptedExtensions: this._formatAcceptedExtensions(this.options.acceptedExtensions)
      }));
      this._renderFileInput();
      return this;
    },
  
    _initBinds: function _initBinds() {
      _.bindAll(this, '_onInputChange', '_onSuccess', '_onError');
      this.listenTo(this._model, 'change', this.render);
    },
  
    _destroyFileInput: function _destroyFileInput() {
      var $file = this.$(':file');
      $file.unbind('change', this._onInputChange, this);
      $file.filestyle('destroy');
    },
  
    _renderFileInput: function _renderFileInput() {
      var $file = this.$(':file');
      var opts = { buttonText: 'Choose image' };
  
      // If we set disabled, no mather if it is true
      // or false, it turns into disabled
      if (this._model.get('state') === 'loading') {
        opts.disabled = true;
      }
  
      $file.filestyle(opts);
      $file.bind('change', this._onInputChange);
    },
  
    _onInputChange: function _onInputChange() {
      var file = this.$(':file').prop('files');
      var iconUpload = new AssetModel(null, {
        userId: this._renderModel.get('id'),
        configModel: this._configModel
      });
  
      iconUpload.save({
        kind: this.options.imageKind,
        filename: file
      }, {
        success: this._onSuccess,
        error: this._onError
      });
  
      // If we move "loading" state before starting the upload,
      // it would trigger a new render and "remove" file value :S
      this._model.set('state', 'loading');
    },
  
    _onSuccess: function _onSuccess(model, data) {
      this._renderModel.set(this.options.imageURLAttribute, data.public_url);
      this._model.set('state', 'success');
    },
  
    _onError: function _onError() {
      this._model.set('state', 'error');
    },
  
    clean: function clean() {
      this._destroyFileInput();
      CoreView.prototype.clean.apply(this);
    },
  
    _formatAcceptedExtensions: function _formatAcceptedExtensions(acceptedExtensions) {
      var formattedExtensions = [];
  
      for (var i = 0; i < acceptedExtensions.length; i++) {
        formattedExtensions[i] = 'image/' + acceptedExtensions[i];
      }
  
      return formattedExtensions.join(',');
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/mapcard-preview-view.js":
  /*!*****************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/mapcard-preview-view.js ***!
    \*****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var TEMPLATES = {
    // Using <%= %> instead of <%- %> because if not / characters (for example) will be escaped
    regular: '<%- protocol %>://<%= mapsApiResource %>/api/v1/map/static/named/<%- tpl %>/<%- width %>/<%- height %>.png<%= authTokens %>',
    cdn: '<%- protocol %>://<%- cdn %>/<%- username %>/api/v1/map/static/named/<%- tpl %>/<%- width %>/<%- height %>.png<%= authTokens %>'
  };
  
  var REQUIRED_OPTS = ['config', 'visId', 'mapsApiResource', 'username'];
  
  /**
   *  MapCard previews
   *
   */
  
  module.exports = CoreView.extend({
    options: {
      width: 300,
      height: 170,
      privacy: 'PUBLIC',
      className: '',
      authTokens: []
    },
  
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
    },
  
    load: function load() {
      this._startLoader();
      this._loadFromVisId();
  
      return this;
    },
  
    _generateImageTemplate: function _generateImageTemplate() {
      return 'tpl_' + this._visId.replace(/-/g, '_');
    },
  
    _loadFromVisId: function _loadFromVisId() {
      var protocol = this._isHTTPS() ? 'https' : 'http';
      var cdnConfig = this._config.get('cdn_url');
      var template = _.template(cdnConfig ? TEMPLATES['cdn'] : TEMPLATES['regular']);
  
      var options = {
        protocol: protocol,
        username: this._username,
        mapsApiResource: this._mapsApiResource,
        tpl: this._generateImageTemplate(),
        width: this.options.width,
        height: this.options.height,
        authTokens: this._generateAuthTokensParams()
      };
  
      if (cdnConfig) {
        options = _.extend(options, {
          cdn: cdnConfig[protocol]
        });
      }
  
      var url = template(options);
  
      this._loadImage({}, url);
    },
  
    _generateAuthTokensParams: function _generateAuthTokensParams() {
      var authTokens = this.options.authTokens;
      if (authTokens && authTokens.length > 0) {
        return '?' + _.map(authTokens, function (t) {
          return 'auth_token=' + t;
        }).join('&');
      } else {
        return '';
      }
    },
  
    _isHTTPS: function _isHTTPS() {
      return location.protocol.indexOf('https') === 0;
    },
  
    loadURL: function loadURL(url) {
      var $img = $('<img class="MapCard-preview" src="' + url + '" />');
      this.$el.append($img);
  
      if (this.options.className) {
        $img.addClass(this.options.className);
      }
  
      $img.fadeIn(250);
    },
  
    showError: function showError() {
      this._onError();
    },
  
    _startLoader: function _startLoader() {
      this.$el.addClass('is-loading');
    },
  
    _stopLoader: function _stopLoader() {
      this.$el.removeClass('is-loading');
    },
  
    _onSuccess: function _onSuccess(url) {
      this._stopLoader();
      this.loadURL(url);
      this.trigger('loaded', url);
    },
  
    _onError: function _onError() {
      this._stopLoader();
      this.$el.addClass('has-error');
      var $error = $('<div class="MapCard-error" />');
      this.$el.append($error);
      $error.fadeIn(250);
      this.trigger('error');
    },
  
    _loadImage: function _loadImage(error, url) {
      var self = this;
      var img = new Image();
  
      img.onerror = function () {
        self._onError(error);
      };
  
      img.onload = function () {
        self._onSuccess(url);
      };
  
      try {
        img.src = url;
      } catch (err) {
        this._onError(err);
      }
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/navbar/user-industries-view.js":
  /*!************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/navbar/user-industries-view.js ***!
    \************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var IndustriesDropdown = __webpack_require__(/*! ./user-industries/dropdown-view */ "./lib/assets/javascripts/dashboard/components/navbar/user-industries/dropdown-view.js");
  
  /**
   * View to render the user settings section in the header.
   * Expected to be created from existing DOM element.
   */
  module.exports = CoreView.extend({
    events: {
      'click .js-dropdown-target': '_createDropdown'
    },
  
    _createDropdown: function _createDropdown(event) {
      if (event) {
        event.preventDefault();
      }
  
      var $target = $(event.target);
  
      var view = new IndustriesDropdown({
        target: $target,
        verticalOffset: -10,
        horizontalOffset: $target.width() - 100,
        horizontalPosition: 'left',
        tick: 'center'
      });
  
      view.render();
  
      view.on('onDropdownHidden', function () {
        view.clean();
      }, this);
  
      view.open();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/navbar/user-industries/dropdown-view.js":
  /*!*********************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/navbar/user-industries/dropdown-view.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var DropdownAdminView = __webpack_require__(/*! dashboard/components/dropdown/dropdown-admin-view */ "./lib/assets/javascripts/dashboard/components/dropdown/dropdown-admin-view.js");
  var template = __webpack_require__(/*! ./dropdown.tpl */ "./lib/assets/javascripts/dashboard/components/navbar/user-industries/dropdown.tpl");
  
  /**
   * The content of the dropdown menu opened by the industries link in the header, e.g.:
   *   CartoDB, Industries, Explore, Pricing
   *             ______/\____
   *            |            |
   *            |    this    |
   *            |____________|
   */
  module.exports = DropdownAdminView.extend({
    className: 'CDB-Text Dropdown Dropdown--public',
  
    render: function render() {
      this.$el.html(template());
  
      // TODO: taken from existing code, how should dropdowns really be added to the DOM?
      $('body').append(this.el);
  
      return this;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/navbar/user-settings-view.js":
  /*!**********************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/navbar/user-settings-view.js ***!
    \**********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var SettingsDropdownView = __webpack_require__(/*! ./user-settings/dropdown-view */ "./lib/assets/javascripts/dashboard/components/navbar/user-settings/dropdown-view.js");
  var userSettingsTemplate = __webpack_require__(/*! ./user-settings.tpl */ "./lib/assets/javascripts/dashboard/components/navbar/user-settings.tpl");
  
  /**
   * View to render the user settings section in the header.
   * Expected to be created from existing DOM element.
   */
  module.exports = CoreView.extend({
  
    events: {
      'click .js-dropdown-target': '_createDropdown'
    },
  
    render: function render() {
      var dashboardUrl = this.model.viewUrl().dashboard();
      var datasetsUrl = dashboardUrl.datasets();
      var mapsUrl = dashboardUrl.maps();
  
      this.$el.html(userSettingsTemplate({
        avatarUrl: this.model.get('avatar_url'),
        mapsUrl: mapsUrl,
        datasetsUrl: datasetsUrl
      }));
  
      return this;
    },
  
    _createDropdown: function _createDropdown(event) {
      var view = new SettingsDropdownView({
        target: $(event.target),
        model: this.model, // user
        horizontalOffset: 18
      });
      view.render();
  
      view.on('onDropdownHidden', function () {
        view.clean();
      }, this);
  
      view.open();
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/navbar/user-settings/dropdown-view.js":
  /*!*******************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/navbar/user-settings/dropdown-view.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var template = __webpack_require__(/*! ./dropdown.tpl */ "./lib/assets/javascripts/dashboard/components/navbar/user-settings/dropdown.tpl");
  var DropdownAdminView = __webpack_require__(/*! dashboard/components/dropdown/dropdown-admin-view */ "./lib/assets/javascripts/dashboard/components/dropdown/dropdown-admin-view.js");
  
  /**
   * The content of the dropdown menu opened by the user avatar in the top-right of the header, e.g.:
   *   Explore, Learn, 
   *             ______/\____
   *            |            |
   *            |    this    |
   *            |____________|
   */
  
  module.exports = DropdownAdminView.extend({
    className: 'CDB-Text Dropdown',
  
    render: function render() {
      var user = this.model;
      var userUrl = user.viewUrl();
  
      this.$el.html(template({
        name: user.fullName() || user.get('username'),
        email: user.get('email'),
        isOrgOwner: user.isOrgOwner(),
        dashboardUrl: userUrl.dashboard(),
        publicProfileUrl: userUrl.publicProfile(),
        accountProfileUrl: userUrl.accountProfile(),
        logoutUrl: userUrl.logout()
      }));
  
      // TODO: taken from existing code, how should dropdowns really be added to the DOM?
      $('body').append(this.el);
  
      return this;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/pages-subheader/pages-subheader.js":
  /*!****************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/pages-subheader/pages-subheader.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./pages-subheader.tpl */ "./lib/assets/javascripts/dashboard/components/pages-subheader/pages-subheader.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var bytesToSize = __webpack_require__(/*! dashboard/helpers/bytes-to-size */ "./lib/assets/javascripts/dashboard/helpers/bytes-to-size.js");
  
  var REQUIRED_OPTS = ['userModel', 'configModel'];
  
  module.exports = CoreView.extend({
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
    },
  
    render: function render() {
      var usedDataBytes = this._userModel.get('db_size_in_bytes');
      var quotaInBytes = this._userModel.get('quota_in_bytes');
      var usedDataPct = Math.round(usedDataBytes / quotaInBytes * 100);
      var progressBarClass = '';
  
      if (usedDataPct > 80 && usedDataPct < 90) {
        progressBarClass = 'caution';
      } else if (usedDataPct > 89) {
        progressBarClass = 'danger';
      }
  
      this.$el.html(template({
        isCartoDBHosted: this._configModel.get('cartodb_com_hosted'),
        usedDataStr: bytesToSize(usedDataBytes).toString(2),
        usedDataPct: usedDataPct,
        progressBarClass: progressBarClass,
        availableDataStr: bytesToSize(quotaInBytes).toString(2),
        profileUrl: this._userModel.viewUrl().accountProfile().pathname(),
        accountUrl: this._userModel.viewUrl().accountSettings().pathname(),
        apiKeysUrl: this._userModel.viewUrl().apiKeys().pathname(),
        connectedAppsUrl: this._userModel.viewUrl().connectedApps().pathname(),
        isInsideOrg: this._userModel.isInsideOrg(),
        planUrl: this._userModel.get('plan_url'),
        isOrgAdmin: this._userModel.isOrgAdmin(),
        organizationUrl: this._userModel.viewUrl().organization().pathname(),
        isOrgOwner: this._userModel.isOrgOwner(),
        upgradeContactEmail: this._userModel.upgradeContactEmail(),
        path: this.getPath()
      }));
  
      return this;
    },
  
    getPath: function getPath() {
      return window.location.pathname;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/password-confirmation/password-confirmation-view.js":
  /*!*********************************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/password-confirmation/password-confirmation-view.js ***!
    \*********************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./password-confirmation.tpl */ "./lib/assets/javascripts/dashboard/components/password-confirmation/password-confirmation.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['modalModel', 'onPasswordTyped'];
  
  /**
   * Password Confirmation Modal
   *
   * Modal used for password validated forms, so
   * the user needs to type the password in to
   * save form changes
   */
  
  module.exports = CoreView.extend({
    events: {
      'click .js-ok': '_onConfirm',
      'click .js-cancel': '_closeDialog',
      'keydown #password-confirmation-form': '_onEnterPressed',
      'input .js-password': '_toggleConfirmButton'
    },
  
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
      this._isConfirmDisabled = true;
    },
  
    render: function render() {
      this.$el.html(template({
        isConfirmDisabled: this._isConfirmDisabled
      }));
  
      this._okButton = this.$('.js-ok');
      return this;
    },
  
    _toggleConfirmButton: function _toggleConfirmButton(event) {
      var passwordInput = event.target;
      this._isConfirmDisabled = _.isEmpty(passwordInput.value);
      this._okButton.toggleClass('is-disabled', this._isConfirmDisabled);
    },
  
    _onConfirm: function _onConfirm(event) {
      this.killEvent(event);
  
      if (this._isConfirmDisabled) {
        return;
      }
  
      var passwordValue = this.$('#password-confirmation').val();
      this._onPasswordTyped && this._onPasswordTyped(passwordValue);
      this._closeDialog();
    },
  
    _onEnterPressed: function _onEnterPressed(event) {
      if (event.keyCode !== 13) {
        return;
      }
  
      this._onConfirm(event);
    },
  
    _closeDialog: function _closeDialog() {
      this._modalModel.destroy();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/tabpane/tabpane.js":
  /*!************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/tabpane/tabpane.js ***!
    \************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  module.exports = CoreView.extend({
  
    initialize: function initialize() {
      this.tabs = {};
      this.activeTab = null;
      this.activePane = null;
    },
  
    addTab: function addTab(name, view, options) {
      options = options || { active: true };
      if (this.tabs[name] !== undefined) {
        console.debug(name + 'already added');
      } else {
        this.tabs[name] = view.cid;
        this.addView(view);
        if (options.after !== undefined) {
          var e = this.$el.children()[options.after];
          view.$el.insertAfter(e);
        } else if (options.prepend) {
          this.$el.prepend(view.el);
        } else {
          this.$el.append(view.el);
        }
        this.trigger('tabAdded', name, view);
        if (options.active) {
          this.active(name);
        } else {
          view.hide();
        }
      }
    },
  
    getPreviousPane: function getPreviousPane() {
      var tabs = _.toArray(this.tabs);
      var panes = _.toArray(this._subviews);
  
      var i = _.indexOf(tabs, this.activePane.cid) - 1;
      if (i < 0) i = panes.length - 1;
  
      return panes[i];
    },
  
    getNextPane: function getNextPane() {
      var tabs = _.toArray(this.tabs);
      var panes = _.toArray(this._subviews);
  
      var i = 1 + _.indexOf(tabs, this.activePane.cid);
      if (i > panes.length - 1) i = 0;
  
      return panes[i];
    },
  
    getPane: function getPane(name) {
      var vid = this.tabs[name];
      return this._subviews[vid];
    },
  
    getActivePane: function getActivePane() {
      return this.activePane;
    },
  
    size: function size() {
      return _.size(this.tabs);
    },
  
    clean: function clean() {
      this.removeTabs();
      CoreView.prototype.clean.call(this);
    },
  
    removeTab: function removeTab(name) {
      if (this.tabs[name] !== undefined) {
        var vid = this.tabs[name];
        this._subviews[vid].clean();
        delete this.tabs[name];
  
        if (this.activeTab == name) {
          // eslint-disable-line eqeqeq
          this.activeTab = null;
        }
  
        if (_.size(this.tabs)) {
          this.active(_.keys(this.tabs)[0]);
        }
      }
    },
  
    removeTabs: function removeTabs() {
      for (var name in this.tabs) {
        var vid = this.tabs[name];
        this._subviews[vid].clean();
        delete this.tabs[name];
      }
      this.activeTab = null;
    },
  
    active: function active(name) {
      var vid = this.tabs[name];
  
      if (vid !== undefined) {
        if (this.activeTab !== name) {
          var v = this._subviews[vid];
  
          if (this.activeTab) {
            var vid_old = this._subviews[this.tabs[this.activeTab]];
  
            vid_old.hide();
            this.trigger('tabDisabled', this.activeTab, vid_old);
            this.trigger('tabDisabled:' + this.activeTab, vid_old);
            if (vid_old.deactivated) {
              vid_old.deactivated();
            }
          }
  
          v.show();
          if (v.activated) {
            v.activated();
          }
  
          this.activeTab = name;
          this.activePane = v;
  
          this.trigger('tabEnabled', name, v);
          this.trigger('tabEnabled:' + name, v);
        }
  
        return this.activePane;
      }
    },
  
    render: function render() {
      return this;
    },
  
    each: function each(fn) {
      var _this = this;
  
      _.each(this.tabs, function (cid, tab) {
        fn(tab, _this.getPane(tab));
      });
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/trial-notification/trial-notification-view.js":
  /*!***************************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/trial-notification/trial-notification-view.js ***!
    \***************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./trial-notification.tpl */ "./lib/assets/javascripts/dashboard/components/trial-notification/trial-notification.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['userModel', 'upgradeUrl', 'trialDays'];
  
  module.exports = CoreView.extend({
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      this.userAccount = this._userModel.get('account_type');
    },
  
    render: function render() {
      this.clearSubViews();
  
      this.$el.html(template({
        upgradeUrl: this._upgradeUrl,
        trialDays: this._trialDays
      }));
  
      return this;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/upgrade-message-view.js":
  /*!*****************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/upgrade-message-view.js ***!
    \*****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./upgrade-message.tpl */ "./lib/assets/javascripts/dashboard/components/upgrade-message.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel', 'userModel'];
  
  /**
   *  Upgrade message for settings pages
   *
   */
  
  module.exports = CoreView.extend({
  
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      this._initBinds();
    },
  
    render: function render() {
      var upgradeUrl = this._configModel.get('upgrade_url');
      var canUpgrade = upgradeUrl && !this._configModel.get('cartodb_com_hosted') && (!this._userModel.isInsideOrg() || this._userModel.isOrgOwner());
  
      this.$el.html(template({
        canUpgrade: canUpgrade,
        closeToLimits: this._userModel.isCloseToLimits(),
        upgradeableWithoutContactingSales: !this._userModel.isEnterprise(),
        quotaPer: this._userModel.get('remaining_byte_quota') * 100 / this._userModel.get('quota_in_bytes'),
        upgradeUrl: upgradeUrl,
        showTrial: this._userModel.canStartTrial()
      }));
      return this;
    },
  
    _initBinds: function _initBinds() {
      this.listenTo(this._userModel, 'change', this.render);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/user-info/dropdown-view.js":
  /*!********************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/user-info/dropdown-view.js ***!
    \********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var DropdownAdminView = __webpack_require__(/*! dashboard/components/dropdown/dropdown-admin-view */ "./lib/assets/javascripts/dashboard/components/dropdown/dropdown-admin-view.js");
  
  /**
   * The content of the dropdown menu opened by the link at the end of the breadcrumbs menu, e.g.
   *   username / Maps v
   *            ______/\____
   *           |            |
   *           |    this    |
   *           |____________|
   */
  module.exports = DropdownAdminView.extend({
    className: 'Dropdown',
  
    hide: function hide() {
      this.$el.css({
        opacity: 0
      });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/user-info/user-info-view.js":
  /*!*********************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/user-info/user-info-view.js ***!
    \*********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var BreadcrumbDropdown = __webpack_require__(/*! ./dropdown-view.js */ "./lib/assets/javascripts/dashboard/components/user-info/dropdown-view.js");
  
  /**
   * View to render the user info section.
   * Expected to be created from existing DOM element.
   */
  module.exports = CoreView.extend({
  
    events: {
      'click .js-breadcrumb-dropdown-target': '_createBreadcrumbDropdown'
    },
  
    _previousDropDown: null,
  
    _createBreadcrumbDropdown: function _createBreadcrumbDropdown(ev) {
      ev.preventDefault();
  
      if (this._previousDropDown) {
        this._previousDropDown.open();
        return;
      }
  
      var dropdown = new BreadcrumbDropdown({
        target: $(ev.target),
        el: $('.js-breadcrumb-dropdown-content'),
        horizontal_offset: 3, // to match the dropdown indicator/arrow
        horizontal_position: 'right',
        tick: 'right'
      });
  
      this._previousDropDown = dropdown;
      this.addView(dropdown);
      dropdown.on('onDropdownHidden', function () {
        dropdown.clean();
      }, this);
  
      dropdown.render();
      dropdown.open();
    },
  
    _closeAnyOtherOpenDialogs: function _closeAnyOtherOpenDialogs() {
      if (this._previousDropDown) {
        this._previousDropDown.hide();
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/components/vendor-scripts/vendor-scripts-view.js":
  /*!*******************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/components/vendor-scripts/vendor-scripts-view.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./vendor-scripts.tpl */ "./lib/assets/javascripts/dashboard/components/vendor-scripts/vendor-scripts.tpl");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel', 'userModel', 'assetsVersion'];
  
  module.exports = CoreView.extend({
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
    },
  
    render: function render() {
      this.$el.html(template({
        assetsVersion: this._assetsVersion,
        googleTagManagerId: this._configModel.get('google_tag_manager_id'),
        hubspotIds: this._configModel.get('hubspot_ids'),
        hubspotToken: this._configModel.get('hubspot_token'),
        intercomAppId: this._configModel.get('intercom_app_id'),
        intercomEnabled: !!this._userModel.featureEnabled('intercom'),
        trackjsAppKey: this._configModel.get('trackjs_app_key'),
        trackjsCustomer: this._configModel.get('trackjs_customer'),
        trackjsEnabled: !!this._configModel.get('trackjs_enabled'),
        fullstoryEnabled: !!this._configModel.get('fullstory_enabled'),
        fullstoryOrg: this._configModel.get('fullstoryOrg'),
        userEmail: this._userModel.get('email'),
        userName: this._userModel.get('username'),
        userId: this._userModel.get('id'),
        userAccountType: this._userModel.get('account_type'),
        userCreatedAtInSeconds: Date.parse(this._userModel.get('created_at')) / 1000,
        userJobRole: this._userModel.get('job_role'),
        userInTrialPeriod: this._userModel.get('show_trial_reminder')
      }));
  
      return this;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/asset-model.js":
  /*!**************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/asset-model.js ***!
    \**************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  /**
   *  Model that let user upload files
   *  to our endpoints
   */
  
  __webpack_require__(/*! backbone-model-file-upload */ "./node_modules/backbone-model-file-upload/backbone-model-file-upload.js");
  
  var REQUIRED_OPTS = ['configModel', 'userId'];
  
  module.exports = Backbone.Model.extend({
    url: function url(method) {
      var version = this._configModel.urlVersion('asset', method);
      return '/api/' + version + '/users/' + this._userId + '/assets';
    },
  
    fileAttribute: 'filename',
  
    initialize: function initialize(attributes, options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/authenticated-user-model.js":
  /*!***************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/authenticated-user-model.js ***!
    \***************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  module.exports = Backbone.Model.extend({
    defaults: {
      username: '',
      avatar_url: ''
    },
  
    url: function url() {
      return '//' + this.getHost() + '/api/v1/get_authenticated_users';
    },
  
    getHost: function getHost() {
      var currentHost = window.location.host;
      return this.get('host') ? this.get('host') : currentHost;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/backbone/sync-abort.js":
  /*!**********************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/backbone/sync-abort.js ***!
    \**********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   * Custom sync method to only allow a single request at a time,
   * any prev ongoing request at a time of a sync call will be aborted.
   *
   * @example
   *   var MyModel = Backbone.Model.extend({
   *     // 
   *     sync: syncAbort,
   */
  module.exports = function (method, self, opts) {
    if (this._xhr) {
      this._xhr.abort();
    }
  
    var xhr = this._xhr = Backbone.Model.prototype.sync.apply(this, arguments);
    xhr.always(function () {
      self._xhr = null;
    });
  
    return xhr;
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/backbone/sync-options.js":
  /*!************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/backbone/sync-options.js ***!
    \************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  (function () {
    // helper functions needed from backbone (they are not exported)
    var getValue = function getValue(object, prop, method) {
      if (!(object && object[prop])) return null;
      return _.isFunction(object[prop]) ? object[prop](method) : object[prop];
    };
  
    // Throw an error when a URL is needed, and none is supplied.
    var urlError = function urlError() {
      throw new Error('A "url" property or function must be specified');
    };
  
    // backbone.sync replacement to control url prefix
    Backbone.originalSync = Backbone.sync;
    Backbone.sync = function (method, model, options) {
      var url = options.url || getValue(model, 'url', method) || urlError();
      // prefix if http is not present
      var absoluteUrl = url.indexOf('http') === 0 || url.indexOf('//') === 0;
      if (!absoluteUrl) {
        // We need to fix this
        // this comes from cdb.config.prefixUrl
        options.url = (model._configModel || model._config || model).get('base_url') + url;
      } else {
        options.url = url;
      }
      if (method !== 'read') {
        // remove everything related
        if (model.surrogateKeys) {
          Backbone.cachedSync.invalidateSurrogateKeys(getValue(model, 'surrogateKeys'));
        }
      }
      return Backbone.originalSync(method, model, options);
    };
  
    Backbone.currentSync = Backbone.sync;
    Backbone.withCORS = function (method, model, options) {
      if (!options) {
        options = {};
      }
  
      if (!options.crossDomain) {
        options.crossDomain = true;
      }
  
      if (!options.xhrFields) {
        options.xhrFields = { withCredentials: true };
      }
  
      return Backbone.currentSync(method, model, options);
    };
  
    // this method returns a cached version of backbone sync
    // take a look at https://github.com/teambox/backbone.memoized_sync/blob/master/backbone.memoized_sync.js
    // this is the same concept but implemented as a wrapper for ``Backbone.sync``
    // usage:
    // initialize: function () {
    //    this.sync = Backbone.cachedSync(this.user_name);
    // }
    Backbone.cachedSync = function (namespace, sync) {
      if (!namespace) {
        throw new Error('cachedSync needs a namespace as argument');
      }
  
      var surrogateKey = namespace;
      var session = window.user_data && window.user_data.username;
      // no user session, no cache
      // there should be a session to have cache so we avoid
      // cache collision for someone with more than one account
      if (session) {
        namespace += '-' + session;
      } else {
        return Backbone.sync;
      }
  
      var namespaceKey = 'cdb-cache/' + namespace;
  
      // saves all the localstore references to the namespace
      // inside localstore. It allows to remove all the references
      // at a time
      var index = {
        // return a list of references for the namespace
        _keys: function _keys() {
          return JSON.parse(localStorage.getItem(namespaceKey) || '{}');
        },
  
        // add a new reference for the namespace
        add: function add(key) {
          var keys = this._keys();
          keys[key] = +new Date();
          localStorage.setItem(namespaceKey, JSON.stringify(keys));
        },
  
        // remove all the references for the namespace
        invalidate: function invalidate() {
          var keys = this._keys();
          _.each(keys, function (v, k) {
            localStorage.removeItem(k);
          });
          localStorage.removeItem(namespaceKey);
        }
      };
  
      // localstore-like cache wrapper
      var cache = {
        setItem: function setItem(key, value) {
          localStorage.setItem(key, value);
          index.add(key);
          return this;
        },
  
        // this is async in case the data needs to be compressed
        getItem: function getItem(key, callback) {
          var val = localStorage.getItem(key);
          _.defer(function () {
            callback(val);
          });
        },
  
        removeItem: function removeItem(key) {
          localStorage.removeItem(key);
          index.invalidate();
        }
      };
  
      var cached = function cached(method, model, options) {
        var url = options.url || getValue(model, 'url') || urlError();
        var key = namespaceKey + '/' + url;
  
        if (method === 'read') {
          var success = options.success;
          var cachedValue = null;
  
          options.success = function (resp, status, xhr) {
            // if cached value is ok
            if (cachedValue && xhr.responseText === cachedValue) {
              return;
            }
            cache.setItem(key, xhr.responseText);
            success(resp, status, xhr);
          };
  
          cache.getItem(key, function (val) {
            cachedValue = val;
            if (val) {
              success(JSON.parse(val), 'success');
            }
          });
        } else {
          cache.removeItem(key);
        }
        return (sync || Backbone.sync)(method, model, options);
      };
  
      // create a public function to invalidate all the namespace
      // items
      cached.invalidate = function () {
        index.invalidate();
      };
  
      // for testing and debugging porpuposes
      cached.cache = cache;
  
      // have a global namespace -> sync function in order to avoid invalidation
      Backbone.cachedSync.surrogateKeys[surrogateKey] = cached;
  
      return cached;
    };
  
    Backbone.cachedSync.surrogateKeys = {};
  
    Backbone.cachedSync.invalidateSurrogateKeys = function (keys) {
      _.each(keys, function (k) {
        var s = Backbone.cachedSync.surrogateKeys[k];
        if (s) {
          s.invalidate();
        } else {
          console.error('Backbone sync options: surrogate key not found: ' + k);
        }
      });
    };
  
    Backbone.syncAbort = function () {
      var self = arguments[1];
      if (self._xhr) {
        self._xhr.abort();
      }
      self._xhr = Backbone.sync.apply(this, arguments);
      self._xhr.always(function () {
        self._xhr = null;
      });
      return self._xhr;
    };
  
    Backbone.delayedSaveSync = function (sync, delay) {
      var dsync = _.debounce(sync, delay);
      return function (method, model, options) {
        if (method === 'create' || method === 'update') {
          return dsync(method, model, options);
        } else {
          return sync(method, model, options);
        }
      };
    };
  
    Backbone.saveAbort = function () {
      var self = this;
      if (this._saving && this._xhr) {
        this._xhr.abort();
      }
      this._saving = true;
      var xhr = Backbone.Model.prototype.save.apply(this, arguments);
      this._xhr = xhr;
      xhr.always(function () {
        self._saving = false;
      });
      return xhr;
    };
  })();
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/background-polling/background-polling-model.js":
  /*!**********************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/background-polling/background-polling-model.js ***!
    \**********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var ImportsCollection = __webpack_require__(/*! dashboard/data/imports-collection */ "./lib/assets/javascripts/dashboard/data/imports-collection.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var pollingsTimer = 3000;
  
  var REQUIRED_OPTS = ['userModel', 'configModel'];
  
  /**
   *  Background polling default model
   *
   */
  
  module.exports = Backbone.Model.extend({
    defaults: {
      showGeocodingDatasetURLButton: false,
      showSuccessDetailsButton: true,
      geocodingsPolling: false, // enable geocodings polling
      importsPolling: false // enable imports polling
    },
  
    initialize: function initialize(attributes, options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      this.importsCollection = options.importsCollection || new ImportsCollection(null, {
        userModel: this._userModel,
        configModel: this._configModel
      });
      this._initBinds();
      this.startPollings();
    },
  
    _initBinds: function _initBinds() {
      this.importsCollection.bind('change:state', function (mdl) {
        this.trigger('change', mdl, this);
        this._onImportsStateChange(mdl);
      }, this);
      this.importsCollection.bind('remove', function (mdl) {
        this.trigger('importRemoved', mdl, this);
      }, this);
      this.importsCollection.bind('add', function (mdl) {
        this.trigger('importAdded', mdl, this);
      }, this);
    },
  
    // Helper functions
  
    getTotalFailedItems: function getTotalFailedItems() {
      return this.importsCollection.failedItems().length;
    },
  
    removeImportItem: function removeImportItem(mdl) {
      if (!mdl) {
        return false;
      }
      this.importsCollection.remove(mdl);
    },
  
    addImportItem: function addImportItem(mdl) {
      if (!mdl) {
        return false;
      }
      this.importsCollection.add(mdl);
    },
  
    canAddImport: function canAddImport() {
      return this.importsCollection.canImport();
    },
  
    getTotalImports: function getTotalImports() {
      return this.importsCollection.size();
    },
  
    getTotalPollings: function getTotalPollings() {
      return this.importsCollection.size();
    },
  
    stopPollings: function stopPollings() {
      if (this.get('importsPolling')) {
        this.importsCollection.destroyCheck();
      }
    },
  
    startPollings: function startPollings() {
      var _this = this;
  
      // Don't start pollings inmediately,
      // wait some seconds
      setTimeout(function () {
        if (_this.get('importsPolling')) {
          _this.importsCollection.pollCheck();
        }
      }, pollingsTimer);
    },
  
    // onChange functions
    _onImportsStateChange: function _onImportsStateChange() {},
  
    clean: function clean() {
      this.importsCollection.unbind(null, null, this);
      Backbone.Model.prototype.clean.apply(this);
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/background-polling/dashboard-background-polling-model.js":
  /*!********************************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/background-polling/dashboard-background-polling-model.js ***!
    \********************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var BackgroundPollingModel = __webpack_require__(/*! dashboard/data/background-polling/background-polling-model */ "./lib/assets/javascripts/dashboard/data/background-polling/background-polling-model.js");
  
  /**
   *  Background polling model for the dashboard context.
   */
  module.exports = BackgroundPollingModel.extend({
  
    _onImportsStateChange: function _onImportsStateChange(importsModel) {
      if (this._shouldRedirect(importsModel)) {
        this._redirectTo(importsModel.getRedirectUrl(this._userModel));
        return;
      }
  
      if (importsModel.hasCompleted()) {
        this.trigger('importCompleted', importsModel, this);
      }
    },
  
    /**
     * Determines if the user can be redirected after the given
     * import has been completed. The following conditions must be true:
     *   - Import has been completed
     *   - No imports are still running
     *   - No other imports have been previously completed
     *   - Import has a redirect URL for the given user
     *   - Import was NOT a twitter import
     *   - Number of tables created:
     *     - n if import was a .carto file
     *     - 1 otherwise
     */
    _shouldRedirect: function _shouldRedirect(importsModel) {
      return importsModel.hasCompleted() && this.importsCollection.allImportsCompletedOrFailed() && this.importsCollection.getCompletedItemsCount() === 1 && !importsModel.isTwitterImport() && importsModel.getRedirectUrl(this._userModel) && (importsModel.getNumberOfTablesCreated() === 1 || importsModel.isCartoImport());
    },
  
    _redirectTo: function _redirectTo(url) {
      window.location = url;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/config-model.js":
  /*!***************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/config-model.js ***!
    \***************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   * Model for general frontend configuration.
   * Ported from old cdb.config, since we can't reuse the older model that's tied to v3 of cartodb.js
   *
   * Also, rather than putting it as a global object, it's intended to be instantiated at the entry point and passed as
   * a collaborator object the models that needs it, e.g.:
   * var myModel = new MyModel({ id: 123,  }, {
   *   configModel: configModel
   * })
   */
  module.exports = Backbone.Model.extend({
  
    VERSION: 2,
  
    initialize: function initialize() {
      this.modules = new Backbone.Collection();
      this.modules.on('add', function (model) {
        this.trigger('moduleLoaded');
        this.trigger('moduleLoaded:' + model.get('name'));
      }, this);
    },
  
    // error track
    REPORT_ERROR_URL: '/api/v0/error',
    ERROR_TRACK_ENABLED: false,
  
    /**
     * returns the base url to compose the final url
     * http://user.carto.com/
     */
    getSqlApiBaseUrl: function getSqlApiBaseUrl() {
      var url;
      if (this.get('sql_api_template')) {
        url = this.get('sql_api_template').replace('{user}', this.get('user_name'));
      } else {
        url = this.get('sql_api_protocol') + '://' + this.get('user_name') + '.' + this.get('sql_api_domain') + ':' + this.get('sql_api_port');
      }
      return url;
    },
  
    /**
     * returns the full sql api url, including the api endpoint
     * allos to specify the version
     * http://user.carto.com/api/v1/sql
     */
    getSqlApiUrl: function getSqlApiUrl(version) {
      version = version || 'v2';
      return this.getSqlApiBaseUrl() + '/api/' + version + '/sql';
    },
  
    /**
     *  returns the maps api host, removing user template
     *  and the protocol.
     *  carto.com:3333
     */
    getMapsApiHost: function getMapsApiHost() {
      var url;
      var mapsApiTemplate = this.get('maps_api_template');
      if (mapsApiTemplate) {
        url = mapsApiTemplate.replace(/https?:\/\/{user}\./, '');
      }
      return url;
    },
  
    setUrlVersion: function setUrlVersion(modelName, method, v) {
      this.set(modelName + '_' + method + '_url_version', v || 'v1');
    },
  
    urlVersion: function urlVersion(modelName, method, defaultVersion) {
      method = method || '';
      var version = this.get(modelName + '_' + method + '_url_version');
      return version || defaultVersion || 'v1';
    },
  
    prefixUrl: function prefixUrl() {
      return this.get('url_prefix') || '';
    },
  
    prefixUrlPathname: function prefixUrlPathname() {
      var prefix = this.prefixUrl();
      if (prefix !== '') {
        try {
          if (prefix && prefix.indexOf('/') === -1) throw new TypeError('invalid URL');
          var a = document.createElement('a');
          a.href = prefix;
          var url = a.pathname;
          // remove trailing slash
          return url.replace(/\/$/, '');
        } catch (e) {
          // not an url
        }
      }
      return prefix;
    },
  
    getMapsResourceName: function getMapsResourceName(username) {
      var url;
      var mapsApiTemplate = this.get('maps_api_template');
      if (mapsApiTemplate) {
        url = mapsApiTemplate.replace(/(http|https)?:\/\//, '').replace(/{user}/g, username);
      }
      return url;
    },
  
    dataLibraryEnabled: function dataLibraryEnabled() {
      return this.get('data_library_enabled');
    },
  
    isHosted: function isHosted() {
      return this.get('cartodb_com_hosted');
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/dashboard-datasets-url-model.js":
  /*!*******************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/dashboard-datasets-url-model.js ***!
    \*******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var DashboardVisUrlModel = __webpack_require__(/*! dashboard/data/dashboard-vis-url-model */ "./lib/assets/javascripts/dashboard/data/dashboard-vis-url-model.js");
  
  /**
   * URL representing dashboard datasets
   */
  var DashboardDatasetsUrlModel = DashboardVisUrlModel.extend({
  
    dataLibrary: function dataLibrary() {
      return this.urlToPath('library');
    }
  });
  
  module.exports = DashboardDatasetsUrlModel;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/dashboard-url-model.js":
  /*!**********************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/dashboard-url-model.js ***!
    \**********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var UrlModel = __webpack_require__(/*! dashboard/data/url-model */ "./lib/assets/javascripts/dashboard/data/url-model.js");
  var DashboardVisUrlModel = __webpack_require__(/*! dashboard/data/dashboard-vis-url-model */ "./lib/assets/javascripts/dashboard/data/dashboard-vis-url-model.js");
  var DashboardDatasetsUrlModel = __webpack_require__(/*! dashboard/data/dashboard-datasets-url-model */ "./lib/assets/javascripts/dashboard/data/dashboard-datasets-url-model.js");
  /**
   * URLs associated with the dashboard.
   */
  var DashboardUrlModel = UrlModel.extend({
  
    datasets: function datasets() {
      return new DashboardDatasetsUrlModel({
        base_url: this.urlToPath('datasets')
      });
    },
  
    maps: function maps() {
      return new DashboardVisUrlModel({
        base_url: this.urlToPath('maps')
      });
    },
  
    deepInsights: function deepInsights() {
      return new DashboardVisUrlModel({
        base_url: this.urlToPath('deep-insights')
      });
    }
  });
  
  module.exports = DashboardUrlModel;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/dashboard-vis-url-model.js":
  /*!**************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/dashboard-vis-url-model.js ***!
    \**************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var UrlModel = __webpack_require__(/*! dashboard/data/url-model */ "./lib/assets/javascripts/dashboard/data/url-model.js");
  
  /**
   * URLs associated with the dashboard visualizations.
   */
  var DashboardVisUrl = UrlModel.extend({
    lockedItems: function lockedItems() {
      return this.urlToPath('locked');
    },
  
    sharedItems: function sharedItems() {
      return this.urlToPath('shared');
    },
  
    likedItems: function likedItems() {
      return this.urlToPath('liked');
    }
  });
  
  module.exports = DashboardVisUrl;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/dataset-url-model.js":
  /*!********************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/dataset-url-model.js ***!
    \********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var UrlModel = __webpack_require__(/*! dashboard/data/url-model */ "./lib/assets/javascripts/dashboard/data/url-model.js");
  
  /**
   * URL for a dataset (standard vis).
   */
  var DatasetUrlModel = UrlModel.extend({
  
    edit: function edit() {
      return this.urlToPath();
    },
  
    public: function _public() {
      return this.urlToPath('public');
    }
  });
  
  module.exports = DatasetUrlModel;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/flash-message-model.js":
  /*!**********************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/flash-message-model.js ***!
    \**********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  module.exports = Backbone.Model.extend({
    defaults: {
      msg: '',
      type: 'error',
      display: false
    },
  
    shouldDisplay: function shouldDisplay() {
      return this.get('display') && !!this.get('msg') && !!this.get('type');
    },
  
    show: function show(message, type) {
      return this.set({
        display: true,
        msg: message,
        type: type
      });
    },
  
    hide: function hide() {
      this.set('display', false);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/grantables-collection.js":
  /*!************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/grantables-collection.js ***!
    \************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var UserModel = __webpack_require__(/*! dashboard/data/user-model */ "./lib/assets/javascripts/dashboard/data/user-model.js");
  var GroupModel = __webpack_require__(/*! dashboard/data/group-model */ "./lib/assets/javascripts/dashboard/data/group-model.js");
  
  var REQUIRED_OPTS = ['configModel'];
  
  /**
   * A collection of Grantable objects.
   */
  module.exports = Backbone.Collection.extend({
  
    model: function model(attrs, _ref) {
      var collection = _ref.collection;
  
      // This used to be in its own file, but we took the same approach as builder
  
      // This used to have:
      // new cdb.admin[className](this.get('model'));
      // We took grantable_presenter types as the truth.
  
      var configModel = collection._configModel,
          organization = collection.organization;
  
  
      var model = void 0;
      if (attrs.type === 'user') {
        model = new UserModel(attrs, { configModel: configModel, collection: collection });
      } else {
        model = new GroupModel(attrs, { configModel: configModel, collection: collection });
      }
      model.organization = organization;
      model.entity = model; // legacy (see grantable.js), left in case someone uses it
      return model;
    },
  
    url: function url(method) {
      var version = this._configModel.urlVersion('organizationGrantables', method);
      return '/api/' + version + '/organization/' + this.organization.id + '/grantables';
    },
  
    initialize: function initialize(users, opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
      if (!opts.organization) throw new Error('organization is required');
      this.organization = opts.organization;
      this.currentUserId = opts.currentUserId;
      this.sync = __webpack_require__(/*! dashboard/data/backbone/sync-abort */ "./lib/assets/javascripts/dashboard/data/backbone/sync-abort.js"); // adds abort behaviour
    },
  
    parse: function parse(response) {
      this.total_entries = response.total_entries;
  
      return _.reduce(response.grantables, function (memo, m) {
        if (m.id === this.currentUserId) {
          this.total_entries--;
        } else {
          memo.push(m);
        }
  
        return memo;
      }, [], this);
    },
  
    // @return {Number, undefined} may be undefined until a first fetch is done
    totalCount: function totalCount() {
      return this.total_entries;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/group-model.js":
  /*!**************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/group-model.js ***!
    \**************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var GroupUsersCollection = __webpack_require__(/*! dashboard/data/group-users-collection */ "./lib/assets/javascripts/dashboard/data/group-users-collection.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel'];
  
  /**
   * Model representing a group.
   * Expected to be used in the context of a groups collection (e.g. cdb.admin.OrganizationGroups),
   * which defines its API endpoint path.
   */
  module.exports = Backbone.Model.extend({
    defaults: {
      display_name: '' // UI name, as given by
      // name: '', // internal alphanumeric representation, converted from display_name internally
      // organization_id: '',
    },
  
    initialize: function initialize(attrs, options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
      this.parse(attrs || {}); // handle given attrs in the same way as for .fetch()
    },
  
    parse: function parse(attrs, options) {
      this.users = new GroupUsersCollection(attrs.users, {
        group: this,
        configModel: this._configModel
      });
      return attrs;
    },
  
    getModelType: function getModelType() {
      return 'group';
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/group-users-collection.js":
  /*!*************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/group-users-collection.js ***!
    \*************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var User = __webpack_require__(/*! dashboard/data/user-model */ "./lib/assets/javascripts/dashboard/data/user-model.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel'];
  
  /**
   * A collection representing a set of users in a group.
   */
  module.exports = Backbone.Collection.extend({
  
    model: User,
  
    initialize: function initialize(models, opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
      if (!opts.group) throw new Error('group is required');
      this.group = opts.group;
    },
  
    url: function url() {
      return this.group.url.apply(this.group, arguments) + '/users';
    },
  
    parse: function parse(response) {
      this.total_entries = response.total_entries;
      this.total_user_entries = response.total_user_entries;
  
      return response.users;
    },
  
    /**
     * Batch add users
     * @param {Array} userIds
     * @return {Object} a deferred jqXHR object
     */
    addInBatch: function addInBatch(userIds, password) {
      return this._batchAsyncProcessUsers('POST', userIds, password);
    },
  
    removeInBatch: function removeInBatch(userIds, password) {
      var self = this;
      return this._batchAsyncProcessUsers('DELETE', userIds, password).done(function () {
        _.each(userIds, self.remove.bind(self));
      });
    },
  
    _batchAsyncProcessUsers: function _batchAsyncProcessUsers(method, ids, password) {
      var self = this;
  
      // postpone relving promise since the fetch is requries for collection to have accurate state
      var deferred = $.Deferred();
      $.ajax({
        type: method,
        url: this._configModel.get('base_url') + this.url(),
        data: {
          users: ids,
          password_confirmation: password
        },
        success: function success() {
          var args = arguments;
  
          // because add/remove don't return any data, so need to fetch to get accurate state
          self.fetch({
            success: function success() {
              deferred.resolve.apply(deferred, args);
            },
            error: function error() {
              // could not update state, but resolve anyway since batch operation worked
              // might have inconsistent state though
              deferred.resolve.apply(deferred, args);
            }
          });
        },
        error: function error() {
          deferred.reject.apply(deferred, arguments);
        }
      });
  
      return deferred;
    },
  
    // @return {Number, undefined} may be undefined until a first fetch is done
    totalCount: function totalCount() {
      return this.total_user_entries;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/import-model.js":
  /*!***************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/import-model.js ***!
    \***************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  module.exports = Backbone.Model.extend({
  
    idAttribute: 'item_queue_id',
  
    urlRoot: '/api/v1/imports',
  
    initialize: function initialize() {
      this.bind('change', this._checkFinish, this);
    },
  
    setUrlRoot: function setUrlRoot(urlRoot) {
      this.urlRoot = urlRoot;
    },
  
    /**
     * checks for poll to finish
     */
    pollCheck: function pollCheck(i) {
      var self = this;
      this.pollTimer = setInterval(function () {
        // cdb.log.debug("checking job for finish: " + tries);
        self.fetch({
          error: function error(e) {
            self.trigger('change');
          }
        });
      }, i || 1500);
    },
  
    destroyCheck: function destroyCheck() {
      clearInterval(this.pollTimer);
    },
  
    _checkFinish: function _checkFinish() {
      // cdb.log.info("state: " + this.get('state'), "success: " + this.get("success"));
  
      if (this.get('success') === true) {
        // cdb.log.debug("job finished");
        clearInterval(this.pollTimer);
        this.trigger('importComplete', this);
      } else if (this.get('success') === false) {
        // cdb.log.debug("job failure");
        clearInterval(this.pollTimer);
        this.trigger('importError', this);
      } else {
        this.trigger('importChange', this);
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/imports-collection.js":
  /*!*********************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/imports-collection.js ***!
    \*********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var ImportsModel = __webpack_require__(/*! dashboard/data/imports-model */ "./lib/assets/javascripts/dashboard/data/imports-model.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var pollTimer = 30000;
  
  var REQUIRED_OPTS = ['configModel', 'userModel'];
  
  /**
   *  Imports collection
   *
   *  If it is fetched, it will add the import
   *
   */
  
  module.exports = Backbone.Collection.extend({
  
    model: function model(attrs, options) {
      return new ImportsModel(attrs, {
        userModel: options.collection._userModel,
        configModel: options.collection._configModel
      });
    },
  
    url: function url(method) {
      var version = this._configModel.urlVersion('import', method);
      return '/api/' + version + '/imports';
    },
  
    initialize: function initialize(models, options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
    },
  
    parse: function parse(r) {
      var _this = this;
  
      if (r.imports.length === 0) {
        this.destroyCheck();
      } else {
        _.each(r.imports, function (id) {
          // Check if that import exists...
          var imports = _this.filter(function (mdl) {
            return mdl._importModel.get('item_queue_id') === id;
          });
  
          if (imports.length === 0) {
            _this.add(new ImportsModel({ id: id }, {
              userModel: _this._userModel,
              configModel: _this._configModel
            }));
          }
        });
      }
  
      return this.models;
    },
  
    canImport: function canImport() {
      var importQuota = this._userModel.getMaxConcurrentImports();
      var total = this.size();
      var finished = 0;
  
      this.each(function (m) {
        if (m.hasFailed() || m.hasCompleted()) {
          ++finished;
        }
      });
  
      return total - finished < importQuota;
    },
  
    pollCheck: function pollCheck(i) {
      var _this2 = this;
  
      if (this.pollTimer) return;
  
      this.pollTimer = setInterval(function () {
        _this2.fetch();
      }, pollTimer || 2000);
  
      // Start doing a fetch
      this.fetch();
    },
  
    destroyCheck: function destroyCheck() {
      clearInterval(this.pollTimer);
      delete this.pollTimer;
    },
  
    completedItems: function completedItems() {
      return this.filter(function (item) {
        return item.hasCompleted();
      });
    },
  
    getCompletedItemsCount: function getCompletedItemsCount() {
      return this.completedItems().length;
    },
  
    failedItems: function failedItems() {
      return this.filter(function (item) {
        return item.hasFailed();
      });
    },
  
    getFailedItemsCount: function getFailedItemsCount() {
      return this.failedItems().length;
    },
  
    allImportsCompletedOrFailed: function allImportsCompletedOrFailed() {
      return this.all(function (item) {
        return item.hasCompleted() || item.hasFailed();
      });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/imports-model.js":
  /*!****************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/imports-model.js ***!
    \****************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  // TODO: Hacer un extend del archivo de builder
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var ImportModel = __webpack_require__(/*! builder/data/background-importer/import-model */ "./lib/assets/javascripts/builder/data/background-importer/import-model.js");
  var UploadModel = __webpack_require__(/*! dashboard/data/upload-model */ "./lib/assets/javascripts/dashboard/data/upload-model.js");
  var VisualizationModel = __webpack_require__(/*! dashboard/data/visualization-model */ "./lib/assets/javascripts/dashboard/data/visualization-model.js");
  var PermissionModel = __webpack_require__(/*! dashboard/data/permission-model */ "./lib/assets/javascripts/dashboard/data/permission-model.js");
  
  /**
   *  Upload/import model
   *
   *  It takes the control of the upload and import,
   *  listening the change of any of these steps.
   *
   *  Steps:
   *  - upload
   *  - import
   *
   */
  
  module.exports = Backbone.Model.extend({
  
    defaults: {
      step: 'upload',
      state: ''
    },
  
    initialize: function initialize(attrs, opts) {
      if (!opts.userModel) throw new Error('userModel is required');
      if (!opts.configModel) throw new Error('configModel is required');
  
      this._userModel = opts.userModel;
      this._configModel = opts.configModel;
  
      this._uploadModel = new UploadModel(opts.upload, {
        userModel: this._userModel,
        configModel: this._configModel
      });
  
      if (_.isEmpty(opts)) {
        opts = {};
      }
  
      this._importModel = new ImportModel(opts.import, {
        configModel: this._configModel
      });
      this._initBinds();
      this._checkStatus();
    },
  
    _initBinds: function _initBinds() {
      this.bind('change:import', this._onImportChange, this);
      this.bind('change:upload', this._onUploadChange, this);
      this.bind('change:id', this._onIdChange, this);
  
      this._importModel.bind('change', function () {
        this.trigger('change:import', this);
        this.trigger('change', this);
      }, this);
  
      this._uploadModel.bind('change', function () {
        this.trigger('change:upload', this);
        this.trigger('change', this);
      }, this);
    },
  
    _destroyBinds: function _destroyBinds() {
      this._uploadModel.unbind(null, null, this);
      this._importModel.unbind(null, null, this);
    },
  
    _onIdChange: function _onIdChange() {
      var item_queue_id = this.get('id');
      if (item_queue_id) this._importModel.set('item_queue_id', item_queue_id);
      this.set('step', 'import');
    },
  
    _onUploadChange: function _onUploadChange(m, i) {
      if (this.get('step') === 'upload') {
        var item_queue_id = this._uploadModel.get('item_queue_id');
        var state = this._uploadModel.get('state');
  
        if (item_queue_id) this.set('id', item_queue_id);
        if (state) this.set('state', state);
      }
    },
  
    _onImportChange: function _onImportChange() {
      if (this.get('step') === 'import') {
        var state = this._importModel.get('state');
        if (state) this.set('state', state);
      }
    },
  
    _checkStatus: function _checkStatus() {
      if (!this.get('id') && !this._uploadModel.isValid()) {
        this.trigger('change:upload');
        return;
      }
  
      if (this._uploadModel.get('type') === 'file') {
        this._uploadModel.upload();
      } else if (this.get('id')) {
        this.set('step', 'import');
        this._importModel.set('item_queue_id', this.get('id'));
      } else if (!this._importModel.get('item_queue_id') && this._uploadModel.get('type') !== '') {
        this.set('step', 'import');
        this._importModel.createImport(this._uploadModel.toJSON());
      }
    },
  
    getImportModel: function getImportModel() {
      return this._importModel;
    },
  
    pause: function pause() {
      this.stopUpload();
      this.stopImport();
    },
  
    hasFailed: function hasFailed() {
      var state = this.get('state');
      var step = this.get('step');
  
      return step === 'import' && state === 'failure' || step === 'upload' && state === 'error';
    },
  
    hasCompleted: function hasCompleted() {
      return this.get('step') === 'import' && this._importModel && this._importModel.get('state') === 'complete';
    },
  
    getWarnings: function getWarnings() {
      return this.get('step') === 'import' ? this._importModel.get('warnings') : '';
    },
  
    getError: function getError() {
      if (this.hasFailed()) {
        var step = this.get('step');
        return _.extend({
          errorCode: this[step === 'upload' ? '_uploadModel' : '_importModel'].get('error_code'),
          itemQueueId: step === 'import' ? this._importModel.get('id') : '',
          originalUrl: step === 'import' ? this._importModel.get('original_url') : '',
          dataType: step === 'import' ? this._importModel.get('data_type') : '',
          httpResponseCode: step === 'import' ? this._importModel.get('http_response_code') : '',
          httpResponseCodeMessage: step === 'import' ? this._importModel.get('http_response_code_message') : ''
        }, this[step === 'upload' ? '_uploadModel' : '_importModel'].get('get_error_text'));
      }
  
      return {
        title: '',
        what_about: '',
        error_code: ''
      };
    },
  
    importedVis: function importedVis() {
      if (this.get('import').derived_visualization_id) {
        return this._getMapVis();
      } else {
        return this._getDatasetVis();
      }
    },
  
    getNumberOfTablesCreated: function getNumberOfTablesCreated() {
      return this._importModel.get('tables_created_count');
    },
  
    _getServiceName: function _getServiceName() {
      return this._importModel.get('service_name');
    },
  
    isTwitterImport: function isTwitterImport() {
      return this._getServiceName() === 'twitter_search';
    },
  
    isCartoImport: function isCartoImport() {
      return this._getDisplayName() && this._getDisplayName().match(/\.carto$/i);
    },
  
    _getDisplayName: function _getDisplayName() {
      return this._importModel.get('display_name');
    },
  
    _getMapVis: function _getMapVis() {
      var derivedVisId = this._importModel.get('derived_visualization_id');
  
      if (!derivedVisId) {
        return false;
      }
  
      return this._createVis({
        type: 'derived',
        id: derivedVisId
      });
    },
  
    _getDatasetVis: function _getDatasetVis() {
      var tableName = this._importModel.get('table_name');
  
      if (!tableName) {
        return false;
      }
  
      return this._createVis({
        type: 'table',
        table: {
          name: tableName
        }
      });
    },
  
    _createVis: function _createVis(attrs) {
      var vis = new VisualizationModel(attrs, {
        configModel: this._configModel
      });
  
      vis.permission = new PermissionModel({
        owner: this._userModel.attributes
      }, {
        configModel: this._configModel,
        userModel: this._userModel
      });
  
      return vis;
    },
  
    setError: function setError(opts) {
      var stepModel = this[this.get('step') === 'upload' ? '_uploadModel' : '_importModel'];
  
      this.stopUpload();
      this.stopImport();
  
      stepModel.set(opts);
  
      this.set('state', 'error');
    },
  
    stopUpload: function stopUpload() {
      this._uploadModel.stopUpload();
    },
  
    stopImport: function stopImport() {
      this._importModel.destroyCheck();
    },
  
    get: function get(attr) {
      if (attr === 'upload') {
        return this._uploadModel.toJSON();
      }
  
      if (attr === 'import') {
        return this._importModel.toJSON();
      }
  
      return Backbone.Model.prototype.get.call(this, attr);
    },
  
    getRedirectUrl: function getRedirectUrl(user) {
      var vis = this.importedVis();
      if (vis) {
        return encodeURI(vis.viewUrl(user).edit());
      }
    },
  
    toJSON: function toJSON() {
      return {
        step: this.get('step'),
        id: this.get('id'),
        state: this.get('state'),
        upload: this._uploadModel.toJSON(),
        import: this._importModel.toJSON()
      };
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/layers-collection.js":
  /*!********************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/layers-collection.js ***!
    \********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var MapLayer = __webpack_require__(/*! dashboard/data/map-layer-model */ "./lib/assets/javascripts/dashboard/data/map-layer-model.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var TILED_LAYER_TYPE = 'Tiled';
  var CARTODB_LAYER_TYPE = 'CartoDB';
  var TORQUE_LAYER_TYPE = 'torque';
  
  var REQUIRED_OPTS = ['configModel'];
  
  var LayersCollection = Backbone.Collection.extend({
    model: MapLayer,
  
    initialize: function initialize(models, options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      this.comparator = function (m) {
        return parseInt(m.get('order'), 10);
      };
      this.bind('add', this._assignIndexes);
      this.bind('remove', this._assignIndexes);
    },
  
    url: function url(method) {
      var version = this._configModel.urlVersion('layer', method);
      return '/api/' + version + '/maps/' + this.map.id + '/layers';
    },
  
    parse: function parse(data) {
      return data.layers;
    },
  
    /**
     * each time a layer is added or removed
     * the index should be recalculated
     */
    _assignIndexes: function _assignIndexes(model, col, options) {
      if (this.size() > 0) {
        // Assign an order of 0 to the first layer
        this.at(0).set({ order: 0 });
  
        if (this.size() > 1) {
          var layersByType = {};
          for (var i = 1; i < this.size(); ++i) {
            var layer = this.at(i);
            var layerType = layer.get('type');
            layersByType[layerType] = layersByType[layerType] || [];
            layersByType[layerType].push(layer);
          }
  
          var lastOrder = 0;
          var sortedTypes = [CARTODB_LAYER_TYPE, TORQUE_LAYER_TYPE, TILED_LAYER_TYPE];
          for (var index = 0; index < sortedTypes.length; ++index) {
            var type = sortedTypes[index];
            var layers = layersByType[type] || [];
            for (var j = 0; j < layers.length; ++j) {
              var layerModel = layers[j];
              layerModel.set({
                order: ++lastOrder
              });
            }
          }
        }
      }
    }
  });
  
  module.exports = LayersCollection;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/like-model.js":
  /*!*************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/like-model.js ***!
    \*************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['config'];
  
  var LikeModel = Backbone.Model.extend({
  
    defaults: {
      likeable: true
    },
  
    url: function url(method) {
      var version = this._config.urlVersion('like', method);
      return this._config.get('base_url') + '/api/' + version + '/viz/' + this.get('vis_id') + '/like';
    },
  
    initialize: function initialize(attrs, options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      _.bindAll(this, '_onSaveError');
  
      this.on('destroy', function () {
        this.set({
          liked: false,
          likes: this.get('likes') - 1
        });
      }, this);
    },
  
    _onSaveError: function _onSaveError(model, response) {
      this.trigger('error', {
        status: response.status,
        statusText: response.statusText
      });
    },
  
    toggleLiked: function toggleLiked() {
      if (this.get('liked')) {
        this.destroy();
      } else {
        this.set({ id: null }, { silent: true });
        this.save({}, { error: this._onSaveError });
      }
    }
  
  }, {
  
    newByVisData: function newByVisData(opts) {
      var d = _.defaults({
        id: opts.liked ? opts.vis_id : null
      }, _.omit(opts, 'url', 'config'));
  
      var model = new LikeModel(d, {
        config: opts.config
      });
  
      if (opts.url) {
        model.url = opts.url;
      }
  
      return model;
    }
  });
  
  module.exports = LikeModel;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/map-layer-model.js":
  /*!******************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/map-layer-model.js ***!
    \******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  var MapLayer = Backbone.Model.extend({
    defaults: {
      visible: true,
      type: 'Tiled'
    }
  });
  
  module.exports = MapLayer;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/map-model.js":
  /*!************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/map-model.js ***!
    \************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var LayersCollection = __webpack_require__(/*! dashboard/data/layers-collection */ "./lib/assets/javascripts/dashboard/data/layers-collection.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel'];
  
  var MapModel = Backbone.Model.extend({
    urlRoot: '/api/v1/maps',
  
    initialize: function initialize(options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
      this.bind('change:id', this._fetchLayers, this);
  
      this.layers = new LayersCollection(null, { configModel: this._configModel });
      this.layers.map = this;
    },
  
    // fetch related layers
    _fetchLayers: function _fetchLayers() {
      this.layers.fetch();
    }
  });
  
  module.exports = MapModel;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/map-url-model.js":
  /*!****************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/map-url-model.js ***!
    \****************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var UrlModel = __webpack_require__(/*! dashboard/data/url-model */ "./lib/assets/javascripts/dashboard/data/url-model.js");
  
  /**
   * URL for a map (derived vis).
   */
  var MapUrlModel = UrlModel.extend({
  
    edit: function edit() {
      return this.urlToPath('map');
    },
  
    public: function _public() {
      return this.urlToPath('public_map');
    },
  
    deepInsights: function deepInsights() {
      return this.urlToPath('deep-insights');
    }
  });
  
  module.exports = MapUrlModel;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/organization-groups-collection.js":
  /*!*********************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/organization-groups-collection.js ***!
    \*********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var GroupModel = __webpack_require__(/*! dashboard/data/group-model */ "./lib/assets/javascripts/dashboard/data/group-model.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel'];
  
  /**
   * A collection that holds a set of organization groups
   */
  module.exports = Backbone.Collection.extend({
  
    model: function model(attrs, _ref) {
      var collection = _ref.collection;
  
      return new GroupModel(attrs, {
        collection: collection,
        configModel: collection._configModel
      });
    },
  
    url: function url(method) {
      var version = this._configModel.urlVersion('organizationGroups', method);
      return '/api/' + version + '/organization/' + this.organization.id + '/groups';
    },
  
    initialize: function initialize(models, opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
      if (!opts.organization) throw new Error('organization is required');
      this.organization = opts.organization;
    },
  
    parse: function parse(response) {
      this.total_entries = response.total_entries;
      return response.groups;
    },
  
    // @return {Object} A instance of cdb.admin.Group. If group wasn't already present a new model with id and collection
    //  set will be returned, i.e. group.fetch() will be required to get the data or handle the err case (e.g. non-existing)
    newGroupById: function newGroupById(id) {
      var group = this.get(id);
      if (!group) {
        group = new GroupModel({
          id: id
        }, { configModel: this._configModel, collection: this });
      }
      return group;
    },
  
    // @return {Number, undefined} may be undefined until a first fetch is done
    totalCount: function totalCount() {
      return this.total_entries;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/organization-model.js":
  /*!*********************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/organization-model.js ***!
    \*********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var OrganizationUsersCollection = __webpack_require__(/*! dashboard/data/organization-users-collection */ "./lib/assets/javascripts/dashboard/data/organization-users-collection.js");
  var GrantablesCollection = __webpack_require__(/*! dashboard/data/grantables-collection */ "./lib/assets/javascripts/dashboard/data/grantables-collection.js");
  var OrganizationGroupsCollection = __webpack_require__(/*! dashboard/data/organization-groups-collection */ "./lib/assets/javascripts/dashboard/data/organization-groups-collection.js");
  var OrganizationUrl = __webpack_require__(/*! dashboard/data/organization-url-model */ "./lib/assets/javascripts/dashboard/data/organization-url-model.js");
  var UserModel = __webpack_require__(/*! dashboard/data/user-model */ "./lib/assets/javascripts/dashboard/data/user-model.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel'];
  
  /**
   * this model contains information about the organization for
   * the current user and the users who are inside the organizacion.
   *
   * Attributes:
   * - users: collection with user instances within the organization (see cdb.admin.Organization.Users
   */
  module.exports = Backbone.Model.extend({
  
    url: '/api/v1/org/',
  
    initialize: function initialize(attrs, opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
      attrs = attrs || {};
  
      this.owner = new UserModel(this.get('owner'));
  
      // ESlint errors on the below line ported as they were (== instead of ===)
      this.display_email = typeof attrs.admin_email !== 'undefined' && attrs.admin_email != null && (attrs.admin_email == '' ? this.owner.email : attrs.admin_email); // eslint-disable-line
  
      var collectionOpts = {
        organization: this,
        currentUserId: opts && opts.currentUserId,
        configModel: this._configModel
      };
      this.users = new OrganizationUsersCollection(attrs.users, collectionOpts);
      this.groups = new OrganizationGroupsCollection(attrs.groups, collectionOpts);
      this.grantables = new GrantablesCollection(undefined, collectionOpts);
  
      // make sure all the users/groups have a reference to this organization
      this.users.each(this._setOrganizationOnModel, this);
      this.groups.each(this._setOrganizationOnModel, this);
    },
  
    _setOrganizationOnModel: function _setOrganizationOnModel(m) {
      m.organization = this;
    },
  
    fetch: function fetch() {
      throw new Error('organization should not be fetch, should be static');
    },
  
    containsUser: function containsUser(user) {
      return !!this.users.find(function (u) {
        return u.id === user.id;
      });
    },
  
    isOrgAdmin: function isOrgAdmin(user) {
      return this.owner.id === user.id || !!_.find(this.get('admins'), function (u) {
        return u.id === user.id;
      });
    },
  
    viewUrl: function viewUrl() {
      return new OrganizationUrl({
        base_url: this.get('base_url')
      });
    },
  
    getModelType: function getModelType() {
      return 'org';
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/organization-url-model.js":
  /*!*************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/organization-url-model.js ***!
    \*************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var UrlModel = __webpack_require__(/*! dashboard/data/url-model */ "./lib/assets/javascripts/dashboard/data/url-model.js");
  
  /**
   * URL for a map (derived vis).
   */
  var OrganizationUrlModel = UrlModel.extend({
    edit: function edit(user) {
      if (!user) {
        throw new Error('User is needed to create the url');
      }
      return this.urlToPath(user.get('username') + '/edit');
    },
  
    create: function create() {
      return this.urlToPath('new');
    },
  
    groups: function groups() {
      return this.urlToPath('groups');
    }
  });
  
  module.exports = OrganizationUrlModel;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/organization-users-collection.js":
  /*!********************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/organization-users-collection.js ***!
    \********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var UserModel = __webpack_require__(/*! dashboard/data/user-model */ "./lib/assets/javascripts/dashboard/data/user-model.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['organization', 'configModel'];
  
  // helper to manage organization users
  module.exports = Backbone.Collection.extend({
    model: UserModel,
  
    _DEFAULT_EXCLUDE_CURRENT_USER: true,
  
    url: function url() {
      return '/api/v1/organization/' + this.organization.id + '/users';
    },
  
    initialize: function initialize(models, options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      this.organization = this._organization;
      this.currentUserId = options.currentUserId;
      this._excludeCurrentUser = this._DEFAULT_EXCLUDE_CURRENT_USER;
    },
  
    comparator: function comparator(model) {
      return model.get('username');
    },
  
    excludeCurrentUser: function excludeCurrentUser(exclude) {
      exclude = !!exclude;
      this._excludeCurrentUser = exclude;
      if (exclude && !this.currentUserId) {
        console.error('set excludeCurrentUser to true, but there is no current user id set to exclude!');
      }
    },
  
    restoreExcludeCurrentUser: function restoreExcludeCurrentUser() {
      this.excludeCurrentUser(this._DEFAULT_EXCLUDE_CURRENT_USER);
    },
  
    parse: function parse(r) {
      this.total_entries = r.total_entries;
      this.total_user_entries = r.total_user_entries;
  
      return _.reduce(r.users, function (memo, user) {
        if (this._excludeCurrentUser && user.id === this.currentUserId) {
          this.total_user_entries--;
          this.total_entries--;
        } else {
          memo.push(user);
        }
        return memo;
      }, [], this);
    },
  
    // @return {Number, undefined} may be undefined until a first fetch is done
    totalCount: function totalCount() {
      return this.total_user_entries;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/permission-model.js":
  /*!*******************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/permission-model.js ***!
    \*******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var result = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js").result;
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var UserModel = __webpack_require__(/*! dashboard/data/user-model */ "./lib/assets/javascripts/dashboard/data/user-model.js");
  var OrganizationModel = __webpack_require__(/*! dashboard/data/organization-model */ "./lib/assets/javascripts/dashboard/data/organization-model.js");
  var GroupModel = __webpack_require__(/*! dashboard/data/group-model */ "./lib/assets/javascripts/dashboard/data/group-model.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  // Nobody else uses this, and it would incur on a circular dependency if moved to a file
  var ACLItemModel = Backbone.Model.extend({
    defaults: {
      access: 'r'
    },
  
    isOwn: function isOwn(model) {
      return model.id === this.get('entity').id;
    },
  
    validate: function validate(attrs, options) {
      var p = PermissionModel;
      if (attrs.access !== p.READ_ONLY && attrs.access !== p.READ_WRITE) {
        return "access can't take 'r' or 'rw' values";
      }
    },
  
    toJSON: function toJSON() {
      var entity = _.pick(this.get('entity').toJSON(), 'id', 'username', 'avatar_url', 'name');
      // translate name to username
      if (!entity.username) {
        entity.username = entity.name;
        delete entity.name;
      }
      return {
        type: this.get('type') || 'user',
        entity: entity,
        access: this.get('access')
      };
    }
  });
  
  var REQUIRED_OPTS = ['configModel'];
  
  /**
   * manages a cartodb permission object, it contains:
   * - owner: an cdb.admin.User instance
   * - acl: a collection which includes the user and their permission.
   *
   *   see https://github.com/Vizzuality/cartodb-management/wiki/multiuser-REST-API#permissions-object
   *
   *   this object is not created to work alone, it should be a member of an object like visualization
   *   table
   */
  var PermissionModel = Backbone.Model.extend({
    urlRoot: '/api/v1/perm',
  
    initialize: function initialize(attrs, options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
      this.acl = new Backbone.Collection();
      this.owner = null;
      this._generateOwner();
      this._generateAcl();
      this.bind('change:owner', this._generateOwner, this);
      this.bind('change:acl', this._generateAcl, this);
    },
  
    _generateOwner: function _generateOwner() {
      if (!this.owner) {
        this.owner = new UserModel(undefined, { configModel: this._configModel });
      }
      this.owner.set(this.get('owner'));
    },
  
    _generateAcl: function _generateAcl() {
      this.acl.reset([], { silent: true });
      _.each(this.get('acl'), function (aclItem) {
        var model;
        switch (aclItem.type) {
          case 'user':
            model = new UserModel(aclItem.entity, { configModel: this._configModel });
            break;
          case 'org':
            model = new OrganizationModel(aclItem.entity, { configModel: this._configModel });
            break;
          case 'group':
            model = new GroupModel(aclItem.entity, { configModel: this._configModel });
            break;
          default:
            throw new Error('Unknown ACL item type: ' + aclItem.type);
        }
        this._grantAccess(model, aclItem.access);
      }, this);
    },
  
    cleanPermissions: function cleanPermissions() {
      this.acl.reset();
    },
  
    hasAccess: function hasAccess(model) {
      // Having at least read access is the same as having any access
      return this.hasReadAccess(model);
    },
  
    hasReadAccess: function hasReadAccess(model) {
      // If there is a representable ACL item it must be one of at least READ_ONLY access
      return !!this.findRepresentableAclItem(model);
    },
  
    hasWriteAccess: function hasWriteAccess(model) {
      var access = result(this.findRepresentableAclItem(model), 'get', 'access');
      return access === PermissionModel.READ_WRITE;
    },
  
    canChangeReadAccess: function canChangeReadAccess(model) {
      return this._canChangeAccess(model);
    },
  
    canChangeWriteAccess: function canChangeWriteAccess(model) {
      return (!model.isBuilder || model.isBuilder()) && this._canChangeAccess(model, function (representableAclItem) {
        return result(representableAclItem, 'get', 'access') !== PermissionModel.READ_WRITE;
      });
    },
  
    _canChangeAccess: function _canChangeAccess(model) {
      var representableAclItem = this.findRepresentableAclItem(model);
      return this.isOwner(model) || !representableAclItem || representableAclItem === this._ownAclItem(model) || result(arguments, 1, representableAclItem) || false;
    },
  
    grantWriteAccess: function grantWriteAccess(model) {
      this._grantAccess(model, this.constructor.READ_WRITE);
    },
  
    grantReadAccess: function grantReadAccess(model) {
      this._grantAccess(model, this.constructor.READ_ONLY);
    },
  
    revokeWriteAccess: function revokeWriteAccess(model) {
      // Effectively "downgrades" to READ_ONLY
      this.grantReadAccess(model);
    },
  
    /**
     * Revokes access to a set of items
     * @param {Object} model A single model or an array of models
     */
    revokeAccess: function revokeAccess(model) {
      var aclItem = this._ownAclItem(model);
      if (aclItem) {
        this.acl.remove(aclItem);
      }
    },
  
    getOwner: function getOwner() {
      return this.owner;
    },
  
    isOwner: function isOwner(model) {
      return _.result(this.owner, 'id') === _.result(model, 'id');
    },
  
    toJSON: function toJSON() {
      return {
        entity: this.get('entity'),
        acl: this.acl.toJSON()
      };
    },
  
    getUsersWithAnyPermission: function getUsersWithAnyPermission() {
      return this.acl.chain().filter(this._hasTypeUser).map(this._getEntity).value();
    },
  
    isSharedWithOrganization: function isSharedWithOrganization() {
      return this.acl.any(this._hasTypeOrg);
    },
  
    clone: function clone() {
      var attrs = _.clone(this.attributes);
      delete attrs.id;
      return new PermissionModel(attrs, { configModel: this._configModel });
    },
  
    /**
     * Overwrite this ACL list from other permission object
     * @param otherPermission {Object} instance of PermissionModel
     */
    overwriteAcl: function overwriteAcl(otherPermission) {
      this.acl.reset(otherPermission.acl.models);
    },
  
    // Note that this may return an inherited ACL item
    // use ._ownAclItem instead if only model's own is wanted (if there is any)
    findRepresentableAclItem: function findRepresentableAclItem(model) {
      if (this.isOwner(model)) {
        return this._newAclItem(model, this.constructor.READ_WRITE);
      } else {
        var checkList = ['_ownAclItem', '_organizationAclItem', '_mostPrivilegedGroupAclItem'];
        return this._findMostPrivilegedAclItem(checkList, function (fnName) {
          return this[fnName](model);
        });
      }
    },
  
    _hasTypeUser: function _hasTypeUser(m) {
      return m.get('type') === 'user';
    },
  
    _getEntity: function _getEntity(m) {
      return m.get('entity');
    },
  
    _hasTypeOrg: function _hasTypeOrg(m) {
      return m.get('type') === 'org';
    },
  
    _isOrganization: function _isOrganization(object) {
      return object instanceof OrganizationModel;
    },
  
    _ownAclItem: function _ownAclItem(model) {
      if (!model || !_.isFunction(model.isNew)) {
        console.error('model is required to find an ACL item');
      }
      if (!model.isNew()) {
        return this.acl.find(function (aclItem) {
          return aclItem.get('entity').id === model.id;
        });
      }
    },
  
    _organizationAclItem: function _organizationAclItem(m) {
      var org = _.result(m.collection, 'organization') || m.organization;
      if (org) {
        return this._ownAclItem(org);
      }
    },
  
    _mostPrivilegedGroupAclItem: function _mostPrivilegedGroupAclItem(m) {
      var groups = _.result(m.groups, 'models');
      if (groups) {
        return this._findMostPrivilegedAclItem(groups, this._ownAclItem);
      }
    },
  
    /**
     * Iterates over a items in given list using the iteratee, stops and returns when found the ACL item with best access (i.e. READ_WRITE), or the
     * list is completed.
     * @param {Array} list
     * @param {Function} iteratee that takes an item from list and returns an access
     *   iteratee is called in context of this model.
     * @Return {String} 'r', 'rw', or undefined if there were no access for given item
     */
    _findMostPrivilegedAclItem: function _findMostPrivilegedAclItem(list, iteratee) {
      var aclItem;
      for (var i = 0, x = list[i]; x && result(aclItem, 'get', 'access') !== PermissionModel.READ_WRITE; x = list[++i]) {
        // Keep last ACL item if iteratee returns nothing
        aclItem = iteratee.call(this, x) || aclItem;
      }
      return aclItem;
    },
  
    /**
     * Grants access to a set of items
     * @param {Object} model
     * @param {String} access can take the following values:
     * - 'r': read only
     * - 'rw': read and write permission
     */
    _grantAccess: function _grantAccess(model, access) {
      var aclItem = this._ownAclItem(model);
      if (aclItem) {
        aclItem.set('access', access);
      } else {
        aclItem = this._newAclItem(model, access);
        if (aclItem.isValid()) {
          this.acl.add(aclItem);
        } else {
          throw new Error(access + ' is not a valid ACL access');
        }
      }
    },
  
    _newAclItem: function _newAclItem(model, access) {
      var type = model.get('type') || model.getModelType();
  
      return new ACLItemModel({
        type: type,
        entity: model,
        access: access
      });
    }
  
  }, {
  
    READ_ONLY: 'r',
    READ_WRITE: 'rw'
  
  });
  
  module.exports = PermissionModel;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/slide-transition-model.js":
  /*!*************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/slide-transition-model.js ***!
    \*************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  // TODO: Maybe this file is unnecessary
  
  var SlideTransition = Backbone.Model.extend({
    defaults: {
      time: 0
    }
  });
  
  module.exports = SlideTransition;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/table-synchronization-model.js":
  /*!******************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/table-synchronization-model.js ***!
    \******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel'];
  
  /**
   *  Synced table model
   */
  
  module.exports = Backbone.Model.extend({
    _X: 1.2, // Multiply current interval for this number
    _INTERVAL: 1500, // Interval time between poll checkings
    _STATES: ['created', 'failure', 'success', 'syncing', 'queued'],
  
    defaults: {
      name: '',
      url: '',
      state: '',
      run_at: 0,
      ran_at: 0,
      retried_times: 0,
      interval: 0,
      error_code: 0,
      error_message: '',
      service_name: '',
      service_item_id: '',
      content_guessing: true,
      type_guessing: true
    },
  
    url: function url(method) {
      var version = this._configModel.urlVersion('synchronization', method);
  
      var base = '/api/' + version + '/synchronizations/';
      if (this.isNew()) {
        return base;
      }
      return base + this.id;
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
      this.bind('destroy', function () {
        this.unset('id');
      });
    },
  
    toJSON: function toJSON() {
      var c = _.clone(this.attributes);
  
      var d = {
        url: c.url,
        interval: c.interval,
        content_guessing: c.content_guessing,
        type_guessing: c.type_guessing,
        create_vis: c.create_vis
      };
  
      if (c.type === 'remote') {
        _.extend(d, {
          remote_visualization_id: c.remote_visualization_id,
          create_vis: false,
          value: c.value
        });
      }
  
      if (c.id !== undefined) {
        d.id = c.id;
      }
  
      // Comes from a service?
      if (c.service_name) {
        d.service_name = c.service_name;
        d.service_item_id = c.service_item_id;
      }
  
      return d;
    },
  
    syncNow: function syncNow(callback) {
      $.ajax({
        url: this._configModel.prefixUrl() + this.url() + '/sync_now',
        type: 'PUT'
      }).always(callback);
    },
  
    // Checks for poll to finish
    pollCheck: function pollCheck(i) {
      var self = this;
      var interval = this._INTERVAL;
  
      this.pollTimer = setInterval(request, interval);
  
      function request() {
        self.destroyCheck();
  
        self.fetch({
          error: function error(m, e) {
            self.set({
              error_message: e.statusText || '',
              state: 'failure'
            });
          }
        });
  
        interval = interval * self._X;
  
        self.pollTimer = setInterval(request, interval);
      }
    },
  
    destroyCheck: function destroyCheck() {
      clearInterval(this.pollTimer);
    },
  
    isSync: function isSync() {
      return !this.isNew();
    },
  
    linkToTable: function linkToTable(table) {
      var self = this;
      if (table.has('synchronization')) {
        this.set(table.get('synchronization'));
      }
  
      table.bind('change:synchronization', function () {
        self.set(table.get('synchronization'));
      }, table);
  
      table.bind('destroy', function destroy() {
        self.unbind(null, null, table);
        self.destroy();
      }, table);
      // TODO: manage table renaming
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/table/carto-table-data.js":
  /*!*************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/table/carto-table-data.js ***!
    \*************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var TableDataCollection = __webpack_require__(/*! dashboard/data/table/table-data-collection */ "./lib/assets/javascripts/dashboard/data/table/table-data-collection.js");
  var RowModel = __webpack_require__(/*! dashboard/data/table/row-model */ "./lib/assets/javascripts/dashboard/data/table/row-model.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var WKT = __webpack_require__(/*! dashboard/common/wkt */ "./lib/assets/javascripts/dashboard/common/wkt.js");
  var safeTableNameQuoting = __webpack_require__(/*! dashboard/helpers/safe-table-name-quoting */ "./lib/assets/javascripts/dashboard/helpers/safe-table-name-quoting.js");
  var cartoMetadataStatic = __webpack_require__(/*! dashboard/views/public-dataset/carto-table-metadata-static */ "./lib/assets/javascripts/dashboard/views/public-dataset/carto-table-metadata-static.js");
  
  var REQUIRED_OPTS = ['configModel'];
  
  module.exports = TableDataCollection.extend({
    _ADDED_ROW_TEXT: 'Row added correctly',
    _ADDING_ROW_TEXT: 'Adding a new row',
    _GEOMETRY_UPDATED: 'Table geometry updated',
  
    model: function model(attrs, opts) {
      var configModel = opts.collection._configModel;
      return new RowModel(attrs, {
        configModel: configModel,
        // TODO: Check this
        collection: opts.collection
      });
    },
  
    initialize: function initialize(models, options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
      this.table = options ? options.table : null;
      this.model.prototype.idAttribute = 'cartodb_id';
      this.initOptions();
      this.filter = null;
      this._fetching = false;
      this.pages = [];
      this.lastPage = false;
      this.bind('newPage', this.newPage, this);
      this.bind('reset', function () {
        var pages = Math.floor(this.size() / this.options.get('rows_per_page'));
        this.pages = [];
  
        for (var i = 0; i < pages; ++i) {
          this.pages.push(i);
        }
      }, this);
  
      if (this.table) {
        this.bind('add change:the_geom', function (row) {
          var gt = this.table.get('geometry_types');
          if (gt && gt.length > 0) return;
          if (row.get('the_geom')) {
            // we set it to silent because a change in geometry_types
            // raises rendering and column feching
            this.table.addGeomColumnType(row.getGeomType());
          }
        }, this);
      }
      TableDataCollection.prototype.initialize.call(this);
    },
  
    initOptions: function initOptions() {
      var _this = this;
  
      this.options = new Backbone.Model({
        rows_per_page: 40,
        page: 0,
        sort_order: 'asc',
        order_by: 'cartodb_id',
        filter_column: '',
        filter_value: ''
      });
      this.options.bind('change', function () {
        if (_this._fetching) {
          return;
        }
        _this._fetching = true;
        var opt = {};
        var previous = _this.options.previous('page');
  
        if (_this.options.hasChanged('page')) {
          opt.add = true;
          opt.changingPage = true;
          // if user is going backwards insert new rows at the top
          if (previous > _this.options.get('page')) {
            opt.at = 0;
          }
        } else {
          if (_this.options.hasChanged('mode')) {
            _this.options.set({
              'page': 0
            }, { silent: true });
          }
        }
  
        opt.success = function (_coll, resp) {
          _this.trigger('loaded');
          if (resp.rows && resp.rows.length !== 0) {
            if (opt.changingPage) {
              _this.trigger('newPage', _this.options.get('page'), opt.at === 0 ? 'up' : 'down');
            }
          } else {
            // no data so do not change the page
            _this.options.set({ page: previous }); //, { silent: true });
          }
          _this.trigger('endLoadingRows', _this.options.get('page'), opt.at === 0 ? 'up' : 'down');
          _this._fetching = false;
        };
  
        opt.error = function () {
          console.error('there was some problem fetching rows');
          _this.trigger('endLoadingRows');
          _this._fetching = false;
        };
  
        _this.trigger('loadingRows', opt.at === 0 ? 'up' : 'down');
  
        _this.fetch(opt);
      }, this);
    },
  
    parse: function parse(d) {
      // when the query modifies the data modified flag is true
      // TODO: change this when SQL API was able to say if a
      // query modify some data
      // HACK, it will fail if using returning sql statement
      this.modify_rows = d.rows.length === 0 && _.size(d.fields) === 0;
      this.affected_rows = d.affected_rows;
      this.lastPage = false;
      if (d.rows.length < this.options.get('rows_per_page')) {
        this.lastPage = true;
      }
      return d.rows;
    },
  
    // given fields array as they come from SQL create a map name -> type
    _schemaFromQueryFields: function _schemaFromQueryFields(fields) {
      var sc = {};
      for (var k in fields) {
        sc[k] = fields[k].type;
      }
      return sc;
    },
  
    _createUrlOptions: function _createUrlOptions(filter) {
      var attr;
      if (filter) {
        var a = {};
        for (var k in this.options.attributes) {
          if (filter(k)) {
            a[k] = this.options.attributes[k];
          }
        }
        attr = _(a);
      } else {
        attr = _(this.options.attributes);
      }
      var params = attr.map(function (v, k) {
        return k + '=' + encodeURIComponent(v);
      }).join('&');
      params += '&api_key=' + this._configModel.get('api_key');
      return params;
    },
  
    _geometryColumnSQL: function _geometryColumnSQL(c) {
      return ['CASE', 'WHEN GeometryType(' + c + ") = 'POINT' THEN", 'ST_AsGeoJSON(' + c + ',8)', 'WHEN (' + c + ' IS NULL) THEN', 'NULL', 'ELSE', 'GeometryType(' + c + ')', 'END ' + c].join(' ');
    },
  
    // return wrapped SQL removing the_geom and the_geom_webmercator
    // to avoid fetching those columns.
    // So for a sql like
    // select * from table the returned value is
    // select column1, column2, column3... from table
    wrappedSQL: function wrappedSQL(schema, exclude, fetchGeometry) {
      var _this2 = this;
  
      exclude = exclude || ['the_geom_webmercator'];
      schema = _.clone(schema);
  
      var select_columns = _.chain(schema).omit(exclude).map(function (v, k) {
        if (v === 'geometry') {
          if (fetchGeometry) {
            return 'st_astext("' + k + '") ' + 'as ' + k;
          }
          return _this2._geometryColumnSQL(k);
        }
        return '"' + k + '"';
      }).value();
  
      select_columns = select_columns.join(',');
  
      var mode = this.options.get('sort_order') === 'desc' ? 'desc' : 'asc';
  
      var q = 'select ' + select_columns + ' from (' + this.getSQL() + ') __wrapped';
      var order_by = this.options.get('order_by');
      if (order_by && order_by.length > 0) {
        q += ' order by ' + order_by + ' ' + mode;
      }
      return q;
    },
  
    url: function url() {
      return this.sqlApiUrl();
    },
  
    /**
    * we need to override sync to avoid the sql request to be sent by GET.
    * For security reasons, we need them to be send as a PUT request.
    * @method sync
    * @param method {'save' || 'read' || 'delete' || 'create'}
    * @param model {Object}
    * @param options {Object}
    */
    sync: function sync(method, model, options) {
      if (!options) {
        options = {};
      }
      options.data = this._createUrlOptions(function (d) {
        return d !== 'sql';
      });
  
      if (cartoMetadataStatic.alterTableData(this.options.get('sql') || '')) {
        options.data += '&q=' + encodeURIComponent(this.options.get('sql'));
        options.type = 'POST';
      } else {
        // when a geometry can be lazy fetched, don't fetch it
        var fetchGeometry = 'cartodb_id' in this.query_schema;
        options.data += '&q=' + encodeURIComponent(this.wrappedSQL(this.query_schema, [], !fetchGeometry));
  
        if (options.data.length > 2048) {
          options.type = 'POST';
        }
      }
  
      return Backbone.sync.call(this, method, this, options);
    },
  
    sqlApiUrl: function sqlApiUrl() {
      return this._configModel.getSqlApiUrl();
    },
  
    setOptions: function setOptions(opt) {
      this.options.set(opt);
    },
  
    // Refresh all table data
    refresh: function refresh() {
      this.fetch();
    },
  
    isFetchingPage: function isFetchingPage() {
      return this._fetching;
    },
  
    loadPageAtTop: function loadPageAtTop() {
      if (!this._fetching) {
        var first = this.pages[0];
  
        if (first > 0) {
          this.options.set('page', first - 1);
        }
      }
    },
  
    loadPageAtBottom: function loadPageAtBottom() {
      if (!this._fetching) {
        var last = this.pages[this.pages.length - 1];
  
        if (!this.lastPage) {
          this.options.set('page', last + 1);
        }
      }
    },
  
    /**
     * called when a new page is loaded
     * removes the models to max
     */
    newPage: function newPage(currentPage, direction) {
      if (this.pages.indexOf(currentPage) < 0) {
        this.pages.push(currentPage);
      }
      this.pages.sort(function (a, b) {
        return Number(a) > Number(b);
      });
      // remove blocks if there are more rows than allowed
      var rowspp = this.options.get('rows_per_page');
      var max_items = rowspp * 4;
      if (this.size() > max_items) {
        if (direction == 'up') {
          // eslint-disable-line eqeqeq
          // remove page from the bottom (the user is going up)
          this.pages.pop();
          this.remove(this.models.slice(max_items, this.size()));
        } else {
          // remove page from the top (the user is going down)
          this.pages.shift();
          this.remove(this.models.slice(0, rowspp));
        }
      }
    },
  
    addRow: function addRow(opts) {
      var _this3 = this;
  
      this.table.notice(this._ADDING_ROW_TEXT, 'load', 0);
      opts = opts || {};
      _.extend(opts, {
        wait: true,
        success: function success() {
          _this3.table.notice(_this3._ADDED_ROW_TEXT);
        },
        error: function error(e, resp) {
          // TODO: notice user
          _this3.table.error(_this3._ADDING_ROW_TEXT, resp);
        }
      });
      return this.create(null, opts);
    },
  
    /**
     * creates a new row model in local, it is NOT serialized to the server
     */
    newRow: function newRow(attrs) {
      var r = new RowModel(attrs, {
        configModel: this._configModel
      });
      r.table = this.table;
      r.bind('saved', function _saved() {
        if (r.table.data().length === 0) {
          r.table.data().fetch();
          r.unbind('saved', _saved, r.table);
        }
      }, r.table);
      return r;
    },
  
    /**
     * return a model row
     */
    getRow: function getRow(id, options) {
      options = options || {};
      var r = this.get(id);
      if (!r) {
        r = new RowModel({ cartodb_id: id }, { configModel: this._configModel });
      }
      if (!options.no_add) {
        this.table._data.add(r);
      }
      r.table = this.table;
      return r;
    },
  
    getRowAt: function getRowAt(index) {
      var r = this.at(index);
      r.table = this.table;
      return r;
    },
  
    deleteRow: function deleteRow(row_id) {},
  
    isReadOnly: function isReadOnly() {
      return false;
    },
  
    quartiles: function quartiles(nslots, column, callback, error) {
      var tmpl = _.template('select quartile, max(<%= column %>) as maxamount from (select <%= column %>, ntile(<%= slots %>) over (order by <%= column %>) as quartile from (<%= sql %>) _table_sql where <%= column %> is not null) x group by quartile order by quartile');
      this._sqlQuery(tmpl({
        slots: nslots,
        sql: this.getSQL(),
        column: column
      }), function (data) {
        callback(_(data.rows).pluck('maxamount'));
      }, error);
    },
  
    equalInterval: function equalInterval(nslots, column, callback, error) {
      var tmpl = _.template('\n      with params as (select min(a), max(a) from ( select <%= column %> as a from (<%= sql %>) _table_sql where <%= column %> is not null ) as foo )\n      select (max-min)/<%= slots %> as s, min, max from params');
      this._sqlQuery(tmpl({
        slots: nslots,
        sql: this.getSQL(),
        column: column
      }), function (data) {
        var min = data.rows[0].min;
        var max = data.rows[0].max;
        var range = data.rows[0].s;
        var values = [];
  
        for (var i = 1, l = nslots; i < l; i++) {
          values.push(range * i + min);
        }
  
        // Add last value
        values.push(max);
        // Callback
        callback(values);
      }, error);
    },
  
    _quantificationMethod: function _quantificationMethod(functionName, nslots, column, distinct, callback, error) {
      var tmpl = _.template('select unnest(<%= functionName %>(array_agg(<%= simplify_fn %>((<%= column %>::numeric))), <%= slots %>)) as buckets from (<%= sql %>) _table_sql where <%= column %> is not null');
      this._sqlQuery(tmpl({
        slots: nslots,
        sql: this.getSQL(),
        column: column,
        functionName: functionName,
        simplify_fn: 'distinct'
      }), function (data) {
        callback(_(data.rows).pluck('buckets'));
      }, error);
    },
  
    discreteHistogram: function discreteHistogram(nbuckets, column, callback, error) {
      var query = 'SELECT DISTINCT(<%= column %>) AS bucket, count(*) AS value FROM (<%= sql %>) _table_sql GROUP BY <%= column %> ORDER BY value DESC LIMIT <%= nbuckets %> + 1';
  
      var sql = _.template(query, {
        column: column,
        nbuckets: nbuckets,
        sql: this.getSQL()
      });
  
      this._sqlQuery(sql, function (data) {
        var count = data.rows.length;
        var reached_limit = false;
  
        if (count > nbuckets) {
          data.rows = data.rows.slice(0, nbuckets);
          reached_limit = true;
        }
  
        callback({ rows: data.rows, reached_limit: reached_limit }); // eslint-disable-line
      });
    },
  
    date_histogram: function date_histogram(nbuckets, column, callback, error) {
      column = 'EXTRACT(EPOCH FROM ' + column + '::TIMESTAMP WITH TIME ZONE )';
  
      var tmpl = _.template('with bounds as ( ' + 'SELECT  ' + 'current_timestamp as tz, ' + 'min(<%= column %>) as lower,  ' + 'max(<%= column %>) as upper,  ' + '(max(<%= column %>) - min(<%= column %>)) as span,  ' + 'CASE WHEN ABS((max(<%= column %>) - min(<%= column %>))/<%= nbuckets %>) <= 0 THEN 1 ELSE GREATEST(1.0, pow(10,ceil(log((max(<%= column %>) - min(<%= column %>))/<%= nbuckets %>)))) END as bucket_size ' + 'FROM  (<%= sql %>) _table_sql ' + ')  ' + 'select array_agg(v) val, array_agg(bucket) buckets, tz, bounds.upper, bounds.lower, bounds.span, bounds.bucket_size from ' + '( ' + 'select  ' + 'count(<%= column %>) as v,   ' + 'round((<%= column %> - bounds.lower)/bounds.bucket_size) as bucket  ' + 'from (<%= sql %>) _table_sql, bounds  ' + 'where <%= column %> is not null ' + 'group by bucket order by bucket ' + ') a, bounds ' + 'group by ' + 'bounds.upper, bounds.lower, bounds.span, bounds.bucket_size, bounds.tz ');
  
      // transform array_agg from postgres to a js array
      function agg_array(a) {
        return a.map(function (v) {
          return parseFloat(v);
        });
      }
  
      this._sqlQuery(tmpl({
        nbuckets: nbuckets,
        sql: this.getSQL(),
        column: column
      }), function (data) {
        if (!data.rows || data.rows.length === 0) {
          callback(null, null);
          return;
        }
  
        data = data.rows[0];
        data.val = agg_array(data.val);
        data.buckets = agg_array(data.buckets);
  
        var hist = [];
        var bounds = {};
  
        // create a sorted array and normalize
        var upper = data.upper;
        var lower = data.lower;
        var tz = data.tz;
        var bucket_size = data.bucket_size;
        var max;
  
        max = data.val[0];
  
        for (var r = 0; r < data.buckets.length; ++r) {
          var b = data.buckets[r];
          var v = hist[b] = data.val[r];
          max = Math.max(max, v);
        }
  
        // var maxBucket = _.max(data.buckets)
        for (var i = 0; i < hist.length; ++i) {
          if (hist[i] === undefined) {
            hist[i] = 0;
          } else {
            hist[i] = hist[i] / max;
          }
        }
  
        bounds.upper = parseFloat(upper);
        bounds.lower = parseFloat(lower);
        bounds.bucket_size = parseFloat(bucket_size);
        bounds.tz = tz;
  
        callback(hist, bounds);
      }, error);
    },
  
    histogram: function histogram(nbuckets, column, callback, error) {
      var tmpl = _.template('with bounds as ( ' + 'SELECT  ' + 'min(<%= column %>) as lower,  ' + 'max(<%= column %>) as upper,  ' + '(max(<%= column %>) - min(<%= column %>)) as span,  ' + 'CASE WHEN ABS((max(<%= column %>) - min(<%= column %>))/<%= nbuckets %>) <= 0 THEN 1 ELSE GREATEST(1.0, pow(10,ceil(log((max(<%= column %>) - min(<%= column %>))/<%= nbuckets %>)))) END as bucket_size ' + 'FROM  (<%= sql %>) _table_sql  ' + ')  ' + 'select array_agg(v) val, array_agg(bucket) buckets, bounds.upper, bounds.lower, bounds.span, bounds.bucket_size from ' + '( ' + 'select  ' + 'count(<%= column %>) as v,   ' + 'round((<%= column %> - bounds.lower)/bounds.bucket_size) as bucket  ' + 'from (<%= sql %>) _table_sql, bounds  ' + 'where <%= column %> is not null ' + 'group by bucket order by bucket ' + ') a, bounds ' + 'group by ' + 'bounds.upper, ' + 'bounds.lower, bounds.span, bounds.bucket_size ');
  
      // transform array_agg from postgres to a js array
      function agg_array(a) {
        return a.map(function (v) {
          return parseFloat(v);
        });
        // return JSON.parse(a.replace('{', '[').replace('}', ']'))
      }
  
      this._sqlQuery(tmpl({
        nbuckets: nbuckets,
        sql: this.getSQL(),
        column: column
      }), function (data) {
        if (!data.rows || data.rows.length === 0) {
          callback(null, null);
          return;
        }
  
        data = data.rows[0];
  
        data.val = agg_array(data.val);
        data.buckets = agg_array(data.buckets);
  
        var hist = [];
        var bounds = {};
  
        // create a sorted array and normalize
        var upper = data.upper;
        var lower = data.lower;
        var bucket_size = data.bucket_size;
        var max;
  
        max = data.val[0];
  
        for (var r = 0; r < data.buckets.length; ++r) {
          var b = data.buckets[r];
          var v = hist[b] = data.val[r];
          max = Math.max(max, v);
        }
  
        // var maxBucket = _.max(data.buckets)
        for (var i = 0; i < hist.length; ++i) {
          if (hist[i] === undefined) {
            hist[i] = 0;
          } else {
            hist[i] = hist[i] / max;
          }
        }
  
        bounds.upper = parseFloat(upper);
        bounds.lower = parseFloat(lower);
        bounds.bucket_size = parseFloat(bucket_size);
  
        callback(hist, bounds);
      }, error);
    },
  
    jenkBins: function jenkBins(nslots, column, callback, error) {
      this._quantificationMethod('CDB_JenksBins', nslots, column, true, callback, error);
    },
  
    headTails: function headTails(nslots, column, callback, error) {
      this._quantificationMethod('CDB_HeadsTailsBins', nslots, column, false, callback, error);
    },
  
    quantileBins: function quantileBins(nslots, column, callback, error) {
      this._quantificationMethod('CDB_QuantileBins', nslots, column, false, callback, error);
    },
  
    categoriesForColumn: function categoriesForColumn(max_values, column, callback, error) {
      var tmpl = _.template('SELECT <%= column %>, count(<%= column %>) FROM (<%= sql %>) _table_sql ' + 'GROUP BY <%= column %> ORDER BY count DESC LIMIT <%= max_values %> ');
  
      this._sqlQuery(tmpl({
        sql: this.getSQL(),
        column: column,
        max_values: max_values + 1
      }), function (data) {
        callback({ // eslint-disable-line
          type: data.fields[column].type || 'string',
          categories: _(data.rows).pluck(column)
        });
      }, error);
    },
  
    /**
     * call callback with the geometry bounds
     */
    geometryBounds: function geometryBounds(callback) {
      var tmpl = _.template('SELECT ST_XMin(ST_Extent(the_geom)) as minx,ST_YMin(ST_Extent(the_geom)) as miny, ST_XMax(ST_Extent(the_geom)) as maxx,ST_YMax(ST_Extent(the_geom)) as maxy from (<%= sql %>) _table_sql');
      this._sqlQuery(tmpl({
        sql: this.getSQL()
      }), function (result) {
        var coordinates = result.rows[0];
  
        var lon0 = coordinates.maxx;
        var lat0 = coordinates.maxy;
        var lon1 = coordinates.minx;
        var lat1 = coordinates.miny;
  
        var minlat = -85.0511;
        var maxlat = 85.0511;
        var minlon = -179;
        var maxlon = 179;
  
        var clampNum = function clampNum(x, min, max) {
          return x < min ? min : x > max ? max : x;
        };
  
        lon0 = clampNum(lon0, minlon, maxlon);
        lon1 = clampNum(lon1, minlon, maxlon);
        lat0 = clampNum(lat0, minlat, maxlat);
        lat1 = clampNum(lat1, minlat, maxlat);
        callback([[lat0, lon0], [lat1, lon1]]); // eslint-disable-line
      });
    },
  
    _sqlQuery: function _sqlQuery(sql, callback, error, type) {
      var s = encodeURIComponent(sql);
      return $.ajax({
        type: type || 'POST',
        data: 'q=' + s + '&api_key=' + this._configModel.get('api_key'),
        url: this.url(),
        success: callback,
        error: error
      });
    },
  
    getSQL: function getSQL() {
      // use table.id to fetch data because if always contains the real table name
      return 'select * from ' + safeTableNameQuoting(this.table.get('id'));
    },
  
    fetch: function fetch(opts) {
      var _this4 = this,
          _arguments = arguments;
  
      opts = opts || {};
      if (!opts || !opts.add) {
        this.options.attributes.page = 0;
        this.options._previousAttributes.page = 0;
        this.pages = [];
      }
      var error = opts.error;
      opts.error = function (model, resp) {
        _this4.fetched = true;
        _this4.trigger('error', model, resp);
        error && error(model, resp);
      };
      var success = opts.success;
      opts.success = function (model, resp) {
        _this4.fetched = true;
        success && success.apply(_this4, _arguments);
      };
      this._fetch(opts);
    },
  
    _fetch: function _fetch(opts) {
      var _this5 = this;
  
      var MAX_GET_LENGTH = 1024;
      this.trigger('loading', opts);
  
      var sql = this.getSQL();
      // if the query changes the database just send it
      if (cartoMetadataStatic.alterTableData(sql)) {
        TableDataCollection.prototype.fetch.call(this, opts);
        return;
      }
  
      // use get to fetch the schema, probably cached
      this._sqlQuery(_.template('select * from (<%= sql %>) __wrapped limit 0')({ sql: sql }), function (data) {
        // get schema
        _this5.query_schema = _this5._schemaFromQueryFields(data.fields);
        if (!_this5.table.isInSQLView()) {
          if ('the_geom' in _this5.query_schema) {
            delete _this5.query_schema['the_geom_webmercator'];
          }
        }
        TableDataCollection.prototype.fetch.call(_this5, opts);
      }, function (err) {
        _this5.trigger('error', _this5, err);
      }, sql.length > MAX_GET_LENGTH ? 'POST' : 'GET');
    },
  
    /**
     * with the data from the rows fetch create an schema
     * if the schema from original table is passed the method
     * set the column types according to it
     * return an empty list if no data was fetch
     */
    schemaFromData: function schemaFromData(originalTableSchema) {
      // build schema in format [ [field, type] , ...]
      return cartoMetadataStatic.sortSchema(_(this.query_schema).map(function (v, k) {
        return [k, v];
      }));
    },
  
    geometryTypeFromGeoJSON: function geometryTypeFromGeoJSON(geojson) {
      try {
        var geo = JSON.parse(geojson);
        return geo.type;
      } catch (e) {}
    },
  
    geometryTypeFromWKT: function geometryTypeFromWKT(wkt) {
      if (!wkt) return null;
      var types = WKT.types;
      wkt = wkt.toUpperCase();
      for (var i = 0; i < types.length; ++i) {
        var t = types[i];
        if (wkt.indexOf(t) !== -1) {
          return t;
        }
      }
    },
  
    geometryTypeFromWKB: function geometryTypeFromWKB(wkb) {
      if (!wkb) return null;
  
      var typeMap = {
        '0001': 'Point',
        '0002': 'LineString',
        '0003': 'Polygon',
        '0004': 'MultiPoint',
        '0005': 'MultiLineString',
        '0006': 'MultiPolygon'
      };
  
      var bigendian = wkb[0] === '0' && wkb[1] === '0';
      var type = wkb.substring(2, 6);
      if (!bigendian) {
        // swap '0100' => '0001'
        type = type[2] + type[3] + type[0] + type[1];
      }
      return typeMap[type];
    },
  
    //
    // guesses from the first row the geometry types involved
    // returns an empty array where there is no rows
    // return postgist types, like st_GEOTYPE
    //
    getGeometryTypes: function getGeometryTypes() {
      var row = null;
      var i = this.size();
      while (i-- && !(row && row.get('the_geom'))) {
        row = this.at(i);
      }
      if (!row) return [];
      var geom = row.get('the_geom') || row.get('the_geom_webmercator');
      var geoType = this.geometryTypeFromWKB(geom) || this.geometryTypeFromWKT(geom);
      if (geoType) {
        return ['ST_' + geoType[0].toUpperCase() + geoType.substring(1).toLowerCase()];
      }
      return [];
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/table/column-model.js":
  /*!*********************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/table/column-model.js ***!
    \*********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel'];
  
  module.exports = Backbone.Model.extend({
  
    idAttribute: 'name',
  
    url: function url(method) {
      var version = this._configModel.urlVersion('column', method);
      var table = this.table || this.collection.table;
      if (!table) {
        console.error('column has no table assigned');
      }
  
      var base = '/api/' + version + '/tables/' + table.get('name') + '/columns/';
      if (this.isNew()) {
        return base;
      }
      return base + this.id;
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
      this.table = this.get('table');
      if (!this.table) {
        throw 'you should specify a table model'; // eslint-disable-line
      }
      this.unset('table', { silent: true });
    },
  
    toJSON: function toJSON() {
      var c = _.clone(this.attributes);
      // this hack is created to create new column
      // if you set _name instead name backbone does not get
      // it as idAttribute so launch a POST instead of a PUT
      if (c._name) {
        c.name = c._name;
        delete c._name;
      }
      return c;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/table/row-model.js":
  /*!******************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/table/row-model.js ***!
    \******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var SQL = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js").SQL;
  var WKT = __webpack_require__(/*! dashboard/common/wkt */ "./lib/assets/javascripts/dashboard/common/wkt.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel'];
  
  var RESERVED_COLUMNS = 'the_geom the_geom_webmercator cartodb_id created_at updated_at'.split(' ');
  
  module.exports = Backbone.Model.extend({
  
    _GEOMETRY_TYPES: {
      'point': 'st_point',
      'multipoint': 'st_multipoint',
      'linestring': 'st_linestring',
      'multilinestring': 'st_multilinestring',
      'polygon': 'st_polygon',
      'multipolygon': 'st_multipolygon'
    },
  
    initialize: function initialize(attrs, opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
    },
  
    url: function url(method) {
      var version = this._configModel.urlVersion('record', method);
      var table = this.table || this.collection.table;
      if (!table) {
        console.error('row has no table assigned');
      }
  
      var base = '/api/' + version + '/tables/' + table.get('name') + '/records/';
      if (this.isNew()) {
        return base;
      }
      return base + this.id;
    },
  
    fetch: function fetch(opts) {
      opts = opts || {};
      var username = this.options && this.options.user_data ? this.options.user_data.username : window.user_data ? window.user_data.username : window.user_name;
      var api_key = this.options && this.options.user_data ? this.options.user_data.api_key : window.user_data ? window.user_data.api_key : window.api_key;
  
      var table = this.table || this.collection.table;
  
      var sqlApi = new SQL({
        user: username,
        version: 'v2',
        api_key: api_key,
        sql_api_template: this._configModel.getSqlApiBaseUrl(),
        extra_params: ['skipfields']
      });
      // this.trigger('loading')
      var sql = null;
      var columns = table.columnNames();
      if (opts.no_geom) {
        columns = _.without(columns, 'the_geom', 'the_geom_webmercator');
      } else {
        columns = _.without(columns, 'the_geom');
      }
      sql = 'SELECT ' + columns.join(',') + ' ';
      if (table.containsColumn('the_geom') && !opts.no_geom) {
        sql += ',ST_AsGeoJSON(the_geom, 8) as the_geom ';
      }
      sql += ' from (' + table.data().getSQL() + ') _table_sql WHERE cartodb_id = ' + this.get('cartodb_id');
      // Added opts to sql execute function to apply
      // parameters ( like cache ) to the ajax request
      if (opts.no_geom) {
        opts.skipfields = 'the_geom,the_geom_webmercator';
      } else {
        opts.skipfields = 'the_geom_webmercator';
      }
      sqlApi.execute(sql, {}, opts).done(function (data) {
        if (this.parse(data.rows[0])) {
          this.set(data.rows[0]); //, {silent: silent});
          this.trigger('sync');
        }
      });
    },
  
    toJSON: function toJSON() {
      var attr = _.clone(this.attributes);
      // remove read-only attributes
      delete attr['updated_at'];
      delete attr['created_at'];
      delete attr['the_geom_webmercator'];
      if (!this.isGeometryGeoJSON()) {
        delete attr['the_geom'];
      }
      return attr;
    },
  
    isGeomLoaded: function isGeomLoaded() {
      var geojson = this.get('the_geom');
      var column_types_WKT = WKT.types;
      return geojson !== 'GeoJSON' && geojson !== -1 && !_.contains(column_types_WKT, geojson);
    },
  
    hasGeometry: function hasGeometry() {
      var the_geom = this.get('the_geom');
      return !!(the_geom != null && the_geom != undefined && the_geom != ''); // eslint-disable-line eqeqeq
    },
    /**
     * Checks if the_geom contains a valid geoJson
     */
    isGeometryGeoJSON: function isGeometryGeoJSON() {
      var the_geom = this.get('the_geom');
      if (the_geom && (typeof the_geom === 'undefined' ? 'undefined' : _typeof(the_geom)) === 'object') {
        return !!the_geom.coordinates;
      } else if (typeof the_geom !== 'string') {
        return false;
      }
      // if the geom contains GeoJSON, the row has a valid geometry, but is not loaded yet
      if (the_geom === 'GeoJSON') {
        return true;
      }
  
      try {
        var g = JSON.parse(the_geom);
        return !!g.coordinates;
      } catch (e) {
        return false;
      }
    },
  
    getFeatureType: function getFeatureType() {
      if (this.isGeomLoaded()) {
        // Problem geometry type from a WKB format
        // Not possible for the moment
        try {
          var geojson = JSON.parse(this.get('the_geom'));
          return geojson.type.toLowerCase();
        } catch (e) {
          console.info('Not possible to parse geometry type');
        }
      }
      return null;
    },
  
    getGeomType: function getGeomType() {
      try {
        return this._GEOMETRY_TYPES[this.getFeatureType()];
      } catch (e) {
        console.info('Not possible to parse geometry type');
      }
    }
  
  }, {
    RESERVED_COLUMNS: RESERVED_COLUMNS,
    isReservedColumn: function isReservedColumn(c) {
      return _(RESERVED_COLUMNS).indexOf(c) !== -1;
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/table/table-data-collection.js":
  /*!******************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/table/table-data-collection.js ***!
    \******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  module.exports = Backbone.Collection.extend({
    fetched: false,
  
    initialize: function initialize() {
      var _this = this;
  
      this.bind('sync', function () {
        _this.fetched = true;
      });
    },
  
    /**
     * get value for row index and columnName
     */
    getCell: function getCell(index, columnName) {
      var r = this.at(index);
      if (!r) {
        return null;
      }
      return r.get(columnName);
    },
  
    isEmpty: function isEmpty() {
      return this.length === 0;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/upload-model.js":
  /*!***************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/upload-model.js ***!
    \***************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var UploadConfig = __webpack_require__(/*! dashboard/common/upload-config */ "./lib/assets/javascripts/dashboard/common/upload-config.js");
  var UploadModel = __webpack_require__(/*! builder/data/upload-model */ "./lib/assets/javascripts/builder/data/upload-model.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils.js */ "./lib/assets/javascripts/builder/helpers/utils.js");
  var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  
  module.exports = UploadModel.extend({
    validate: function validate(attrs) {
      if (!attrs) return;
  
      if (attrs.type === 'file') {
        // Number of files
        if (attrs.value && attrs.value.length) {
          return {
            msg: _t('data.upload-model.one-file')
          };
        }
  
        // File name
        var name = attrs.value.name;
        if (!name) {
          return {
            msg: _t('data.upload-model.file-defined')
          };
        }
  
        // File extension
        var ext = name.substr(name.lastIndexOf('.') + 1);
        if (ext) {
          ext = ext.toLowerCase();
        }
        if (!_.contains(UploadConfig.fileExtensions, ext)) {
          return {
            msg: _t('data.upload-model.file-extension')
          };
        }
        // File size
        if (this._userModel.get('remaining_byte_quota') * UploadConfig.fileTimesBigger < attrs.value.size) {
          return {
            msg: _t('data.upload-model.file-size'),
            error_code: 8001
          };
        }
      }
  
      if (attrs.type === 'remote') {
        // Valid remote visualization id?
        if (!attrs.remote_visualization_id) {
          return {
            msg: _t('data.upload-model.visualization-id')
          };
        }
        // Remote size?
        if (attrs.size && this._userModel.get('remaining_byte_quota') * UploadConfig.fileTimesBigger < attrs.size) {
          return {
            msg: _t('data.upload-model.remote-file-size'),
            error_code: 8001
          };
        }
      }
  
      if (attrs.type === 'url') {
        // Valid URL?
        if (!Utils.isURL(attrs.value)) {
          return {
            msg: _t('data.upload-model.url-invalid')
          };
        }
      }
  
      if (attrs.type === 'sql') {
        if (!attrs.value) {
          return {
            msg: _t('data.upload-model.query-undefined')
          };
        }
      }
  
      if (attrs.type === 'duplication') {
        if (!attrs.value) {
          return {
            msg: _t('data.upload-model.dataset-copy-undefined')
          };
        }
      }
  
      if (attrs.type === 'service' && attrs.service_name === 'twitter_search') {
        var service_item_id = attrs.service_item_id;
  
        // Empty?
        if (!service_item_id || _.isEmpty(service_item_id)) {
          return {
            msg: _t('data.upload-model.twitter-data')
          };
        }
  
        // Categories?
        if (_.isEmpty(service_item_id.categories)) {
          return {
            msg: _t('data.upload-model.twitter-categories-invalid')
          };
        }
  
        // Dates?
        var dates = service_item_id.dates;
        if (!dates || _.isEmpty(dates)) {
          return {
            msg: _t('data.upload-model.twitter-dates-empty')
          };
        }
        var isToDateValid = moment(dates.fromDate) <= moment(new Date());
        if (!dates.fromDate || !dates.toDate || !isToDateValid) {
          return {
            msg: _t('data.upload-model.twitter-dates-invalid')
          };
        }
      }
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/url-model.js":
  /*!************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/url-model.js ***!
    \************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   * Represents a URL.
   * Provides common semantics to manipulate a URL without having to resort to manipulating strings manually.
   * Rather don't subclass but you composition if you need to extend some functionality.
   *
   * Can safely be coerced into a string implicitly, e.g.:
   *   const myUrl = UrlModel.byBasePath('http://foobar.com/some/path')
   *   alert(myUrl); // will output 'http://foobar.com/some/path'
   */
  
  var UrlModel = Backbone.Model.extend({
    initialize: function initialize(attrs) {
      if (!attrs.base_url) {
        throw new Error('base_url is required');
      }
    },
  
    /**
     * Get a new URL object with new basepath.
     * @param {String,*} path new sub path. Slashes are not necessary, e.g. 'my_path'
     * @return {Object} instance of cdb.common.Url
     */
    urlToPath: function urlToPath() {
      return UrlModel.byBaseUrl(this.toString.apply(this, arguments));
    },
  
    /**
     * @return {String} Path of this URL, e.g. '/some/path'
     */
    pathname: function pathname() {
      return this.toString().match(/^.+\/\/[^\/]+(.*)$/)[1];
    },
  
    toString: function toString() {
      return this._joinArgumentsWithSlashes(this.get('base_url'), Array.prototype.slice.call(arguments, 0));
    },
  
    _joinArgumentsWithSlashes: function _joinArgumentsWithSlashes() {
      return _.chain(arguments).flatten().compact().value().join('/');
    }
  }, {
    byBaseUrl: function byBaseUrl(url) {
      return new UrlModel({ base_url: url });
    }
  });
  
  module.exports = UrlModel;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/user-groups-collection.js":
  /*!*************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/user-groups-collection.js ***!
    \*************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var GroupModel = __webpack_require__(/*! dashboard/data/group-model */ "./lib/assets/javascripts/dashboard/data/group-model.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel'];
  
  module.exports = Backbone.Collection.extend({
  
    model: function model(attrs, _ref) {
      var collection = _ref.collection;
  
      return new GroupModel(attrs, {
        collection: collection,
        configModel: collection._configModel
      });
    },
  
    initialize: function initialize(models, opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
      this.organization = opts.organization;
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/user-model.js":
  /*!*************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/user-model.js ***!
    \*************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var UserUrlModel = __webpack_require__(/*! dashboard/data/user-url-model */ "./lib/assets/javascripts/dashboard/data/user-url-model.js");
  
  var UserModel = Backbone.Model.extend({
    urlRoot: '/api/v1/users',
  
    defaults: {
      avatar_url: 'http://cartodb.s3.amazonaws.com/static/public_dashboard_default_avatar.png',
      username: ''
    },
  
    initialize: function initialize(attrs, opts) {
      attrs = attrs || {};
      opts = opts || {};
      this.tables = [];
      // Removing avatar_url attribute if it comes as null
      // Due to a Backbone Model constructor uses _.extends
      // instead of _.defaults
      if (this.get('avatar_url') === null) {
        this.set('avatar_url', this.defaults.avatar_url);
      }
  
      this.email = typeof attrs.email !== 'undefined' ? attrs.email : '';
  
      if (opts.groups) {
        this.setGroups(opts.groups);
      }
  
      if (opts.organization) {
        this.setOrganization(opts.organization);
      }
    },
  
    setGroups: function setGroups(groups) {
      this.groups = groups;
    },
  
    setOrganization: function setOrganization(organization) {
      this.organization = organization;
  
      if (this.groups) {
        this.groups.organization = organization;
      }
    },
  
    isInsideOrg: function isInsideOrg() {
      if (this.organization) {
        return this.organization.id !== false || this.isOrgOwner();
      }
      return false;
    },
  
    isAuthUsernamePasswordEnabled: function isAuthUsernamePasswordEnabled() {
      if (this.organization) {
        return this.organization.get('auth_username_password_enabled');
      }
      return false;
    },
  
    isOrgOwner: function isOrgOwner() {
      if (this.organization) {
        return this.organization.owner.get('id') === this.get('id');
      }
      return false;
    },
  
    isOrgAdmin: function isOrgAdmin() {
      if (this.organization) {
        return this.organization.isOrgAdmin(this);
      }
      return false;
    },
  
    isViewer: function isViewer() {
      return this.get('viewer') === true;
    },
  
    isBuilder: function isBuilder() {
      return !this.isViewer();
    },
  
    nameOrUsername: function nameOrUsername() {
      return this.fullName() || this.get('username');
    },
  
    fullName: function fullName() {
      var name = this.get('name') || '';
      var lastName = this.get('last_name') || '';
      if (name || lastName) {
        return name + (name && lastName ? ' ' : '') + lastName;
      }
      return '';
    },
  
    renderData: function renderData(currentUser) {
      var name = this.get('username');
  
      if (currentUser && currentUser.id === this.id) {
        name = _t('You');
      }
  
      return {
        username: name,
        avatar_url: this.get('avatar_url')
      };
    },
  
    hasCreateDatasetsFeature: function hasCreateDatasetsFeature() {
      return this.isBuilder();
    },
  
    canCreateDatasets: function canCreateDatasets() {
      if (!this.get('remaining_byte_quota') || this.get('remaining_byte_quota') <= 0) {
        return false;
      }
  
      return this.hasCreateDatasetsFeature();
    },
  
    hasCreateMapsFeature: function hasCreateMapsFeature() {
      return this.isBuilder();
    },
  
    canAddLayerTo: function canAddLayerTo(map) {
      if (!map || !map.layers || !map.layers.getDataLayers) {
        throw new Error('Map model is not defined or wrong');
      }
      var dataLayers = map.layers.getDataLayers();
      return dataLayers.length < this.getMaxLayers();
    },
  
    getMaxLayers: function getMaxLayers() {
      return this.get('limits') && this.get('limits').max_layers || 5;
    },
  
    getMaxConcurrentImports: function getMaxConcurrentImports() {
      return this.get('limits') && this.get('limits').concurrent_imports || 1;
    },
  
    featureEnabled: function featureEnabled(name) {
      var featureFlags = this.get('feature_flags');
  
      if (!featureFlags || featureFlags.length === 0 || !name) {
        return false;
      }
  
      return _.contains(featureFlags, name);
    },
  
    isCloseToLimits: function isCloseToLimits() {
      var quota = this.get('quota_in_bytes');
      var remainingQuota = this.get('remaining_byte_quota');
  
      return remainingQuota * 100 / quota < 20;
    },
  
    isEnterprise: function isEnterprise() {
      return this.get('account_type').toLowerCase().indexOf('enterprise') != -1; // eslint-disable-line
    },
  
    getOrganizationName: function getOrganizationName() {
      return this.isInsideOrg() ? this.organization.get('name') : '';
    },
  
    getOrgName: function getOrgName() {
      return this.isInsideOrg() ? this.organization.get('name') : '';
    },
  
    getMaxLayersPerMap: function getMaxLayersPerMap() {
      return this.get('max_layers') || 4;
    },
  
    canStartTrial: function canStartTrial() {
      return !this.isInsideOrg() && this.get('account_type') === 'FREE' && this.get('table_count') > 0;
    },
  
    canCreatePrivateDatasets: function canCreatePrivateDatasets() {
      var actions = this.get('actions');
      return actions && actions.private_tables;
    },
  
    canCreateTwitterDataset: function canCreateTwitterDataset() {
      var twitter = this.get('twitter');
      return !(twitter.quota - twitter.monthly_use) <= 0 && twitter.hard_limit;
    },
  
    canSelectPremiumOptions: function canSelectPremiumOptions(visModel) {
      return this.get('actions')[visModel.isVisualization() ? 'private_maps' : 'private_tables'];
    },
  
    hasOwnTwitterCredentials: function hasOwnTwitterCredentials() {
      var twitter = this.get('twitter');
      return twitter && twitter.customized_config || false;
    },
  
    equals: function equals(otherUser) {
      if (otherUser.get) {
        return this.get('id') === otherUser.get('id');
      }
    },
  
    viewUrl: function viewUrl() {
      return new UserUrlModel({
        base_url: this.get('base_url'),
        is_org_admin: this.isOrgAdmin()
      });
    },
  
    upgradeContactEmail: function upgradeContactEmail() {
      if (this.isInsideOrg()) {
        if (this.isOrgOwner()) {
          return 'enterprise-support@carto.com';
        } else {
          return this.organization.owner.get('email');
        }
      } else {
        return 'support@carto.com';
      }
    },
  
    needsPasswordConfirmation: function needsPasswordConfirmation() {
      return this.get('needs_password_confirmation');
    },
  
    usedQuotaPercentage: function usedQuotaPercentage() {
      return this.get('db_size_in_bytes') * 100 / this.organization.get('available_quota_for_user');
    },
  
    assignedQuotaInRoundedMb: function assignedQuotaInRoundedMb() {
      return Math.floor(this.get('quota_in_bytes') / 1024 / 1024).toFixed(0);
    },
  
    assignedQuotaPercentage: function assignedQuotaPercentage() {
      return this.get('quota_in_bytes') * 100 / this.organization.get('available_quota_for_user');
    },
  
    getGoogleApiKey: function getGoogleApiKey() {
      return this.get('google_maps_private_key');
    },
  
    hasGoogleMaps: function hasGoogleMaps() {
      return !!this.getGoogleApiKey();
    },
  
    showGoogleApiKeys: function showGoogleApiKeys() {
      return this.hasGoogleMaps() && (!this.isInsideOrg() || this.isOrgOwner());
    },
  
    getSchema: function getSchema() {
      return this.isInsideOrg() ? this.get('username') : 'public';
    },
  
    getAuthToken: function getAuthToken() {
      return btoa(this.get('username') + ':' + this.get('api_key'));
    },
  
    getModelType: function getModelType() {
      return 'user';
    },
  
    isActionEnabled: function isActionEnabled(action) {
      return this.get('actions') && this.get('actions')[action];
    },
  
    hasAccountType: function hasAccountType(accountType) {
      return this.get('account_type') === accountType;
    }
  });
  
  module.exports = UserModel;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/user-url-model.js":
  /*!*****************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/user-url-model.js ***!
    \*****************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var UrlModel = __webpack_require__(/*! dashboard/data/url-model */ "./lib/assets/javascripts/dashboard/data/url-model.js");
  var DashboardUrlModel = __webpack_require__(/*! dashboard/data/dashboard-url-model */ "./lib/assets/javascripts/dashboard/data/dashboard-url-model.js");
  var OrganizationUrlModel = __webpack_require__(/*! dashboard/data/organization-url-model */ "./lib/assets/javascripts/dashboard/data/organization-url-model.js");
  
  /**
   * URLs associated with a particular user.
   */
  var UserUrlModel = UrlModel.extend({
    initialize: function initialize(attrs) {
      UrlModel.prototype.initialize.apply(this, arguments);
  
      if (_.isUndefined(attrs.is_org_admin)) {
        throw new Error('is_org_admin is required');
      }
    },
  
    organization: function organization() {
      if (this.get('is_org_admin')) {
        return new OrganizationUrlModel({
          base_url: this.urlToPath('organization')
        });
      } else {
        return this.urlToPath('account');
      }
    },
  
    accountProfile: function accountProfile() {
      return this.urlToPath('profile');
    },
  
    accountSettings: function accountSettings() {
      return this.urlToPath('account');
    },
  
    publicProfile: function publicProfile() {
      return this.urlToPath('me');
    },
  
    apiKeys: function apiKeys() {
      return this.urlToPath('your_apps');
    },
  
    logout: function logout() {
      return this.urlToPath('logout');
    },
  
    dashboard: function dashboard() {
      return new DashboardUrlModel({
        base_url: this.urlToPath('dashboard')
      });
    },
  
    connectedApps: function connectedApps() {
      return new DashboardUrlModel({
        base_url: this.urlToPath('dashboard/connected_apps')
      });
    }
  });
  
  module.exports = UserUrlModel;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/visualization-model.js":
  /*!**********************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/visualization-model.js ***!
    \**********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var LikeModel = __webpack_require__(/*! dashboard/data/like-model */ "./lib/assets/javascripts/dashboard/data/like-model.js");
  var UserModel = __webpack_require__(/*! dashboard/data/user-model */ "./lib/assets/javascripts/dashboard/data/user-model.js");
  var PermissionModel = __webpack_require__(/*! dashboard/data/permission-model */ "./lib/assets/javascripts/dashboard/data/permission-model.js");
  var MapModel = __webpack_require__(/*! dashboard/data/map-model */ "./lib/assets/javascripts/dashboard/data/map-model.js");
  var VisualizationOrderModel = __webpack_require__(/*! dashboard/data/visualization-order-model */ "./lib/assets/javascripts/dashboard/data/visualization-order-model.js");
  var SlideTransition = __webpack_require__(/*! dashboard/data/slide-transition-model */ "./lib/assets/javascripts/dashboard/data/slide-transition-model.js");
  var MapUrlModel = __webpack_require__(/*! dashboard/data/map-url-model */ "./lib/assets/javascripts/dashboard/data/map-url-model.js");
  var DatasetUrlModel = __webpack_require__(/*! dashboard/data/dataset-url-model */ "./lib/assets/javascripts/dashboard/data/dataset-url-model.js");
  var CartoTableMetadata = __webpack_require__(/*! dashboard/views/public-dataset/carto-table-metadata */ "./lib/assets/javascripts/dashboard/views/public-dataset/carto-table-metadata.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel'];
  
  var PRIVACY_OPTIONS = {
    public: 'PUBLIC',
    link: 'LINK',
    private: 'PRIVATE',
    password: 'PASSWORD'
  };
  
  var VisualizationModel = Backbone.Model.extend({
  
    defaults: {
      bindMap: true
    },
  
    INHERIT_TABLE_ATTRIBUTES: ['name', 'description', 'privacy'],
  
    initialize: function initialize(attrs, opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      this.map = new MapModel({ configModel: this._configModel });
      this.permission = new PermissionModel(this.get('permission'), { configModel: this._configModel });
      this.order = new VisualizationOrderModel({ visualization: this });
      this.transition = new SlideTransition(this.get('transition_options'), { parse: true });
  
      this.like = LikeModel.newByVisData({
        vis_id: this.id,
        liked: this.get('liked'),
        likes: this.get('likes'),
        config: this._configModel
      });
  
      if (this.get('bindMap')) this._bindMap();
  
      this._initBinds();
    },
  
    _initBinds: function _initBinds() {
      this.permission.acl.bind('reset', function () {
        // Sync the local permission object w/ the raw data, so vis.save don't accidentally overwrites permissions changes
        this.set('permission', this.permission.attributes, { silent: true });
        this.trigger('change:permission', this);
      }, this);
  
      // Keep permission model in sync, e.g. on vis.save
      this.bind('change:permission', function () {
        this.permission.set(this.get('permission'));
      }, this);
    },
  
    _bindMap: function _bindMap() {
      this.on('change:map_id', this._fetchMap, this);
  
      this.map.bind('change:id', function () {
        this.set('map_id', this.map.id);
      }, this);
  
      this.map.set('id', this.get('map_id'));
    },
  
    url: function url(method) {
      var version = this._configModel.urlVersion('visualization', method);
      var base = '/api/' + version + '/viz';
      if (this.isNew()) {
        return base;
      }
      return base + '/' + this.id;
    },
  
    parse: function parse(data) {
      if (this.transition && data.transition_options) {
        this.transition.set(this.transition.parse(data.transition_options));
      }
  
      if (this.like) {
        this.like.set({
          vis_id: this.id,
          likes: this.get('likes'),
          liked: this.get('liked')
        });
      }
  
      if (this.owner) {
        this.owner = new UserModel(this.owner);
      }
  
      return data;
    },
  
    toJSON: function toJSON() {
      var attr = _.clone(this.attributes);
  
      delete attr.bindMap;
      delete attr.stats;
      delete attr.related_tables;
      delete attr.children;
  
      attr.transition_options = this.transition.toJSON();
  
      return attr;
    },
  
    getLikesModel: function getLikesModel() {
      return this.like;
    },
  
    /**
     *  Create a copy of the visualization model
     */
    copy: function copy(attrs, options) {
      attrs = attrs || {};
      options = options || {};
      var vis = new VisualizationModel(_.extend({
        source_visualization_id: this.id
      }, attrs), { configModel: this._configModel });
      vis.save(null, options);
      return vis;
    },
  
    /**
     *  Fetch map information
     */
    _fetchMap: function _fetchMap() {
      this.map.set('id', this.get('map_id')).fetch();
    },
  
    /**
     * Get the URL for current instance.
     * @param {Object} currentUser (Optional) Get the URL from the perspective of the current user, necessary to
     *   correctly setup URLs to tables.
     * @return {Object} instance of cdb.common.Url
     */
    viewUrl: function viewUrl(currentUser) {
      var owner = this.permission.owner;
      var userUrl = this.permission.owner.viewUrl();
  
      // the undefined check is required for backward compability, in some cases (e.g. dependant visualizations) the type
      // is not available on the attrs, if so assume the old behavior (e.g. it's a visualization/derived/map).
      if (this.isVisualization() || _.isUndefined(this.get('type'))) {
        var id = this.get('id');
  
        if (currentUser && currentUser.id !== owner.id && this.permission.hasAccess(currentUser)) {
          userUrl = currentUser.viewUrl();
          id = owner.get('username') + '.' + id;
        }
  
        return new MapUrlModel({
          base_url: userUrl.urlToPath('viz', id)
        });
      } else {
        if (currentUser && this.permission.hasAccess(currentUser)) {
          userUrl = currentUser.viewUrl();
        }
        return new DatasetUrlModel({
          base_url: userUrl.urlToPath('tables', this.tableMetadata().getUnquotedName())
        });
      }
    },
  
    // return: Array of entities (user or organizations) this vis is shared with
    sharedWithEntities: function sharedWithEntities() {
      return _.map(this.permission.acl.toArray() || [], function (aclItem) {
        return aclItem.get('entity');
      });
    },
  
    /**
     *  Is this model a true visualization?
     */
    isVisualization: function isVisualization() {
      return this.get('type') === 'derived' || this.get('type') === 'slide';
    },
  
    /**
     * Get table metadata related to this vis.
     * Note that you might need to do a {metadata.fetch()} to get full data.
     *
     * @returns {CartoTableMetadata} if this vis represents a table
     * TODO: when and when isn't it required to do a fetch really?
     */
    tableMetadata: function tableMetadata() {
      if (!this._metadata) {
        this._metadata = new CartoTableMetadata(this.get('table'), { configModel: this._configModel });
      }
      return this._metadata;
    },
  
    getTableModel: function getTableModel() {
      if (!this._metadata) {
        this._metadata = new CartoTableMetadata(this.get('table'), { configModel: this._configModel });
      }
      return this._metadata;
    },
  
    privacyOptions: function privacyOptions() {
      var privacyOptions = _.values(PRIVACY_OPTIONS);
  
      if (this.isVisualization()) {
        return privacyOptions;
      } else {
        return _.filter(privacyOptions, function (option) {
          return option !== 'PASSWORD';
        });
      }
    },
  
    isRaster: function isRaster() {
      return this.get('kind') === 'raster';
    },
  
    getPermissionModel: function getPermissionModel() {
      return this.permission;
    },
  
    getSynchronizationModel: function getSynchronizationModel() {
      return this._synchronizationModel;
    },
  
    mapcapsURL: function mapcapsURL() {
      var baseUrl = this._configModel.get('base_url');
      return baseUrl + '/api/v3/viz/' + this.id + '/mapcaps';
    }
  }, {
    isPubliclyAvailable: function isPubliclyAvailable(privacyStatus) {
      return privacyStatus === PRIVACY_OPTIONS.password || privacyStatus === PRIVACY_OPTIONS.link || privacyStatus === PRIVACY_OPTIONS.public;
    }
  });
  
  module.exports = VisualizationModel;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/visualization-order-model.js":
  /*!****************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/visualization-order-model.js ***!
    \****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  module.exports = Backbone.Model.extend({
  
    url: function url(method) {
      return this.visualization.url(method) + '/next_id';
    },
  
    initialize: function initialize() {
      this.visualization = this.get('visualization');
      this.set('id', this.visualization.id);
      this.unset('visualization');
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/data/visualizations-collection.js":
  /*!****************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/data/visualizations-collection.js ***!
    \****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var VisualizationModel = __webpack_require__(/*! dashboard/data/visualization-model */ "./lib/assets/javascripts/dashboard/data/visualization-model.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['configModel'];
  
  /**
   * Visualizations endpoint available for a given user.
   *
   * Usage:
   *
   *   const visualizations = new VisualizationsCollection();
   *   visualizations.fetch();
   *
   */
  
  module.exports = Backbone.Collection.extend({
  
    _PREVIEW_TABLES_PER_PAGE: 10,
    _TABLES_PER_PAGE: 20,
    _PREVIEW_ITEMS_PER_PAGE: 3,
    _ITEMS_PER_PAGE: 9,
  
    sync: __webpack_require__(/*! dashboard/data/backbone/sync-abort */ "./lib/assets/javascripts/dashboard/data/backbone/sync-abort.js"),
  
    initialize: function initialize(models, opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
  
      var default_options = new Backbone.Model({
        tag_name: '',
        q: '',
        page: 1,
        type: 'derived',
        exclude_shared: false,
        per_page: this._ITEMS_PER_PAGE
      });
  
      this.options = _.extend(default_options, this.options);
  
      this.total_entries = 0;
  
      this.bind('reset', this._checkPage, this);
    },
  
    model: function model(attrs, opts) {
      var options = _extends({}, opts, { configModel: opts.collection._configModel });
  
      return new VisualizationModel(attrs, options);
    },
  
    getTotalPages: function getTotalPages() {
      return Math.ceil(this.total_entries / this.options.get('per_page'));
    },
  
    _checkPage: function _checkPage() {
      var total = this.getTotalPages();
  
      if (this.options.get('page') > total) {
        this.options.set({ page: total + 1 });
      } else if (this.options.get('page') < 1) {
        this.options.set({ page: 1 });
      }
    },
  
    _createUrlOptions: function _createUrlOptions() {
      var urlParams = _(this.options.attributes).map(function (v, k) {
        return k + '=' + encodeURIComponent(v);
      });
  
      return _.compact(urlParams).join('&');
    },
  
    url: function url(method) {
      var version = this._configModel.urlVersion('visualizations', method);
  
      return '/api/' + version + '/viz?' + this._createUrlOptions();
    },
  
    remove: function remove(options) {
      this.total_entries--;
  
      Backbone.Collection.prototype.remove.apply(this, arguments);
    },
  
    // add bindMap: false for all the visulizations
    // vis model does not need map information in dashboard
    parse: function parse(response) {
      this.total_entries = response.total_entries;
      this.slides && this.slides.reset(response.children);
      this.total_shared = response.total_shared;
      this.total_likes = response.total_likes;
      this.total_user_entries = response.total_user_entries;
  
      return response.visualizations.map(function (vis) {
        return _extends({}, vis, { bindMap: false });
      });
    },
  
    create: function create(model) {
      var deferred = $.Deferred();
  
      Backbone.Collection.prototype.create.call(this, model, {
        wait: true,
        success: function success() {
          return deferred.resolve();
        },
        error: function error() {
          return deferred.reject();
        }
      });
  
      return deferred.promise();
    },
  
    fetch: function fetch(opts) {
      var deferred = $.Deferred();
      var self = this;
  
      this.trigger('loading', this);
  
      $.when(Backbone.Collection.prototype.fetch.call(this, opts)).done(function (res) {
        self.trigger('loaded');
        deferred.resolve();
      }).fail(function (res) {
        self.trigger('loadFailed');
        deferred.reject(res);
      });
  
      return deferred.promise();
    },
  
    getTotalStat: function getTotalStat(attribute) {
      return this[attribute] || 0;
    },
  
    getDefaultParam: function getDefaultParam(param) {
      return this.options.get(param);
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/helpers/assets-version.js":
  /*!********************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/helpers/assets-version.js ***!
    \********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  module.exports = {
    getAssetsVersion: function getAssetsVersion(version) {
      var query = window.location.search.substring(1);
      var vars = query.split('&');
      var i = 0;
  
      for (i; i < vars.length; i++) {
        var pair = vars[i].split('=');
  
        if (pair[0] === 'v') {
          return pair[1];
        }
      }
  
      return window.StaticConfig.assetVersion || window.CartoConfig.data.user_frontend_version || version;
    },
  
    getAssetsBaseUrl: function getAssetsBaseUrl() {
      var data = window.CartoConfig.data;
      var dataAssetsHost = data.asset_host && data.asset_host + '/assets';
  
      var assetsBaseUrl = window.StaticConfig.assetsBaseUrl || dataAssetsHost || data.config.app_assets_base_url;
  
      return assetsBaseUrl + '/';
    },
  
    getAssetsUrl: function getAssetsUrl(version) {
      return this.getAssetsBaseUrl() + this.getAssetsVersion(version);
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/helpers/bytes-to-size.js":
  /*!*******************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/helpers/bytes-to-size.js ***!
    \*******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  /**
   * Object representing human-readable version of a given number of bytes.
   *
   * (Extracted logic from an old dashboard view)
   *
   * @param bytes {Number}
   * @returns {Object}
   */
  var BytesToSize = function BytesToSize(bytes) {
    if (!(this instanceof BytesToSize)) return new BytesToSize(bytes);
  
    this.bytes = bytes;
    if (bytes === 0) {
      this.unit = 0;
    } else {
      this.unit = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
    }
  
    return this;
  };
  
  BytesToSize.prototype.size = function () {
    return this.bytes / Math.pow(1024, this.unit);
  };
  
  BytesToSize.prototype.UNIT_SUFFIXES = ['B', 'kB', 'MB', 'GB', 'TB'];
  BytesToSize.prototype.suffix = function () {
    return this.UNIT_SUFFIXES[this.unit];
  };
  
  BytesToSize.prototype.toString = function (decimals) {
    var size = this.size();
    if (decimals) {
      // 1 decimal: 9.995 => 9.9
      var round = Math.pow(10, decimals);
      size = Math.floor(size * round) / round;
    } else {
      size = Math.floor(size);
    }
    return size + this.suffix();
  };
  
  module.exports = BytesToSize;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/helpers/local-storage.js":
  /*!*******************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/helpers/local-storage.js ***!
    \*******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  /**
   *  Local storage wrapper
   *
   *  - It should be used within 'cartodb' key, for example:
   *
   *  var loc_sto = new cdb.common.LocalStorage();
   *  loc_sto.set({ 'dashboard.order': 'create_at' });
   *  loc_sto.get('dashboard.order');
   *
   */
  
  var LocalStorageWrapper = function LocalStorageWrapper(name) {
    this.name = name || 'cartodb';
    if (!localStorage.getItem(this.name) && this.isEnabled()) {
      localStorage.setItem(this.name, '{}');
    }
  };
  
  // Some browsers with private mode don't allow to use
  // local storage
  LocalStorageWrapper.prototype.isEnabled = function () {
    try {
      localStorage.setItem('checking', 'test');
      localStorage.removeItem('checking');
      return true;
    } catch (e) {
      return false;
    }
  };
  
  LocalStorageWrapper.prototype.get = function (n) {
    if (!this.isEnabled()) return false;
  
    if (n === undefined) {
      return JSON.parse(localStorage.getItem(this.name));
    } else {
      var data = JSON.parse(localStorage.getItem(this.name));
      return data[n];
    }
  };
  
  LocalStorageWrapper.prototype.search = function (searchTerm) {
    if (!this.isEnabled()) return null;
  
    var wholeArray = JSON.parse(localStorage.getItem(this.name));
  
    for (var i in wholeArray) {
      if (wholeArray[i][searchTerm]) {
        return wholeArray[i][searchTerm];
      }
    }
    return null;
  };
  
  LocalStorageWrapper.prototype.set = function (data) {
    if (!this.isEnabled()) return null;
    var d = _.extend(this.get(), data);
    return localStorage.setItem(this.name, JSON.stringify(d));
  };
  
  LocalStorageWrapper.prototype.add = function (obj) {
    return this.set(obj);
  };
  
  LocalStorageWrapper.prototype.remove = function (n) {
    if (!this.isEnabled()) return null;
    var d = _.omit(this.get(), n);
    return localStorage.setItem(this.name, JSON.stringify(d));
  };
  
  LocalStorageWrapper.prototype.destroy = function () {
    delete localStorage.removeItem(this.name);
  };
  
  module.exports = LocalStorageWrapper;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/helpers/password-validated-form.js":
  /*!*****************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/helpers/password-validated-form.js ***!
    \*****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
  
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var ConfirmPasswordModal = __webpack_require__(/*! dashboard/components/password-confirmation/password-confirmation-view.js */ "./lib/assets/javascripts/dashboard/components/password-confirmation/password-confirmation-view.js");
  
  var PasswordValidatedForm = function () {
    function PasswordValidatedForm() {
      _classCallCheck(this, PasswordValidatedForm);
    }
  
    _createClass(PasswordValidatedForm, null, [{
      key: 'bindEventTo',
      value: function bindEventTo(formSelector, options) {
        var _this = this;
  
        var form = $(formSelector);
        var saveButton = form.find('.js-save');
  
        saveButton.bind('click', function (event) {
          event.preventDefault();
          event.stopPropagation();
  
          if (!options.passwordConfirmationNeeded) {
            return options.onPasswordTyped ? options.onPasswordTyped() : _this.addPasswordToForm(form);
          }
  
          _this.showPasswordModal({
            modalService: options.modals,
            onPasswordTyped: options.onPasswordTyped || _this.addPasswordToForm.bind(_this, form)
          });
        });
      }
    }, {
      key: 'showPasswordModal',
      value: function showPasswordModal(options) {
        options.modalService.create(function (modalModel) {
          return new ConfirmPasswordModal({
            modalModel: modalModel,
            onPasswordTyped: options.onPasswordTyped
          });
        });
      }
    }, {
      key: 'addPasswordToForm',
      value: function addPasswordToForm(form, password) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  
        var passwordInput = document.createElement('input');
        passwordInput.setAttribute('type', 'hidden');
        passwordInput.setAttribute('name', 'password_confirmation');
        passwordInput.setAttribute('value', password);
  
        form.prepend(passwordInput);
        if (!options.doNotSubmit) {
          form.submit();
        }
      }
    }]);
  
    return PasswordValidatedForm;
  }();
  
  module.exports = PasswordValidatedForm;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/helpers/pluralize.js":
  /*!***************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/helpers/pluralize.js ***!
    \***************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var pluralize = function pluralize(singular, plural, count) {
    if (arguments.length === 2) {
      // Backward compability with prev usages, retrofit to the new params signature
      // pluralize('foobar' , 3) // => foobars
      return pluralize.call(this, arguments[0], arguments[0] + 's', arguments[1]);
    }
  
    return count === 1 ? singular : plural;
  };
  
  pluralize.prefixWithCount = function (singular, plural, count) {
    return pluralize('1 ' + singular, // e.g. 1 item
    count + ' ' + plural, // e.g. 123 items
    count);
  };
  
  module.exports = pluralize;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/helpers/retrigger.js":
  /*!***************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/helpers/retrigger.js ***!
    \***************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  // This used to be on core-model
  /**
    * Listen for an event on another object and triggers on itself, with the same name or a new one
    * @method retrigger
    * @param ev {String} event who triggers the action
    * @param obj {Object} object where the event happens
    * @param obj {Object} [optional] name of the retriggered event
    * @todo [xabel]: This method is repeated here and in the base view definition. There's should be a way to make it unique
    */
  module.exports = function (ev, obj, retrigEvent) {
    var _this = this;
  
    if (!retrigEvent) {
      retrigEvent = ev;
    }
    obj.bind && obj.bind(ev, function () {
      _this.trigger(retrigEvent);
    }, this);
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/helpers/safe-table-name-quoting.js":
  /*!*****************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/helpers/safe-table-name-quoting.js ***!
    \*****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  /*
  * Returns a (double) quoted table name if needed (if it contains a dash, for example).
  * Coupled to backend lib/carto/table_utils.rb#safe_table_name_quoting.
  * Duplicated at lib/assets/javascripts/builder/helpers/utils.js to make it available for older models.
  */
  module.exports = function (table_name) {
    if (table_name === undefined || table_name.indexOf('-') === -1 || table_name[0] === '"' || table_name[table_name.length - 1] === '"') {
      return table_name;
    } else {
      return '"' + table_name + '"';
    }
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/helpers/scroll-tofixed-view.js":
  /*!*************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/helpers/scroll-tofixed-view.js ***!
    \*************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  
  var REQUIRED_OPTS = ['el'];
  
  module.exports = CoreView.extend({
  
    events: {
      'click .js-foo': '_fooHandler'
    },
  
    initialize: function initialize(opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
      this._onWindowScroll = this._onWindowScroll.bind(this);
  
      this._topBoundary = this.$el.offset().top;
      this._initBinds();
    },
  
    _initBinds: function _initBinds() {
      this._bindScroll();
    },
  
    _onWindowScroll: function _onWindowScroll() {
      this.$el.toggleClass('is-fixed', $(window).scrollTop() > this._topBoundary);
    },
  
    _unbindScroll: function _unbindScroll() {
      $(window).unbind('scroll', this._onWindowScroll);
    },
  
    _bindScroll: function _bindScroll() {
      this._unbindScroll();
      $(window).bind('scroll', this._onWindowScroll);
    },
  
    clean: function clean() {
      this._unbindScroll();
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/views/public-dataset/carto-table-metadata-static.js":
  /*!**********************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/views/public-dataset/carto-table-metadata-static.js ***!
    \**********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  module.exports = {
    sortSchema: function sortSchema(schema) {
      var priorities = {
        'cartodb_id': 1,
        'the_geom': 2,
        '__default__': 3,
        'created_at': 4,
        'updated_at': 5
      };
  
      function priority(v) {
        return priorities[v] || priorities['__default__'];
      }
  
      return _.chain(schema).clone().sort(function (a, b) {
        // ..and then re-sort by priorities defined above
        var prioA = priority(a[0]);
        var prioB = priority(b[0]);
        if (prioA < prioB) {
          return -1;
        } else if (prioA > prioB) {
          return 1;
        } else {
          // priority is the same (i.e. __default__), so compare alphabetically
          return a[0] < b[0] ? -1 : 1;
        }
      }).value();
    },
  
    /**
     * return true if the sql query alters table schema in some way
     */
    alterTable: function alterTable(sql) {
      sql = sql.trim();
      return sql.search(/alter\s+[\w\."]+\s+/i) !== -1 || sql.search(/drop\s+[\w\.\"]+/i) !== -1 || sql.search(/^vacuum\s+[\w\.\"]+/i) !== -1 || sql.search(/^create\s+[\w\.\"]+/i) !== -1 || sql.search(/^reindex\s+[\w\.\"]+/i) !== -1 || sql.search(/^grant\s+[\w\.\"]+/i) !== -1 || sql.search(/^revoke\s+[\w\.\"]+/i) !== -1 || sql.search(/^cluster\s+[\w\.\"]+/i) !== -1 || sql.search(/^comment\s+on\s+[\w\.\"]+/i) !== -1 || sql.search(/^explain\s+[\w\.\"]+/i) !== -1;
    },
  
    /**
     * return true if the sql query alters table data
     */
    alterTableData: function alterTableData(sql) {
      return this.alterTable(sql) || sql.search(/^refresh\s+materialized\s+view\s+[\w\.\"]+/i) !== -1 || sql.search(/^truncate\s+[\w\.\"]+/i) !== -1 || sql.search(/insert\s+into/i) !== -1 || sql.search(/update\s+[\w\.\-"]+\s+.*set/i) !== -1 || sql.search(/delete\s+from/i) !== -1;
    }
  
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/views/public-dataset/carto-table-metadata.js":
  /*!***************************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/views/public-dataset/carto-table-metadata.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var SQL = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js").SQL;
  var safeTableNameQuoting = __webpack_require__(/*! dashboard/helpers/safe-table-name-quoting */ "./lib/assets/javascripts/dashboard/helpers/safe-table-name-quoting.js");
  var cartoMetadataStatic = __webpack_require__(/*! ./carto-table-metadata-static */ "./lib/assets/javascripts/dashboard/views/public-dataset/carto-table-metadata-static.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var CartoTableData = __webpack_require__(/*! dashboard/data/table/carto-table-data */ "./lib/assets/javascripts/dashboard/data/table/carto-table-data.js");
  var ColumnModel = __webpack_require__(/*! dashboard/data/table/column-model */ "./lib/assets/javascripts/dashboard/data/table/column-model.js");
  var RowModel = __webpack_require__(/*! dashboard/data/table/row-model */ "./lib/assets/javascripts/dashboard/data/table/row-model.js");
  var PermissionModel = __webpack_require__(/*! dashboard/data/permission-model */ "./lib/assets/javascripts/dashboard/data/permission-model.js");
  var ImportModel = __webpack_require__(/*! dashboard/data/import-model */ "./lib/assets/javascripts/dashboard/data/import-model.js");
  var TableSynchronizationModel = __webpack_require__(/*! dashboard/data/table-synchronization-model */ "./lib/assets/javascripts/dashboard/data/table-synchronization-model.js");
  var getSimpleGeometryType = __webpack_require__(/*! builder/data/get-simple-geometry-type */ "./lib/assets/javascripts/builder/data/get-simple-geometry-type.js");
  var retrigger = __webpack_require__(/*! dashboard/helpers/retrigger */ "./lib/assets/javascripts/dashboard/helpers/retrigger.js");
  
  var REQUIRED_OPTS = ['configModel'];
  
  var Base = Backbone.Model.extend({
  
    columnNames: function columnNames() {
      return _.map(this.get('schema'), function (c) {
        return c[0];
      });
    },
  
    columnName: function columnName(idx) {
      return this.columnNames()[idx];
    }
  });
  
  var CartoTableMetadata = Base.extend({
    currentLoading: 0, // class variable (shared). I'm still not sure if this is messy as hell or powerfull as a transformer
  
    _TEXTS: {
      columnDeleted: 'Your column has been deleted',
      columnDeleting: 'Deleting your column',
      columnAdded: 'Your column has been added',
      columnAdding: 'Adding new column'
    },
  
    hiddenColumns: ['the_geom', 'the_geom_webmercator', 'cartodb_georef_status', 'created_at', 'updated_at', 'cartodb_id'],
  
    initialize: function initialize(attrs, opts) {
      checkAndBuildOpts(opts, REQUIRED_OPTS, this);
      _.bindAll(this, 'notice');
      this.readOnly = false;
      this.bind('change:schema', this._prepareSchema, this);
      this._prepareSchema();
      this.sqlView = null;
      this.synchronization = new TableSynchronizationModel({ configModel: opts.configModel });
      this.synchronization.linkToTable(this);
      this.synchronization.bind('change:id', function isSyncChanged() {
        this.trigger('change:isSync', this, this.synchronization.isSync());
      }, this);
      if (this.get('no_data_fetch')) {
        this.no_data_fetch = true;
        delete this.attributes.no_data_fetch;
      }
      this.data();
      this.bind('error', function (e, resp) {
        this.error('', resp);
      }, this);
      this._data.bind('error', function (e, resp) {
        this.notice('error loading rows, check your SQL query', 'error', 5000);
      }, this);
  
      this._data.bind('reset', function () {
        var view = this._data;
        this.set({
          schema: view.schemaFromData(this.get('schema')),
          geometry_types: view.getGeometryTypes()
        });
      }, this);
  
      retrigger.call(this, 'change', this._data, 'data:changed');
      retrigger.call(this, 'saved', this._data, 'data:saved');
  
      this.bind('change:table_visualization', function () {
        this.permission = new PermissionModel(this.get('table_visualization').permission, { configModel: this._configModel });
        this.trigger('change:permission', this, this.permission);
      }, this);
  
      // create permission if permission is set
      this.permission = new PermissionModel(this.get('permission'), { configModel: this._configModel });
    },
  
    url: function url(method) {
      var version = this._configModel.urlVersion('table', method);
      var base = '/api/' + version + '/tables';
      if (this.isNew()) {
        return base;
      }
      return base + '/' + this.id;
    },
  
    // use the name as the id since the api works
    // in the same way to table name and id
    parse: function parse(resp, xhr) {
      if (resp.name) {
        resp.id = resp.name;
      }
      // move geometry_types to stats one
      // geometry_types from backend are not reliable anymore and it can only be used
      // for non editing stuff (showing icons, general checks on table list)
      resp.stats_geometry_types = resp.geometry_types;
      delete resp.geometry_types;
      delete resp.schema;
      return resp;
    },
  
    notice: function notice(msg, type, timeout) {
      this.trigger('notice', msg, type, timeout);
    },
  
    setReadOnly: function setReadOnly(_) {
      var trigger = false;
      if (this.readOnly !== _) {
        trigger = true;
      }
      this.readOnly = _;
      if (trigger) {
        this.trigger('change:readOnly', this, _);
      }
    },
  
    isReadOnly: function isReadOnly() {
      return this.readOnly || this.data().isReadOnly() || this.synchronization.isSync();
    },
  
    isSync: function isSync() {
      return this.synchronization.isSync();
    },
  
    getUnqualifiedName: function getUnqualifiedName() {
      var name = this.get('name');
      if (!name) return null;
      var tk = name.split('.');
      if (tk.length == 2) {
        // eslint-disable-line eqeqeq
        return tk[1];
      }
      return name;
    },
  
    // "user".table -> user.table
    getUnquotedName: function getUnquotedName() {
      var name = this.get('name');
      return name && name.replace(/"/g, '');
    },
  
    sortSchema: function sortSchema() {
      this.set('schema', CartoTableMetadata.sortSchema(this.get('schema')));
    },
  
    error: function error(msg, resp) {
      var err = '';
      try {
        err = resp && resp.responseText && JSON.parse(resp.responseText).errors[0];
      } catch (e) {} finally {
        this.trigger('notice', msg + ': ' + err, 'error');
      }
    },
  
    _prepareSchema: function _prepareSchema() {
      var _this = this;
  
      this._columnType = {};
  
      _(this.get('schema')).each(function (schema) {
        _this._columnType[schema[0]] = schema[1];
      });
  
      if (!this.isInSQLView()) {
        this.set('original_schema', this.get('schema'));
      }
    },
  
    columnNames: function columnNames(sc) {
      sc = sc || 'schema';
      return _(this.get(sc)).pluck(0);
    },
  
    containsColumn: function containsColumn(name) {
      return _.contains(this.columnNames(), name);
    },
  
    columnNamesByType: function columnNamesByType(type, sc) {
      sc = sc || 'schema';
      var t = _(this.get(sc)).filter(function (c) {
        return c[1] == type; // eslint-disable-line eqeqeq
      });
      return _(t).pluck(0);
    },
  
    // return geometry columns calculated backend stats
    // use geomColumnTypes if you need something reliable (but slower and async)
    statsGeomColumnTypes: function statsGeomColumnTypes(geometryTypes) {
      return this.geomColumnTypes(this.get('stats_geometry_types'));
    },
  
    // return the current column types in an array
    // the values inside the array can be:
    //  'point', 'line', 'polygon'
    geomColumnTypes: function geomColumnTypes(geometryTypes) {
      var types = geometryTypes || this.get('geometry_types');
      var geomTypes = [];
      if (!_.isArray(types)) {
        return [];
      }
      var _map = {
        'st_multipolygon': 'polygon',
        'st_polygon': 'polygon',
        'st_multilinestring': 'line',
        'st_linestring': 'line',
        'st_multipoint': 'point',
        'st_point': 'point'
      };
      for (var t in types) {
        var type = types[t];
        // when there are rows with no geo type null is returned as geotype
        if (type) {
          var a = _map[type.toLowerCase()];
          if (a) {
            geomTypes.push(a);
          }
        }
      }
      return _.uniq(geomTypes);
    },
  
    /**
     *  Adding a new geometry type to the table
     *  @param geom type {st_polygon, st_point,...}
     *  @param set options
     */
    addGeomColumnType: function addGeomColumnType(t, opts) {
      if (!t) return;
      var types = _.clone(this.get('geometry_types')) || [];
      if (!_.contains(types, t)) {
        types.push(t);
  
        this.set({
          'geometry_types': types
        }, opts);
      }
    },
  
    nonReservedColumnNames: function nonReservedColumnNames() {
      var _this2 = this;
  
      return _.filter(this.columnNames(), function (columnName) {
        return !_this2.isReservedColumn(columnName);
      });
    },
  
    columnTypes: function columnTypes() {
      return _.clone(this._columnType);
    },
  
    _getColumn: function _getColumn(columnName) {
      if (this._columnType[columnName] === undefined) {
        return;
        // throw "the column does not exists";
      }
      var c = new ColumnModel({
        table: this,
        name: columnName,
        type: this._columnType[columnName],
        configModel: this._configModel
      }, { configModel: this._configModel });
      return c;
    },
  
    getColumnType: function getColumnType(columnName, sc) {
      sc = sc || 'schema';
      var t = _(this.get(sc)).filter(function (c) {
        return c[0] == columnName; // eslint-disable-line eqeqeq
      });
      if (t.length > 0) {
        return t[0][1];
      }
    },
  
    addColumn: function addColumn(columnName, columnType, opts) {
      var _this3 = this;
  
      var c = new ColumnModel({
        table: this,
        _name: columnName,
        type: columnType || 'string',
        configModel: this._configModel
      }, { configModel: this._configModel });
      this.notice(this._TEXTS.columnAdding, 'load', 0);
      c.save(null, {
        success: function success(model, obj) {
          _this3.notice(_this3._TEXTS.columnAdded, 'info');
          _this3.trigger('columnAdd', columnName);
          _this3.data().fetch();
          opts && opts.success && opts.success(model, obj);
        },
        error: function error(_error, resp) {
          _this3.error('error adding column', resp);
          opts && opts.error && opts.error(_error);
        },
        wait: true
      });
    },
  
    deleteColumn: function deleteColumn(columnName, opts) {
      var _this4 = this;
  
      var c = this._getColumn(columnName);
      if (c !== undefined) {
        this.notice(this._TEXTS.columnDeleting, 'load', 0);
        c.destroy({
          success: function success() {
            _this4.trigger('columnDelete', columnName);
            _this4.notice(_this4._TEXTS.columnDeleted, 'info');
            _this4.data().fetch();
            opts && opts.success && opts.success();
          },
          error: function error(e, resp) {
            _this4.error('error deleting column', resp);
            opts && opts.error && opts.error();
          },
          wait: true
        });
      }
    },
  
    renameColumn: function renameColumn(columnName, newName, opts) {
      var _this5 = this;
  
      if (columnName == newName) return; // eslint-disable-line eqeqeq
      var c = this._getColumn(columnName);
      var oldName = c.get('name');
      c.set({
        new_name: newName,
        old_name: c.get('name')
      });
      this.notice('renaming column', 'load', 0);
      c.save(null, {
        success: function success(mdl, data) {
          _this5.notice('Column has been renamed', 'info');
          _this5.trigger('columnRename', newName, oldName);
          _this5.data().fetch();
          opts && opts.success && opts.success(mdl, data);
        },
        error: function error(e, resp) {
          console.error("can't rename column");
          _this5.error('error renaming column', resp);
          opts && opts.error && opts.error(e, resp);
        },
        wait: true
      });
    },
  
    isTypeChangeAllowed: function isTypeChangeAllowed(columnName, newType) {
      var deactivateMatrix = {
        'number': ['date'],
        'boolean': ['date'],
        'date': ['boolean']
      };
      var c = this._getColumn(columnName);
      if (!c) {
        return true;
      }
      var type = c.get('type');
      var deactivated = deactivateMatrix[type] || [];
      deactivated = deactivated.concat([type]);
      return !_.contains(deactivated, newType);
    },
  
    isTypeChangeDestructive: function isTypeChangeDestructive(columnName, newType) {
      var columnType = this.getColumnType(columnName);
  
      var destructiveMatrix = {
        'string': {
          'string': false,
          'number': true,
          'date': true,
          'boolean': true
        },
        'number': {
          'string': false,
          'number': false,
          'date': true,
          'boolean': true
        },
        'date': {
          'string': false,
          'number': true,
          'date': false,
          'boolean': true
        },
        'boolean': {
          'string': false,
          'number': false,
          'date': true,
          'boolean': false
        }
      };
      return destructiveMatrix[columnType][newType];
    },
  
    changeColumnType: function changeColumnType(columnName, newType, opts) {
      var c = this._getColumn(columnName);
  
      if (this.getColumnType(columnName) == newType) {
        // eslint-disable-line eqeqeq
        opts && opts.success && opts.success();
        return;
      }
      this.saveNewColumnType(c, newType, opts);
    },
  
    saveNewColumnType: function saveNewColumnType(column, newType, opts) {
      var _this6 = this;
  
      column.set({ type: newType });
      this.notice('Changing column type', 'load', 0);
      column.save(null, {
        success: function success() {
          _this6.notice('Column type has been changed', 'info');
          _this6.trigger('typeChanged', newType); // to make it testable
          _this6.data().fetch();
          opts && opts.success && opts.success();
        },
        error: function error(e, resp) {
          _this6.trigger('typeChangeFailed', newType, e); // to make it testable
          _this6.error('error changing column type', resp);
          opts && opts.error && opts.error(e, resp);
        },
        wait: true
      });
    },
  
    /**
     * returns the original data for the table not the current applied view
     */
    originalData: function originalData() {
      return this._data;
    },
  
    data: function data() {
      if (this._data === undefined) {
        this._data = new CartoTableData(null, {
          table: this,
          configModel: this._configModel
        });
        this.bindData();
      }
      if (this.sqlView) {
        return this.sqlView;
      }
      return this._data;
    },
  
    bindData: function bindData(data) {
      if (this._data && !this._data.bindedReset) {
        retrigger.call(this, 'sync', this._data, 'dataLoaded');
        retrigger.call(this, 'add', this._data, 'dataAdded');
        this._data.bindedReset = true;
      }
      if (this.sqlView && !this.sqlView.bindedReset) {
        retrigger.call(this, 'sync', this.sqlView, 'dataLoaded');
        retrigger.call(this, 'add', this.sqlView, 'dataAdded');
        this.sqlView.bindedReset = true;
      }
    },
  
    useSQLView: function useSQLView(view, options) {
      if (!view && !this.sqlView) return;
      options = options || {};
  
      if (this.sqlView) {
        this.sqlView.unbind(null, null, this);
        this.sqlView.unbind(null, null, this._data);
      }
  
      // reset previous
      if (!view && this.sqlView) {
        this.sqlView.table = null;
      }
  
      this.sqlView = view;
      this.bindData();
  
      if (view) {
        view.bind('sync reset', function () {
          if (!view.modify_rows) {
            this.set({
              schema: view.schemaFromData(this.get('schema')),
              geometry_types: view.getGeometryTypes()
            });
          }
        }, this);
        // listen for errors
        view.bind('error', function (e, resp) {
          this.notice('error loading rows, check your SQL query', 'error', 5000);
        }, this);
  
        view.bind('loading', function () {
          // this.notice(_t('loading query'), 'load', 0);
        }, this);
  
        view.bind('reset loaded', function () {
          if (view.modify_rows) {
            this.notice(view.affected_rows + ' rows affected');
            this.useSQLView(null);
          } else {
            this.notice(_t('loaded'));
          }
        }, this);
  
        // swicth source data
        this.dataModel = this.sqlView;
        view.table = this;
      } else {
        this.dataModel = this._data;
        // get the original schema
        this.set({
          'schema': this.get('original_schema')
        }); /// *, { silent: true });
        this.data().fetch();
      }
      this.trigger('change:dataSource', this.dataModel, this);
    },
  
    isInSQLView: function isInSQLView() {
      return !!this.sqlView;
    },
  
    /**
     * replace fetch functionally to add some extra call for logging
     * it can be used in the same way fetch is
     */
    fetch: function fetch(opts) {
      var _this7 = this;
  
      var silent = opts ? opts.silent : false;
      if (!silent) {
        this.notice('loading table', 'load', this, 0, 0);
      }
      var xhr = Base.prototype.fetch.call(this, opts);
      $.when(xhr).done(function () {
        opts && opts.success && opts.success.old_success && opts.success.old_success();
        if (!silent) {
          _this7.notice('loaded');
        }
      }).fail(function () {
        if (!silent) {
          _this7.notice('error loading the table');
        }
      });
      return xhr;
    },
  
    isReservedColumn: function isReservedColumn(c) {
      return RowModel.isReservedColumn(c);
    },
  
    /**
     * when a table is linked to a infowindow each time a column
     * is renamed or removed the table pings to infowindow to remove
     * or rename the fields
     */
    linkToInfowindow: function linkToInfowindow(infowindow) {
      this.bind('columnRename', function (newName, oldName) {
        if (infowindow.containsField(oldName)) {
          infowindow.removeField(oldName);
          infowindow.addField(newName);
        }
      }, infowindow);
      this.bind('columnDelete', function (oldName, newName) {
        infowindow.removeField(oldName);
      }, infowindow);
  
      this.bind('change:schema', function () {
        var columns = _(this.columnNames()).filter(function (c) {
          return !_.contains(infowindow.SYSTEM_COLUMNS, c);
        });
  
        function _hash(str) {
          var hash = 0;
          var c;
          var i;
          for (i = 0; i < str.length; i++) {
            c = str.charCodeAt(i);
            hash = c + (hash << 6) + (hash << 16) - hash;
          }
          return hash;
        }
  
        if (this.isInSQLView()) {
          if (!infowindow.has('defaul_schema_fields')) {
            infowindow.saveFields('defaul_schema_fields');
          }
          var current_schema_key = 'schema_' + _hash(this.columnNames().sort().join(''));
          var previous_schema_key = 'schema_' + _hash(_(this.previous('schema')).pluck(0).sort().join(''));
  
          if (!infowindow.has(previous_schema_key)) {
            infowindow.saveFields(previous_schema_key);
          }
          if (infowindow.has(current_schema_key)) {
            infowindow.restoreFields(null, current_schema_key);
          }
        } else {
          infowindow.restoreFields(null, 'defaul_schema_fields');
        }
  
        if (infowindow.get('template')) {
          // merge fields checking actual schema
          infowindow.mergeFields(columns);
        } else {
          // remove fields that no longer exist
          infowindow.removeMissingFields(columns);
        }
      }, this);
    },
  
    embedURL: function embedURL() {
      return '/tables/' + this.get('name') + '/embed_map';
    },
  
    /**
     * @deprecated use vis.viewUrl() or vis.viewUrl(currentUser) instead.
     */
    viewUrl: function viewUrl() {
      return this._configModel.prefixUrl() + '/tables/' + this.getUnqualifiedName();
    },
  
    hasTheGeom: function hasTheGeom() {
      var currentSchema = this.get('schema');
      // if we have "the_geom" in our current schema, returnstrue
      for (var n in currentSchema) {
        if (currentSchema[n][0] === 'the_geom') {
          return true;
        }
      }
      return false;
    },
  
    /**
     * Checks the server to see if the table has any georeferenced row, independently of the applyed query
     * @return {promise}
     */
    fetchGeoreferenceStatus: function fetchGeoreferenceStatus() {
      var dfd = $.Deferred();
      var username = this.options && this.options.user_data ? this.options.user_data.username : window.user_data ? window.user_data.username : window.user_name;
      var api_key = this.options && this.options.user_data ? this.options.user_data.api_key : window.user_data ? window.user_data.api_key : window.api_key;
  
      this.sqlApi = new SQL({
        user: username,
        version: 'v1',
        api_key: api_key,
        sql_api_template: this._configModel.getSqlApiBaseUrl()
      });
  
      var sql = 'SELECT the_geom FROM ' + this.get('name') + ' WHERE the_geom is not null';
      this.sqlApi.execute(sql).done(function (data) {
        if (data.rows.length > 0) {
          dfd.resolve(true);
        } else {
          dfd.resolve(false);
        }
      });
  
      return dfd.promise();
    },
  
    /**
     * Checks the current loaded records to see if they are georeferenced
     * @return {boolean}
     */
    isGeoreferenced: function isGeoreferenced() {
      var geoColumns = this.geomColumnTypes();
      if (geoColumns && geoColumns.length > 0) {
        return true;
      } else {
        if (!this.isInSQLView()) {
          // sometimes the columns are changed in the frontend site
          // and the geocolumns are not updated.
          // check the columns in local
          return this._data.any(function (row) {
            return row.hasGeometry();
          });
        }
      }
      return false;
    },
  
    /**
     * this function can only be called during change event
     * returns true if the geometry type has changed
     * for this method multipolygon and polygon are the same geometry type
     */
    geometryTypeChanged: function geometryTypeChanged() {
      if (!('geometry_types' in this.changed)) return false;
      var geoTypes = this.get('geometry_types');
      var prevGeoTypes = this.previousAttributes().geometry_types;
      function normalize(e) {
        e = e.toLowerCase();
        if (e === 'st_multipolygon') {
          return 'st_polygon';
        }
        if (e === 'st_multilinestring') {
          return 'st_linestring';
        }
        if (e === 'st_multipoint') {
          return 'st_point';
        }
        return e;
      }
  
      if (!geoTypes || geoTypes.length === 0 || !prevGeoTypes || prevGeoTypes.length === 0) {
        return true;
      }
  
      var n = normalize(geoTypes[0]);
      var o = normalize(prevGeoTypes[0]);
      return n !== o;
    },
  
    /**
     * Get necessary data create a duplicated dataset from this table.
     *
     * @param {Object} newName name of new dataset.
     * @param {Object} callbacks
     * @returns {Object}
     */
    duplicate: function duplicate(newName, callbacks) {
      var _this8 = this;
  
      callbacks = callbacks || {};
  
      // Extracted from duplicate_table_dialog
      var data = {
        table_name: newName
      };
  
      // Set correct data object, depending on if the app has a query applied or not
      if (this.isInSQLView()) {
        var query = this.data().getSQL();
        data.sql = !query || query == '' ? 'SELECT * FROM ' + safeTableNameQuoting(this.get('name')) : query; // eslint-disable-line eqeqeq
      } else {
        data.table_copy = this.get('name');
      }
  
      var importModel = new ImportModel();
      importModel.save(data, {
        error: callbacks.error,
        success: function success(model, changes) {
          var checkImportModel = new ImportModel({
            item_queue_id: changes.item_queue_id
          });
  
          checkImportModel.bind('importComplete', function () {
            checkImportModel.unbind();
  
            // So import is done, create new table object from the new table and fetch, callback once finished.
            var newTable = new CartoTableMetadata({
              id: checkImportModel.get('table_id')
            }, { configModel: _this8._configModel });
  
            newTable.fetch({
              success: function success() {
                callbacks.success(newTable);
              },
              error: callbacks.error
            });
          });
  
          checkImportModel.bind('importError', function () {
            checkImportModel.unbind();
            callbacks.error.apply(this, arguments);
          });
  
          checkImportModel.pollCheck();
        }
      });
    },
  
    /**
     * Get the visualizations that are using this table dataset.
     * Note! a .fetch() is required to be sure the data to be available.
     * @return {Array}
     */
    dependentVisualizations: function dependentVisualizations() {
      // dependent = visualizations with a single layer
      // non-dependant = have more than this dataset as a layer
      return _.chain(this.get('dependent_visualizations')).union(this.get('non_dependent_visualizations')).compact().value() || [];
    },
  
    getGeometryType: function getGeometryType() {
      var types = this.get('geometry_types');
      var geomTypes = [];
      if (!_.isArray(types)) {
        return [];
      }
  
      for (var t in types) {
        var type = types[t];
        // when there are rows with no geo type null is returned as geotype
        if (type) {
          var a = getSimpleGeometryType(type.toLowerCase());
          if (a) {
            geomTypes.push(a);
          }
        }
      }
  
      return _.uniq(geomTypes);
    }
  
  }, _extends({
    /**
     * creates a new table from query
     * the called is responsable of calling save to create
     * the table in the server
     */
    createFromQuery: function createFromQuery(name, query, configModel) {
      return new CartoTableMetadata({
        sql: query,
        name: name
      }, { configModel: configModel });
    }
  
  }, cartoMetadataStatic));
  
  module.exports = CartoTableMetadata;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/dashboard/views/public-profile/fav-map-view.js":
  /*!*******************************************************************************!*\
    !*** ./lib/assets/javascripts/dashboard/views/public-profile/fav-map-view.js ***!
    \*******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var carto = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var createDefaultFallbackMap = __webpack_require__(/*! dashboard/components/create-fallback-map */ "./lib/assets/javascripts/dashboard/components/create-fallback-map.js");
  
  /**
   * View to render the "favourite" map, either a user's map visualization, or a default fallback map.
   */
  module.exports = CoreView.extend({
  
    render: function render() {
      this.$el.removeClass('is-pre-loading').addClass('is-loading');
  
      var promise;
      if (this.options.createVis) {
        promise = this._createVisMap(this.options.createVis);
      } else {
        promise = this._createFallbackMap();
      }
  
      var self = this;
      promise.done(function () {
        self.$el.removeClass('is-loading');
        self.$('.js-spinner').remove();
      });
  
      return this;
    },
  
    _createVisMap: function _createVisMap(createVis) {
      return carto.createVis(this.el, createVis.url || createVis.vizJson, _.defaults(createVis.opts, {
        authToken: 'default_public',
        title: false,
        header: false,
        description: false,
        searchControl: false,
        layer_selector: false,
        text: false,
        image: false,
        zoomControl: false,
        logo: false,
        scrollwheel: false,
        mobile_layout: true,
        legends: false,
        loader: false,
        fullscreen: false,
        no_cdn: false
      }));
    },
  
    _createFallbackMap: function _createFallbackMap() {
      createDefaultFallbackMap({
        el: this.el,
        basemap: this.options.fallbackBaselayer
      });
  
      // Fake promise, to keep the render method consistent with how the vis map would have been handled (async)
      return {
        done: function done(fn) {
          fn();
        }
      };
    }
  
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/api/create-dashboard.js":
  /*!**********************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/api/create-dashboard.js ***!
    \**********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var Dashboard = __webpack_require__(/*! deep-insights/api/dashboard.js */ "./lib/assets/javascripts/deep-insights/api/dashboard.js");
  var DashboardView = __webpack_require__(/*! deep-insights/dashboard-view */ "./lib/assets/javascripts/deep-insights/dashboard-view.js");
  var WidgetsCollection = __webpack_require__(/*! deep-insights/widgets/widgets-collection */ "./lib/assets/javascripts/deep-insights/widgets/widgets-collection.js");
  var WidgetsService = __webpack_require__(/*! deep-insights/widgets-service */ "./lib/assets/javascripts/deep-insights/widgets-service.js");
  var URLHelper = __webpack_require__(/*! deep-insights/api/url-helper */ "./lib/assets/javascripts/deep-insights/api/url-helper.js");
  
  /**
   * Translates a vizJSON v3 datastructure into a working dashboard which will be rendered in given selector.
   *
   * @param {String} selector e.g. "#foobar-id", ".some-class"
   * @param {Object} vizJSON JSON datastructure
   * @param {Object} opts (Optional) flags, see 3rd param for cdb.createVis for available ones. Keys used here:
   *   renderMenu: {Boolean} If true (default), render a top-level menu on the left side.
   * @return {Object} with keys:
   *   dashboardView: root (backbone) view of the dashboard
   *   vis: the instantiated vis map, same result as given from cdb.createVis()
   */
  var createDashboard = function (selector, vizJSON, opts, callback) {
    var dashboardEl = document.querySelector(selector);
    if (!dashboardEl) throw new Error('no element found with selector ' + selector);
  
    // Default options
    opts = opts || {};
    opts.renderMenu = _.isBoolean(opts.renderMenu)
      ? opts.renderMenu
      : true;
    opts.autoStyle = _.isBoolean(opts.autoStyle)
      ? opts.autoStyle
      : false;
  
    var widgets = new WidgetsCollection();
  
    var model = new cdb.core.Model({
      title: vizJSON.title,
      description: vizJSON.description,
      updatedAt: vizJSON.updated_at,
      userName: vizJSON.user.fullname,
      userProfileURL: vizJSON.user.profile_url,
      userAvatarURL: vizJSON.user.avatar_url,
      renderMenu: opts.renderMenu,
      autoStyle: opts.autoStyle,
      showLogo: opts.cartodb_logo,
      initialPosition: {
        bounds: vizJSON.bounds
      }
    });
    var dashboardView = new DashboardView({
      el: dashboardEl,
      widgets: widgets,
      model: model
    });
    var dashboardState = opts.state || URLHelper.getStateFromCurrentURL();
    if (dashboardState && !_.isEmpty(dashboardState.map)) {
      if (_.isArray(dashboardState.map.center)) {
        vizJSON.center = dashboardState.map.center;
      }
      if (_.isNumber(dashboardState.map.zoom)) {
        vizJSON.zoom = dashboardState.map.zoom;
      }
      if (dashboardState.map.ne && dashboardState.map.sw) {
        vizJSON.bounds = [dashboardState.map.ne, dashboardState.map.sw];
      }
    }
  
    var vis = cdb.createVis(dashboardView.$('#map'), vizJSON, _.extend(opts, {
      skipMapInstantiation: true
    }));
  
    vis.once('load', function (vis) {
      var widgetsState = (dashboardState && dashboardState.widgets) || {};
  
      // Create widgets
      var widgetsService = new WidgetsService(widgets, vis.dataviews);
  
      var widgetModelsMap = {
        formula: widgetsService.createFormulaModel.bind(widgetsService),
        histogram: widgetsService.createHistogramModel.bind(widgetsService),
        'time-series': widgetsService.createTimeSeriesModel.bind(widgetsService),
        category: widgetsService.createCategoryModel.bind(widgetsService)
      };
      vizJSON.widgets.forEach(function (widget) {
        // Flatten the data structure given in vizJSON, the widgetsService will use whatever it needs and ignore the rest
        var attrs = _.extend({}, widget, widget.options);
        var newWidgetModel = widgetModelsMap[widget.type];
        var state = widgetsState[widget.id];
  
        if (_.isFunction(newWidgetModel)) {
          // Find the Layer that the Widget should be created for.
          var layer;
          var source;
          if (widget.layer_id) {
            layer = vis.map.layers.get(widget.layer_id);
          } else if (Number.isInteger(widget.layerIndex)) {
            // TODO Since namedmap doesn't have ids we need to map in another way, here using index
            //   should we solve this in another way?
            layer = vis.map.layers.at(widget.layerIndex);
          }
          if (widget.source && widget.source.id) {
            source = vis.analysis.findNodeById(widget.source.id);
            attrs.source = source;
          }
  
          newWidgetModel(attrs, layer, state);
        } else {
          cdb.log.error('No widget found for type ' + widget.type);
        }
      });
  
      dashboardView.render();
  
      var callbackObj = {
        dashboardView: dashboardView,
        widgets: widgetsService,
        areWidgetsInitialised: function () {
          var widgetsCollection = widgetsService.getCollection();
          if (widgetsCollection.size() > 0) {
            return widgetsCollection.hasInitialState();
          }
          return true;
        },
        vis: vis
      };
  
      vis.instantiateMap({
        success: function () {
          callback && callback(null, callbackObj);
        },
        error: function (errorMessage) {
          callback && callback(new Error(errorMessage), callbackObj);
        }
      });
    });
  };
  
  module.exports = function (selector, vizJSON, opts, callback) {
    var args = arguments;
    var fn = args[args.length - 1];
  
    if (_.isFunction(fn)) {
      callback = fn;
    }
  
    function _load (vizJSON) {
      createDashboard(selector, vizJSON, opts, function (error, dashboard) {
        var _dashboard = new Dashboard(dashboard);
  
        if (opts.share_urls) {
          _dashboard.onStateChanged(
            _.debounce(
              function (state, url) {
                window.history.replaceState('Object', 'Title', url);
              },
              500
            )
          );
        }
  
        callback && callback(error, _dashboard);
      });
    }
  
    if (typeof vizJSON === 'string') {
      cdb.core.Loader.get(vizJSON, function (data) {
        if (data) {
          _load(data, opts);
        } else {
          callback && callback(new Error('Error fetching viz.json file: ' + vizJSON));
        }
      });
    } else {
      _load(vizJSON, opts);
    }
  };
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/api/dashboard.js":
  /*!***************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/api/dashboard.js ***!
    \***************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var URLHelper = __webpack_require__(/*! ./url-helper */ "./lib/assets/javascripts/deep-insights/api/url-helper.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  function Dashboard (dashboard) {
    this._dashboard = dashboard;
  
    this.onDataviewsFetched(function () {
      dashboard.widgets._widgetsCollection.initialState();
      dashboard.widgets._widgetsCollection.each(function (m) {
        m && m.applyInitialState && m.applyInitialState();
      });
    });
  }
  
  Dashboard.prototype = {
  
    /**
     * @return {View} used in the dashboard
     */
    getView: function () {
      return this._dashboard.dashboardView;
    },
  
    /**
     * @return {Map} the map used in the dashboard
     */
    getMap: function () {
      return this._dashboard.vis;
    },
  
    reloadMap: function () {
      this.getMap().reload();
    },
  
    forceResize: function () {
      this._dashboard.widgets.getCollection()
        .each(function (widget) {
          widget.forceResize();
        });
    },
  
    /**
     * @return {Array} of widgets in the dashboard
     */
    getWidgets: function () {
      return this._dashboard.widgets.getList();
    },
  
    getDashboardURL: function () {
      return URLHelper.getURLFromState(this.getState());
    },
  
    getState: function () {
      var state = {};
      var mapState = this.getMapState();
      if (!_.isEmpty(mapState)) state.map = mapState;
  
      var widgetsCollection = this._dashboard.widgets.getCollection();
      var widgetsState = widgetsCollection.getStates();
      if (!_.isEmpty(widgetsState)) state.widgets = widgetsState;
      return state;
    },
  
    getMapState: function () {
      var map = this._dashboard.vis.map;
      var currentBoundingBox = map.getViewBounds();
      var center = map.get('center');
      var zoom = map.get('zoom');
  
      return {
        ne: currentBoundingBox[0],
        sw: currentBoundingBox[1],
        center: center,
        zoom: zoom
      };
    },
  
    setState: function (state) {
      // todo: set map state
      this._dashboard.widgets.setWidgetsState(state.widgets);
      this._dashboard.vis.mapvis.map.setBounds([state.map.ne, state.map.sw]);
    },
  
    onDataviewsFetched: function (callback) {
      var areWidgetsInitialized = this._dashboard.areWidgetsInitialised();
      if (areWidgetsInitialized) {
        callback && callback();
      } else {
        this._dashboard.vis.once('dataviewsFetched', function () {
          callback && callback();
        });
      }
    },
  
    onStateChanged: function (callback) {
      this.onDataviewsFetched(function () {
        callback && this._bindChange(callback);
      }.bind(this));
    },
  
    _bindChange: function (callback) {
      var widgetsCollection = this._dashboard.widgets.getCollection();
      widgetsCollection.bind('change', function () {
        callback(this.getState(), this.getDashboardURL());
      }, this);
  
      this._dashboard.vis.map.bind('change', function () {
        callback(this.getState(), this.getDashboardURL());
      }, this);
    },
  
    /**
     * @param {Integer} id - widget id
     * @return a widget object
     */
    getWidget: function (id) {
      return this._dashboard.widgets.get(id);
    },
  
    /**
     * Create a category widget.
     * @param {Object} widgetAttrs - attributes for the new widget
     * @param {string} widgetAttrs.id - id (required)
     * @param {string} widgetAttrs.title - title (required)
     * @param {number} widgetAttrs.order - index of the widget (optional)
     * @param ...
     * @return {CategoryWidget} The new widget
     */
    createCategoryWidget: function (widgetAttrs, layer) {
      return this._dashboard.widgets.createCategoryModel(widgetAttrs, layer, null);
    },
  
    /**
     * Create a histogram widget
     * @param {Object} widgetAttrs - attributes for the new widget
     * @param {string} widgetAttrs.id - id (required)
     * @param {string} widgetAttrs.title - title (required)
     * @param {number} widgetAttrs.order - index of the widget (optional)
     * @param ...
     * @return {HistogramWidget} The new widget
     */
    createHistogramWidget: function (widgetAttrs, layer) {
      return this._dashboard.widgets.createHistogramModel(widgetAttrs, layer, null);
    },
  
    /**
     * Create a formula widget
     * @param {Object} widgetAttrs - attributes for the new widget
     * @param {string} widgetAttrs.id - id (required)
     * @param {string} widgetAttrs.title - title (required)
     * @param {number} widgetAttrs.order - index of the widget (optional)
     * @param ...
     * @return {FormulaWidget} The new widget
     */
    createFormulaWidget: function (widgetAttrs, layer) {
      return this._dashboard.widgets.createFormulaModel(widgetAttrs, layer, null);
    },
  
    /**
     * Create a timesier es widget
     * @param {Object} widgetAttrs - attributes for the new widget
     * @param {string} widgetAttrs.id - id (required)
     * @param {string} widgetAttrs.title - title (required)
     * @param {number} widgetAttrs.order - index of the widget (optional)
     * @param ...
     * @return {TimeSeriesWidget} The new widget
     */
    createTimeSeriesWidget: function (widgetAttrs, layer) {
      return this._dashboard.widgets.createTimeSeriesModel(widgetAttrs, layer, null);
    }
  
  };
  
  module.exports = Dashboard;
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/api/url-helper.js":
  /*!****************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/api/url-helper.js ***!
    \****************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var URI = __webpack_require__(/*! urijs */ "./node_modules/urijs/src/URI.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  module.exports = {
    getURLFromState: function (state) {
      var thisURL = new URI(this.getLocalURL());
      thisURL.removeQuery('state');
      if (!_.isEmpty(state)) {
        var statesString = JSON.stringify(state);
        thisURL.setQuery('state', statesString);
      }
      return thisURL.toString();
    },
    getStateFromCurrentURL: function () {
      var currentURL = this.getLocalURL();
      return this.getStateFromURL(currentURL);
    },
    getStateFromURL: function (url) {
      var uri = new URI(url);
      var state;
      var result = {};
      if (uri.hasQuery('state')) {
        state = uri.query(true)['state'];
        if (!_.isEmpty(state)) {
          result = JSON.parse(decodeURIComponent(state));
        }
      }
      return result;
    },
    getLocalURL: _.constant(window.location.href)
  };
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/dashboard-below-map-view.js":
  /*!**************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/dashboard-below-map-view.js ***!
    \**************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var WidgetViewFactory = __webpack_require__(/*! ./widgets/widget-view-factory */ "./lib/assets/javascripts/deep-insights/widgets/widget-view-factory.js");
  var TimeSeriesContentView = __webpack_require__(/*! ./widgets/time-series/content-view */ "./lib/assets/javascripts/deep-insights/widgets/time-series/content-view.js");
  var TorqueTimeSeriesContentView = __webpack_require__(/*! ./widgets/time-series/torque-content-view */ "./lib/assets/javascripts/deep-insights/widgets/time-series/torque-content-view.js");
  
  var TIME_SERIES_TYPE = 'time-series';
  
  module.exports = CoreView.extend({
    className: 'CDB-Dashboard-belowMap',
  
    initialize: function (options) {
      this._widgetViewFactory = new WidgetViewFactory([
        {
          // same type as below, but also check if the associated layer is a a torque layer
          match: function (widgetModel) {
            if (widgetModel.get('type') === TIME_SERIES_TYPE) {
              var dataviewModel = widgetModel.dataviewModel;
              var layerModel = widgetModel.layerModel;
              return dataviewModel && layerModel.get('type') === 'torque' && widgetModel.get('animated') === true;
            }
            return false;
          },
          createContentView: function (widgetModel) {
            return new TorqueTimeSeriesContentView({
              model: widgetModel
            });
          },
          customizeWidgetAttrs: function (attrs) {
            attrs.className += ' CDB-Widget--timeSeries';
            return attrs;
          }
        }, {
          type: TIME_SERIES_TYPE,
          createContentView: function (widgetModel) {
            return new TimeSeriesContentView({
              model: widgetModel
            });
          },
          customizeWidgetAttrs: function (attrs) {
            attrs.className += ' CDB-Widget--timeSeries';
            return attrs;
          }
        }
      ]);
  
      this._widgets = options.widgets;
      this._widgets.bind('add', this._maybeRenderWidgetView, this);
      this._widgets.bind('reset', this.render, this);
      this._widgets.bind('add reset remove', this._onWidgetsChange, this);
      this.add_related_model(this._widgets);
    },
  
    render: function () {
      this.clearSubViews();
      this.$el.empty();
  
      this._widgets.each(this._maybeRenderWidgetView, this);
      this._toggleVisiblity();
  
      return this;
    },
  
    _maybeRenderWidgetView: function (widgetModel) {
      var view = this._widgetViewFactory.createWidgetView(widgetModel);
      if (view) {
        this.addView(view);
        this.$el.append(view.render().el);
      }
    },
  
    _toggleVisiblity: function () {
      this.$el.toggle(!_.isEmpty(this._subviews));
    },
  
    _onWidgetsChange: function () {
      this._widgets.each(function (widget) {
        widget.forceResize();
      });
      this._toggleVisiblity();
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/dashboard-menu-view.js":
  /*!*********************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/dashboard-menu-view.js ***!
    \*********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var template = __webpack_require__(/*! ./dashboard-menu-view.tpl */ "./lib/assets/javascripts/deep-insights/dashboard-menu-view.tpl");
  var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  var Ps = __webpack_require__(/*! perfect-scrollbar */ "./node_modules/perfect-scrollbar/index.js");
  
  var BREAKPOINT = 1201;
  
  var DashboardMenuView = CoreView.extend({
    className: 'CDB-Dashboard-menu',
  
    events: {
      'click .js-toggle-view': '_toogleView'
    },
  
    initialize: function () {
      this.viewModel = new cdb.core.Model({
        open: false,
        footer: $(window).width() < BREAKPOINT
      });
  
      this._initBinds();
    },
  
    _initBinds: function () {
      this.listenTo(this.viewModel, 'change', this.render);
      this._resize = _.debounce(this._onResizeWindow.bind(this), 20);
      $(window).on('resize', this._resize);
    },
  
    render: function () {
      var shortTitle = this.model.get('title');
      var isOpen = this.viewModel.get('open');
      var isFooter = this.viewModel.get('footer');
  
      if (shortTitle && shortTitle.length > 120) {
        shortTitle = shortTitle.slice(0, 110) + '...' + ' %23 map';
      }
  
      this.$el.html(
        template({
          hasTranslation: isOpen || isFooter,
          showLogo: this.model.get('showLogo'),
          title: this.model.get('title'),
          description: this.model.get('description'),
          updatedAt: moment(this.model.get('updatedAt')).fromNow(),
          userName: this.model.get('userName'),
          url: window.location.href,
          urlWithoutParams: window.location.protocol + '//' + window.location.host + window.location.pathname,
          inIframe: (window.location !== window.parent.location),
          shortTitle: shortTitle,
          userAvatarURL: this.model.get('userAvatarURL'),
          userProfileURL: this.model.get('userProfileURL')
        })
      );
  
      this.$el.toggleClass('is-active', isOpen);
  
      var content = this._getDescription().get(0);
      Ps.initialize(content, {
        wheelSpeed: 2,
        suppressScrollX: true
      });
  
      return this;
    },
  
    _getDescription: function () {
      return this.$('.js-scroll-wrapper');
    },
  
    _toogleView: function () {
      var open = this.viewModel.get('open');
      this.viewModel.set({open: !open});
    },
  
    _onResizeWindow: function () {
      this.viewModel.set({
        footer: $(window).width() < BREAKPOINT
      });
    },
  
    clean: function () {
      $(window).off('resize', this._resize);
      CoreView.prototype.clean.call(this);
    }
  });
  
  module.exports = DashboardMenuView;
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/dashboard-sidebar-view.js":
  /*!************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/dashboard-sidebar-view.js ***!
    \************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var Ps = __webpack_require__(/*! perfect-scrollbar */ "./node_modules/perfect-scrollbar/index.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var CategoryContentView = __webpack_require__(/*! ./widgets/category/content-view */ "./lib/assets/javascripts/deep-insights/widgets/category/content-view.js");
  var FormulaContentView = __webpack_require__(/*! ./widgets/formula/content-view */ "./lib/assets/javascripts/deep-insights/widgets/formula/content-view.js");
  var HistogramContentView = __webpack_require__(/*! ./widgets/histogram/content-view */ "./lib/assets/javascripts/deep-insights/widgets/histogram/content-view.js");
  var WidgetViewFactory = __webpack_require__(/*! ./widgets/widget-view-factory */ "./lib/assets/javascripts/deep-insights/widgets/widget-view-factory.js");
  var template = __webpack_require__(/*! ./dashboard-sidebar.tpl */ "./lib/assets/javascripts/deep-insights/dashboard-sidebar.tpl");
  var matchMedia = window.matchMedia;
  
  module.exports = CoreView.extend({
    className: 'CDB-Widget-canvas',
  
    initialize: function (options) {
      this._widgetViewFactory = new WidgetViewFactory([
        {
          type: 'formula',
          createContentView: function (widgetModel) {
            return new FormulaContentView({
              model: widgetModel
            });
          }
        }, {
          type: 'histogram',
          createContentView: function (widgetModel) {
            return new HistogramContentView({
              model: widgetModel
            });
          }
        }, {
          type: 'category',
          createContentView: function (widgetModel) {
            return new CategoryContentView({
              model: widgetModel
            });
          }
        }
      ]);
  
      this._widgets = options.widgets;
  
      this._widgets.bind('add', this._maybeRenderWidgetView, this);
      this._widgets.bind('reset', this.render, this);
      this._widgets.bind('orderChanged', this.render, this);
      this._widgets.bind('change:collapsed', this._onWidgetUpdate, this);
      this._widgets.bind('add remove reset', this._onWidgetsChange, this);
      this.add_related_model(this._widgets);
  
      this._resizeHandler = this._onResize.bind(this);
    },
  
    render: function () {
      this._cleanScroll();
      this._observer && this._observer.disconnect();
      this.clearSubViews();
  
      this.$el.html(template());
      this.$el.toggleClass('CDB-Widget-canvas--withMenu', this.model.get('renderMenu'));
      this._widgets.each(this._maybeRenderWidgetView, this);
      this._toggleVisiblity();
  
      this._renderScroll();
      this._renderShadows();
      this._bindScroll();
      this._initResize();
  
      return this;
    },
  
    _initResize: function () {
      var breakpoints = ['(max-width: 1600px)', '(max-width: 1280px)', '(max-width: 759px)'];
      breakpoints.forEach(function (breakpoint) {
        var mq = matchMedia(breakpoint);
        mq.addListener(this._resizeHandler);
      }, this);
    },
  
    _updateScrollCss: function () {
      this._onWidgetUpdate();
  
      var element = this._container();
      if (!element) return;
  
      var containerWidth = element.clientWidth;
      var containerHeight = element.clientHeight;
      var contentWidth = element.scrollWidth;
      var contentHeight = element.scrollHeight;
      var xScroll = containerWidth < contentWidth;
      var yScroll = containerHeight < contentHeight;
  
      this._$container().toggleClass('hasXScroll', xScroll);
      this._$container().toggleClass('hasYScroll', yScroll);
    },
  
    _$container: function () {
      return $(this._container());
    },
  
    _container: function () {
      return this.el.querySelector('.js-container');
    },
  
    _maybeRenderWidgetView: function (widgetModel) {
      var view = this._widgetViewFactory.createWidgetView(widgetModel);
  
      if (view) {
        this.addView(view);
        this._$container().append(view.render().el);
      }
    },
  
    _bindScroll: function () {
      this._$container()
        .on('ps-y-reach-start', _.bind(this._onScrollTop, this))
        .on('ps-y-reach-end', _.bind(this._onScrollBottom, this))
        .on('ps-scroll-y', _.bind(this._onScroll, this));
    },
  
    _renderScroll: function () {
      Ps.initialize(this._container(), {
        wheelSpeed: 1,
        wheelPropagation: false,
        swipePropagation: true,
        stopPropagationOnClick: false,
        minScrollbarLength: 20,
        useBothWheelAxes: true
      });
    },
  
    _onWidgetUpdate: function () {
      Ps.update(this._container());
    },
  
    _renderShadows: function () {
      this.$shadowTop = $('<div>').addClass('CDB-Widget-canvasShadow CDB-Widget-canvasShadow--top');
      this.$shadowBottom = $('<div>').addClass('CDB-Widget-canvasShadow CDB-Widget-canvasShadow--bottom');
      this.$el.append(this.$shadowTop);
      this.$el.append(this.$shadowBottom);
    },
  
    _onScrollTop: function () {
      this.$shadowTop.removeClass('is-visible');
    },
  
    _onScroll: function () {
      var $el = this._$container();
      var currentPos = $el.scrollTop();
      var max = $el.get(0).scrollHeight;
      var height = $el.outerHeight();
      var maxPos = max - height;
  
      this.$shadowTop.toggleClass('is-visible', currentPos > 0);
      this.$shadowBottom.toggleClass('is-visible', currentPos < maxPos);
    },
  
    _updateScroll: function () {
      this._$container().scrollLeft = 0;
      this._$container().scrollTop = 0;
    },
  
    _onResize: function (mediaQuery) {
      // we don't use mediaQuery.matches
      // trigger actions always if breakpoints changes
      this._updateScroll();
      this._onScroll();
    },
  
    _onScrollBottom: function () {
      this.$shadowBottom.removeClass('is-visible');
    },
  
    _cleanScroll: function () {
      $(window).off('resize', this._resizeHandler);
      if (this._container()) {
        this._$container().off('ps-scroll-y');
        Ps.destroy(this._container());
      }
    },
  
    _toggleVisiblity: function () {
      this.$el.toggle(!_.isEmpty(this._subviews));
    },
  
    _onWidgetsChange: function () {
      this._toggleVisiblity();
      this.render();
    },
  
    clean: function () {
      this._cleanScroll();
      this._observer && this._observer.disconnect();
      CoreView.prototype.clean.call(this);
    }
  
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/dashboard-view.js":
  /*!****************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/dashboard-view.js ***!
    \****************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./dashboard.tpl */ "./lib/assets/javascripts/deep-insights/dashboard.tpl");
  var DashboardBelowMapView = __webpack_require__(/*! ./dashboard-below-map-view */ "./lib/assets/javascripts/deep-insights/dashboard-below-map-view.js");
  var DashboardMenuView = __webpack_require__(/*! ./dashboard-menu-view */ "./lib/assets/javascripts/deep-insights/dashboard-menu-view.js");
  var DashboardSidebarView = __webpack_require__(/*! ./dashboard-sidebar-view */ "./lib/assets/javascripts/deep-insights/dashboard-sidebar-view.js");
  
  /**
   * Dashboard is a wrapper around the map canvas, which contains widget views for the map contdxt
   * Widgets may be rendered in two areas, in the "sidebar" or "below-map".
   */
  module.exports = CoreView.extend({
    className: 'CDB-Dashboard-canvas',
  
    initialize: function (options) {
      this._widgets = options.widgets;
      this._infoView = options.infoView;
  
      // TODO parent context requires some markup to be present already, but NOT the other views
      this.el.classList.add(this.className);
      this.$el.html(template());
  
      this._onWindowResize = this._onWindowResize.bind(this);
      $(window).bind('resize', this._onWindowResize);
    },
  
    render: function () {
      this.clearSubViews();
  
      var view;
      var doRenderMenu = this.model.get('renderMenu');
  
      this.$el.toggleClass('CDB-Dashboard-canvas--withMenu', doRenderMenu);
  
      if (doRenderMenu) {
        view = new DashboardMenuView({
          model: this.model
        });
        this.addView(view);
        this.$el.append(view.render().el);
      }
  
      const hasTimeSeries = this._widgets.some(function (model) {
        return model.get('type') === 'time-series';
      });
  
      if (hasTimeSeries) {
        this.$el.toggleClass('CDB-Dashboard-canvas--withTimeSeries');
      }
  
      view = new DashboardBelowMapView({
        widgets: this._widgets
      });
      this.addView(view);
      this.$('.js-map-wrapper')
        .toggleClass('CDB-Dashboard-mapWrapper--withMenu', doRenderMenu)
        .append(view.render().el);
  
      if (this._widgets && this._widgets.length) {
        this.$el.toggleClass('CDB-Dashboard-canvas--withWidgets');
      }
  
      view = new DashboardSidebarView({
        widgets: this._widgets,
        model: this.model
      });
      this.addView(view);
      this.$el.append(view.render().el);
  
      return this;
    },
  
    getInitialMapState: function () {
      return {
        bounds: this.model.get('initialPosition').bounds
      };
    },
  
    _onWindowResize: function () {
      this._widgets.each(function (widget) {
        widget.forceResize();
      });
    },
  
    clean: function () {
      $(window).unbind('resize', this._onWindowResize);
      CoreView.prototype.clean.call(this);
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/data/analyses.js":
  /*!***************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/data/analyses.js ***!
    \***************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var ACTIVE_LOCALE = 'en';
  var Locale = __webpack_require__(/*! locale/index */ "./lib/assets/javascripts/locale/index.js");
  var Polyglot = __webpack_require__(/*! node-polyglot */ "./node_modules/node-polyglot/index.js");
  var polyglot = new Polyglot({
    locale: ACTIVE_LOCALE, // Needed for pluralize behaviour
    phrases: Locale[ACTIVE_LOCALE]
  });
  var _t = polyglot.t.bind(polyglot);
  
  var MAP = {
    'aggregate-intersection': {
      title: _t('analyses.aggregate-intersection.short-title')
    },
    'bounding-box': {
      title: _t('analyses.bounding-box.short-title')
    },
    'bounding-circle': {
      title: _t('analyses.bounding-circle.short-title')
    },
    'buffer': {
      title: _t('analyses.area-of-influence.short-title')
    },
    'centroid': {
      title: _t('analyses.centroid.short-title')
    },
    'convex-hull': {
      title: _t('analyses.convex-hull.short-title')
    },
    'concave-hull': {
      title: _t('analyses.concave-hull.short-title')
    },
    'data-observatory-measure': {
      title: _t('analyses.data-observatory-measure.short-title')
    },
    'data-observatory-multiple-measures': {
      title: _t('analyses.data-observatory-multiple-measures.short-title')
    },
    'filter-by-node-column': {
      title: _t('analyses.filter-by-node-column.short-title')
    },
    'filter-category': {
      title: _t('analyses.filter.short-title')
    },
    'filter-range': {
      title: _t('analyses.filter.short-title')
    },
    'georeference-city': {
      title: _t('analyses.georeference.short-title')
    },
    'georeference-ip-address': {
      title: _t('analyses.georeference.short-title')
    },
    'georeference-country': {
      title: _t('analyses.georeference.short-title')
    },
    'georeference-long-lat': {
      title: _t('analyses.georeference.short-title')
    },
    'georeference-postal-code': {
      title: _t('analyses.georeference.short-title')
    },
    'georeference-street-address': {
      title: _t('analyses.georeference.short-title')
    },
    'georeference-admin-region': {
      title: _t('analyses.georeference.short-title')
    },
    'intersection': {
      title: _t('analyses.filter-intersection.short-title')
    },
    'kmeans': {
      title: _t('analyses.kmeans.short-title')
    },
    'line-to-single-point': {
      title: _t('analyses.connect-with-lines.short-title')
    },
    'line-source-to-target': {
      title: _t('analyses.connect-with-lines.short-title')
    },
    'line-sequential': {
      title: _t('analyses.connect-with-lines.short-title')
    },
    'merge': {
      title: _t('analyses.merge.short-title')
    },
    'moran': {
      title: _t('analyses.moran-cluster.short-title')
    },
    'routing-sequential': {
      title: _t('analyses.routing.short-title')
    },
    'routing-to-layer-all-to-all': {
      title: _t('analyses.routing.short-title')
    },
    'routing-to-single-point': {
      title: _t('analyses.routing.short-title')
    },
    'sampling': {
      title: _t('analyses.sampling.short-title')
    },
    'spatial-markov-trend': {
      title: _t('analyses.spatial-markov-trend.short-title')
    },
    'trade-area': {
      title: _t('analyses.area-of-influence.short-title')
    },
    'weighted-centroid': {
      title: _t('analyses.centroid.short-title')
    },
    'closest': {
      title: _t('analyses.find-nearest.short-title')
    },
    'deprecated-sql-function': {
      title: _t('analyses.deprecated-sql-function.short-title')
    }
  };
  
  var getAnalysisByType = function (type) {
    var safeType = type === '' ? 'unknown' : type;
    return MAP[safeType] || {
      title: _t('analyses.' + safeType)
    };
  };
  
  module.exports = {
    MAP: MAP,
  
    title: function (type) {
      return getAnalysisByType(type).title;
    }
  };
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/formatter.js":
  /*!***********************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/formatter.js ***!
    \***********************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");
  var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  
  var AGGREGATION_FORMATS = {
    second: {
      display: 'HH:mm:ss',
      unit: 's'
    },
    minute: {
      display: 'HH:mm - MMM Do, YYYY',
      unit: 'm'
    },
    hour: {
      display: 'HH:00 - MMM Do, YYYY',
      unit: 'h'
    },
    day: {
      display: 'MMM Do, YYYY',
      unit: 'd'
    },
    week: {
      display: 'MMM Do, YYYY',
      unit: 'w'
    },
    month: {
      display: 'MMM YYYY',
      unit: 'M'
    },
    quarter: {
      display: '[Q]Q YYYY',
      unit: 'Q'
    },
    year: {
      display: 'YYYY',
      unit: 'y'
    },
    decade: {
      display: 'YYYY',
      unit: 'y'
    }
  };
  
  var format = {};
  
  format.formatNumber = function (value, unit) {
    if (!_.isNumber(value) || value === 0) {
      return value;
    }
  
    var format = d3.format('.2s');
    var p = 0;
    var absV = Math.abs(value);
  
    if (value > 1000) {
      value = format(value) + (unit ? ' ' + unit : '');
      return value;
    }
  
    if (absV > 100) {
      p = 0;
    } else if (absV > 10) {
      p = 1;
    } else if (absV > 1) {
      p = 2;
    } else if (absV > 0) {
      p = Math.max(Math.ceil(Math.abs(Math.log(absV) / Math.log(10))) + 2, 3);
    }
  
    value = value.toFixed(p);
    var m = value.match(/(\.0+)$/);
    if (m) {
      value = value.replace(m[0], '');
    }
  
    return value;
  };
  
  format.formatDate = function (value) {
    return d3.time.format('%Y-%m-%d')(value);
  };
  
  format.formatTime = function (value) {
    return d3.time.format('%H:%M:%S %d/%m/%Y')(value);
  };
  
  format.timeFactory = function (format) {
    return d3.time.format(format);
  };
  
  format.formatValue = function (value) {
    if (_.isNumber(value)) {
      return format.formatNumber(value);
    }
    if (_.isDate(value)) {
      return format.formatDate(value);
    }
    return value;
  };
  
  format.timestampFactory = function (aggregation, offset) {
    return function (timestamp) {
      if (!_.has(AGGREGATION_FORMATS, aggregation)) {
        return '-';
      }
      var format = AGGREGATION_FORMATS[aggregation];
      var date = moment.unix(timestamp).utc();
      if (_.isFinite(offset)) {
        date.utcOffset(offset / 60);
      }
      var formatted = date.format(format.display);
      return formatted;
    };
  };
  
  module.exports = format;
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/index.js":
  /*!*******************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/index.js ***!
    \*******************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  module.exports = {
    VERSION: '',
    createDashboard: __webpack_require__(/*! ./api/create-dashboard */ "./lib/assets/javascripts/deep-insights/api/create-dashboard.js")
  };
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/util/error-enhancer.js":
  /*!*********************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/util/error-enhancer.js ***!
    \*********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  var ERRORS = {
    generic: {
      level: 'error',
      refresh: true
    },
    limit: {
      level: 'error',
      error: 'Timeout',
      message: 'The server is taking too long to respond, due to poor conectivity or a temporary error with our servers. Please try again soon.',
      refresh: true
    },
    no_data_available: {
      level: 'alert',
      error: 'No data available',
      message: 'There are no results for the combination of filters applied to your data. Try tweaking your filters, or zoom and pan the map to adjust the Map View.',
      refresh: false
    },
    too_many_bins: {
      level: 'error',
      error: 'Too many bins returned',
      message: 'There are too many bins returned. Try selecting a less granular aggregation or filtering the data source.',
      refresh: false
    },
    dataview: {
      level: 'error',
      refresh: false
    }
  };
  
  module.exports = function (error) {
    var type = error && error.type && _.has(ERRORS, error.type)
      ? error.type
      : 'generic';
    return _.extend({}, error, ERRORS[type]);
  };
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/util/escape-html.js":
  /*!******************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/util/escape-html.js ***!
    \******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  module.exports = function escapeHTML (str) {
    return _.escape(str);
  };
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/util/get-object-value.js":
  /*!***********************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/util/get-object-value.js ***!
    \***********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
    * Gets the value at path of object. If the resolved value is undefined, the defaultValue is returned in its place.
    * @param {Object} object The object to query.
    * @param {String} path The path of the property to get.
    * @param {Any} defaultValue The value returned for undefined resolved values.
    * @return {Any} Returns the resolved value.
    */
  module.exports = function (object, path, defaultValue) {
    var keys = path.split('.');
    var value = keys.reduce(function (a, b) {
      return (a || {})[b];
    }, object);
  
    return value || defaultValue;
  };
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/util/layer-colors.js":
  /*!*******************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/util/layer-colors.js ***!
    \*******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  module.exports = {
    COLORS: [
      '#11A579',
      '#E83f74',
      '#9F5DC8',
      '#EF8205',
      '#29B3B2',
      '#E54F3B',
      '#59BB12',
      '#EF57BA',
      '#E2AF00',
      '#12AADE'
    ],
  
    /**
     * Get the letter representation.
     * @param {String, Object} sourceId or backbone model that have id. e.g. 'c2'
     * @return {String} e.g. 'c' or an empty string if there is no letter in the given id
     */
    letter: function (sourceId) {
      if (!sourceId || !_.isString(sourceId)) return '';
      var match = sourceId.match(/^([a-z]+)/);
      return (_.isArray(match) && match[0]) || '';
    },
  
    /**
     * Returns a color given a letter
     * @param  {String} Letter. eg: 'a', 'b', 'c', etc.
     * @return {String} Hex color code: eg: '#7F3C8D'
     */
    getColorForLetter: function (letter) {
      if (!letter) {
        return this.COLORS[0];
      }
  
      var letterNumber = letter.charCodeAt(0) - 97;
      var colorIndex = ((letterNumber / this.COLORS.length % 1) * 10).toFixed();
      return this.COLORS[colorIndex] || this.COLORS[0];
    }
  };
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/util/timestamp-helper.js":
  /*!***********************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/util/timestamp-helper.js ***!
    \***********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var helper = {};
  
  helper.substractOneUnit = function (timestamp, aggregation) {
    if (!_.isNumber(timestamp)) {
      return timestamp;
    }
  
    var result = moment.unix(timestamp).utc();
    aggregation && aggregation === 'week'
      ? result.subtract(1, 'day')
      : result.subtract(1, aggregation);
  
    return result.unix();
  };
  
  module.exports = helper;
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/util/unescape-html.js":
  /*!********************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/util/unescape-html.js ***!
    \********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  module.exports = function unescapeHTML (str) {
    return _.unescape(str);
  };
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/viewport-utils.js":
  /*!****************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/viewport-utils.js ***!
    \****************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  
  var TABLET_WIDTH = 760;
  var MOBILE_WIDTH = 480;
  
  var utils = {};
  
  utils._isViewport = function (vp) {
    return $(window).width() < vp;
  };
  
  utils.isMobileViewport = function () {
    return this._isViewport(MOBILE_WIDTH);
  };
  
  utils.isTabletViewport = function () {
    return this._isViewport(TABLET_WIDTH);
  };
  
  module.exports = utils;
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets-service.js":
  /*!*****************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets-service.js ***!
    \*****************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var WidgetModel = __webpack_require__(/*! ./widgets/widget-model */ "./lib/assets/javascripts/deep-insights/widgets/widget-model.js");
  var CategoryWidgetModel = __webpack_require__(/*! ./widgets/category/category-widget-model */ "./lib/assets/javascripts/deep-insights/widgets/category/category-widget-model.js");
  var HistogramWidgetModel = __webpack_require__(/*! ./widgets/histogram/histogram-widget-model */ "./lib/assets/javascripts/deep-insights/widgets/histogram/histogram-widget-model.js");
  var TimeSeriesWidgetModel = __webpack_require__(/*! ./widgets/time-series/time-series-widget-model */ "./lib/assets/javascripts/deep-insights/widgets/time-series/time-series-widget-model.js");
  
  var WIDGETSTYLEPARAMS = {
    auto_style_allowed: 'autoStyleEnabled'
  };
  
  // We create an object with options off the attributes
  var makeWidgetStyleOptions = function (attrs) {
    return _.reduce(WIDGETSTYLEPARAMS, function (memo, value, key) {
      if (attrs[key] !== undefined) {
        memo[value] = attrs[key];
        return memo;
      }
    }, {});
  };
  
  var _checkProperties = function (obj, propertiesArray) {
    _.each(propertiesArray, function (prop) {
      if (obj[prop] === undefined) {
        throw new Error(prop + ' is required');
      }
    });
  };
  
  var extendAttrs = function (attrs, state, hasInitialState) {
    return _.extend(attrs, state, { hasInitialState: hasInitialState }); // Will overwrite preset attributes with the ones passed on the state
  };
  
  var checkAnalysisModel = function (attrs) {
    if (!(attrs.source instanceof Object) || !attrs.source.cid) {
      throw new Error('Source must be defined and be an instance of AnalysisModel.');
    }
  };
  
  /**
   * Public API to interact with dashboard widgets.
   */
  var WidgetsService = function (widgetsCollection, dataviews) {
    this._widgetsCollection = widgetsCollection;
    this._dataviews = dataviews;
  };
  
  WidgetsService.prototype.getCollection = function () {
    return this._widgetsCollection;
  };
  
  WidgetsService.prototype.get = function (id) {
    return this._widgetsCollection.get(id);
  };
  
  WidgetsService.prototype.getList = function () {
    return this._widgetsCollection.models;
  };
  
  /**
   * @param {Object} attrs
   * @param {String} attrs.title Title rendered on the widget view
   * @param {String} attrs.column Name of column to use to aggregate
   * @param {String} attrs.aggregation Name of aggregation operation to apply to get categories
   *   can be any of ['sum', 'count']. Default is 'count'
   * @param {String} attrs.aggregation_column column to be used for the aggregation operation
   *  it only applies for sum operations.
   * @param {Object} attrs.source Object with the id of the source analysis node that the widget points to
   * @param {Object} layer Instance of a layer model (cartodb.js)
   * @return {CategoryWidgetModel}
   */
  WidgetsService.prototype.createCategoryModel = function (attrs, layer, state) {
    _checkProperties(attrs, ['title']);
    var extendedAttrs = extendAttrs(attrs, state, this._widgetsCollection.hasInitialState());
    checkAnalysisModel(extendedAttrs);
  
    var dataviewModel = this._dataviews.createCategoryModel(extendedAttrs);
  
    var ATTRS_NAMES = ['id', 'title', 'order', 'collapsed', 'prefix', 'suffix', 'show_stats', 'show_source', 'style', 'hasInitialState'];
    var widgetAttrs = _.pick(extendedAttrs, ATTRS_NAMES);
    var options = makeWidgetStyleOptions(extendedAttrs);
  
    widgetAttrs.attrsNames = ATTRS_NAMES;
  
    var widgetModel = new CategoryWidgetModel(widgetAttrs, {
      dataviewModel: dataviewModel,
      layerModel: layer
    }, options);
    widgetModel.setInitialState(state);
    this._widgetsCollection.add(widgetModel);
  
    return widgetModel;
  };
  
  /**
   * @param {Object} attrs
   * @param {String} attrs.title Title rendered on the widget view
   * @param {String} attrs.column Name of column
   * @param {Number} attrs.bins Count of bins
   * @param {Object} layer Instance of a layer model (cartodb.js)
   * @return {WidgetModel}
   */
  WidgetsService.prototype.createHistogramModel = function (attrs, layer, state, opts) {
    _checkProperties(attrs, ['title']);
    var extendedAttrs = extendAttrs(attrs, state, this._widgetsCollection.hasInitialState());
    checkAnalysisModel(extendedAttrs);
    var dataviewModel = this._dataviews.createHistogramModel(extendedAttrs);
  
    // Default bins attribute was removed from dataViewModel because of time-series aggregation.
    // Just in case it's needed for histogram models we added it here.
    if (!dataviewModel.has('bins')) {
      dataviewModel.set('bins', 10, { silent: true });
    }
  
    var attrsNames = ['id', 'title', 'order', 'collapsed', 'bins', 'show_stats', 'show_source', 'normalized', 'style', 'hasInitialState', 'table_name'];
    var widgetAttrs = _.pick(extendedAttrs, attrsNames);
    var options = makeWidgetStyleOptions(extendedAttrs);
  
    widgetAttrs.type = 'histogram';
    widgetAttrs.attrsNames = attrsNames;
  
    var widgetModel = new HistogramWidgetModel(widgetAttrs, {
      dataviewModel: dataviewModel,
      layerModel: layer
    }, options);
    widgetModel.setInitialState(state);
    this._widgetsCollection.add(widgetModel);
  
    return widgetModel;
  };
  
  /**
   * @param {Object} attrs
   * @param {String} attrs.title Title rendered on the widget view
   * @param {String} attrs.column Name of column
   * @param {String} attrs.operation Name of operation to use, can be any of ['min', 'max', 'avg', 'sum']
   * @param {Object} layer Instance of a layer model (cartodb.js)
   * @return {CategoryWidgetModel}
   */
  WidgetsService.prototype.createFormulaModel = function (attrs, layer, state) {
    _checkProperties(attrs, ['title']);
    var extendedAttrs = extendAttrs(attrs, state, this._widgetsCollection.hasInitialState());
    checkAnalysisModel(extendedAttrs);
    var dataviewModel = this._dataviews.createFormulaModel(extendedAttrs);
  
    var ATTRS_NAMES = ['id', 'title', 'order', 'collapsed', 'prefix', 'suffix', 'show_stats', 'show_source', 'description', 'hasInitialState'];
    var widgetAttrs = _.pick(extendedAttrs, ATTRS_NAMES);
    widgetAttrs.type = 'formula';
    widgetAttrs.attrsNames = ATTRS_NAMES;
  
    var widgetModel = new WidgetModel(widgetAttrs, {
      dataviewModel: dataviewModel,
      layerModel: layer
    });
    widgetModel.setInitialState(state);
    this._widgetsCollection.add(widgetModel);
  
    return widgetModel;
  };
  
  /**
   * @param {Object} attrs
   * @param {String} attrs.column Name of column that contains
   * @param {Object} layer Instance of a layer model (cartodb.js)
   * @param {Number} bins
   * @return {WidgetModel}
   */
  WidgetsService.prototype.createTimeSeriesModel = function (attrs, layer, state, opts) {
    // TODO will other kind really work for a time-series?
    attrs.column_type = attrs.column_type || 'date';
    checkAnalysisModel(attrs);
    var dataviewModel = this._dataviews.createHistogramModel(attrs);
  
    var ATTRS_NAMES = ['id', 'style', 'title', 'normalized', 'animated', 'timezone'];
    var widgetAttrs = _.pick(attrs, ATTRS_NAMES);
    widgetAttrs.type = 'time-series';
    widgetAttrs.attrsNames = ATTRS_NAMES;
  
    var widgetModel = new TimeSeriesWidgetModel(widgetAttrs, {
      dataviewModel: dataviewModel,
      layerModel: layer
    }, opts);
    widgetModel.setInitialState(state);
    this._widgetsCollection.add(widgetModel);
  
    return widgetModel;
  };
  
  WidgetsService.prototype.setWidgetsState = function (state) {
    this._widgetsCollection.setStates(state);
  };
  
  module.exports = WidgetsService;
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/animate-values.js":
  /*!************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/animate-values.js ***!
    \************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  /**
   * Animate between two values
   */
  module.exports = CoreView.extend({
    animateFromValues: function (from, to, className, template, opts) {
      var $el = this.$(className);
      var options = opts || {};
      var formatter = options.formatter || d3.format('0,000');
      var templateData = options.templateData || {};
      var debounceWait = options.debounceWait || 500;
  
      var hasDecimals = (to % 1 === 0);
  
      var stepValue = function (i) {
        i = hasDecimals ? Math.round(i) : i;
        var value = (_.isNaN(i) || i === undefined) ? (options.defaultValue || 0) : formatter(i);
        var data = _.extend({ value: value }, templateData);
        $el.text(template(data));
      };
  
      if (options.animationSpeed === 0) {
        stepValue(to);
        return;
      }
  
      stepValue(from);
  
      var animate = _.debounce(function () {
        $el.prop('counter', from).stop().animate({ counter: to }, {
          duration: options.animationSpeed || 500,
          easing: options.easingMethod || 'swing',
          step: stepValue
        });
      }, debounceWait);
  
      animate();
    },
  
    animateFromCurrentValue: function (value, className, template, opts) {
      var $el = this.$(className);
  
      var options = opts || {};
      var debounceWait = options.debounceWait || 500;
  
      var to = value;
      var from = +this.$(className).text();
  
      var formatter = options.formatter || d3.format('0,000');
      var templateData = options.templateData || {};
  
      var hasDecimals = (to % 1 === 0);
  
      var stepValue = function (i) {
        i = hasDecimals ? Math.round(i) : i;
        value = (_.isNaN(i) || i === undefined) ? (options.defaultValue || 0) : formatter(i);
        var data = _.extend({ value: value }, templateData);
        $el.text(template(data));
      };
  
      if (options.animationSpeed === 0) {
        stepValue(to);
        return;
      }
  
      stepValue(from);
  
      var animate = _.debounce(function () {
        $el.prop('counter', from).stop().animate({ counter: to }, {
          duration: options.animationSpeed || 500,
          easing: options.easingMethod || 'swing',
          step: stepValue
        });
      }, debounceWait);
  
      animate();
    },
  
    animateValue: function (model, what, className, template, opts) {
      var $el = this.$(className);
  
      var options = opts || {};
      var debounceWait = options.debounceWait || 500;
  
      var to = model.get(what);
      var from = model.previous(what) || 0;
  
      var formatter = options.formatter || d3.format('0,000');
      var templateData = options.templateData || {};
  
      var hasDecimals = (to % 1 === 0);
  
      var stepValue = function (i) {
        i = hasDecimals ? Math.round(i) : i;
        var value = (_.isNaN(i) || i === undefined) ? (options.defaultValue || 0) : formatter(i);
        var data = _.extend({ value: value }, templateData);
        $el.text(template(data));
      };
  
      if (options.animationSpeed === 0) {
        stepValue(to);
        return;
      }
  
      stepValue(from);
  
      var animate = _.debounce(function () {
        $el.prop('counter', from).stop().animate({ counter: to }, {
          duration: options.animationSpeed || 500,
          easing: options.easingMethod || 'swing',
          step: stepValue
        });
      }, debounceWait);
  
      animate();
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/auto-style/auto-styler.js":
  /*!********************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/auto-style/auto-styler.js ***!
    \********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var StyleUtils = __webpack_require__(/*! ./style-utils */ "./lib/assets/javascripts/deep-insights/widgets/auto-style/style-utils.js");
  var CategoryColors = __webpack_require__(/*! ./category-colors */ "./lib/assets/javascripts/deep-insights/widgets/auto-style/category-colors.js");
  var getValue = __webpack_require__(/*! ../../util/get-object-value */ "./lib/assets/javascripts/deep-insights/util/get-object-value.js");
  
  var AutoStyler = cdb.core.Model.extend({
    initialize: function (dataviewModel, layerModel, options) {
      this.options = options || {};
      this.styles = options && options.auto_style;
      this.dataviewModel = dataviewModel;
      this.colors = new CategoryColors(this.styles);
      this.layer = layerModel;
    },
  
    getStyle: function () {
      var style = this.layer.get('initialStyle');
      if (!style) return;
  
      AutoStyler.FILL_SELECTORS.forEach(function (item) {
        style = StyleUtils.changeStyle(style, item, this._getFillColor(item));
      }.bind(this));
  
      AutoStyler.OPACITY_SELECTORS.forEach(function (item) {
        style = StyleUtils.changeStyle(style, item, this._getOpacity());
      }.bind(this));
  
      return StyleUtils.replaceWrongSpaceChar(style);
    },
  
    _getColor: function () {
      return getValue(this.styles, 'definition.color');
    },
  
    _getOpacity: function () {
      return getValue(this.styles, 'definition.color.opacity');
    }
  });
  
  AutoStyler.FILL_SELECTORS = ['marker-fill', 'polygon-fill', 'line-color'];
  AutoStyler.OPACITY_SELECTORS = ['marker-fill-opacity', 'polygon-opacity', 'line-opacity'];
  
  module.exports = AutoStyler;
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/auto-style/category-colors.js":
  /*!************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/auto-style/category-colors.js ***!
    \************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var colorScales = [
    '#7F3C8D',
    '#11A579',
    '#3969AC',
    '#F2B701',
    '#E73F74'
  ]; // Demo colors
  
  function getColorRange (styles) {
    var colorRange = styles && styles.definition &&
        styles.definition.color &&
        styles.definition.color.range;
  
    return colorRange || colorScales;
  }
  
  /**
   *  Class to set categories to each color
   *  - Right now, there is a relation 1 color to 1 category.
   *  - If that category is not available in the new data, that
   *    color will be freed.
   *
   */
  
  function CategoryColors (styles) {
    this.updateColors(styles);
  }
  
  CategoryColors.prototype.updateColors = function (styles) {
    var colorRange = getColorRange(styles);
    this.colors = {};
    _.each(colorRange, function (c) {
      this.colors[c] = null;
    }, this);
  };
  
  CategoryColors.prototype.updateData = function (d) {
    // Remove categories from colors where they are not present anymore
    _.each(this.colors, function (value, key) {
      if (!_.contains(d, value)) {
        this.colors[key] = null;
      } else {
        d = _.without(d, value);
      }
    }, this);
  
    // Set colors by new categories
    _.each(d, function (category) {
      var nextFreeColor = this.getNextAvailableColor();
      if (nextFreeColor) {
        this.colors[nextFreeColor] = category;
      }
    }, this);
  };
  
  CategoryColors.prototype.getNextAvailableColor = function () {
    for (var i in this.colors) {
      if (this.colors[i] === null) {
        return i;
      }
    }
    return null;
  };
  
  CategoryColors.prototype.getColorByCategory = function (category) {
    for (var i in this.colors) {
      if (this.colors[i] === category) {
        return i;
      }
    }
    return '#A5AA99';
  };
  
  CategoryColors.prototype.getCategoryByColor = function (color) {
    return this.colors[color];
  };
  
  module.exports = CategoryColors;
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/auto-style/category.js":
  /*!*****************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/auto-style/category.js ***!
    \*****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var AutoStyler = __webpack_require__(/*! ./auto-styler */ "./lib/assets/javascripts/deep-insights/widgets/auto-style/auto-styler.js");
  
  module.exports = AutoStyler.extend({
    updateStyle: function (style) {
      this.styles = style.auto_style;
      this.colors.updateColors(style.auto_style);
      this.colors.updateData(_.pluck(this.dataviewModel.get('data'), 'name'));
    },
  
    _getRange: function () {
      return _.map(this.dataviewModel.get('data'), function (category) {
        return this.colors.getColorByCategory(category.name);
      }, this);
    },
  
    getDef: function () {
      var model = this.dataviewModel;
      var categories = model.get('data');
      var range = this._getRange();
      var definitions = {};
  
      AutoStyler.FILL_SELECTORS.forEach(function (item) {
        var definition = {};
        var geom = item.substring(0, item.indexOf('-'));
        definition = { color:
          { domain: _.pluck(categories, 'name'), range: range, attribute: model.get('column') }
        };
        definitions[geom === 'marker' ? 'point' : geom] = definition;
      });
  
      return definitions;
    },
  
    _getFillColor: function () {
      var model = this.dataviewModel;
      var categories = model.get('data');
      var column = model.get('column');
  
      return this._getCategoryRamp(categories, column);
    },
  
    _getCategoryRamp: function (categories, column) {
      var ramp = 'ramp([' + column + '], ';
  
      var catListColors = '';
      var catListValues = '';
  
      for (var i = 0; i < categories.length; i++) {
        var cat = categories[i];
        var next = i !== categories.length - 1 ? ', ' : '';
  
        catListColors += '"' + this.colors.getColorByCategory(cat.name) + '"' + next;
        if (!cat.agg) {
          if (typeof cat.name !== 'string') {
            catListValues += cat.name + next;
          } else {
            catListValues += '"' + String(cat.name).replace(/"/g, '\\"') + '"' + next;
          }
        } else if (i === categories.length - 1) {
          catListValues = catListValues.substring(0, catListValues.length - 2);
        }
      }
  
      return ramp + '(' + catListColors + '), (' + catListValues + '), \'=\')';
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/auto-style/factory.js":
  /*!****************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/auto-style/factory.js ***!
    \****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var Stylers = {
    category: __webpack_require__(/*! ./category */ "./lib/assets/javascripts/deep-insights/widgets/auto-style/category.js"),
    histogram: __webpack_require__(/*! ./histogram */ "./lib/assets/javascripts/deep-insights/widgets/auto-style/histogram.js")
  };
  
  module.exports = {
    get: function (dataviewModel, layerModel, style) {
      var AutoStyler = Stylers[dataviewModel.get('type')];
      if (AutoStyler) {
        return new AutoStyler(dataviewModel, layerModel, style);
      } else {
        throw new Error('dataview type not supported');
      }
    }
  };
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/auto-style/histogram.js":
  /*!******************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/auto-style/histogram.js ***!
    \******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var cartocolor = __webpack_require__(/*! cartocolor */ "./node_modules/cartocolor/index.js");
  var AutoStyler = __webpack_require__(/*! ./auto-styler */ "./lib/assets/javascripts/deep-insights/widgets/auto-style/auto-styler.js");
  var StyleUtils = __webpack_require__(/*! ./style-utils */ "./lib/assets/javascripts/deep-insights/widgets/auto-style/style-utils.js");
  
  var HistogramAutoStyler = AutoStyler.extend({
    updateStyle: function (style) {
      this.styles = style.auto_style;
    },
  
    _getFillColor: function (sym) {
      var custom = this._getColor();
      var scales = custom || {};
  
      if (!custom) {
        var shape = this.dataviewModel.getDistributionType(
          this.dataviewModel.getUnfilteredDataModel().get('data')
        );
  
        scales = HistogramAutoStyler.SCALES_MAP[sym][shape];
      }
  
      var ramp = 'ramp([' + this.dataviewModel.get('column') + '], ';
      var colors = custom
        ? "('" + scales.range.join("', '") + "'), "
        : 'cartocolor(' + scales.palette + ', ' + this.dataviewModel.get('bins') + '), ';
      var cuantification = scales.quantification + ')';
  
      return ramp + colors + cuantification;
    },
  
    getDef: function (cartocss) {
      var definitions = {};
      var shape = this.dataviewModel.getDistributionType(
        this.dataviewModel.getUnfilteredDataModel().get('data')
      );
      var bins = this.dataviewModel.get('bins');
      var attr = this.dataviewModel.get('column');
      var styles = this.styles;
      var isCustomDefinition = (this.styles && this.styles.custom) || false;
  
      AutoStyler.FILL_SELECTORS.forEach(function (item) {
        if (StyleUtils.isPropertyIncluded(cartocss, item)) {
          var scales = HistogramAutoStyler.SCALES_MAP[item][shape];
          var geom = item.substring(0, item.indexOf('-'));
          var definition = {};
  
          if (scales) {
            if (isCustomDefinition === true) {
              definition = _.extend(definition, styles.definition);
            } else {
              definition = {
                color: {
                  range: cartocolor[scales.palette][bins] || cartocolor[scales.palette][Object.keys(cartocolor[scales.palette]).length],
                  quantification: scales.quantification,
                  attribute: attr
                }
              };
            }
          }
  
          definitions[geom === 'marker' ? 'point' : geom] = definition;
        }
      });
  
      return definitions;
    }
  
  });
  
  HistogramAutoStyler.SCALES_MAP = {
    'polygon-fill': {
      'F': {
        palette: 'PinkYl',
        quantification: 'equal'
      },
      'L': {
        palette: 'Emrld',
        quantification: 'headtails'
      },
      'J': {
        palette: 'Emrld',
        quantification: 'headtails'
      },
      'A': {
        palette: 'Geyser',
        quantification: 'quantiles'
      },
      'C': {
        palette: 'Sunset',
        quantification: 'jenks'
      },
      'U': {
        palette: 'Sunset',
        quantification: 'jenks'
      }
    },
    'line-color': {
      'F': {
        palette: 'PinkYl',
        quantification: 'equal'
      },
      'L': {
        palette: 'Emrld',
        quantification: 'headtails'
      },
      'J': {
        palette: 'Emrld',
        quantification: 'headtails'
      },
      'A': {
        palette: 'Geyser',
        quantification: 'quantiles'
      },
      'C': {
        palette: 'Sunset',
        quantification: 'jenks'
      },
      'U': {
        palette: 'Sunset',
        quantification: 'jenks'
      }
    },
    'marker-fill': {
      'F': {
        palette: 'RedOr',
        quantification: 'equal'
      },
      'L': {
        palette: 'BluYl',
        quantification: 'headtails'
      },
      'J': {
        palette: 'BluYl',
        quantification: 'headtails'
      },
      'A': {
        palette: 'Geyser',
        quantification: 'quantiles'
      },
      'C': {
        palette: 'SunsetDark',
        quantification: 'jenks'
      },
      'U': {
        palette: 'SunsetDark',
        quantification: 'jenks'
      }
    }
  };
  
  module.exports = HistogramAutoStyler;
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/auto-style/style-utils.js":
  /*!********************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/auto-style/style-utils.js ***!
    \********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var postcss = __webpack_require__(/*! postcss */ "./node_modules/postcss/lib/postcss.js");
  var stripInlineComments = __webpack_require__(/*! postcss-strip-inline-comments */ "./node_modules/postcss-strip-inline-comments/lib/strip-inline-comments.js");
  var SCSSsyntax = __webpack_require__(/*! postcss-scss */ "./node_modules/postcss-scss/lib/scss-syntax.js");
  
  var OUTLINE_ATTRS = ['line-color', 'line-opacity'];
  
  function generateCSSTreeFromCartoCSS (cartocss) {
    return postcss()
      .use(stripInlineComments)
      .process(cartocss, { syntax: SCSSsyntax });
  }
  
  function isPropertyIncluded (cartocss, attr) {
    var cssTree = generateCSSTreeFromCartoCSS(cartocss);
    var root = cssTree.result.root;
    var propertyIncluded = false;
  
    if (root) {
      root.walkDecls(attr, function (node) {
        var parentNode = node.parent;
  
        if (!isSelectorRule(parentNode) || isMapnikGeometrySelectorRule(parentNode)) {
          propertyIncluded = true;
        }
      });
    }
  
    return propertyIncluded;
  }
  
  function isSelectorRule (node) {
    return node.type === 'rule' && node.selector.search(/\[(.)+\]/g) !== -1;
  }
  
  function isMapnikGeometrySelectorRule (node) {
    return isSelectorRule(node) && node.selector.search('mapnik::geometry_type') !== -1;
  }
  
  function isOutlineRule (node) {
    return node.type === 'rule' && node.selector.search('::outline') !== -1;
  }
  
  function replaceWrongSpaceChar (cartocss) {
    return cartocss.replace(new RegExp(String.fromCharCode(160), 'g'), ' ');
  }
  
  /**
   * Change attr style and remove all the duplicates
   * @param  {String} cartocss cartocss original String
   * @param  {String} attr     CSS Attribute ex, polygon-fill
   * @param  {String} newStyle New style value ex, red;
   * @return {String}          Cartocss modified String
   */
  function changeStyle (cartocss, attr, newStyle) {
    if (_.isUndefined(newStyle)) return cartocss;
  
    var cssTree = generateCSSTreeFromCartoCSS(cartocss);
    var root = cssTree.result.root;
    var attributeAlreadyChanged = false;
  
    if (root) {
      root.walkDecls(attr, function (node) {
        var parentNode = node.parent;
  
        if (!(isOutlineRule(parentNode) && _.contains(OUTLINE_ATTRS, attr))) {
          if (isSelectorRule(parentNode) || attributeAlreadyChanged) {
            // If the attribute is inside a conditional selection, it has to be removed
            node.remove();
          } else {
            // If the attribute is inside a regular root (or symbolizer), it just
            // changes the value
            node.value = newStyle;
            attributeAlreadyChanged = true;
          }
        }
      });
  
      return cssTree.css;
    }
  
    return cartocss;
  }
  
  module.exports = {
    changeStyle: _.memoize(changeStyle, function (css, attr, style) {
      return css + attr + style;
    }),
    isPropertyIncluded: isPropertyIncluded,
    replaceWrongSpaceChar: replaceWrongSpaceChar
  };
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/category/category-widget-model.js":
  /*!****************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/category/category-widget-model.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var WidgetModel = __webpack_require__(/*! ../widget-model */ "./lib/assets/javascripts/deep-insights/widgets/widget-model.js");
  var LockedCategoriesCollection = __webpack_require__(/*! ./locked-categories-collection */ "./lib/assets/javascripts/deep-insights/widgets/category/locked-categories-collection.js");
  
  /**
   * Model for a category widget
   */
  module.exports = WidgetModel.extend({
  
    defaults: _.extend({
      type: 'category',
      search: false,
      locked: false
    },
    WidgetModel.prototype.defaults
    ),
  
    defaultState: _.extend({
      acceptedCategories: [],
      locked: false,
      autoStyle: false
    },
    WidgetModel.prototype.defaultState
    ),
  
    initialize: function () {
      WidgetModel.prototype.initialize.apply(this, arguments);
      this.lockedCategories = new LockedCategoriesCollection();
  
      this.listenTo(this.dataviewModel, 'change:allCategoryNames', this._onDataviewAllCategoryNamesChange);
  
      this.on('change:locked', this._onLockedChange, this);
      this.on('change:collapsed', this._onCollapsedChange, this);
  
      if (this.isAutoStyleEnabled()) {
        this.on('change:style', this._updateAutoStyle, this);
      }
  
      this.dataviewModel.filter.on('change', function () {
        this.set('acceptedCategories', this._acceptedCategories().pluck('name'));
      }, this);
      this.dataviewModel.once('change:allCategoryNames', function () {
        if (this.get('autoStyle')) {
          this.autoStyle();
        }
      }, this);
    },
  
    setupSearch: function () {
      this.dataviewModel.setupSearch();
      this.lockedCategories.addItems(this._acceptedCategories().toJSON());
      this.toggleSearch();
    },
  
    toggleSearch: function () {
      this.set('search', !this.get('search'));
    },
  
    enableSearch: function () {
      this.set('search', true);
    },
  
    disableSearch: function () {
      this.set('search', false);
    },
  
    isSearchEnabled: function () {
      return this.get('search');
    },
  
    cleanSearch: function () {
      this.dataviewModel.cleanSearch();
      this.lockedCategories.reset([]);
    },
  
    autoStyle: function () {
      // NOTE: maybe not pre-assing colors to categories?
      this.autoStyler.colors.updateData(this.dataviewModel.get('allCategoryNames'));
      WidgetModel.prototype.autoStyle.call(this);
    },
  
    isLocked: function () {
      return this.get('locked');
    },
  
    canBeLocked: function () {
      return this.isLocked() || this._acceptedCategories().size() > 0;
    },
  
    canApplyLocked: function () {
      if (this._acceptedCategories().size() !== this.lockedCategories.size()) {
        return true;
      }
  
      return this._acceptedCategories().any(function (m) {
        return !this.lockedCategories.isItemLocked(m.get('name'));
      }, this);
    },
  
    applyLocked: function () {
      var currentLocked = this.lockedCategories.getItemsName();
      if (!currentLocked.length) {
        this.unlockCategories();
        return false;
      }
  
      this.set('locked', true);
  
      var f = this.dataviewModel.filter;
      f.cleanFilter(false);
      f.accept(currentLocked);
      f.applyFilter();
  
      this.cleanSearch();
    },
  
    lockCategories: function () {
      this.set('locked', true);
      this.dataviewModel.fetch();
    },
  
    unlockCategories: function () {
      this.set('locked', false);
      this.dataviewModel.filter.acceptAll();
    },
  
    _onDataviewAllCategoryNamesChange: function (m, names) {
      if (this.isAutoStyleEnabled()) {
        if (!this.isAutoStyle()) {
          this.autoStyler.colors.updateData(names);
        }
      }
    },
  
    _onLockedChange: function (m, isLocked) {
      if (isLocked) {
        this.dataviewModel.enableFilter();
      } else {
        this.dataviewModel.disableFilter();
      }
    },
  
    _acceptedCategories: function () {
      return this.dataviewModel.filter.acceptedCategories;
    },
  
    _onCollapsedChange: function (m, isCollapsed) {
      this.dataviewModel.set('enabled', !isCollapsed);
    }
  
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/category/content-view.js":
  /*!*******************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/category/content-view.js ***!
    \*******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var SearchTitleView = __webpack_require__(/*! ./title/search-title-view */ "./lib/assets/javascripts/deep-insights/widgets/category/title/search-title-view.js");
  var CategoryOptionsView = __webpack_require__(/*! ./options/options-view */ "./lib/assets/javascripts/deep-insights/widgets/category/options/options-view.js");
  var CategoryItemsView = __webpack_require__(/*! ./list/items-view */ "./lib/assets/javascripts/deep-insights/widgets/category/list/items-view.js");
  var CategoryStatsView = __webpack_require__(/*! ./stats/stats-view */ "./lib/assets/javascripts/deep-insights/widgets/category/stats/stats-view.js");
  var CategoryPaginatorView = __webpack_require__(/*! ./paginator/paginator-view */ "./lib/assets/javascripts/deep-insights/widgets/category/paginator/paginator-view.js");
  var SearchCategoryItemsView = __webpack_require__(/*! ./list/search-items-view */ "./lib/assets/javascripts/deep-insights/widgets/category/list/search-items-view.js");
  var SearchCategoryPaginatorView = __webpack_require__(/*! ./paginator/search-paginator-view */ "./lib/assets/javascripts/deep-insights/widgets/category/paginator/search-paginator-view.js");
  var template = __webpack_require__(/*! ./content-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/category/content-template.tpl");
  
  var STARTING_PAGE = 1;
  
  /**
   * Content view for category widget
   */
  module.exports = CoreView.extend({
    className: 'CDB-Widget-body',
  
    _ITEMS_PER_PAGE: 6,
  
    initialize: function () {
      this._dataviewModel = this.model.dataviewModel;
      this._layerModel = this.model.layerModel;
  
      this._paginatorModel = new Backbone.Model({
        page: STARTING_PAGE
      });
  
      this._initBinds();
    },
  
    render: function () {
      this.clearSubViews();
  
      this.$el.toggleClass('is-collapsed', !!this.model.get('collapsed'));
  
      this.$el.html(template());
  
      this._initViews();
  
      return this;
    },
  
    _initBinds: function () {
      if (this.model.get('hasInitialState') === true) {
        this._onInitialState();
      } else {
        this.model.bind('change:hasInitialState', this._onInitialState, this);
      }
      this.model.bind('change:collapsed', function (mdl, isCollapsed) {
        this.$el.toggleClass('is-collapsed', !!isCollapsed);
      }, this);
    },
  
    _onInitialState: function () {
      this.render();
  
      if (this.model.get('autoStyle') === true) {
        this.model.autoStyle();
      }
    },
  
    _initViews: function () {
      var searchTitle = new SearchTitleView({
        widgetModel: this.model,
        dataviewModel: this._dataviewModel,
        layerModel: this._layerModel
      });
      this.$('.js-header').append(searchTitle.render().el);
      this.addView(searchTitle);
  
      var stats = new CategoryStatsView({
        widgetModel: this.model,
        dataviewModel: this._dataviewModel
      });
      this.$('.js-header').append(stats.render().el);
      this.addView(stats);
  
      var options = new CategoryOptionsView({
        widgetModel: this.model,
        dataviewModel: this._dataviewModel
      });
      this.$('.js-content').html(options.render().el);
      this.addView(options);
  
      var dataList = new CategoryItemsView({
        widgetModel: this.model,
        dataviewModel: this._dataviewModel,
        itemsPerPage: this._ITEMS_PER_PAGE,
        paginatorModel: this._paginatorModel
      });
      this.$('.js-content').append(dataList.render().el);
      this.addView(dataList);
  
      var pagination = new CategoryPaginatorView({
        widgetModel: this.model,
        dataviewModel: this._dataviewModel,
        itemsPerPage: this._ITEMS_PER_PAGE,
        paginatorModel: this._paginatorModel
      });
      this.$('.js-footer').append(pagination.render().el);
      this.addView(pagination);
  
      var searchList = new SearchCategoryItemsView({
        widgetModel: this.model,
        dataviewModel: this._dataviewModel,
        itemsPerPage: this._ITEMS_PER_PAGE,
        paginator: true,
        paginatorModel: this._paginatorModel
      });
      this.$('.js-content').append(searchList.render().el);
      this.addView(searchList);
  
      var searchPagination = new SearchCategoryPaginatorView({
        widgetModel: this.model,
        dataviewModel: this._dataviewModel,
        itemsPerPage: this._ITEMS_PER_PAGE,
        paginator: true,
        paginatorModel: this._paginatorModel
      });
      this.$('.js-footer').append(searchPagination.render().el);
      this.addView(searchPagination);
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/category/list/item/item-view.js":
  /*!**************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/category/list/item/item-view.js ***!
    \**************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var formatter = __webpack_require__(/*! ../../../../formatter */ "./lib/assets/javascripts/deep-insights/formatter.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var clickableTemplate = __webpack_require__(/*! ./item-clickable-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/category/list/item/item-clickable-template.tpl");
  var unclickableTemplate = __webpack_require__(/*! ./item-unclickable-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/category/list/item/item-unclickable-template.tpl");
  
  /**
   * Category list item view
   */
  module.exports = CoreView.extend({
    tagName: 'li',
    className: 'CDB-Widget-listItem',
  
    events: {
      'click .js-button': '_onItemClick'
    },
  
    initialize: function (options) {
      this.widgetModel = this.options.widgetModel;
      this.dataviewModel = this.options.dataviewModel;
      this._initBinds();
    },
  
    render: function () {
      var name = this.model.get('name');
      var value = this.model.get('value');
      var template = this.model.get('agg') || this.widgetModel.isLocked()
        ? unclickableTemplate
        : clickableTemplate;
      var acceptedCategories = this.dataviewModel.filter.getAcceptedCategoryNames();
      var isAccepted = _.contains(acceptedCategories, name);
  
      this.$el.html(
        template({
          isAggregated: this.model.get('agg'),
          name: name,
          value: value,
          formattedValue: formatter.formatNumber(value),
          percentage: ((value / this.dataviewModel.get('max')) * 100),
          color: this.widgetModel.getColor(name),
          isDisabled: !this.model.get('selected') ? 'is-disabled' : '',
          isAccepted: isAccepted,
          prefix: this.widgetModel.get('prefix'),
          suffix: this.widgetModel.get('suffix')
        })
      );
  
      return this;
    },
  
    _initBinds: function () {
      this.model.bind('change', this.render, this);
      this.widgetModel.bind('change:search change:prefix change:suffix change:autoStyle', this.render, this);
      this.add_related_model(this.widgetModel);
    },
  
    _onItemClick: function () {
      this.trigger('itemClicked', this.model, this);
    }
  
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/category/list/item/search-item-view.js":
  /*!*********************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/category/list/item/search-item-view.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var formatter = __webpack_require__(/*! ../../../../formatter */ "./lib/assets/javascripts/deep-insights/formatter.js");
  var template = __webpack_require__(/*! ./search-item-clickable-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/category/list/item/search-item-clickable-template.tpl");
  
  /**
   * Category search list view
   */
  module.exports = CoreView.extend({
    tagName: 'li',
    className: 'CDB-Widget-listItem',
  
    events: {
      'click .js-button': '_onItemClick'
    },
  
    initialize: function (options) {
      // This data model comes from the original data in order to get
      // the max value and set properly the progress bar and add the
      // necessary suffix and prefix for the item.
      this.dataviewModel = this.options.dataviewModel;
      this.widgetModel = this.options.widgetModel;
      this._initBinds();
    },
  
    render: function () {
      var value = this.model.get('value');
  
      this.$el.html(
        template({
          name: this.model.get('name'),
          value: value,
          formattedValue: formatter.formatNumber(value),
          percentage: ((value / this.dataviewModel.get('max')) * 100),
          isDisabled: !this.model.get('selected'),
          prefix: this.widgetModel.get('prefix'),
          suffix: this.widgetModel.get('suffix')
        })
      );
  
      return this;
    },
  
    _initBinds: function () {
      this.model.bind('change:selected', this.render, this);
  
      this.widgetModel.bind('change:prefix change:suffix', this.render, this);
      this.add_related_model(this.widgetModel);
    },
  
    _onItemClick: function () {
      this.model.set('selected', !this.model.get('selected'));
    }
  
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/category/list/items-view.js":
  /*!**********************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/category/list/items-view.js ***!
    \**********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var CategoryItemView = __webpack_require__(/*! ./item/item-view */ "./lib/assets/javascripts/deep-insights/widgets/category/list/item/item-view.js");
  var placeholder = __webpack_require__(/*! ./items-placeholder-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/category/list/items-placeholder-template.tpl");
  
  var REQUIRED_OPTS = [
    'dataviewModel',
    'widgetModel',
    'paginatorModel'
  ];
  
  /**
   * Category list view
   */
  module.exports = CoreView.extend({
    options: {
      paginator: false,
      itemsPerPage: 6
    },
  
    className: 'CDB-Widget-list js-list',
  
    tagName: 'ul',
  
    initialize: function (options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      if (!this._dataviewModel.get('sync_on_bbox_change')) {
        this.$el.addClass('CDB-Widget-list--nodynamic');
      }
  
      this._initBinds();
    },
  
    render: function () {
      this.clearSubViews();
      this.$el.empty();
      var data = this._dataviewModel.getData();
      var isDataEmpty = _.isEmpty(data) || _.size(data) === 0;
  
      if (isDataEmpty) {
        this._renderPlaceholder();
      } else {
        this._renderList();
      }
      return this;
    },
  
    _initBinds: function () {
      this.listenTo(this._paginatorModel, 'change:page', this.render);
  
      this.listenTo(this._widgetModel, 'change:search', this.toggle);
      this.listenTo(this._widgetModel, 'change:style change:autoStyle', this.render);
  
      this.listenTo(this._dataviewModel, 'change:data', this.render);
      this.listenTo(this._dataviewModel, 'change:sync_on_bbox_change', this.blockFiltering);
    },
  
    _renderPlaceholder: function () {
      // Change view classes
      this.$el.addClass('CDB-Widget-list--withBorders CDB-Widget-list--fake');
      this.$el.append(placeholder());
    },
  
    _renderList: function () {
      this._createList();
  
      this.$el.removeClass('CDB-Widget-list--withBorders CDB-Widget-list--fake CDB-Widget-list--noresults');
  
      this._renderItems();
    },
  
    _renderItems: function () {
      var currentPage = this._paginatorModel.get('page');
      var pageIndex = currentPage - 1; // Transform from 1-based index to zero-based index
      var items = this.pagesData[pageIndex];
  
      _.each(items, function (model) {
        this._addItem(model);
      }.bind(this));
    },
  
    _createList: function () {
      this.pagesData = {};
  
      var data = this._getData();
      var currentIndex = 0;
  
      data.each(function (model, index) {
        if (index % this.options.itemsPerPage === 0) {
          if (index !== 0) {
            currentIndex += 1;
          }
          this.pagesData[currentIndex] = [];
        }
  
        this.pagesData[currentIndex].push(model);
      }, this);
    },
  
    _getData: function () {
      return this._dataviewModel.getData();
    },
  
    _addItem: function (model) {
      var view = new CategoryItemView({
        model: model,
        widgetModel: this._widgetModel,
        dataviewModel: this._dataviewModel
      });
  
      view.bind('itemClicked', this._setFilters, this);
  
      this.addView(view);
      this.$el.append(view.render().el);
    },
  
    _setFilters: function (mdl) {
      var isSelected = mdl.get('selected');
      var filter = this._dataviewModel.filter;
      var clickedName = mdl.get('name');
  
      if (isSelected) {
        // If there isn't any filter applied,
        // clicking over one will turn rest into as "unselected"
        if (filter.rejectedCategories.size() === 0 &&
            filter.acceptedCategories.size() === 0
        ) {
          var data = this._dataviewModel.getData();
          // Make elements "unselected"
          data.each(function (m) {
            var name = m.get('name');
            if (name !== clickedName) {
              m.set('selected', false);
            }
          });
          filter.accept(mdl.get('name'));
        } else {
          mdl.set('selected', false);
          filter.reject(clickedName);
        }
      } else {
        mdl.set('selected', true);
        filter.accept(clickedName);
      }
      this._widgetModel.set('acceptedCategories', this._widgetModel._acceptedCategories().pluck('name'));
    },
  
    blockFiltering: function (e) {
      if (e.changed['sync_on_bbox_change']) { // Is dynamic
        this.$el.removeClass('CDB-Widget-list--nodynamic');
      } else { // It is not
        this.$el.addClass('CDB-Widget-list--nodynamic');
        this._dataviewModel.filter.acceptAll();
      }
    },
  
    removeSelections: function () {
      this._dataviewModel.filter.acceptAll();
    },
  
    toggle: function () {
      this[!this._widgetModel.isSearchEnabled() ? 'show' : 'hide']();
    },
  
    show: function () {
      this.$el.removeClass('is-hidden');
    },
  
    hide: function () {
      this.$el.addClass('is-hidden');
    }
  
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/category/list/search-items-view.js":
  /*!*****************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/category/list/search-items-view.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var CategoryItemsView = __webpack_require__(/*! ./items-view */ "./lib/assets/javascripts/deep-insights/widgets/category/list/items-view.js");
  var WidgetSearchCategoryItemView = __webpack_require__(/*! ./item/search-item-view */ "./lib/assets/javascripts/deep-insights/widgets/category/list/item/search-item-view.js");
  var placeholder = __webpack_require__(/*! ./search-items-no-results-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/category/list/search-items-no-results-template.tpl");
  
  /**
   * Category list view
   */
  module.exports = CategoryItemsView.extend({
    className: 'CDB-Widget-list is-hidden js-list',
  
    render: function () {
      this.clearSubViews();
      this.$el.empty();
      var data = this._searchResultsCollection;
      var isDataEmpty = data.isEmpty() || data.size() === 0;
  
      if (isDataEmpty) {
        this._renderPlaceholder();
      } else {
        this._renderList();
      }
      return this;
    },
  
    _initBinds: function () {
      CategoryItemsView.prototype._initBinds.apply(this, arguments);
      this._searchResultsCollection = this._dataviewModel.getSearchResult();
      this.listenTo(this._searchResultsCollection, 'change:selected', this._onSelectedItemChange);
      this.listenTo(this._searchResultsCollection, 'reset', this.render);
    },
  
    _getData: function () {
      return this._searchResultsCollection;
    },
  
    _renderPlaceholder: function () {
      this.$el.addClass('CDB-Widget-list--noresults');
  
      this.$el.html(
        placeholder({
          q: this._dataviewModel.getSearchQuery()
        })
      );
    },
  
    _addItem: function (model) {
      var view = new WidgetSearchCategoryItemView({
        model: model,
        widgetModel: this._widgetModel,
        dataviewModel: this._dataviewModel
      });
      this.addView(view);
      this.$el.append(view.render().el);
    },
  
    toggle: function () {
      this[this._widgetModel.isSearchEnabled() ? 'show' : 'hide']();
    },
  
    _onSelectedItemChange: function (model, isSelected) {
      this._widgetModel.lockedCategories[isSelected ? 'addItem' : 'removeItem'](model);
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/category/locked-categories-collection.js":
  /*!***********************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/category/locked-categories-collection.js ***!
    \***********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   *  Locked categories collection
   *
   */
  module.exports = Backbone.Collection.extend({
  
    addItem: function (mdl) {
      if (!this.isItemLocked(mdl.get('name'))) {
        this.add(mdl);
      }
    },
  
    addItems: function (mdls) {
      _.each(mdls, function (m) {
        if (!this.isItemLocked(m.name)) {
          this.add(m);
        }
      }, this);
    },
  
    resetItems: function (mdls) {
      this.reset(mdls);
    },
  
    removeItem: function (mdl) {
      var lockedItem = this.isItemLocked(mdl.get('name'));
      if (lockedItem) {
        this.remove(lockedItem);
      }
    },
  
    removeItems: function () {
      this.reset([]);
    },
  
    isItemLocked: function (name) {
      return this.find(function (d) {
        return d.get('name') === name;
      });
    },
  
    getItemsName: function () {
      return this.pluck('name');
    }
  
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/category/options/options-view.js":
  /*!***************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/category/options/options-view.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./options-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/category/options/options-template.tpl");
  
  /**
   * Category filter view
   *
   */
  module.exports = CoreView.extend({
    className: 'CDB-Widget-filter CDB-Widget-contentSpaced CDB-Widget-contentSpaced--sideMargins',
  
    events: {
      'click .js-all': '_onSelectAll',
      'click .js-lock': '_lockCategories',
      'click .js-unlock': '_unlockCategories'
    },
  
    initialize: function () {
      this.dataviewModel = this.options.dataviewModel;
      this.widgetModel = this.options.widgetModel;
      this._initBinds();
    },
  
    render: function () {
      var acceptedCats = this.dataviewModel.filter.acceptedCategories.size();
      var rejectedCats = this.dataviewModel.filter.rejectedCategories.size();
      var areAllRejected = this.dataviewModel.filter.areAllRejected();
      var totalCats = this.dataviewModel.getData().size();
      var isLocked = this.widgetModel.isLocked();
  
      this.$el.html(
        template({
          isSearchEnabled: this.widgetModel.isSearchEnabled(),
          isSearchApplied: this.dataviewModel.isSearchApplied(),
          isLocked: isLocked,
          canBeLocked: this.widgetModel.canBeLocked(),
          allSelected: (rejectedCats === 0 && acceptedCats === 0 && !areAllRejected),
          canSelectAll: !isLocked && (rejectedCats > 0 || acceptedCats > 0 || areAllRejected),
          noneSelected: areAllRejected || (!totalCats && !acceptedCats),
          acceptedCats: acceptedCats,
          totalLocked: this.widgetModel.lockedCategories.size(),
          totalCats: totalCats
        })
      );
      return this;
    },
  
    _initBinds: function () {
      this.widgetModel.bind('change:search change:locked', this.render, this);
      this.widgetModel.lockedCategories.bind('change add remove', this.render, this);
      this.add_related_model(this.widgetModel);
      this.add_related_model(this.widgetModel.lockedCategories);
  
      this.dataviewModel.bind('change:data', this.render, this);
      this.add_related_model(this.dataviewModel);
  
      var f = this.dataviewModel.filter;
      f.acceptedCategories.bind('add remove reset', this.render, this);
      f.rejectedCategories.bind('add remove reset', this.render, this);
      this.add_related_model(f.rejectedCategories);
      this.add_related_model(f.acceptedCategories);
    },
  
    _lockCategories: function () {
      this.widgetModel.lockCategories();
    },
  
    _unlockCategories: function () {
      this.widgetModel.unlockCategories();
    },
  
    _onSelectAll: function () {
      this.dataviewModel.filter.acceptAll();
    }
  
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/category/paginator/paginator-view.js":
  /*!*******************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/category/paginator/paginator-view.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var checkAndBuildOpts = __webpack_require__(/*! builder/helpers/required-opts */ "./lib/assets/javascripts/builder/helpers/required-opts.js");
  var defaultTemplate = __webpack_require__(/*! ./paginator-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/category/paginator/paginator-template.tpl");
  var paginationTemplate = __webpack_require__(/*! ./pagination-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/category/paginator/pagination-template.tpl");
  
  var MIN_CATEGORIES = 5;
  var STARTING_PAGE = 1;
  var PAGINATION_STEP = 1;
  
  var REQUIRED_OPTS = [
    'dataviewModel',
    'widgetModel',
    'paginatorModel'
  ];
  
  /**
   *  Display paginator for category widget
   *
   */
  
  module.exports = CoreView.extend({
    options: {
      itemsPerPage: 6,
      template: defaultTemplate,
      paginator: false
    },
  
    className: 'CDB-Widget-nav CDB-Widget-contentSpaced',
  
    events: {
      'click .js-searchToggle': '_onSearchClicked',
      'click .js-next': '_onNextPage',
      'click .js-prev': '_onPrevPage'
    },
  
    initialize: function (options) {
      checkAndBuildOpts(options, REQUIRED_OPTS, this);
  
      this._initBinds();
    },
  
    render: function () {
      this.clearSubViews();
      this.$el.empty();
  
      this._initViews();
  
      return this;
    },
  
    _initBinds: function () {
      this.listenTo(this._paginatorModel, 'change:page', this.render);
  
      this.listenTo(this._dataviewModel, 'change:categoriesCount', this.render);
      this.listenTo(this._dataviewModel, 'change:data change:searchData', this._onDataChanged);
  
      this.listenTo(this._widgetModel, 'change:search', this.toggle);
    },
  
    _initViews: function () {
      var categoriesCount = this._dataviewModel.getCount();
  
      if (categoriesCount > MIN_CATEGORIES) {
        var template = this.options.template;
  
        this.$el.html(template({
          categoriesCount: categoriesCount
        }));
  
        if (this.options.paginator) {
          this.$el.append(paginationTemplate({
            currentPage: this._paginatorModel.get('page'),
            pages: this._totalPages()
          }));
        }
      } else {
        this._paginatorModel.set('page', STARTING_PAGE);
      }
    },
  
    // If current page doesn't exist due to a data change, we should reset it
    _setPage: function () {
      var pages = this._totalPages();
  
      if (this._paginatorModel.get('page') > pages || this._paginatorModel.get('page') < STARTING_PAGE) {
        this._paginatorModel.set({ page: STARTING_PAGE }, { silent: true });
      }
    },
  
    _onSearchClicked: function () {
      this._widgetModel.setupSearch();
    },
  
    _onDataChanged: function () {
      this._setPage();
      this.render();
    },
  
    _onPrevPage: function () {
      this._changePage(-PAGINATION_STEP);
    },
  
    _onNextPage: function () {
      this._changePage(PAGINATION_STEP);
    },
  
    _changePage: function (step) {
      var totalPages = this._totalPages();
      var currentPage = this._paginatorModel.get('page');
      var nextPage = currentPage + step;
  
      if (nextPage > totalPages) {
        nextPage = STARTING_PAGE;
      }
  
      if (nextPage < STARTING_PAGE) {
        nextPage = totalPages;
      }
  
      this._paginatorModel.set('page', nextPage);
    },
  
    _totalPages: function () {
      return Math.ceil(this._dataviewModel.getSize() / this.options.itemsPerPage);
    },
  
    toggle: function () {
      this[ this._widgetModel.isSearchEnabled() ? 'hide' : 'show' ]();
    },
  
    hide: function () {
      this.$el.addClass('is-hidden');
    },
  
    show: function () {
      this.$el.removeClass('is-hidden');
    },
  
    clean: function () {
      $(window).unbind('resize.' + this.cid);
      CoreView.prototype.clean.call(this);
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/category/paginator/search-paginator-view.js":
  /*!**************************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/category/paginator/search-paginator-view.js ***!
    \**************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var PaginatorView = __webpack_require__(/*! ./paginator-view */ "./lib/assets/javascripts/deep-insights/widgets/category/paginator/paginator-view.js");
  var searchTemplate = __webpack_require__(/*! ./search-paginator-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/category/paginator/search-paginator-template.tpl");
  var paginationTemplate = __webpack_require__(/*! ./pagination-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/category/paginator/pagination-template.tpl");
  
  module.exports = PaginatorView.extend({
    className: 'CDB-Widget-nav is-hidden CDB-Widget-contentSpaced',
  
    render: function () {
      this.clearSubViews();
      this.$el.empty();
  
      var pages = this._totalPages();
  
      this.$el.html(searchTemplate());
  
      if (pages > 1) {
        this.$el.append(paginationTemplate({
          currentPage: this._paginatorModel.get('page'),
          pages: pages
        }));
      }
      return this;
    },
  
    _totalPages: function () {
      return Math.ceil(this._dataviewModel.getSearchCount() / this.options.itemsPerPage);
    },
  
    toggle: function () {
      this[ !this._widgetModel.isSearchEnabled() ? 'hide' : 'show' ]();
    },
  
    _onSearchClicked: function () {
      this._widgetModel.cleanSearch();
      this._widgetModel.toggleSearch();
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/category/stats/stats-view.js":
  /*!***********************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/category/stats/stats-view.js ***!
    \***********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var formatter = __webpack_require__(/*! ../../../formatter */ "./lib/assets/javascripts/deep-insights/formatter.js");
  var template = __webpack_require__(/*! ./stats-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/category/stats/stats-template.tpl");
  var animationTemplate = __webpack_require__(/*! ./cats-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/category/stats/cats-template.tpl");
  var AnimateValues = __webpack_require__(/*! ../../animate-values */ "./lib/assets/javascripts/deep-insights/widgets/animate-values.js");
  
  /**
   * Category stats info view
   *
   */
  
  module.exports = CoreView.extend({
    className: 'CDB-Widget-info CDB-Text CDB-Size-small u-secondaryTextColor u-upperCase u-tSpace',
    tagName: 'dl',
  
    initialize: function () {
      this.widgetModel = this.options.widgetModel;
      this.dataviewModel = this.options.dataviewModel;
      this._initBinds();
    },
  
    render: function () {
      this.$el.html(
        template({
          isSearchEnabled: this.widgetModel.isSearchEnabled(),
          isSearchApplied: this.dataviewModel.isSearchApplied(),
          isLocked: this.widgetModel.isLocked(),
          isOtherAvailable: this.dataviewModel.isOtherAvailable(),
          resultsCount: this.dataviewModel.getSearchCount(),
          totalCats: this._getCategoriesSize(),
          nullsPer: this._getNullPercentage(),
          catsPer: this._getCurrentCategoriesPercentage()
        })
      );
  
      var animator = new AnimateValues({
        el: this.$el
      });
  
      animator.animateFromValues(this._getPreviousCategoriesPercentage(), this._getCurrentCategoriesPercentage(), '.js-cats',
        animationTemplate, { defaultValue: '-', animationSpeed: 700, formatter: formatter.formatValue }
      );
  
      this._checkVisibility();
  
      return this;
    },
  
    _initBinds: function () {
      this.dataviewModel.bind('change:data change:totalCount', this.render, this);
      this.widgetModel.bind('change:search change:locked', this.render, this);
      this.widgetModel.bind('change:show_stats change:collapsed', this._checkVisibility, this);
      this.add_related_model(this.dataviewModel);
      this.add_related_model(this.widgetModel);
    },
  
    _getNullPercentage: function () {
      var nulls = this.dataviewModel.get('nulls');
      var total = this.dataviewModel.get('totalCount') || 0;
      return !nulls ? 0 : ((nulls / total) * 100).toFixed(2);
    },
  
    _getPreviousCategoriesPercentage: function () {
      var total = this.dataviewModel.previous('totalCount') || 0;
      var data = this.dataviewModel.getPreviousData();
      return this._getCategoriesPercentage(data, total);
    },
  
    _getCurrentCategoriesPercentage: function () {
      var total = this.dataviewModel.get('totalCount') || 0;
      var data = this.dataviewModel.getData().toJSON();
      return this._getCategoriesPercentage(data, total);
    },
  
    _getCategoriesPercentage: function (data, total) {
      if (!total) {
        return 0;
      }
  
      var currentTotal = data.reduce(function (memo, mdl) {
        return !mdl.agg ? (memo + parseFloat(mdl.value)) : memo;
      }, 0);
  
      if (!currentTotal) {
        return 0;
      }
  
      return ((currentTotal / total) * 100).toFixed(2);
    },
  
    _getCategoriesSize: function () {
      return _.pluck(
        this.dataviewModel.getData().reject(function (mdl) {
          return mdl.get('agg');
        }), 'name').length;
    },
  
    _checkVisibility: function () {
      var isVisible = !!this.widgetModel.get('show_stats') && !this.widgetModel.get('collapsed');
      this.$el.toggle(isVisible);
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/category/title/search-title-view.js":
  /*!******************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/category/title/search-title-view.js ***!
    \******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var DropdownView = __webpack_require__(/*! ../../dropdown/widget-dropdown-view */ "./lib/assets/javascripts/deep-insights/widgets/dropdown/widget-dropdown-view.js");
  var TipsyTooltipView = __webpack_require__(/*! ../../../../builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  var template = __webpack_require__(/*! ./search-title-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/category/title/search-title-template.tpl");
  var layerColors = __webpack_require__(/*! ../../../util/layer-colors */ "./lib/assets/javascripts/deep-insights/util/layer-colors.js");
  var analyses = __webpack_require__(/*! ../../../data/analyses */ "./lib/assets/javascripts/deep-insights/data/analyses.js");
  var escapeHTML = __webpack_require__(/*! ../../../util/escape-html */ "./lib/assets/javascripts/deep-insights/util/escape-html.js");
  
  /**
   *  Show category title or search any category
   *  + another options for this widget, as in,
   *  colorize categories, lock defined categories...
   *
   */
  
  module.exports = CoreView.extend({
    events: {
      'keyup .js-textInput': '_onKeyupInput',
      'submit .js-form': '_onSubmitForm',
      'click .js-applyLocked': '_applyLocked',
      'click .js-autoStyle': '_autoStyle',
      'click .js-cancelAutoStyle': '_cancelAutoStyle'
    },
  
    initialize: function () {
      if (!this.options.widgetModel) throw new Error('widgetModel is required');
      if (!this.options.dataviewModel) throw new Error('dataviewModel is required');
      if (!this.options.layerModel) throw new Error('layerModel is required');
  
      this.model = this.options.widgetModel;
      this.dataviewModel = this.options.dataviewModel;
      this.layerModel = this.options.layerModel;
      this._initBinds();
    },
  
    render: function () {
      this.clearSubViews();
  
      var sourceId = this.dataviewModel.get('source').id;
      var letter = layerColors.letter(sourceId);
      var sourceColor = layerColors.getColorForLetter(letter);
      var sourceType = this.dataviewModel.getSourceType() || '';
      var isSourceType = this.dataviewModel.isSourceType();
      var layerName = isSourceType
        ? this.model.get('table_name')
        : this.layerModel.get('layer_name');
  
      this.$el.html(
        template({
          isCollapsed: this.model.get('collapsed'),
          isAutoStyleEnabled: this._isAutoStyleButtonVisible(),
          isAutoStyle: this.model.isAutoStyle(),
          title: this.model.get('title'),
          sourceId: sourceId,
          sourceType: analyses.title(sourceType),
          isSourceType: isSourceType,
          showSource: this.model.get('show_source') && letter !== '',
          sourceColor: sourceColor,
          layerName: escapeHTML(layerName),
          columnName: this.dataviewModel.get('column'),
          q: this.dataviewModel.getSearchQuery(),
          isLocked: this.model.isLocked(),
          canBeLocked: this.model.canBeLocked(),
          isSearchEnabled: this.model.isSearchEnabled(),
          canShowApply: this.model.canApplyLocked()
        })
      );
      this._initViews();
      return this;
    },
  
    _initBinds: function () {
      this.listenTo(this.model, 'change:search', this._onSearchToggled);
      this.listenTo(this.model, 'change:title change:collapsed change:autoStyle change:style', this.render);
      this.listenTo(this.model.lockedCategories, 'change add remove', this.render);
      this.listenTo(this.dataviewModel, 'change:column', this.render);
      this.listenTo(this.dataviewModel.filter, 'change', this.render);
      this.listenTo(this.layerModel, 'change:visible change:cartocss change:layer_name', this.render);
    },
  
    _initViews: function () {
      var dropdown = new DropdownView({
        model: this.model,
        target: '.js-actions',
        container: this.$el
      });
      this.addView(dropdown);
  
      var colorsTooltip = new TipsyTooltipView({
        el: this.$el.find('.js-colors'),
        gravity: 'auto'
      });
      this.addView(colorsTooltip);
  
      var actionsTooltip = new TipsyTooltipView({
        el: this.$el.find('.js-actions'),
        gravity: 'auto'
      });
      this.addView(actionsTooltip);
    },
  
    _isAutoStyleButtonVisible: function () {
      return this.model.isAutoStyleEnabled() &&
        this.layerModel.get('visible') &&
        this.model.hasColorsAutoStyle();
    },
  
    _onSearchToggled: function () {
      var isSearchEnabled = this.model.isSearchEnabled();
      this[isSearchEnabled ? '_bindESC' : '_unbindESC']();
      this.render();
      if (isSearchEnabled) {
        this._focusOnInput();
      }
    },
  
    _onSubmitForm: function (ev) {
      if (ev) {
        ev.preventDefault();
      }
      var q = this.$('.js-textInput').val();
      if (this.dataviewModel.getSearchQuery() !== q) {
        this.dataviewModel.setSearchQuery(q);
        if (this.dataviewModel.isSearchValid()) {
          this.dataviewModel.applySearch();
        }
      }
    },
  
    _focusOnInput: function () {
      var self = this;
      setTimeout(function () {
        self.$('.js-textInput').focus();
      }, 0);
    },
  
    _onKeyupInput: _.debounce(
      function (ev) {
        var q = this.$('.js-textInput').val();
        if (ev.keyCode !== 13 && ev.keyCode !== 27 && q !== '') {
          this._onSubmitForm();
        }
      }, 250
    ),
  
    _bindESC: function () {
      $(document).bind('keyup.' + this.cid, _.bind(this._onKeyUp, this));
    },
  
    _unbindESC: function () {
      $(document).unbind('keyup.' + this.cid);
    },
  
    _onKeyUp: function (ev) {
      if (ev.keyCode === 27) {
        this._cancelSearch();
        return false;
      }
    },
  
    _applyLocked: function () {
      this.model.toggleSearch();
      this.model.applyLocked();
    },
  
    _autoStyle: function () {
      this.model.autoStyle();
    },
  
    _cancelAutoStyle: function () {
      this.model.cancelAutoStyle();
    },
  
    _cancelSearch: function () {
      this.model.cleanSearch();
      this.model.disableSearch();
    },
  
    clean: function () {
      this._unbindESC();
      CoreView.prototype.clean.call(this);
    }
  
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/dropdown/widget-dropdown-view.js":
  /*!***************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/dropdown/widget-dropdown-view.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/dropdown/template.tpl");
  var DropdownOverlay = __webpack_require__(/*! ../../../builder/components/dropdown-overlay/dropdown-overlay-view */ "./lib/assets/javascripts/builder/components/dropdown-overlay/dropdown-overlay-view.js");
  
  /**
   * Standard widget dropdown view
   *
   */
  module.exports = CoreView.extend({
  
    className: 'CDB-Dropdown',
  
    events: {
      'click .js-toggleLocalTimezone': '_toggleLocalTimezone',
      'click .js-toggleNormalized': '_toggleNormalized',
      'click .js-toggleCollapsed': '_toggleCollapsed',
      'click .js-removeWidget': '_removeWidget',
      'click .js-editWidget': '_editWidget'
    },
  
    initialize: function (opts) {
      if (!opts.target) {
        throw new Error('target is not defined');
      }
  
      this._target = this.options.target;
      this._$container = this.options.container;
  
      this._initBinds();
    },
  
    render: function () {
      var flags = _.defaults(
        this.options.flags || {}, {
          canCollapse: true
        }
      );
  
      var templateData = _.defaults({},
        this.model.attributes, {
          flags: flags
        }, {
          'local_timezone': false,
          'normalized': false,
          'collapsed': false,
          'show_options': false
        }
      );
  
      this.$el.html(template(templateData));
  
      this._dropdownOverlay = new DropdownOverlay({
        visible: true,
        onClickAction: this._onGlobalClick.bind(this)
      });
      this.addView(this._dropdownOverlay);
  
      return this;
    },
  
    _initBinds: function () {
      this.add_related_model(this.model);
  
      this.model.bind('change:widget_dropdown_open', this._onChangeOpen, this);
  
      this._$container.delegate(this._target, 'click', _.bind(this._toggle, this));
    },
  
    _removeWidget: function () {
      this.model.trigger('removeWidget', this.model);
      this._toggle();
    },
  
    _editWidget: function () {
      this.model.trigger('editWidget', this.model);
      this._toggle();
    },
  
    _bindESC: function () {
      $(document).bind('keyup.' + this.cid, _.bind(this._onKeyUp, this));
    },
  
    _unbindESC: function () {
      $(document).unbind('keyup.' + this.cid);
    },
  
    _onGlobalClick: function (ev) {
      this.model.set('widget_dropdown_open', false);
    },
  
    _onKeyUp: function (ev) {
      if (ev.keyCode === 27) {
        this.model.set('widget_dropdown_open', false);
        return false;
      }
    },
  
    _onChangeOpen: function () {
      if (this.model.get('widget_dropdown_open')) {
        this._open();
      } else {
        this._close();
      }
    },
  
    _toggleCollapsed: function () {
      var collapsed = !this.model.get('collapsed');
      this.model.set('collapsed', collapsed);
      this._toggle();
    },
  
    _toggleNormalized: function () {
      var normalized = !this.model.get('normalized');
      this.model.set('normalized', normalized);
      this._toggle();
    },
  
    _toggleLocalTimezone: function () {
      var localTimezone = !this.model.get('local_timezone');
      this.model.set('local_timezone', localTimezone);
      this._toggle();
    },
  
    _open: function () {
      this._bindESC();
  
      this.render();
      this._$container.append(this.$el);
      this.$el.show();
  
      this._adjustVerticalPosition();
    },
  
    _adjustVerticalPosition: function () {
      if (this._getDropdownBottom() > this._getBodyHeight()) {
        this.$el.addClass('has-top-position');
      }
    },
  
    _getDropdownBottom: function () {
      return this.$el.offset().top + this.$el.height();
    },
  
    _getBodyHeight: function () {
      return $('body').height();
    },
  
    _close: function () {
      this._unbindESC();
      this._dropdownOverlay && this._dropdownOverlay.clean();
      this.$el.hide();
      this.$el.removeClass('has-top-position');
    },
  
    _toggle: function () {
      this.model.set('widget_dropdown_open', !this.model.get('widget_dropdown_open'));
    },
  
    clean: function () {
      this.model.set('widget_dropdown_open', false);
      this._unbindESC();
      this._dropdownOverlay && this._dropdownOverlay.clean();
      this._$container.undelegate(this._target, 'click');
      CoreView.prototype.clean.call(this);
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/formula/content-view.js":
  /*!******************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/formula/content-view.js ***!
    \******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var formatter = __webpack_require__(/*! ../../formatter */ "./lib/assets/javascripts/deep-insights/formatter.js");
  var template = __webpack_require__(/*! ./template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/formula/template.tpl");
  var DropdownView = __webpack_require__(/*! ../dropdown/widget-dropdown-view */ "./lib/assets/javascripts/deep-insights/widgets/dropdown/widget-dropdown-view.js");
  var animationTemplate = __webpack_require__(/*! ./animation-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/formula/animation-template.tpl");
  var AnimateValues = __webpack_require__(/*! ../animate-values.js */ "./lib/assets/javascripts/deep-insights/widgets/animate-values.js");
  var layerColors = __webpack_require__(/*! ../../util/layer-colors */ "./lib/assets/javascripts/deep-insights/util/layer-colors.js");
  var Analyses = __webpack_require__(/*! ../../data/analyses */ "./lib/assets/javascripts/deep-insights/data/analyses.js");
  var escapeHTML = __webpack_require__(/*! ../../util/escape-html */ "./lib/assets/javascripts/deep-insights/util/escape-html.js");
  var unescapeHTML = __webpack_require__(/*! ../../util/unescape-html */ "./lib/assets/javascripts/deep-insights/util/unescape-html.js");
  var TipsyTooltipView = __webpack_require__(/*! ../../../builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  
  /**
   * Default widget content view:
   */
  module.exports = CoreView.extend({
    className: 'CDB-Widget-body',
  
    initialize: function () {
      this._dataviewModel = this.model.dataviewModel;
      this._layerModel = this.model.layerModel;
  
      if (this.model.get('hasInitialState') === true) {
        this._initBinds();
      } else {
        this.listenToOnce(this.model, 'change:hasInitialState', this._onInitialState);
      }
    },
  
    _onInitialState: function () {
      this._initBinds();
      this.render();
    },
  
    render: function () {
      this.clearSubViews();
      var value = this._dataviewModel.get('data');
  
      var format = function (value) {
        var formatter = d3.format('0,000');
  
        if (_.isNumber(value)) {
          return formatter(value.toFixed(2));
        }
        return 0;
      };
  
      var nulls = (!_.isUndefined(this._dataviewModel.get('nulls')) && formatter.formatNumber(this._dataviewModel.get('nulls'))) || '-';
      var isCollapsed = this.model.get('collapsed');
  
      var prefix = this.model.get('prefix');
      var suffix = this.model.get('suffix');
  
      var sourceId = this._dataviewModel.get('source').id;
      var letter = layerColors.letter(sourceId);
      var sourceColor = layerColors.getColorForLetter(letter);
      var sourceType = this._dataviewModel.getSourceType() || '';
      var isSourceType = this._dataviewModel.isSourceType();
      var layerName = isSourceType
        ? this.model.get('table_name')
        : this._layerModel.get('layer_name');
  
      this.$el.html(
        template({
          title: this.model.get('title'),
          sourceId: sourceId,
          sourceType: Analyses.title(sourceType),
          isSourceType: isSourceType,
          showStats: this.model.get('show_stats'),
          showSource: this.model.get('show_source') && letter !== '',
          operation: this._dataviewModel.get('operation'),
          value: value,
          formatedValue: format(value),
          description: this.model.get('description'),
          nulls: nulls,
          prefix: unescapeHTML(prefix),
          suffix: unescapeHTML(suffix),
          isCollapsed: isCollapsed,
          sourceColor: sourceColor,
          layerName: escapeHTML(layerName)
        })
      );
  
      var animator = new AnimateValues({
        el: this.$el
      });
  
      animator.animateValue(
        this._dataviewModel,
        'data',
        '.js-value',
        animationTemplate,
        {
          animationSpeed: 700,
          formatter: format,
          templateData: {
            prefix: unescapeHTML(prefix),
            suffix: unescapeHTML(suffix)
          }
        }
      );
  
      this.$el.toggleClass('is-collapsed', !!isCollapsed);
  
      this._initViews();
  
      return this;
    },
  
    _initBinds: function () {
      this.listenTo(this.model, 'change:title change:description change:collapsed change:prefix change:suffix', this.render);
      this.listenTo(this._dataviewModel, 'change:data', this.render);
      this.listenTo(this._layerModel, 'change:layer_name', this.render);
    },
  
    _initViews: function () {
      var dropdown = new DropdownView({
        model: this.model,
        target: '.js-actions',
        container: this.$('.js-header')
      });
      this.addView(dropdown);
  
      var actionsTooltip = new TipsyTooltipView({
        el: this.$el.find('.js-actions'),
        gravity: 'auto'
      });
      this.addView(actionsTooltip);
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/histogram/chart.js":
  /*!*************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/histogram/chart.js ***!
    \*************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");
  var d3Interpolate = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
  var CoreModel = __webpack_require__(/*! backbone/core-model */ "./lib/assets/javascripts/vendor/backbone/core-model.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var formatter = __webpack_require__(/*! ../../formatter */ "./lib/assets/javascripts/deep-insights/formatter.js");
  var timestampHelper = __webpack_require__(/*! ../../util/timestamp-helper */ "./lib/assets/javascripts/deep-insights/util/timestamp-helper.js");
  var viewportUtils = __webpack_require__(/*! ../../viewport-utils */ "./lib/assets/javascripts/deep-insights/viewport-utils.js");
  
  var FILTERED_COLOR = '#2E3C43';
  var UNFILTERED_COLOR = 'rgba(0, 0, 0, 0.06)';
  var TIP_RECT_HEIGHT = 17;
  var TIP_H_PADDING = 6;
  var TRIANGLE_SIDE = 14;
  var TRIANGLE_HEIGHT = 7;
  // How much lower (based on height) will the triangle be on the right side
  var TRIANGLE_RIGHT_FACTOR = 1.3;
  var TOOLTIP_MARGIN = 2;
  var DASH_WIDTH = 2;
  var MOBILE_BAR_HEIGHT = 3;
  
  var BEZIER_MARGIN_X = 0.1;
  var BEZIER_MARGIN_Y = 1;
  
  var trianglePath = function (x1, y1, x2, y2, x3, y3, yFactor) {
    // Bezier Control point y
    var cy = y3 + (yFactor * BEZIER_MARGIN_Y);
    // Bezier Control point x 1
    var cx1 = x3 + BEZIER_MARGIN_X;
    var cx2 = x3 - BEZIER_MARGIN_X;
    return 'M ' + x1 + ' ' + y1 + ' L ' + x2 + ' ' + y2 + ' C ' + cx1 + ' ' + cy + ' ' + cx2 + ' ' + cy + ' ' + x1 + ' ' + y1 + ' z';
  };
  
  module.exports = CoreView.extend({
    options: {
      // render the chart once the width is set as default, provide false value for this prop to disable this behavior
      // e.g. for "mini" histogram behavior
      showOnWidthChange: true,
      chartBarColor: '#F2CC8F',
      labelsMargin: 16, // px
      hasAxisTip: false,
      minimumBarHeight: 2,
      animationSpeed: 750,
      handleWidth: 8,
      handleRadius: 3,
      divisionWidth: 80,
      animationBarDelay: function (d, i) {
        return Math.random() * (100 + (i * 10));
      },
      transitionType: 'elastic'
    },
  
    initialize: function () {
      this._originalData = this.options.originalData;
  
      if (!_.isNumber(this.options.height)) throw new Error('height is required');
      if (!this.options.dataviewModel) throw new Error('dataviewModel is required');
      if (!this.options.layerModel) throw new Error('layerModel is required');
      if (!this.options.type) throw new Error('type is required');
  
      _.bindAll(this, '_selectBars', '_adjustBrushHandles', '_onBrushMove', '_onBrushEnd', '_onMouseMove', '_onMouseOut');
  
      // Use this special setup for each view instance ot have its own debounced listener
      // TODO in theory there's the possiblity that the callback is called before the view is rendered in the DOM,
      //  which would lead to the view not being visible until an explicit window resize.
      //  a wasAddedToDOM event would've been nice to have
      this.forceResize = _.debounce(this._resizeToParentElement.bind(this), 50);
  
      // using tagName: 'svg' doesn't work,
      // and w/o class="" d3 won't instantiate properly
      this.setElement($('<svg class=""></svg>')[0]);
  
      this._widgetModel = this.options.widgetModel;
      this._dataviewModel = this.options.dataviewModel;
      this._layerModel = this.options.layerModel;
  
      this.canvas = d3.select(this.el)
        .style('overflow', 'visible')
        .attr('width', 0)
        .attr('height', this.options.height);
  
      this.canvas
        .append('g')
        .attr('class', 'CDB-WidgetCanvas');
  
      this._setupModel();
      this._setupBindings();
      this._setupDimensions();
      this._setupD3Bindings();
      this._setupFillColor();
  
      this.hide(); // will be toggled on width change
  
      this._tooltipFormatter = formatter.formatNumber; // Tooltips are always numbers
      this._createFormatter();
    },
  
    render: function () {
      this._generateChart();
      this._generateChartContent();
      return this;
    },
  
    replaceData: function (data) {
      this.model.set({ data: data });
    },
  
    toggleLabels: function (show) {
      this.model.set('showLabels', show);
    },
  
    chartWidth: function () {
      var margin = this.model.get('margin');
  
      // Get max because width might be negative initially
      return Math.max(0, this.model.get('width') - margin.left - margin.right);
    },
  
    chartHeight: function () {
      var m = this.model.get('margin');
      var labelsMargin = this.model.get('showLabels')
        ? this.options.labelsMargin
        : 0;
  
      return this.model.get('height') - m.top - m.bottom - labelsMargin;
    },
  
    getSelectionExtent: function () {
      if (this.brush && this.brush.extent()) {
        var extent = this.brush.extent();
  
        return extent[1] - extent[0];
      }
  
      return 0;
    },
  
    _resizeToParentElement: function () {
      if (this.$el.parent()) {
        // Hide this view temporarily to get actual size of the parent container
        var wasHidden = this.isHidden();
  
        this.hide();
  
        var parent = this.$el.parent();
        var grandParent = parent.parent && parent.parent() && parent.parent().length > 0
          ? parent.parent()
          : null;
        var width = parent.width() || 0;
  
        if (this.model.get('animated')) {
          // We could just substract 24, width of play/pause but imho this is more future proof
          this.$el.siblings().each(function () {
            width -= $(this).width();
          });
        }
  
        if (grandParent && grandParent.outerWidth && this._isTabletViewport()) {
          width -= grandParent.outerWidth(true) - grandParent.width();
        }
  
        if (wasHidden) {
          this.hide();
        } else {
          this.show();
        }
  
        this.model.set('width', width);
      }
    },
  
    _onChangeLeftAxisTip: function () {
      this._updateAxisTip('left');
    },
  
    _onChangeRightAxisTip: function () {
      this._updateAxisTip('right');
    },
  
    _overlap: function (first, second) {
      var bFirst = first.node().getBoundingClientRect();
      var bSecond = second.node().getBoundingClientRect();
  
      return !(bFirst.right < bSecond.left ||
      bFirst.left > bSecond.right ||
      bFirst.bottom < bSecond.top ||
      bFirst.top > bSecond.bottom);
    },
  
    _updateTriangle: function (isRight, triangle, start, center, rectWidth) {
      var ySign = isRight && !(this._isTabletViewport() && this._isTimeSeries()) ? -1 : 1;
  
      var transform = d3.transform(triangle.attr('transform'));
      var side = Math.min(TRIANGLE_SIDE, rectWidth);
      var translate = center - (side / 2);
  
      var offset = isRight
        ? Math.min((start + rectWidth) - (translate + side), 0)
        : Math.abs(Math.min(translate - start, 0));
  
      var p0 = [0, 0];
      var p1 = [side, 0];
      var p2 = [side / 2 - offset, TRIANGLE_HEIGHT * ySign];
  
      triangle.attr('d', trianglePath(p0[0], p0[1], p1[0], p1[1], p2[0], p2[1], ySign));
      transform.translate[0] = center - (side / 2) + offset;
  
      triangle.attr('transform', transform.toString());
    },
  
    _updateAxisTip: function (className) {
      var leftTip = 'left_axis_tip';
      var rightTip = 'right_axis_tip';
      var attr = className + '_axis_tip';
      var isRight = className === 'right';
      var isLeft = !isRight;
      var isWeek = this._dataviewModel.get('aggregation') === 'week';
      var model = this.model.get(attr);
      if (model === undefined) { return; }
  
      var leftValue = this.model.get(leftTip);
      var rightValue = this.model.get(rightTip);
  
      var textLabel = this.chart.select('.CDB-Chart-axisTipText.CDB-Chart-axisTip-' + className);
      var axisTip = this.chart.select('.CDB-Chart-axisTip.CDB-Chart-axisTip-' + className);
      var rectLabel = this.chart.select('.CDB-Chart-axisTipRect.CDB-Chart-axisTip-' + className);
      var handle = this.chart.select('.CDB-Chart-handle.CDB-Chart-handle-' + className);
      var triangle = handle.select('.CDB-Chart-axisTipTriangle');
  
      textLabel.data([model]).text(function (d) {
        var text = this.formatter(d);
  
        this._dataviewModel.trigger('on_update_axis_tip', {
          attr: attr,
          text: text
        });
  
        return text;
      }.bind(this));
  
      if (!textLabel.node()) {
        return;
      }
  
      var textBBox = textLabel.node().getBBox();
      var width = textBBox.width;
      var rectWidth = width + TIP_H_PADDING;
      var handleWidth = this.options.handleWidth;
      var barWidth = this.barWidth;
      var chartWidth = this.chartWidth();
  
      rectLabel.attr('width', rectWidth);
      textLabel.attr('dx', TIP_H_PADDING / 2);
      textLabel.attr('dy', textBBox.height - Math.abs((textBBox.height - TIP_RECT_HEIGHT) / 2));
  
      var parts = d3.transform(handle.attr('transform')).translate;
      var xPos = +parts[0] + (this.options.handleWidth / 2);
  
      var yPos = isRight && !(this._isMobileViewport() && this._isTimeSeries())
        ? this.chartHeight() + (TRIANGLE_HEIGHT * TRIANGLE_RIGHT_FACTOR) - 1
        : -(TRIANGLE_HEIGHT + TIP_RECT_HEIGHT + TOOLTIP_MARGIN);
      yPos = Math.floor(yPos);
  
      // Align rect and bar centers
      var rectCenter = rectWidth / 2;
      var barCenter = (handleWidth + barWidth) / 2;
      barCenter -= (isRight ? barWidth : 0); // right tip should center to the previous bin
      if (!this._isDateTimeSeries() || isWeek) { // In numeric and week histograms, axis should point to the handler
        barCenter = handleWidth / 2;
      }
      var translate = barCenter - rectCenter;
  
      // Check if rect if out of bounds and clip translate if that happens
      var leftPos = xPos + translate;
      var rightPos = leftPos + rectWidth;
      var translatedCenter = translate + rectCenter;
      var rightExceed = rightPos - (chartWidth + handleWidth);
  
      // Do we exceed left?
      if (leftPos < 0) {
        translate -= leftPos;
      }
  
      // Do we exceed right?
      if (rightExceed > 0) {
        translate -= rightExceed;
      }
  
      // Show / hide labels depending on their values
      var showTip = isLeft
        ? leftValue <= rightValue
        : (leftValue <= rightValue && !(leftValue === rightValue && this._isDateTimeSeries()));
  
      this._showAxisTip(className, showTip);
  
      // Translate axis tip
      axisTip.attr('transform', 'translate(' + translate + ', ' + yPos + ')');
  
      // Update triangle position
      this._updateTriangle(isRight, triangle, translate, translatedCenter, rectWidth);
  
      if (this.model.get('dragging') && this._isMobileViewport() && this._isTimeSeries()) {
        this._showAxisTip(className, true);
      }
    },
  
    _onChangeData: function () {
      if (this.model.previous('data').length !== this.model.get('data').length) {
        this.reset();
      } else {
        this.refresh();
      }
  
      this._setupFillColor();
      this._refreshBarsColor();
    },
  
    _onChangeRange: function () {
      var loIndex = this.model.get('lo_index');
      var hiIndex = this.model.get('hi_index');
      if ((loIndex === 0 && hiIndex === 0) || (loIndex === null && hiIndex === null)) {
        return;
      }
  
      this.selectRange(loIndex, hiIndex);
      this._adjustBrushHandles();
      this._setAxisTipAccordingToBins();
      this._selectBars();
      this.trigger('on_brush_end', loIndex, hiIndex);
    },
  
    _onChangeWidth: function () {
      var width = this.model.get('width');
      this.canvas.attr('width', width);
      this.chart.attr('width', width);
      if (this.options.showOnWidthChange && width > 0) {
        this.show();
      }
      this.reset();
  
      var loBarIndex = this.model.get('lo_index');
      var hiBarIndex = this.model.get('hi_index');
      this.selectRange(loBarIndex, hiBarIndex);
      this._updateAxisTip('left');
      this._updateAxisTip('right');
    },
  
    _onChangeNormalized: function () {
      // do not show shadow bars if they are not enabled
      this.model.set('show_shadow_bars', !this.model.get('normalized'));
      this._generateShadowBars();
      this.updateYScale();
      this.refresh();
    },
  
    _onChangeHeight: function () {
      var height = this.model.get('height');
  
      this.$el.height(height);
      this.chart.attr('height', height);
      this.leftHandle.attr('height', height);
      this.rightHandle.attr('height', height);
      this.updateYScale();
  
      this.reset();
    },
  
    _onChangeShowLabels: function () {
      this._axis.style('opacity', this.model.get('showLabels') ? 1 : 0);
    },
  
    _onChangePos: function () {
      var pos = this.model.get('pos');
      var margin = this.model.get('margin');
  
      var x = +pos.x;
      var y = +pos.y;
  
      this.chart
        .transition()
        .duration(150)
        .attr('transform', 'translate(' + (margin.left + x) + ', ' + (margin.top + y) + ')');
    },
  
    _onChangeDragging: function () {
      this.chart.classed('is-dragging', this.model.get('dragging'));
  
      if (!this.model.get('dragging') && this._isMobileViewport() && this._isTimeSeries()) {
        this._showAxisTip('right', false);
        this._showAxisTip('left', false);
      }
    },
  
    _toggleAxisTip: function (className, show) {
      var textLabel = this.chart.select('.CDB-Chart-axisTipText.CDB-Chart-axisTip-' + className);
      var rectLabel = this.chart.select('.CDB-Chart-axisTipRect.CDB-Chart-axisTip-' + className);
      var handle = this.chart.select('.CDB-Chart-handle.CDB-Chart-handle-' + className);
      var triangle = handle.select('.CDB-Chart-axisTipTriangle');
      var duration = 60;
  
      if (textLabel) {
        textLabel.transition().duration(duration).attr('opacity', show);
      }
      if (rectLabel) {
        rectLabel.transition().duration(duration).attr('opacity', show);
      }
      if (triangle) {
        triangle.transition().duration(duration).style('opacity', show);
      }
    },
  
    _showAxisTip: function (className, show) {
      this._toggleAxisTip(className, show ? 1 : 0);
    },
  
    _setAxisTipAccordingToBins: function () {
      var left = this._getValueFromBinIndex(this._getLoBarIndex());
      var right = this._getValueFromBinIndex(this._getHiBarIndex());
      if (this._isDateTimeSeries()) {
        right = timestampHelper.substractOneUnit(right, this._dataviewModel.get('aggregation'));
      }
      this._setAxisTip(left, right);
    },
  
    _setAxisTip: function (left, right) {
      if (this.options.hasAxisTip) {
        this.model.set({
          left_axis_tip: left,
          right_axis_tip: right
        });
      }
    },
  
    reset: function () {
      this._removeChartContent();
      this._setupDimensions();
      this._calcBarWidth();
      this._generateChartContent();
      this._generateShadowBars();
    },
  
    refresh: function () {
      this._createFormatter();
      this._setupDimensions();
      this._removeAxis();
      this._generateAxis();
      this._updateChart();
      this._refreshBarsColor();
  
      this.chart.select('.CDB-Chart-handles').moveToFront();
      this.chart.select('.Brush').moveToFront();
    },
  
    resetIndexes: function () {
      this.model.set({ lo_index: null, hi_index: null });
    },
  
    removeShadowBars: function () {
      this.model.set('show_shadow_bars', false);
    },
  
    _removeShadowBars: function () {
      this.chart.selectAll('.CDB-Chart-shadowBars').remove();
    },
  
    _removeBars: function () {
      this.chart.selectAll('.CDB-Chart-bars').remove();
    },
  
    _removeBrush: function () {
      this.chart.selectAll('.Brush').remove();
      this.chart.classed('is-selectable', false);
      this._axis.classed('is-disabled', false);
    },
  
    _removeLines: function () {
      this.chart.select('.CDB-Chart-lines').remove();
      this.chart.select('.CDB-Chart-line--bottom').remove();
    },
  
    _removeChartContent: function () {
      this._removeBrush();
      this._removeHandles();
      this._removeBars();
      this._removeAxis();
      this._removeLines();
    },
  
    _generateChartContent: function () {
      this._generateAxis();
  
      if (!(this._isTabletViewport() && this._isTimeSeries())) {
        this._generateLines();
      }
  
      this._generateBars();
  
      if (!(this._isMobileViewport() && this._isTimeSeries())) {
        this._generateBottomLine();
      }
  
      this._generateHandles();
      this._setupBrush();
    },
  
    _generateLines: function () {
      this._generateHorizontalLines();
      this._generateVerticalLines();
    },
  
    _generateVerticalLines: function () {
      var lines = this.chart.select('.CDB-Chart-lines');
  
      lines.append('g')
        .selectAll('.CDB-Chart-line')
        .data(this.verticalRange.slice(1, this.verticalRange.length - 1))
        .enter().append('svg:line')
        .attr('class', 'CDB-Chart-line')
        .attr('y1', 0)
        .attr('x1', function (d) { return d; })
        .attr('y2', this.chartHeight())
        .attr('x2', function (d) { return d; });
    },
  
    _generateHorizontalLines: function () {
      var lines = this.chart.append('g')
        .attr('class', 'CDB-Chart-lines');
  
      lines.append('g')
        .attr('class', 'y')
        .selectAll('.CDB-Chart-line')
        .data(this.horizontalRange.slice(0, this.horizontalRange.length - 1))
        .enter().append('svg:line')
        .attr('class', 'CDB-Chart-line')
        .attr('x1', 0)
        .attr('y1', function (d) { return d; })
        .attr('x2', this.chartWidth())
        .attr('y2', function (d) { return d; });
    },
  
    _generateBottomLine: function () {
      this.chart.append('line')
        .attr('class', 'CDB-Chart-line CDB-Chart-line--bottom')
        .attr('x1', 0)
        .attr('y1', this.chartHeight() - 1)
        .attr('x2', this.chartWidth() - 1)
        .attr('y2', this.chartHeight() - 1);
    },
  
    _setupD3Bindings: function () { // TODO: move to a helper
      d3.selection.prototype.moveToBack = function () {
        return this.each(function () {
          var firstChild = this.parentNode.firstChild;
          if (firstChild) {
            this.parentNode.insertBefore(this, firstChild);
          }
        });
      };
  
      d3.selection.prototype.moveToFront = function () {
        return this.each(function () {
          this.parentNode.appendChild(this);
        });
      };
    },
  
    _setupModel: function () {
      this.model = new CoreModel({
        bounded: false,
        showLabels: true,
        data: this.options.data,
        height: this.options.height,
        display: true,
        show_shadow_bars: this.options.displayShadowBars,
        margin: _.clone(this.options.margin),
        width: 0, // will be set on resize listener
        pos: { x: 0, y: 0 },
        normalized: this.options.normalized,
        local_timezone: this.options.local_timezone
      });
    },
  
    _setupBindings: function () {
      this.listenTo(this.model, 'change:data', this._onChangeData);
      this.listenTo(this.model, 'change:display', this._onChangeDisplay);
      this.listenTo(this.model, 'change:dragging', this._onChangeDragging);
      this.listenTo(this.model, 'change:height', this._onChangeHeight);
      this.listenTo(this.model, 'change:left_axis_tip', this._onChangeLeftAxisTip);
      this.listenTo(this.model, 'change:lo_index change:hi_index', this._onChangeRange);
      this.listenTo(this.model, 'change:pos', this._onChangePos);
      this.listenTo(this.model, 'change:right_axis_tip', this._onChangeRightAxisTip);
      this.listenTo(this.model, 'change:showLabels', this._onChangeShowLabels);
      this.listenTo(this.model, 'change:show_shadow_bars', this._onChangeShowShadowBars);
      this.listenTo(this.model, 'change:width', this._onChangeWidth);
      this.listenTo(this.model, 'change:normalized', this._onChangeNormalized);
  
      if (this._widgetModel) {
        this.listenTo(this._widgetModel, 'change:autoStyle', this._refreshBarsColor);
        this.listenTo(this._widgetModel, 'change:style', function () {
          this._setupFillColor();
          this._refreshBarsColor();
        });
      }
  
      if (this._dataviewModel) {
        this.listenTo(this._dataviewModel, 'change:offset change:localTimezone', function () {
          this.refresh();
        });
      }
  
      this.listenTo(this._layerModel, 'change:cartocss', function () {
        if (!this._areGradientsAlreadyGenerated()) {
          this._setupFillColor();
        }
      });
  
      if (this._originalData) {
        this.listenTo(this._originalData, 'change:data', function () {
          this.updateYScale();
          this._removeShadowBars();
          this._generateShadowBars();
        });
      }
    },
  
    _setupDimensions: function () {
      this._setupScales();
      this._setupRanges();
      this.forceResize();
    },
  
    _getData: function () {
      return (this._originalData && this._originalData.getData()) || this.model.get('data');
    },
  
    _getMaxData: function (data) {
      return d3.max(data, function (d) { return _.isEmpty(d) ? 0 : d.freq; });
    },
  
    _getXScale: function () {
      return d3.scale.linear().domain([0, 100]).range([0, this.chartWidth()]);
    },
  
    _getYScale: function () {
      var data = this.model.get('normalized') ? this.model.get('data') : this._getData();
      return d3.scale.linear().domain([0, this._getMaxData(data)]).range([this.chartHeight(), 0]);
    },
  
    updateXScale: function () {
      this.xScale = this._getXScale();
    },
  
    updateYScale: function () {
      this.yScale = this._getYScale();
    },
  
    resetYScale: function () {
      this.yScale = this._originalYScale;
    },
  
    _getDataForScales: function () {
      if (!this.model.get('bounded') && this._originalData) {
        return this._originalData.getData();
      } else {
        return this.model.get('data');
      }
    },
  
    _setupScales: function () {
      var data = this._getDataForScales();
      this.updateXScale();
  
      if (!this._originalYScale || this.model.get('normalized')) {
        this._originalYScale = this.yScale = this._getYScale();
      }
  
      if (!data || !data.length) {
        return;
      }
  
      var start = data[0].start;
      var end = data[data.length - 1].end;
  
      this.xAxisScale = d3.scale.linear().range([start, end]).domain([0, this.chartWidth()]);
    },
  
    _setupRanges: function () {
      this.verticalRange = this._calculateVerticalRangeDivisions();
      this.horizontalRange = d3.range(0, this.chartHeight() + this.chartHeight() / 2, this.chartHeight() / 2);
    },
  
    _calculateVerticalRangeDivisions: function () {
      if (this._isDateTimeSeries() && this.model.get('data').length > 0) {
        return this._calculateTimelySpacedDivisions();
      }
      return this._calculateEvenlySpacedDivisions();
    },
  
    _calculateTimelySpacedDivisions: function () {
      this._calcBarWidth();
      var divisions = Math.round(this.chartWidth() / this.options.divisionWidth);
      var bucketsPerDivision = Math.ceil(this.model.get('data').length / divisions);
      var range = [0];
      var index = 0;
  
      for (var i = 0; i < divisions; i++) {
        index = (i < (divisions - 1)) ? index + bucketsPerDivision : this.model.get('data').length;
        range.push(Math.ceil(this.xAxisScale.invert(this._getValueFromBinIndex(index))));
      }
  
      range = _.uniq(range);
  
      // Sometimes the last two ticks are too close. In those cases, we get rid of the second to last
      if (range.length >= 3) {
        var lastTwo = _.last(range, 2);
        if ((lastTwo[1] - lastTwo[0]) < this.options.divisionWidth) {
          range = _.without(range, lastTwo[0]);
        }
      }
  
      return range;
    },
  
    _calculateEvenlySpacedDivisions: function () {
      var divisions = Math.round(this.chartWidth() / this.options.divisionWidth);
      var step = this.chartWidth() / divisions;
      var stop = this.chartWidth() + step;
      var range = d3.range(0, stop, step).slice(0, divisions + 1);
      return range;
    },
  
    _calcBarWidth: function () {
      this.barWidth = this.chartWidth() / this.model.get('data').length;
    },
  
    _generateChart: function () {
      var margin = this.model.get('margin');
  
      this.chart = d3.select(this.el)
        .selectAll('.CDB-WidgetCanvas')
        .append('g')
        .attr('class', 'CDB-Chart')
        .attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');
  
      this.chart.classed(this.options.className || '', true);
    },
  
    _onChangeShowShadowBars: function () {
      if (this.model.get('show_shadow_bars')) {
        this._generateShadowBars();
      } else {
        this._removeShadowBars();
      }
    },
  
    _onChangeDisplay: function () {
      if (this.model.get('display')) {
        this._show();
      } else {
        this._hide();
      }
    },
  
    hide: function () {
      this.model.set('display', false);
    },
  
    show: function () {
      this.model.set('display', true);
    },
  
    _hide: function () {
      this.$el.hide();
    },
  
    _show: function () {
      this.$el.show();
    },
  
    isHidden: function () {
      return !this.model.get('display');
    },
  
    _selectBars: function () {
      this.chart
        .selectAll('.CDB-Chart-bar')
        .classed({
          'is-selected': function (d, i) {
            return this._isBarChartWithinFilter(i);
          }.bind(this),
          'is-filtered': function (d, i) {
            return !this._isBarChartWithinFilter(i);
          }.bind(this)
        });
    },
  
    _isBarChartWithinFilter: function (i) {
      var extent = this.brush.extent();
      var lo = extent[0];
      var hi = extent[1];
      var a = Math.floor(i * this.barWidth);
      var b = Math.floor(a + this.barWidth);
      var LO = Math.floor(this.xScale(lo));
      var HI = Math.floor(this.xScale(hi));
  
      return (a > LO && a < HI) || (b > LO && b < HI) || (a <= LO && b >= HI);
    },
  
    _isDragging: function () {
      return this.model.get('dragging');
    },
  
    setAnimated: function () {
      return this.model.set('animated', true);
    },
  
    _isAnimated: function () {
      return this.model.get('animated');
    },
  
    _move: function (pos) {
      this.model.set({ pos: pos });
    },
  
    expand: function (height) {
      this.canvas.attr('height', this.model.get('height') + height);
      this._move({ x: 0, y: height });
    },
  
    contract: function (height) {
      this.canvas.attr('height', height);
      this._move({ x: 0, y: 0 });
    },
  
    resizeHeight: function (height) {
      this.model.set('height', height);
    },
  
    setNormalized: function (normalized) {
      this.model.set('normalized', !!normalized);
      return this;
    },
  
    removeSelection: function () {
      this.resetIndexes();
      this.chart.selectAll('.CDB-Chart-bar').classed({'is-selected': false, 'is-filtered': false});
      this._refreshBarsColor();
      this._removeBrush();
      this._setupBrush();
    },
  
    selectRange: function (loBarIndex, hiBarIndex) {
      if (!loBarIndex && !hiBarIndex) {
        return;
      }
  
      // -- HACK: Reset filter if any of the indexes is out of the scope
      var data = this._dataviewModel.get('data');
      if (!data[loBarIndex] || !data[hiBarIndex - 1]) {
        return this.trigger('on_reset_filter');
      }
  
      var loPosition = this._getBarPosition(loBarIndex);
      var hiPosition = this._getBarPosition(hiBarIndex);
  
      this.model.set({ lo_index: loBarIndex, hi_index: hiBarIndex });
      this._selectRange(loPosition, hiPosition);
    },
  
    _selectRange: function (loPosition, hiPosition) {
      this.chart.select('.Brush').transition()
        .duration(this.brush.empty() ? 0 : 150)
        .call(this.brush.extent([loPosition, hiPosition]))
        .call(this.brush.event);
    },
  
    _getLoBarIndex: function () {
      var extent = this.brush.extent();
      return Math.round(this.xScale(extent[0]) / this.barWidth);
    },
  
    _getHiBarIndex: function () {
      var extent = this.brush.extent();
      return Math.round(this.xScale(extent[1]) / this.barWidth);
    },
  
    _getBarIndex: function () {
      var x = d3.event.sourceEvent.layerX;
      return Math.floor(x / this.barWidth);
    },
  
    _getBarPosition: function (index) {
      var data = this.model.get('data');
      return index * (100 / data.length);
    },
  
    _setupBrush: function () {
      // define brush control element and its events
      var brush = d3.svg.brush()
        .x(this.xScale)
        .on('brush', this._onBrushMove)
        .on('brushend', this._onBrushEnd);
  
      // create svg group with class brush and call brush on it
      var brushg = this.chart.append('g')
        .attr('class', 'Brush')
        .call(brush);
  
      var height = this._isTabletViewport() && this._isTimeSeries() ? this.chartHeight() * 2 : this.chartHeight();
      // set brush extent to rect and define objects height
      brushg.selectAll('rect')
        .attr('y', 0)
        .attr('height', height);
  
      // Only bind on the background element
      brushg.selectAll('rect.background')
        .on('mouseout', this._onMouseOut)
        .on('mousemove', this._onMouseMove);
  
      // Prevent scroll while touching selections
      brushg.selectAll('rect')
        .classed('ps-prevent-touchmove', true);
      brushg.selectAll('g')
        .classed('ps-prevent-touchmove', true);
  
      this.brush = brush;
  
      // Make grabby handles as big as the display handles
      this.chart.selectAll('g.resize rect')
        .attr('width', this.options.handleWidth)
        .attr('x', -this.options.handleWidth / 2);
    },
  
    _onBrushMove: function () {
      if (!this.brush.empty()) {
        this.chart.classed('is-selectable', true);
        this._axis.classed('is-disabled', true);
        this.model.set({ dragging: true });
        this._selectBars();
        this._setupFillColor();
        this._refreshBarsColor();
        this._adjustBrushHandles();
        this._updateAxisTip('left');
        this._updateAxisTip('right');
      }
    },
  
    _onBrushEnd: function () {
      var data = this.model.get('data');
      var brush = this.brush;
      var loPosition, hiPosition;
  
      var loBarIndex = this._getLoBarIndex();
      var hiBarIndex = this._getHiBarIndex();
  
      this.model.set({ dragging: false });
  
      // click in animated histogram
      if (brush.empty() && this._isAnimated()) {
        // Send 0..1 factor of position of click in graph
        this.trigger('on_brush_click', brush.extent()[0] / 100);
  
        return;
      } else {
        loPosition = this._getBarPosition(loBarIndex);
        hiPosition = this._getBarPosition(hiBarIndex);
  
        // for some reason d3 launches several brushend events
        if (!d3.event.sourceEvent) {
          return;
        }
  
        // click in first and last indexes
        if (loBarIndex === hiBarIndex) {
          if (hiBarIndex >= data.length) {
            loBarIndex = data.length - 1;
            hiBarIndex = data.length;
          } else {
            hiBarIndex = hiBarIndex + 1;
          }
        }
  
        this.model.set({ lo_index: loBarIndex, hi_index: hiBarIndex }, { silent: true });
        // Maybe the indexes don't change, and the handlers end up stuck in the middle of the
        // bucket because the event doesn't trigger, so let's trigger it manually
        this.model.trigger('change:lo_index');
      }
  
      // click in non animated histogram
      if (d3.event.sourceEvent && loPosition === undefined && hiPosition === undefined) {
        var barIndex = this._getBarIndex();
        this.model.set({ lo_index: barIndex, hi_index: barIndex + 1 });
      }
  
      this._setupFillColor();
      this._refreshBarsColor();
    },
  
    _onMouseOut: function () {
      var bars = this.chart.selectAll('.CDB-Chart-bar');
  
      bars
        .classed('is-highlighted', false)
        .attr('fill', this._getFillColor.bind(this));
  
      this.trigger('hover', { target: null });
    },
  
    _onMouseMove: function () {
      var x = d3.event.offsetX - this.model.get('margin').left;
  
      var barIndex = Math.floor(x / this.barWidth);
      var data = this.model.get('data');
  
      if (data[barIndex] === undefined || data[barIndex] === null) {
        return;
      }
  
      var freq = data[barIndex].freq;
      var hoverProperties = {};
  
      var bar = this.chart.select('.CDB-Chart-bar:nth-child(' + (barIndex + 1) + ')');
  
      if (bar && bar.node() && !bar.classed('is-selected')) {
        var left = (barIndex * this.barWidth) + (this.barWidth / 2);
        var top = this.yScale(freq);
        var h = this.chartHeight() - this.yScale(freq);
  
        if (h < this.options.minimumBarHeight && h > 0) {
          top = this.chartHeight() - this.options.minimumBarHeight;
        }
  
        if (!this._isDragging() && freq > 0) {
          var d = this.formatter(freq);
          hoverProperties = { target: bar[0][0], top: top, left: left, data: d };
        } else {
          hoverProperties = null;
        }
      } else {
        hoverProperties = null;
      }
  
      this.trigger('hover', hoverProperties);
  
      this.chart.selectAll('.CDB-Chart-bar')
        .classed('is-highlighted', false)
        .attr('fill', this._getFillColor.bind(this));
  
      if (bar && bar.node()) {
        bar.attr('fill', function () {
          return this._getHoverFillColor(data[barIndex], barIndex);
        }.bind(this));
        bar.classed('is-highlighted', true);
      }
    },
  
    _adjustBrushHandles: function () {
      var extent = this.brush.extent();
  
      var loExtent = extent[0];
      var hiExtent = extent[1];
  
      this._moveHandle(loExtent, 'left');
      this._moveHandle(hiExtent, 'right');
  
      this._setAxisTipAccordingToBins();
    },
  
    _moveHandle: function (position, selector) {
      var handle = this.chart.select('.CDB-Chart-handle-' + selector);
      var fixedPosition = position.toFixed(5);
      var x = this.xScale(fixedPosition) - this.options.handleWidth / 2;
      var display = (fixedPosition >= 0 && fixedPosition <= 100) ? 'inline' : 'none';
  
      handle
        .style('display', display)
        .attr('transform', 'translate(' + x + ', 0)');
    },
  
    _generateAxisTip: function (className) {
      var handle = this.chart.select('.CDB-Chart-handle.CDB-Chart-handle-' + className);
  
      var yPos = className === 'right' && !(this._isMobileViewport() && this._isTimeSeries())
        ? this.chartHeight() + (TRIANGLE_HEIGHT * TRIANGLE_RIGHT_FACTOR) : -(TRIANGLE_HEIGHT + TIP_RECT_HEIGHT + TOOLTIP_MARGIN);
      yPos = Math.floor(yPos);
  
      var yTriangle = className === 'right' && !(this._isMobileViewport() && this._isTimeSeries())
        ? this.chartHeight() + (TRIANGLE_HEIGHT * TRIANGLE_RIGHT_FACTOR) + 2 : -(TRIANGLE_HEIGHT + TOOLTIP_MARGIN) - 2;
      var yFactor = className === 'right' ? -1 : 1;
      var triangleHeight = TRIANGLE_HEIGHT * yFactor;
  
      var axisTip = handle.selectAll('g')
        .data([''])
        .enter().append('g')
        .attr('class', 'CDB-Chart-axisTip CDB-Chart-axisTip-' + className)
        .attr('transform', 'translate(0,' + yPos + ')');
  
      handle.append('path')
        .attr('class', 'CDB-Chart-axisTipRect CDB-Chart-axisTipTriangle')
        .attr('transform', 'translate(' + ((this.options.handleWidth / 2) - (TRIANGLE_SIDE / 2)) + ', ' + yTriangle + ')')
        .attr('d', trianglePath(0, 0, TRIANGLE_SIDE, 0, (TRIANGLE_SIDE / 2), triangleHeight, yFactor))
        .style('opacity', '1');
  
      axisTip.append('rect')
        .attr('class', 'CDB-Chart-axisTipRect CDB-Chart-axisTip-' + className)
        .attr('rx', '2')
        .attr('ry', '2')
        .attr('opacity', '1')
        .attr('height', TIP_RECT_HEIGHT);
  
      axisTip.append('text')
        .attr('class', 'CDB-Text CDB-Size-small CDB-Chart-axisTipText CDB-Chart-axisTip-' + className)
        .attr('dy', '11')
        .attr('dx', '0')
        .attr('opacity', '1')
        .text(function (d) { return d; });
    },
  
    _isTabletViewport: function () {
      return viewportUtils.isTabletViewport();
    },
  
    _generateHandle: function (className) {
      var height = this._isTabletViewport() && this._isTimeSeries() ? this.chartHeight() * 2 : this.chartHeight();
      var opts = { width: this.options.handleWidth, height: height, radius: this.options.handleRadius };
  
      var handle = this.chart.select('.CDB-Chart-handles')
        .append('g')
        .attr('class', 'CDB-Chart-handle CDB-Chart-handle-' + className);
  
      if (this.options.hasAxisTip) {
        this._generateAxisTip(className);
      }
  
      if (this.options.hasHandles) {
        handle
          .append('rect')
          .attr('class', 'CDB-Chart-handleRect')
          .attr('width', opts.width)
          .attr('height', opts.height)
          .attr('rx', opts.radius)
          .attr('ry', opts.radius);
  
        var y = this._isTabletViewport() && this._isTimeSeries() ? this.chartHeight() : this.chartHeight() / 2;
        y -= 3;
        var x1 = (opts.width - DASH_WIDTH) / 2;
  
        for (var i = 0; i < 3; i++) {
          handle
            .append('line')
            .attr('class', 'CDB-Chart-handleGrip')
            .attr('x1', x1)
            .attr('y1', y + i * 3)
            .attr('x2', x1 + DASH_WIDTH)
            .attr('y2', y + i * 3);
        }
      }
  
      return handle;
    },
  
    _generateHandles: function () {
      this.chart.append('g').attr('class', 'CDB-Chart-handles');
      this.leftHandle = this._generateHandle('left');
      this.rightHandle = this._generateHandle('right');
    },
  
    _removeHandles: function () {
      this.chart.select('.CDB-Chart-handles').remove();
    },
  
    _removeAxis: function () {
      this.canvas.select('.CDB-Chart-axis').remove();
    },
  
    _generateAdjustAnchorMethod: function (ticks) {
      return function (d, i) {
        if (i === 0) {
          return 'start';
        } else if (i === (ticks.length - 1)) {
          return 'end';
        } else {
          return 'middle';
        }
      };
    },
  
    _generateAxis: function () {
      this._axis = this._generateNumericAxis();
  
      this._onChangeShowLabels();
    },
  
    _generateNumericAxis: function () {
      var self = this;
      var adjustTextAnchor = this._generateAdjustAnchorMethod(this.verticalRange);
  
      var axis = this.chart.append('g')
        .attr('class', 'CDB-Chart-axis CDB-Text CDB-Size-small');
  
      function verticalToValue (d) {
        return self.xAxisScale
          ? self.xAxisScale(d)
          : null;
      }
  
      axis
        .append('g')
        .selectAll('.Label')
        .data(this.verticalRange)
        .enter().append('text')
        .attr('x', function (d) {
          return d;
        })
        .attr('y', function () { return self.chartHeight() + 15; })
        .attr('text-anchor', adjustTextAnchor)
        .text(function (d) {
          var value = verticalToValue(d);
          if (_.isFinite(value)) {
            return self.formatter(value);
          }
        });
  
      return axis;
    },
  
    _getMinValueFromBinIndex: function (binIndex) {
      var data = this.model.get('data');
      var dataBin = data[binIndex];
      if (dataBin) {
        return dataBin.min != null ? dataBin.min : dataBin.start;
      } else {
        return null;
      }
    },
  
    _getMaxValueFromBinIndex: function (binIndex) {
      var result = null;
      var data = this.model.get('data');
      var dataBin = data[binIndex];
      if (dataBin) {
        if (this._isDateTimeSeries() && !_.isUndefined(dataBin.next)) {
          result = dataBin.next;
        } else {
          result = dataBin.min != null ? dataBin.max : dataBin.end;
        }
      }
  
      return result;
    },
  
    _getValueFromBinIndex: function (index) {
      if (!_.isNumber(index)) {
        return null;
      }
      var result = null;
      var fromStart = true;
      var data = this.model.get('data');
      if (index >= data.length) {
        index = data.length - 1;
        fromStart = false;
      }
      var dataBin = data[index];
      if (dataBin) {
        result = fromStart ? dataBin.start : _.isFinite(dataBin.next) ? dataBin.next : dataBin.end;
      }
  
      return result;
    },
  
    _getIndexFromValue: function (value) {
      var index = _.findIndex(this.model.get('data'), function (bin) {
        return bin.start <= value && value <= bin.end;
      });
      return index;
    },
  
    _getMaxFromData: function () {
      return this.model.get('data').length > 0
        ? _.last(this.model.get('data')).end
        : null;
    },
  
    // Calculates the domain ([ min, max ]) of the selected data. If there is no selection ongoing,
    // it will take the first and last buckets with frequency.
    _calculateDataDomain: function () {
      var data = _.clone(this.model.get('data'));
      var minBin;
      var maxBin;
      var minValue;
      var maxValue;
  
      if (!this._hasFilterApplied()) {
        minValue = this._getMinValueFromBinIndex(0);
        maxValue = this._getMaxValueFromBinIndex(data.length - 1);
  
        minBin = _.find(data, function (d) {
          return d.freq !== 0;
        });
  
        maxBin = _.find(data.reverse(), function (d) {
          return d.freq !== 0;
        });
      } else {
        var loBarIndex = this._getLoBarIndex();
        var hiBarIndex = this._getHiBarIndex() - 1;
        var filteredData = data.slice(loBarIndex, hiBarIndex);
  
        if (_.isNaN(loBarIndex) || _.isNaN(hiBarIndex)) {
          return [0, 0];
        }
  
        minValue = this._getMinValueFromBinIndex(loBarIndex);
        maxValue = this._getMaxValueFromBinIndex(hiBarIndex);
  
        if (data[loBarIndex] && data[loBarIndex].freq === 0) {
          minBin = _.find(filteredData, function (d) {
            return d.freq !== 0;
          }, this);
        }
  
        if (data[hiBarIndex] && data[hiBarIndex].freq === 0) {
          var reversedData = filteredData.reverse();
          maxBin = _.find(reversedData, function (d) {
            return d.freq !== 0;
          }, this);
        }
      }
  
      minValue = minBin ? (minBin.min != null ? minBin.min : minBin.start) : minValue;
      maxValue = maxBin ? (maxBin.max != null ? maxBin.max : maxBin.end) : maxValue;
  
      return [minValue, maxValue];
    },
  
    _removeFillGradients: function () {
      var defs = d3.select(this.el).select('defs');
      defs.remove();
      delete this._linearGradients;
    },
  
    _areGradientsAlreadyGenerated: function () {
      return !!this._linearGradients;
    },
  
    // Generate a linear-gradient with several stops for each bar
    // in order to generate the proper colors ramp. It will depend
    // of the domain of the selected data.
    _generateFillGradients: function () {
      if (!this._widgetModel || !this._widgetModel.isAutoStyleEnabled()) {
        return false;
      }
  
      var obj = this._widgetModel.getAutoStyle();
  
      if (_.isEmpty(obj) || _.isEmpty(obj.definition)) {
        return false;
      }
  
      var self = this;
      var geometryDefinition = obj.definition[Object.keys(obj.definition)[0]]; // Gets first definition by geometry
      var colorsRange = geometryDefinition && geometryDefinition.color && geometryDefinition.color.range;
      var interpolatedColors = d3Interpolate.interpolateRgbBasis(colorsRange);
      var colorsRangeHover = _.map(colorsRange, function (color) {
        return d3.rgb(color).darker(0.3).toString();
      });
      var interpolatedHoverColors = d3Interpolate.interpolateRgbBasis(colorsRangeHover);
      var data = this.model.get('data');
      var domain = this._calculateDataDomain();
      var domainScale = d3.scale.linear().domain(domain).range([0, 1]);
      var defs = d3.select(this.el).append('defs');
      var stopsNumber = 4; // It is not necessary to create as many stops as colors
  
      this._linearGradients = defs
        .selectAll('.gradient')
        .data(data)
        .enter()
        .append('linearGradient')
        .attr('class', 'gradient')
        .attr('id', function (d, i) {
          // This is the scale for each bin, used in each stop within this gradient
          this.__scale__ = d3.scale.linear()
            .range([ self._getMinValueFromBinIndex(i), self._getMaxValueFromBinIndex(i) ])
            .domain([0, 1]);
          return 'bar-' + self.cid + '-' + i;
        })
        .attr('x1', '0%')
        .attr('y1', '0%')
        .attr('x2', '100%')
        .attr('y2', '0%');
  
      this._linearGradientsHover = defs
        .selectAll('.gradient-hover')
        .data(data)
        .enter()
        .append('linearGradient')
        .attr('class', 'gradient-hover')
        .attr('id', function (d, i) {
          // This is the scale for each bin, used in each stop within this gradient
          this.__scale__ = d3.scale.linear()
            .range([self._getMinValueFromBinIndex(i), self._getMaxValueFromBinIndex(i)])
            .domain([0, 1]);
          return 'bar-' + self.cid + '-' + i + '-hover';
        })
        .attr('x1', '0%')
        .attr('y1', '0%')
        .attr('x2', '100%')
        .attr('y2', '0%');
  
      this._linearGradients
        .selectAll('stop')
        .data(d3.range(stopsNumber + 1))
        .enter()
        .append('stop')
        .attr('offset', function (d, i) {
          var offset = this.__offset__ = Math.floor(((i) / stopsNumber) * 100);
          return (offset + '%');
        })
        .attr('stop-color', function () {
          var localScale = this.parentNode.__scale__;
          var interpolateValue = domainScale(localScale(this.__offset__ / 100));
          return interpolatedColors(interpolateValue);
        });
  
      this._linearGradientsHover
        .selectAll('stop')
        .data(d3.range(stopsNumber + 1))
        .enter()
        .append('stop')
        .attr('offset', function (d, i) {
          var offset = this.__offset__ = Math.floor(((i) / stopsNumber) * 100);
          return (offset + '%');
        })
        .attr('stop-color', function () {
          var localScale = this.parentNode.__scale__;
          var interpolateValue = domainScale(localScale(this.__offset__ / 100));
          return interpolatedHoverColors(interpolateValue);
        });
    },
  
    _setupFillColor: function () {
      this._removeFillGradients();
      this._generateFillGradients();
    },
  
    _getFillColor: function (d, i) {
      if (this._widgetModel) {
        if (this._widgetModel.isAutoStyle()) {
          if (this._hasFilterApplied()) {
            if (!this._isBarChartWithinFilter(i)) {
              return UNFILTERED_COLOR;
            }
          }
  
          return 'url(#bar-' + this.cid + '-' + i + ')';
        } else {
          if (this._hasFilterApplied()) {
            if (this._isBarChartWithinFilter(i)) {
              return FILTERED_COLOR;
            } else {
              return UNFILTERED_COLOR;
            }
          }
  
          return this._widgetModel.getWidgetColor() || this.options.chartBarColor;
        }
      }
  
      return this.options.chartBarColor;
    },
  
    _getHoverFillColor: function (d, i) {
      var currentFillColor = this._getFillColor(d, i);
  
      if (this._widgetModel) {
        if (this._widgetModel.isAutoStyle()) {
          return 'url(#bar-' + this.cid + '-' + i + '-hover)';
        }
      }
  
      return d3.rgb(currentFillColor).darker(0.3).toString();
    },
  
    _updateChart: function () {
      var self = this;
      var data = this.model.get('data');
  
      var bars = this.chart.selectAll('.CDB-Chart-bar')
        .data(data);
  
      bars
        .enter()
        .append('rect')
        .attr('class', 'CDB-Chart-bar')
        .attr('fill', this._getFillColor.bind(this))
        .attr('x', function (d, i) {
          return i * self.barWidth;
        })
        .attr('y', self.chartHeight())
        .attr('height', 0)
        .attr('width', Math.max(0, this.barWidth - 1));
  
      bars
        .attr('data-tooltip', function (d) {
          return self._tooltipFormatter(d.freq);
        })
        .transition()
        .duration(200)
        .attr('height', function (d) {
          if (_.isEmpty(d)) {
            return 0;
          }
  
          if (self._isMobileViewport() && self._isTimeSeries()) {
            return MOBILE_BAR_HEIGHT;
          }
  
          var h = self.chartHeight() - self.yScale(d.freq);
  
          if (h < self.options.minimumBarHeight && h > 0) {
            h = self.options.minimumBarHeight;
          }
          return h;
        })
        .attr('y', function (d) {
          if (_.isEmpty(d)) {
            return self.chartHeight();
          }
  
          if (self._isMobileViewport() && self._isTimeSeries()) {
            return self.chartHeight() / 2 + MOBILE_BAR_HEIGHT;
          }
  
          var h = self.chartHeight() - self.yScale(d.freq);
  
          if (h < self.options.minimumBarHeight && h > 0) {
            return self.chartHeight() - self.options.minimumBarHeight;
          } else {
            return self.yScale(d.freq);
          }
        });
  
      bars
        .exit()
        .transition()
        .duration(200)
        .attr('height', function () {
          return 0;
        })
        .attr('y', function () {
          return self.chartHeight();
        });
    },
  
    _refreshBarsColor: function () {
      this.chart
        .selectAll('.CDB-Chart-bar')
        .classed('is-highlighted', false)
        .attr('fill', this._getFillColor.bind(this));
    },
  
    _isMobileViewport: function () {
      return viewportUtils.isMobileViewport();
    },
  
    _generateBars: function () {
      var self = this;
      var data = this.model.get('data');
  
      this._calcBarWidth();
      // Remove spacing if not enough room for the smallest case, or mobile viewport
      var spacing = ((((data.length * 2) - 1) > this.chartWidth() || this._isMobileViewport()) && this._isDateTimeSeries()) ? 0 : 1;
  
      var bars = this.chart.append('g')
        .attr('transform', 'translate(0, 0)')
        .attr('class', 'CDB-Chart-bars')
        .selectAll('.CDB-Chart-bar')
        .data(data);
  
      bars
        .enter()
        .append('rect')
        .attr('class', 'CDB-Chart-bar')
        .attr('fill', this._getFillColor.bind(self))
        .attr('x', function (d, i) {
          return i * self.barWidth;
        })
        .attr('y', self.chartHeight())
        .attr('height', 0)
        .attr('data-tooltip', function (d) {
          return self._tooltipFormatter(d.freq);
        })
        .attr('width', Math.max(1, this.barWidth - spacing));
  
      bars
        .attr('data-tooltip', function (d) {
          return self._tooltipFormatter(d.freq);
        })
        .transition()
        .ease(this.options.transitionType)
        .duration(this.options.animationSpeed)
        .delay(this.options.animationBarDelay)
        .transition()
        .attr('height', function (d) {
          if (_.isEmpty(d)) {
            return 0;
          }
  
          if (self._isMobileViewport() && self._isTimeSeries()) {
            return MOBILE_BAR_HEIGHT;
          }
  
          var h = self.chartHeight() - self.yScale(d.freq);
          if (h < self.options.minimumBarHeight && h > 0) {
            h = self.options.minimumBarHeight;
          }
  
          return h;
        })
        .attr('y', function (d) {
          if (_.isEmpty(d)) {
            return self.chartHeight();
          }
  
          if (self._isMobileViewport() && self._isTimeSeries()) {
            return self.chartHeight() / 2 + MOBILE_BAR_HEIGHT;
          }
  
          var h = self.chartHeight() - self.yScale(d.freq);
  
          if (h < self.options.minimumBarHeight && h > 0) {
            return self.chartHeight() - self.options.minimumBarHeight;
          } else {
            return self.yScale(d.freq);
          }
        });
    },
  
    showShadowBars: function () {
      if (this.options.displayShadowBars) {
        this.model.set('show_shadow_bars', true);
      }
    },
  
    _generateShadowBars: function () {
      var data = this._getData();
  
      if (!data || !data.length || !this.model.get('show_shadow_bars') || this.model.get('normalized')) {
        this._removeShadowBars();
        return;
      }
  
      this._removeShadowBars();
  
      var self = this;
  
      var yScale = d3.scale.linear().domain([0, this._getMaxData(data)]).range([this.chartHeight(), 0]);
  
      var barWidth = this.chartWidth() / data.length;
  
      this.chart.append('g')
        .attr('transform', 'translate(0, 0)')
        .attr('class', 'CDB-Chart-shadowBars')
        .selectAll('.CDB-Chart-shadowBar')
        .data(data)
        .enter()
        .append('rect')
        .attr('class', 'CDB-Chart-shadowBar')
        .attr('x', function (d, i) {
          return i * barWidth;
        })
        .attr('y', function (d) {
          if (_.isEmpty(d)) {
            return self.chartHeight();
          }
  
          var h = self.chartHeight() - yScale(d.freq);
  
          if (h < self.options.minimumBarHeight && h > 0) {
            return self.chartHeight() - self.options.minimumBarHeight;
          } else {
            return yScale(d.freq);
          }
        })
        .attr('width', Math.max(0.5, barWidth - 1))
        .attr('height', function (d) {
          if (_.isEmpty(d)) {
            return 0;
          }
  
          var h = self.chartHeight() - yScale(d.freq);
  
          if (h < self.options.minimumBarHeight && h > 0) {
            h = self.options.minimumBarHeight;
          }
          return h;
        });
  
      // We need to explicitly move the lines of the grid behind the shadow bars
      this.chart.selectAll('.CDB-Chart-shadowBars').moveToBack();
      this.chart.selectAll('.CDB-Chart-lines').moveToBack();
    },
  
    _hasFilterApplied: function () {
      return this.model.get('lo_index') != null && this.model.get('hi_index') != null;
    },
  
    _isTimeSeries: function () {
      return this.options.type.indexOf('time') === 0;
    },
  
    _isDateTimeSeries: function () {
      return this.options.type === 'time-date';
    },
  
    _calculateDivisionWithByAggregation: function (aggregation) {
      switch (aggregation) {
        case 'year':
          return 50;
        case 'quarter':
        case 'month':
          return 80;
        case 'week':
        case 'day':
          return 120;
        default:
          return 140;
      }
    },
  
    _createFormatter: function () {
      this.formatter = formatter.formatNumber;
  
      if (this._isDateTimeSeries()) {
        this.formatter = formatter.timestampFactory(this._dataviewModel.get('aggregation'), this._dataviewModel.getCurrentOffset());
        this.options.divisionWidth = this._calculateDivisionWithByAggregation(this._dataviewModel.get('aggregation'));
      }
    },
  
    unsetBounds: function () {
      this.model.set('bounded', false);
      this.updateYScale();
      this.contract(this.options.height);
      this.resetIndexes();
      this.removeSelection();
      this._setupFillColor();
    },
  
    setBounds: function () {
      this.model.set('bounded', true);
      this.updateYScale();
      this.expand(4);
      this.removeShadowBars();
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/histogram/content-view.js":
  /*!********************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/histogram/content-view.js ***!
    \********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var formatter = __webpack_require__(/*! ../../formatter */ "./lib/assets/javascripts/deep-insights/formatter.js");
  var HistogramTitleView = __webpack_require__(/*! ./histogram-title-view */ "./lib/assets/javascripts/deep-insights/widgets/histogram/histogram-title-view.js");
  var HistogramChartView = __webpack_require__(/*! ./chart */ "./lib/assets/javascripts/deep-insights/widgets/histogram/chart.js");
  var placeholder = __webpack_require__(/*! ./placeholder.tpl */ "./lib/assets/javascripts/deep-insights/widgets/histogram/placeholder.tpl");
  var template = __webpack_require__(/*! ./content.tpl */ "./lib/assets/javascripts/deep-insights/widgets/histogram/content.tpl");
  var DropdownView = __webpack_require__(/*! ../dropdown/widget-dropdown-view */ "./lib/assets/javascripts/deep-insights/widgets/dropdown/widget-dropdown-view.js");
  var TipsyTooltipView = __webpack_require__(/*! ../../../builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  var AnimateValues = __webpack_require__(/*! ../animate-values.js */ "./lib/assets/javascripts/deep-insights/widgets/animate-values.js");
  var animationTemplate = __webpack_require__(/*! ./animation-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/histogram/animation-template.tpl");
  var layerColors = __webpack_require__(/*! ../../util/layer-colors */ "./lib/assets/javascripts/deep-insights/util/layer-colors.js");
  var analyses = __webpack_require__(/*! ../../data/analyses */ "./lib/assets/javascripts/deep-insights/data/analyses.js");
  var escapeHTML = __webpack_require__(/*! ../../util/escape-html */ "./lib/assets/javascripts/deep-insights/util/escape-html.js");
  
  var TABLET_VIEWPORT_BREAKPOINT = 1200;
  
  /**
   * Widget content view for a histogram
   */
  module.exports = CoreView.extend({
    className: 'CDB-Widget-body',
  
    defaults: {
      chartHeight: 48 + 20 + 4
    },
  
    events: {
      'click .js-clear': '_resetWidget',
      'click .js-zoom': '_zoom'
    },
  
    initialize: function () {
      this._dataviewModel = this.model.dataviewModel;
      this._layerModel = this.model.layerModel;
      this._originalData = this._dataviewModel.getUnfilteredDataModel();
      this.filter = this._dataviewModel.filter;
      this.lockedByUser = false;
      this._numberOfFilters = 0;
      this._initStateApplied = false;
  
      if (this._originalData.get('hasBeenFetched')) {
        this._initBinds();
      } else {
        this.listenToOnce(this._originalData, 'change:hasBeenFetched', function () {
          this._initBinds();
        });
      }
  
      window.addEventListener('resize', this._onWindowResized.bind(this), { passive: true });
    },
  
    render: function () {
      this.clearSubViews();
      this._unbinds();
  
      this.$el.toggleClass('is-collapsed', !!this.model.get('collapsed'));
  
      var data = this._dataviewModel.getData();
      var hasNulls = this._dataviewModel.hasNulls();
      var originalData = this._originalData.getData();
      var isDataEmpty = !_.size(data) && !_.size(originalData);
  
      var sourceId = this._dataviewModel.get('source').id;
      var letter = layerColors.letter(sourceId);
      var sourceColor = layerColors.getColorForLetter(letter);
      var sourceType = this._dataviewModel.getSourceType() || '';
      var isSourceType = this._dataviewModel.isSourceType();
      var layerName = isSourceType
        ? this.model.get('table_name')
        : this._layerModel.get('layer_name');
  
      this.$el.html(
        template({
          title: this.model.get('title'),
          sourceId: sourceId,
          sourceType: analyses.title(sourceType),
          isSourceType: isSourceType,
          showStats: this.model.get('show_stats'),
          showNulls: hasNulls,
          showSource: this.model.get('show_source') && letter !== '',
          itemsCount: !isDataEmpty ? data.length : '-',
          isCollapsed: !!this.model.get('collapsed'),
          sourceColor: sourceColor,
          layerName: escapeHTML(layerName)
        })
      );
  
      if (isDataEmpty) {
        this._addPlaceholder();
        this._initTitleView();
      } else {
        this._setupBindings();
        this._initViews();
      }
  
      return this;
    },
  
    _initViews: function () {
      this._initTitleView();
      this._initDropdownView();
      this._renderMiniChart();
      this._renderMainChart();
      this._renderAllValues();
    },
  
    _onWindowResized: function () {
      if (window.innerWidth < TABLET_VIEWPORT_BREAKPOINT) {
        this.histogramChartView && this.histogramChartView.forceResize();
      }
    },
  
    _initDropdownView: function () {
      var dropdown = new DropdownView({
        model: this.model,
        target: '.js-actions',
        container: this.$('.js-header'),
        flags: {
          normalizeHistogram: true
        }
      });
  
      this.addView(dropdown);
    },
  
    _toggleTooltip: function (event) {
      if (!event || !event.target) {
        return this._clearTooltip();
      }
  
      this._showTooltip(event);
    },
  
    _showTooltip: function (event) {
      if (this.tooltip && event && this.tooltip.getElement() === event.target) {
        return;
      }
  
      this._clearTooltip();
  
      this.tooltip = new TipsyTooltipView({
        el: event.target,
        title: 'data-tooltip',
        trigger: 'manual'
      });
  
      this.tooltip.showTipsy();
      this.addView(this.tooltip);
    },
  
    _clearTooltip: function () {
      if (!this.tooltip) return;
  
      this.tooltip.hideTipsy();
      this.removeView(this.tooltip);
      this.tooltip = undefined;
    },
  
    _initTitleView: function () {
      var titleView = new HistogramTitleView({
        widgetModel: this.model,
        dataviewModel: this._dataviewModel,
        layerModel: this._layerModel
      });
  
      this.$('.js-title').append(titleView.render().el);
      this.addView(titleView);
    },
  
    _initBinds: function () {
      this.listenTo(this.model, 'change:collapsed', this.render);
      this.listenTo(this.model, 'change:normalized', this._onNormalizedChanged);
  
      if (this.model.get('hasInitialState') === true) {
        this._setInitialState();
      } else {
        this.listenTo(this.model, 'change:hasInitialState', this._setInitialState);
      }
  
      this.listenTo(this._layerModel, 'change:layer_name', this.render);
    },
  
    _setInitialState: function () {
      var data = this._dataviewModel.getData();
      if (data.length === 0) {
        this._dataviewModel.once('change:data', this._onInitialState, this);
      } else {
        this._onInitialState();
      }
    },
  
    _onNormalizedChanged: function () {
      var normalized = this.model.get('normalized');
      this.histogramChartView.setNormalized(normalized);
      this.miniHistogramChartView.setNormalized(normalized);
    },
  
    _onInitialState: function () {
      this.add_related_model(this._dataviewModel);
      this.render();
  
      if (this.model.get('autoStyle') === true) {
        this.model.autoStyle();
      }
  
      if (this._hasRange()) {
        this._numberOfFilters = 1;
      }
  
      // in order to calculate the stats right, we simulate the full zommmed range
      if (this._isZoomed()) {
        this._numberOfFilters = 2;
      }
  
      if (this._numberOfFilters !== 0) {
        this._setInitialRange();
      } else {
        this._completeInitialState();
      }
    },
  
    _setupRange: function (data, min, max, updateCallback) {
      var lo = 0;
      var hi = data.length;
      var startMin;
      var startMax;
  
      if (_.isNumber(min)) {
        startMin = _.findWhere(data, {start: min});
        lo = startMin ? startMin.bin : 0;
      }
  
      if (_.isNumber(max)) {
        startMax = _.findWhere(data, {end: max});
        hi = startMax ? startMax.bin + 1 : data.length;
      }
  
      if ((lo && lo !== 0) || (hi && hi !== data.length)) {
        this.filter.setRange(
          data[lo].start,
          data[hi - 1].end
        );
        this._onChangeFilterEnabled();
        this.histogramChartView.selectRange(lo, hi);
      }
  
      updateCallback && updateCallback(lo, hi);
    },
  
    _setInitialRange: function () {
      var data = this._dataviewModel.getData();
      var min = this.model.get('min');
      var max = this.model.get('max');
      var filterEnabled = (min !== undefined || max !== undefined);
  
      this._setupRange(data, min, max, function (lo, hi) {
        this.model.set({ filter_enabled: filterEnabled, lo_index: lo, hi_index: hi });
        this._dataviewModel.bind('change:data', this._onHistogramDataChanged, this);
        this._initStateApplied = true;
  
        // If zoomed, we open the zoom level. Internally it does a fetch, so a change:data is triggered
        // and the _onHistogramDataChanged callback will do the _updateStats call.
        if (this._isZoomed()) {
          this._onChangeZoomEnabled();
          this._onZoomIn();
        } else {
          this._updateStats();
        }
      }.bind(this));
    },
  
    _completeInitialState: function () {
      this._dataviewModel.bind('change:data', this._onHistogramDataChanged, this);
      this._initStateApplied = true;
      this._updateStats();
    },
  
    _isZoomed: function () {
      return this.model.get('zoomed');
    },
  
    _hasRange: function () {
      var min = this.model.get('min');
      var max = this.model.get('max');
  
      return (min != null || max != null);
    },
  
    _onHistogramDataChanged: function () {
      // When the histogram is zoomed, we don't need to rely
      // on the change url to update the histogram
      // TODO the widget should not know about the URL could this state be got from the dataview model somehow?
      if (this._dataviewModel.changed.url && this._isZoomed()) {
        return;
      }
  
      // if the action was initiated by the user
      // don't replace the stored data
      if (this.lockedByUser) {
        this.lockedByUser = false;
      } else {
        if (!this._isZoomed()) {
          this.histogramChartView.showShadowBars();
          this.miniHistogramChartView.replaceData(this._dataviewModel.getData());
        } else {
          this._filteredData = this._dataviewModel.getData();
        }
        this.histogramChartView.replaceData(this._dataviewModel.getData());
      }
  
      if (this.unsettingRange) {
        this._unsetRange();
      }
  
      this._updateStats();
    },
  
    _unsetRange: function () {
      this.unsettingRange = false;
      this.histogramChartView.replaceData(this._dataviewModel.getData());
      this.model.set({ lo_index: null, hi_index: null });
  
      if (!this._isZoomed()) {
        this.histogramChartView.showShadowBars();
      }
    },
  
    _addPlaceholder: function () {
      this.$('.js-content').append(placeholder());
    },
  
    _renderMainChart: function () {
      this.histogramChartView = new HistogramChartView(({
        type: 'histogram',
        margin: { top: 4, right: 4, bottom: 4, left: 4 },
        hasHandles: true,
        hasAxisTip: true,
        chartBarColor: this.model.getColor() || '#9DE0AD',
        width: this.canvasWidth,
        height: this.defaults.chartHeight,
        data: this._dataviewModel.getData(),
        dataviewModel: this._dataviewModel,
        layerModel: this._layerModel,
        originalData: this._originalData,
        displayShadowBars: !this.model.get('normalized'),
        normalized: this.model.get('normalized'),
        widgetModel: this.model
      }));
  
      this.$('.js-chart').append(this.histogramChartView.el);
      this.addView(this.histogramChartView);
  
      this.histogramChartView.bind('on_brush_end', this._onBrushEnd, this);
      this.histogramChartView.bind('hover', this._toggleTooltip, this);
      this.histogramChartView.render().show();
  
      this._updateStats();
    },
  
    _renderMiniChart: function () {
      this.miniHistogramChartView = new HistogramChartView(({
        type: 'histogram',
        className: 'CDB-Chart--mini',
        mini: true,
        margin: { top: 0, right: 4, bottom: 4, left: 4 },
        height: 40,
        showOnWidthChange: false,
        dataviewModel: this._dataviewModel,
        layerModel: this._layerModel,
        data: this._dataviewModel.getData(),
        normalized: this.model.get('normalized'),
        chartBarColor: this.model.getColor() || '#9DE0AD',
        originalData: this._originalData,
        widgetModel: this.model
      }));
  
      this.addView(this.miniHistogramChartView);
      this.$('.js-mini-chart').append(this.miniHistogramChartView.el);
      this.miniHistogramChartView.bind('on_brush_end', this._onMiniRangeUpdated, this);
      this.miniHistogramChartView.render();
    },
  
    _setupBindings: function () {
      this._dataviewModel.bind('change:bins', this._onChangeBins, this);
      this.model.bind('change:zoomed', this._onChangeZoomed, this);
      this.model.bind('change:zoom_enabled', this._onChangeZoomEnabled, this);
      this.model.bind('change:filter_enabled', this._onChangeFilterEnabled, this);
      this.model.bind('change:total', this._onChangeTotal, this);
      this.model.bind('change:nulls', this._onChangeNulls, this);
      this.model.bind('change:max', this._onChangeMax, this);
      this.model.bind('change:min', this._onChangeMin, this);
      this.model.bind('change:avg', this._onChangeAvg, this);
    },
  
    _unbinds: function () {
      this._dataviewModel.off('change:bins', this._onChangeBins, this);
      this.model.off('change:zoomed', this._onChangeZoomed, this);
      this.model.off('change:zoom_enabled', this._onChangeZoomEnabled, this);
      this.model.off('change:filter_enabled', this._onChangeFilterEnabled, this);
      this.model.off('change:total', this._onChangeTotal, this);
      this.model.off('change:nulls', this._onChangeNulls, this);
      this.model.off('change:max', this._onChangeMax, this);
      this.model.off('change:min', this._onChangeMin, this);
      this.model.off('change:avg', this._onChangeAvg, this);
    },
  
    _onMiniRangeUpdated: function (loBarIndex, hiBarIndex) {
      this.lockedByUser = false;
  
      this._clearTooltip();
      this.histogramChartView.removeSelection();
  
      var data = this._originalData.getData();
  
      this.model.set({lo_index: loBarIndex, hi_index: hiBarIndex, zlo_index: null, zhi_index: null});
      this._applyBrushFilter(data, loBarIndex, hiBarIndex);
    },
  
    _onBrushEnd: function (loBarIndex, hiBarIndex) {
      if (this._isZoomed()) {
        this._onBrushEndFiltered(loBarIndex, hiBarIndex);
      } else {
        this._onBrushEndUnfiltered(loBarIndex, hiBarIndex);
      }
    },
  
    _onBrushEndFiltered: function (loBarIndex, hiBarIndex) {
      var data = this._filteredData;
      if ((!data || !data.length) || (this.model.get('zlo_index') === loBarIndex && this.model.get('zhi_index') === hiBarIndex)) {
        return;
      }
  
      this._numberOfFilters = 2;
      this.lockedByUser = true;
      this.model.set({filter_enabled: true, zlo_index: loBarIndex, zhi_index: hiBarIndex});
      this._applyBrushFilter(data, loBarIndex, hiBarIndex);
    },
  
    _onBrushEndUnfiltered: function (loBarIndex, hiBarIndex) {
      var data = this._dataviewModel.getData();
      if ((!data || !data.length) || (this.model.get('lo_index') === loBarIndex && this.model.get('hi_index') === hiBarIndex)) {
        return;
      }
      this._numberOfFilters = 1;
      this.model.set({filter_enabled: true, zoom_enabled: true, lo_index: loBarIndex, hi_index: hiBarIndex});
      this._applyBrushFilter(data, loBarIndex, hiBarIndex);
    },
  
    _applyBrushFilter: function (data, loBarIndex, hiBarIndex) {
      if (loBarIndex !== hiBarIndex && loBarIndex >= 0 && loBarIndex < data.length && (hiBarIndex - 1) >= 0 && (hiBarIndex - 1) < data.length) {
        this.filter.setRange(
          data[loBarIndex].start,
          data[hiBarIndex - 1].end
        );
        this._updateStats();
      } else {
        console.error('Error accessing array bounds', loBarIndex, hiBarIndex, data);
      }
    },
  
    _onChangeFilterEnabled: function () {
      this.$('.js-filter').toggleClass('is-hidden', !this.model.get('filter_enabled'));
    },
  
    _onChangeBins: function (mdl, bins) {
      this._resetWidget();
    },
  
    _onChangeZoomEnabled: function () {
      this.$('.js-zoom').toggleClass('is-hidden', !this.model.get('zoom_enabled'));
    },
  
    _renderAllValues: function () {
      this._changeHeaderValue('.js-nulls', 'nulls', '');
      this._changeHeaderValue('.js-val', 'total', 'SELECTED');
      this._changeHeaderValue('.js-max', 'max', '');
      this._changeHeaderValue('.js-min', 'min', '');
      this._changeHeaderValue('.js-avg', 'avg', '');
    },
  
    _changeHeaderValue: function (className, what, suffix) {
      if (this.model.get(what) == null) {
        this.$(className).text('0 ' + suffix);
        return;
      }
  
      this._addTitleForValue(className, what, suffix);
  
      var animator = new AnimateValues({
        el: this.$el
      });
  
      animator.animateValue(this.model, what, className, animationTemplate, {
        formatter: formatter.formatNumber,
        templateData: { suffix: ' ' + suffix }
      });
    },
  
    _onChangeNulls: function () {
      this._changeHeaderValue('.js-nulls', 'nulls', '');
    },
  
    _onChangeTotal: function () {
      this._changeHeaderValue('.js-val', 'total', 'SELECTED');
    },
  
    _onChangeMax: function () {
      this._changeHeaderValue('.js-max', 'max', '');
    },
  
    _onChangeMin: function () {
      this._changeHeaderValue('.js-min', 'min', '');
    },
  
    _onChangeAvg: function () {
      this._changeHeaderValue('.js-avg', 'avg', '');
    },
  
    _addTitleForValue: function (className, what, unit) {
      this.$(className).attr('title', this._formatNumberWithCommas(this.model.get(what).toFixed(2)) + ' ' + unit);
    },
  
    _formatNumberWithCommas: function (x) {
      return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    },
  
    _calculateBars: function (data) {
      var min;
      var max;
      var loBarIndex;
      var hiBarIndex;
      var startMin;
      var startMax;
  
      if (this._isZoomed() && this._numberOfFilters === 2) {
        min = this.model.get('zmin');
        max = this.model.get('zmax');
        loBarIndex = this.model.get('zlo_index');
        hiBarIndex = this.model.get('zhi_index');
      } else if (this._numberOfFilters === 1) {
        min = this.model.get('min');
        max = this.model.get('max');
        loBarIndex = this.model.get('lo_index');
        hiBarIndex = this.model.get('hi_index');
      }
  
      if (data.length > 0) {
        if (!_.isNumber(min) && !_.isNumber(loBarIndex)) {
          loBarIndex = 0;
        } else if (_.isNumber(min) && !_.isNumber(loBarIndex)) {
          startMin = _.findWhere(data, {start: min});
          loBarIndex = (startMin && startMin.bin) || 0;
        }
  
        if (!_.isNumber(max) && !_.isNumber(hiBarIndex)) {
          hiBarIndex = data.length;
        } else if (_.isNumber(max) && !_.isNumber(hiBarIndex)) {
          startMax = _.findWhere(data, {end: max});
          hiBarIndex = (startMax && startMax.bin + 1) || data.length;
        }
      } else {
        loBarIndex = 0;
        hiBarIndex = data.length;
      }
  
      return {
        loBarIndex: loBarIndex,
        hiBarIndex: hiBarIndex
      };
    },
  
    _updateStats: function () {
      if (!this._initStateApplied) return;
      var data;
  
      if (!this._isZoomed() || (this._isZoomed() && this._numberOfFilters === 2)) {
        data = this.histogramChartView.model.get('data');
      } else {
        data = this.miniHistogramChartView.model.get('data');
      }
  
      if (data == null) {
        return;
      }
  
      var nulls = this._dataviewModel.get('nulls');
      var bars = this._calculateBars(data);
      var loBarIndex = bars.loBarIndex;
      var hiBarIndex = bars.hiBarIndex;
      var sum, avg, min, max;
      var attrs;
  
      if (data && data.length) {
        sum = this._calcSum(data, loBarIndex, hiBarIndex);
        avg = this._calcAvg(data, loBarIndex, hiBarIndex);
  
        if (loBarIndex >= 0 && loBarIndex < data.length) {
          min = data[loBarIndex].start;
        }
  
        if (hiBarIndex >= 0 && hiBarIndex - 1 < data.length) {
          max = data[Math.max(0, hiBarIndex - 1)].end;
        }
  
        if (this._isZoomed() && this._numberOfFilters === 2) {
          attrs = {zmin: min, zmax: max, zlo_index: loBarIndex, zhi_index: hiBarIndex};
        } else if (!this._isZoomed() && this._numberOfFilters === 1) {
          attrs = {min: min, max: max, lo_index: loBarIndex, hi_index: hiBarIndex};
        }
  
        attrs = _.extend(
          { total: sum, nulls: nulls, avg: avg },
          attrs);
  
        this.model.set(attrs);
      }
    },
  
    _calcAvg: function (data, start, end) {
      var selectedData = data.slice(start, end);
  
      var total = this._calcSum(data, start, end);
  
      if (!total) {
        return 0;
      }
  
      var area = _.reduce(selectedData, function (memo, d) {
        return (d.avg && d.freq) ? (d.avg * d.freq) + memo : memo;
      }, 0);
  
      return area / total;
    },
  
    _calcSum: function (data, start, end) {
      return _.reduce(data.slice(start, end), function (memo, d) {
        return d.freq + memo;
      }, 0);
    },
  
    _onChangeZoomed: function () {
      if (this.model.get('zoomed')) {
        this._onZoomIn();
      } else {
        this._resetWidget();
        this._dataviewModel.fetch();
      }
    },
  
    _showMiniRange: function () {
      var loBarIndex = this.model.get('lo_index');
      var hiBarIndex = this.model.get('hi_index');
  
      this.miniHistogramChartView.selectRange(loBarIndex, hiBarIndex);
      this.miniHistogramChartView.show();
    },
  
    _zoom: function () {
      this.model.set({ zoomed: true, zoom_enabled: false });
      this.histogramChartView.removeSelection();
    },
  
    _onZoomIn: function () {
      this.lockedByUser = false;
      this._showMiniRange();
      this.histogramChartView.setBounds();
      this._dataviewModel.enableFilter();
      this._dataviewModel.fetch();
    },
  
    _resetWidget: function () {
      this._numberOfFilters = 0;
      this.model.set({
        zoomed: false,
        zoom_enabled: false,
        filter_enabled: false,
        lo_index: null,
        hi_index: null,
        min: null,
        max: null,
        zlo_index: null,
        zhi_index: null,
        zmin: null,
        zmax: null
      });
      this.filter.unsetRange();
      this._dataviewModel.disableFilter();
      this.histogramChartView.unsetBounds();
      this.miniHistogramChartView.hide();
      this._clearTooltip();
      this._updateStats();
    },
  
    clean: function () {
      window.removeEventListener('resize', this._onWindowResized.bind(this));
      CoreView.prototype.clean.apply(this);
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/histogram/histogram-title-view.js":
  /*!****************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/histogram/histogram-title-view.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var TipsyTooltipView = __webpack_require__(/*! ../../../builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  var template = __webpack_require__(/*! ./histogram-title-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/histogram/histogram-title-template.tpl");
  
  /**
   *  Show title + show if histogram sizes are applied or not
   *
   */
  
  module.exports = CoreView.extend({
    className: 'CDB-Widget-title CDB-Widget-contentSpaced',
  
    events: {
      'click .js-autoStyle': '_autoStyle',
      'click .js-cancelAutoStyle': '_cancelAutoStyle'
    },
  
    initialize: function (opts) {
      if (!opts.widgetModel) throw new Error('widgetModel is required');
      if (!opts.dataviewModel) throw new Error('dataviewModel is required');
      if (!opts.layerModel) throw new Error('layerModel is required');
  
      this.widgetModel = opts.widgetModel;
      this.dataviewModel = opts.dataviewModel;
      this._layerModel = opts.layerModel;
      this._initBinds();
    },
  
    render: function () {
      this.clearSubViews();
      this.$el.html(
        template({
          title: this.widgetModel.get('title'),
          isAutoStyleEnabled: this._isAutoStyleButtonVisible(),
          isAutoStyle: this.widgetModel.get('autoStyle'),
          isCollapsed: this.widgetModel.get('collapsed')
        })
      );
      this._initViews();
  
      return this;
    },
  
    _initBinds: function () {
      this.widgetModel.bind('change:title change:collapsed change:autoStyle change:style', this.render, this);
      this.add_related_model(this.widgetModel);
  
      this._layerModel.bind('change:visible change:cartocss', this.render, this);
      this.add_related_model(this._layerModel);
    },
  
    _initViews: function () {
      var sizesTooltip = new TipsyTooltipView({
        el: this.$el.find('.js-sizes'),
        gravity: 'auto'
      });
      this.addView(sizesTooltip);
  
      var actionsTooltip = new TipsyTooltipView({
        el: this.$el.find('.js-actions'),
        gravity: 'auto'
      });
      this.addView(actionsTooltip);
    },
  
    _isAutoStyleButtonVisible: function () {
      var layerModelMeta = this._layerModel.get('meta');
      var cartocss = this._layerModel.get('cartocss') || (layerModelMeta && layerModelMeta.cartocss);
      var hasColorsAutoStyle = cartocss && this.widgetModel.hasColorsAutoStyle();
  
      return this.widgetModel.isAutoStyleEnabled() &&
        this._layerModel.get('visible') &&
        hasColorsAutoStyle;
    },
  
    _autoStyle: function () {
      this.widgetModel.autoStyle();
    },
  
    _cancelAutoStyle: function () {
      this.widgetModel.cancelAutoStyle();
    }
  
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/histogram/histogram-widget-model.js":
  /*!******************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/histogram/histogram-widget-model.js ***!
    \******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var WidgetModel = __webpack_require__(/*! ../widget-model */ "./lib/assets/javascripts/deep-insights/widgets/widget-model.js");
  
  /**
   * Model for a histogram widget
   */
  module.exports = WidgetModel.extend({
    defaults: {
      normalized: true
    },
  
    defaultState: _.extend(
      {
        autoStyle: false,
        normalized: false
      },
      WidgetModel.prototype.defaultState
    ),
  
    initialize: function (attrs, opts) {
      WidgetModel.prototype.initialize.apply(this, arguments);
      this.on('change:collapsed', this._onCollapsedChange, this);
      this.on('change:style', this._updateAutoStyle, this);
      this.dataviewModel.once('change', function () {
        if (this.get('autoStyle')) {
          this.autoStyle();
        }
      }, this);
    },
  
    _onCollapsedChange: function (m, isCollapsed) {
      this.dataviewModel.set('enabled', !isCollapsed);
    },
  
    getState: function () {
      var state = WidgetModel.prototype.getState.call(this);
      var start = this.dataviewModel.get('start');
      var end = this.dataviewModel.get('end');
      var min = this.get('min');
      var max = this.get('max');
  
      var checkRoughEqual = function (a, b) {
        if (_.isNumber(a) && _.isNumber(b) && (a !== b) && Math.abs(a - b) > Math.abs(start - end) * 0.01) {
          return true;
        }
        return false;
      };
  
      if (checkRoughEqual(start, min)) {
        state.min = min;
      } else {
        delete state.min;
      }
  
      if (checkRoughEqual(end, max)) {
        state.max = max;
      } else {
        delete state.max;
      }
  
      if (this.get('zoomed') === true) {
        state.zoomed = true;
      }
  
      return state;
    }
  
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/time-series/content-view.js":
  /*!**********************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/time-series/content-view.js ***!
    \**********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var placeholderTemplate = __webpack_require__(/*! ./placeholder.tpl */ "./lib/assets/javascripts/deep-insights/widgets/time-series/placeholder.tpl");
  var contentTemplate = __webpack_require__(/*! ./content.tpl */ "./lib/assets/javascripts/deep-insights/widgets/time-series/content.tpl");
  var HistogramView = __webpack_require__(/*! ./histogram-view */ "./lib/assets/javascripts/deep-insights/widgets/time-series/histogram-view.js");
  var TimeSeriesHeaderView = __webpack_require__(/*! ./time-series-header-view */ "./lib/assets/javascripts/deep-insights/widgets/time-series/time-series-header-view.js");
  var DropdownView = __webpack_require__(/*! ../dropdown/widget-dropdown-view */ "./lib/assets/javascripts/deep-insights/widgets/dropdown/widget-dropdown-view.js");
  var layerColors = __webpack_require__(/*! ../../util/layer-colors */ "./lib/assets/javascripts/deep-insights/util/layer-colors.js");
  var analyses = __webpack_require__(/*! ../../data/analyses */ "./lib/assets/javascripts/deep-insights/data/analyses.js");
  var escapeHTML = __webpack_require__(/*! ../../util/escape-html */ "./lib/assets/javascripts/deep-insights/util/escape-html.js");
  
  /**
   * Widget content view for a time-series
   */
  module.exports = CoreView.extend({
    className: 'CDB-Widget-body CDB-Widget-body--timeSeries',
  
    initialize: function () {
      if (!this.model.dataviewModel) throw new Error('dataviewModel is required');
      if (!this.model.layerModel) throw new Error('layerModel is required');
  
      this._dataviewModel = this.model.dataviewModel;
      this._layerModel = this.model.layerModel;
      this._selectedAmount = 0;
      this._initBinds();
    },
  
    render: function () {
      this.clearSubViews();
      this.$el.empty();
  
      var sourceId = this._dataviewModel.get('source').id;
      var letter = layerColors.letter(sourceId);
      var sourceColor = layerColors.getColorForLetter(letter);
      var sourceType = this._dataviewModel.getSourceType() || '';
      var isSourceType = this._dataviewModel.isSourceType();
      var layerName = isSourceType
        ? this.model.get('table_name')
        : this._layerModel.get('layer_name');
  
      if (this._isDataEmpty() || this._hasError()) {
        this.$el.append(placeholderTemplate({
          hasTorqueLayer: false
        }));
      } else {
        this.$el.append(contentTemplate({
          sourceId: sourceId,
          sourceType: analyses.title(sourceType),
          isSourceType: isSourceType,
          showSource: this.model.get('show_source') && letter !== '',
          sourceColor: sourceColor,
          layerName: escapeHTML(layerName)
        }));
        this._createHistogramView();
        this._createHeaderView();
        this._createDropdownView();
        this._updateRange();
      }
      return this;
    },
  
    _initBinds: function () {
      this._dataviewModel.once('error', function () {
        console.log('the tiler does not support non-torque layers just yet');
      });
  
      this.listenTo(this._dataviewModel, 'change:data', this.render);
      this.listenToOnce(this.model, 'change:hasInitialState', this.render);
  
      this.listenTo(this._layerModel, 'change:layer_name', this.render);
      this.add_related_model(this._layerModel);
    },
  
    _createHistogramView: function () {
      if (this._histogramView) {
        this._histogramView.remove();
      }
  
      this._histogramView = new HistogramView({
        timeSeriesModel: this.model,
        dataviewModel: this._dataviewModel,
        layerModel: this._layerModel,
        rangeFilter: this._dataviewModel.filter,
        displayShadowBars: !this.model.get('normalized'),
        normalized: !!this.model.get('normalized')
      });
  
      this.addView(this._histogramView);
      this.$('.js-content').append(this._histogramView.render().el);
    },
  
    _createHeaderView: function () {
      if (this._headerView) {
        this._headerView.remove();
      }
  
      this._headerView = new TimeSeriesHeaderView({
        dataviewModel: this._dataviewModel,
        layerModel: this._layerModel,
        rangeFilter: this._dataviewModel.filter,
        timeSeriesModel: this.model,
        showClearButton: true,
        selectedAmount: this._selectedAmount
      });
  
      if (!this._histogramView) {
        throw new Error('Histogram view must be instantiated before the header view');
      }
      this._headerView.bind('resetFilter', this._histogramView.resetFilter, this._histogramView);
      this.addView(this._headerView);
      this.$('.js-title').append(this._headerView.render().el);
    },
  
    _createDropdownView: function () {
      if (this._dropdownView) {
        this._dropdownView.remove();
      }
  
      this._dropdownView = new DropdownView({
        model: this.model,
        target: '.js-actions',
        container: this.$('.js-header'),
        flags: {
          localTimezone: this._dataviewModel.getColumnType() === 'date',
          normalizeHistogram: true,
          canCollapse: false
        }
      });
  
      this.addView(this._dropdownView);
    },
  
    _updateRange: function () {
      var bars = this._calculateBars();
      var bins = this._dataviewModel.get('bins');
      var lo = Math.max(bars.loBarIndex, 0);
      var hi = Math.min(bars.hiBarIndex, bins);
      if (lo > 0 || hi < bins) {
        this._histogramView.selectRange(lo, hi);
      }
    },
  
    _calculateBars: function () {
      var data = this._dataviewModel.getData();
      var min = this.model.get('min');
      var max = this.model.get('max');
      var loBarIndex = this.model.get('lo_index');
      var hiBarIndex = this.model.get('hi_index');
      var startMin;
      var startMax;
  
      if (data.length > 0) {
        if (!_.isNumber(min) && !_.isNumber(loBarIndex)) {
          loBarIndex = 0;
        } else if (_.isNumber(min) && !_.isNumber(loBarIndex)) {
          startMin = _.findWhere(data, {start: min});
          loBarIndex = (startMin && startMin.bin) || 0;
        }
  
        if (!_.isNumber(max) && !_.isNumber(hiBarIndex)) {
          hiBarIndex = data.length;
        } else if (_.isNumber(max) && !_.isNumber(hiBarIndex)) {
          startMax = _.findWhere(data, {end: max});
          hiBarIndex = (startMax && startMax.bin + 1) || data.length;
        }
      } else {
        loBarIndex = 0;
        hiBarIndex = data.length;
      }
  
      return {
        loBarIndex: loBarIndex,
        hiBarIndex: hiBarIndex
      };
    },
  
    _appendView: function (view) {
      this.addView(view);
      this.$el.append(view.render().el);
    },
  
    _isDataEmpty: function () {
      var data = this._dataviewModel.getUnfilteredData();
      return _.isEmpty(data) || _.size(data) === 0;
    },
  
    _hasError: function () {
      return this._dataviewModel.has('error');
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/time-series/histogram-view.js":
  /*!************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/time-series/histogram-view.js ***!
    \************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var HistogramChartView = __webpack_require__(/*! ../histogram/chart */ "./lib/assets/javascripts/deep-insights/widgets/histogram/chart.js");
  var viewportUtils = __webpack_require__(/*! ../../viewport-utils */ "./lib/assets/javascripts/deep-insights/viewport-utils.js");
  var TipsyTooltipView = __webpack_require__(/*! ../../../builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  
  /**
   * Time-series histogram view.
   */
  
  var INLINE_BARS_HEIGHT_PX = 48;
  var BOTTOM_MARGIN_PX = 4;
  var LABELS_PX = 16;
  var MARGINS_PX = 4;
  var INLINE_BARS_HEIGHT_WITHOUT_BOTTOM_PX = 16;
  
  module.exports = CoreView.extend({
    className: 'CDB-Chart--histogram',
  
    options: {
      tooltipDataAttribute: 'data-tooltip'
    },
  
    defaults: {
      histogramChartHeight: INLINE_BARS_HEIGHT_PX +
        BOTTOM_MARGIN_PX +
        LABELS_PX +
        MARGINS_PX,
      histogramChartMobileHeight: INLINE_BARS_HEIGHT_WITHOUT_BOTTOM_PX
    },
  
    initialize: function () {
      if (!this.options.dataviewModel) throw new Error('dataviewModel is required');
      if (!this.options.layerModel) throw new Error('layerModel is required');
  
      this._timeSeriesModel = this.options.timeSeriesModel;
      this._dataviewModel = this.options.dataviewModel;
      this._layerModel = this.options.layerModel;
      this._rangeFilter = this.options.rangeFilter;
      this._originalData = this._dataviewModel.getUnfilteredDataModel();
      this._initBinds();
    },
  
    render: function () {
      this.clearSubViews();
      this._createHistogramView();
      return this;
    },
  
    selectRange: function (loBarIndex, hiBarIndex) {
      this._chartView.selectRange(loBarIndex, hiBarIndex);
    },
  
    resetFilter: function () {
      this._rangeFilter.unsetRange();
    },
  
    _initBinds: function () {
      this.listenTo(this._dataviewModel, 'change:data', this._onChangeData, this);
      this.listenTo(this._dataviewModel, 'change:column', this.resetFilter, this);
      this.listenTo(this._timeSeriesModel, 'change:normalized', this._onNormalizedChanged);
      this.listenTo(this._timeSeriesModel, 'change:local_timezone', this._onChangeLocalTimezone);
      this.listenTo(this._timeSeriesModel, 'forceResize', this._onForceResize);
      this.listenTo(this._rangeFilter, 'change', this._onFilterChanged);
    },
  
    _toggleTooltip: function (event) {
      if (!event || !event.target) {
        return this._clearTooltip();
      }
  
      this._showTooltip(event);
    },
  
    _showTooltip: function (event) {
      if (this.tooltip && event && this.tooltip.getElement() === event.target) {
        return;
      }
  
      this._clearTooltip();
  
      this.tooltip = new TipsyTooltipView({
        el: event.target,
        title: function () {
          return this._getTooltipTitle(event);
        }.bind(this),
        trigger: 'manual'
      });
  
      this.tooltip.showTipsy();
      this.addView(this.tooltip);
    },
  
    _getTooltipTitle: function (event) {
      return $(event.target).attr(this.options.tooltipDataAttribute);
    },
  
    _clearTooltip: function () {
      if (!this.tooltip) return;
  
      this.tooltip.hideTipsy();
      this.removeView(this.tooltip);
      this.tooltip = undefined;
    },
  
    _createHistogramView: function () {
      this._chartView = this._instantiateChartView();
      this.addView(this._chartView);
      this.$el.append(this._chartView.render().el);
      this._chartView.show();
  
      this.listenTo(this._chartView, 'on_brush_end', this._onBrushEnd, this);
      this.listenTo(this._chartView, 'on_reset_filter', this.resetFilter, this);
      this.listenTo(this._chartView, 'hover', this._toggleTooltip, this);
      this.listenTo(this._chartView.model, 'change:width', this._onChangeChartWidth, this);
    },
  
    _instantiateChartView: function () {
      return new HistogramChartView({
        type: this._getChartType(),
        chartBarColor: this._timeSeriesModel.getWidgetColor() || '#F2CC8F',
        animationSpeed: 100,
        margin: {
          top: this._getMarginTop(),
          right: 4,
          bottom: 4,
          left: this._getMarginLeft()
        },
        hasHandles: true,
        handleWidth: 8,
        hasAxisTip: true,
        animationBarDelay: function (d, i) {
          return (i * 3);
        },
        height: this.defaults.histogramChartHeight,
        dataviewModel: this._dataviewModel,
        layerModel: this._layerModel,
        data: this._dataviewModel.getData(),
        originalData: this._originalData,
        displayShadowBars: !this._timeSeriesModel.get('normalized'),
        normalized: !!this._timeSeriesModel.get('normalized'),
        widgetModel: this._timeSeriesModel,
        local_timezone: !!this._timeSeriesModel.get('local_timezone')
      });
    },
  
    _getChartType: function () {
      return 'time-' + this._dataviewModel.getColumnType();
    },
  
    _onChangeData: function () {
      if (this._chartView) {
        this._chartView.replaceData(this._dataviewModel.getData());
        this._chartView.updateXScale();
        this._chartView.updateYScale();
      }
    },
  
    _onBrushEnd: function (loBarIndex, hiBarIndex) {
      var data = this._dataviewModel.getData();
      this._rangeFilter.setRange(
        data[loBarIndex].start,
        data[hiBarIndex - 1].end
      );
      this._timeSeriesModel.set({lo_index: loBarIndex, hi_index: hiBarIndex});
    },
  
    _onChangeChartWidth: function () {
      var isTablet = viewportUtils.isTabletViewport();
      this._chartView.toggleLabels(!isTablet);
  
      var height = isTablet
        ? this.defaults.histogramChartMobileHeight : this.defaults.histogramChartHeight;
  
      this._chartView.model.set('height', height);
    },
  
    _onNormalizedChanged: function () {
      if (this._chartView) {
        this._chartView.setNormalized(this._timeSeriesModel.get('normalized'));
      }
    },
  
    _onChangeLocalTimezone: function () {
      this._dataviewModel.set('localTimezone', this._timeSeriesModel.get('local_timezone'));
    },
  
    _onForceResize: function () {
      this._chartView.forceResize();
    },
  
    _resetFilterInDI: function () {
      this._timeSeriesModel.set({
        min: undefined,
        max: undefined,
        lo_index: undefined,
        hi_index: undefined
      });
      this._chartView.removeSelection();
    },
  
    _onFilterChanged: function () {
      if (!this._rangeFilter.has('min') && !this._rangeFilter.has('max')) {
        this._resetFilterInDI();
      }
    },
  
    _getMarginLeft: function () {
      return 4;
    },
  
    _getMarginTop: function () {
      return viewportUtils.isTabletViewport() ? 0 : 4;
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/time-series/time-series-header-view.js":
  /*!*********************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/time-series/time-series-header-view.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");
  var template = __webpack_require__(/*! ./time-series-header.tpl */ "./lib/assets/javascripts/deep-insights/widgets/time-series/time-series-header.tpl");
  var formatter = __webpack_require__(/*! ../../formatter */ "./lib/assets/javascripts/deep-insights/formatter.js");
  var AnimateValues = __webpack_require__(/*! ../animate-values.js */ "./lib/assets/javascripts/deep-insights/widgets/animate-values.js");
  var animationTemplate = __webpack_require__(/*! ./animation-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/time-series/animation-template.tpl");
  var TipsyTooltipView = __webpack_require__(/*! ../../../builder/components/tipsy-tooltip-view */ "./lib/assets/javascripts/builder/components/tipsy-tooltip-view.js");
  
  /**
   * View to reset render range.
   */
  module.exports = CoreView.extend({
    className: 'CDB-Widget-contentSpaced CDB-Widget-contentFull',
  
    events: {
      'click .js-clear': '_onClick'
    },
  
    options: {
      showClearButton: true
    },
  
    initialize: function (opts) {
      if (!opts.dataviewModel) throw new Error('dataviewModel is required');
      if (!opts.layerModel) throw new Error('layerModel is required');
      if (!opts.rangeFilter) throw new Error('rangeFilter is required');
      if (!opts.timeSeriesModel) throw new Error('timeSeriesModel is required');
      if (opts.selectedAmount === void 0) throw new Error('selectedAmount is required');
  
      this._timeSeriesModel = opts.timeSeriesModel;
      this._dataviewModel = opts.dataviewModel;
      this._rangeFilter = opts.rangeFilter;
      this._selectedAmount = opts.selectedAmount;
      this._layerModel = opts.layerModel;
  
      this.model = new cdb.core.Model();
  
      this._createFormatter();
      this._initBinds();
    },
  
    render: function () {
      var title = this._timeSeriesModel.get('title');
      var showSelection = !this._rangeFilter.isEmpty();
  
      this.$el.html(
        template({
          start: this.model.get('left_axis_tip') || this.formatter(this._rangeFilter.get('min')),
          end: this.model.get('right_axis_tip') || this.formatter(this._rangeFilter.get('max')),
          title: title,
          showClearButton: this.options.showClearButton && showSelection,
          showSelection: showSelection
        })
      );
  
      this._animateValue();
      this._initViews();
  
      return this;
    },
  
    _initViews: function () {
      var actionsTooltip = new TipsyTooltipView({
        el: this.$el.find('.js-actions'),
        gravity: 'auto'
      });
      this.addView(actionsTooltip);
    },
  
    _createFormatter: function () {
      this.formatter = formatter.formatNumber;
  
      if (this._dataviewModel.getColumnType() === 'date') {
        this.formatter = formatter.timestampFactory(this._dataviewModel.get('aggregation'), this._dataviewModel.getCurrentOffset());
      }
    },
  
    _onLocalTimezoneChanged: function () {
      this._createFormatter();
      this.render();
    },
  
    _animateValue: function () {
      var animator = new AnimateValues({
        el: this.$el
      });
      var property = this._rangeFilter.isEmpty() ? 'totalAmount' : 'filteredAmount';
      var to = this._dataviewModel.get(property);
  
      animator.animateFromValues.call(this, this._selectedAmount, to, '.js-val', animationTemplate, {
        formatter: formatter.formatNumber,
        templateData: { suffix: ' Selected' }
      });
  
      this._selectedAmount = to;
    },
  
    _initBinds: function () {
      this.listenTo(this.model, 'change:left_axis_tip change:right_axis_tip', this.render);
      this.listenTo(this._timeSeriesModel, 'change:title', this.render);
      this.listenTo(this._timeSeriesModel, 'change:local_timezone', this._onLocalTimezoneChanged);
      this.listenTo(this._dataviewModel, 'change:totalAmount', this._animateValue);
      this.listenTo(this._dataviewModel, 'on_update_axis_tip', this._onUpdateAxisTip);
      this.listenTo(this._rangeFilter, 'change', this.render);
    },
  
    _onUpdateAxisTip: function (axisTip) {
      this.model.set(axisTip.attr, axisTip.text);
    },
  
    _setupScales: function () {
      var data = this._dataviewModel.get('data');
      var columnType = this._dataviewModel.getColumnType();
  
      if (columnType === 'date') {
        this._scale = d3.time.scale()
          .domain([data[0].start * 1000, data[data.length - 1].end * 1000])
          .range([this._dataviewModel.get('start'), this._dataviewModel.get('end')]);
      } else {
        this._scale = d3.scale.linear()
          .domain([data[0].start, data[data.length - 1].end])
          .range([this._dataviewModel.get('start'), this._dataviewModel.get('end')]);
      }
    },
  
    _onClick: function () {
      this.trigger('resetFilter', this);
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/time-series/time-series-widget-model.js":
  /*!**********************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/time-series/time-series-widget-model.js ***!
    \**********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var WidgetModel = __webpack_require__(/*! ../widget-model */ "./lib/assets/javascripts/deep-insights/widgets/widget-model.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  
  /**
   * Model for a time-series widget
   */
  module.exports = WidgetModel.extend({
    defaults: {
      normalized: true,
      animated: false
    },
  
    defaultState: _.extend(
      {
        normalized: false
      },
      WidgetModel.prototype.defaultState
    ),
  
    getState: function () {
      var state = WidgetModel.prototype.getState.call(this);
      var start = this.dataviewModel.get('start');
      var end = this.dataviewModel.get('end');
      var data = this.dataviewModel.get('data');
      var lo = this.get('lo_index');
      var hi = this.get('hi_index');
      var l;
      var m;
  
      var checkRoughEqual = function (a, b) {
        if (_.isNumber(a) && _.isNumber(b) && (a !== b) && Math.abs(a - b) > Math.abs(start - end) * 0.01) {
          return true;
        }
        return false;
      };
  
      if (_.isNumber(lo) && _.isNumber(hi) && lo < data.length && (hi - 1) < data.length) {
        l = data[lo].start;
        m = data[hi - 1].end;
      } else {
        l = start;
        m = end;
      }
  
      if (checkRoughEqual(start, l)) {
        state.min = l;
      }
      if (checkRoughEqual(end, m)) {
        state.max = m;
      }
  
      return state;
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/time-series/torque-content-view.js":
  /*!*****************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/time-series/torque-content-view.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var torqueTemplate = __webpack_require__(/*! ./torque-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/time-series/torque-template.tpl");
  var placeholderTemplate = __webpack_require__(/*! ./placeholder.tpl */ "./lib/assets/javascripts/deep-insights/widgets/time-series/placeholder.tpl");
  var TorqueHistogramView = __webpack_require__(/*! ./torque-histogram-view */ "./lib/assets/javascripts/deep-insights/widgets/time-series/torque-histogram-view.js");
  var TorqueHeaderView = __webpack_require__(/*! ./torque-header-view */ "./lib/assets/javascripts/deep-insights/widgets/time-series/torque-header-view.js");
  var DropdownView = __webpack_require__(/*! ../dropdown/widget-dropdown-view */ "./lib/assets/javascripts/deep-insights/widgets/dropdown/widget-dropdown-view.js");
  var layerColors = __webpack_require__(/*! ../../util/layer-colors */ "./lib/assets/javascripts/deep-insights/util/layer-colors.js");
  var analyses = __webpack_require__(/*! ../../data/analyses */ "./lib/assets/javascripts/deep-insights/data/analyses.js");
  var escapeHTML = __webpack_require__(/*! ../../util/escape-html */ "./lib/assets/javascripts/deep-insights/util/escape-html.js");
  
  /**
   * Widget content view for a Torque time-series
   */
  module.exports = CoreView.extend({
    className: 'CDB-Widget-body CDB-Widget-body--timeSeries',
  
    initialize: function () {
      if (!this.model.dataviewModel) throw new Error('dataviewModel is required');
      if (!this.model.layerModel) throw new Error('layerModel is required');
  
      this._dataviewModel = this.model.dataviewModel;
      this._layerModel = this.model.layerModel;
      this._originalData = this._dataviewModel.getUnfilteredDataModel();
      this._selectedAmount = 0;
      this._initBinds();
    },
  
    render: function () {
      this.clearSubViews();
  
      var sourceId = this._dataviewModel.get('source').id;
      var letter = layerColors.letter(sourceId);
      var sourceColor = layerColors.getColorForLetter(letter);
      var sourceType = this._dataviewModel.getSourceType() || '';
      var isSourceType = this._dataviewModel.isSourceType();
      var layerName = isSourceType
        ? this.model.get('table_name')
        : this._layerModel.get('layer_name');
  
      if (this._isDataEmpty()) {
        this.$el.html(placeholderTemplate({
          hasTorqueLayer: true
        }));
      } else {
        this.$el.html(torqueTemplate({
          sourceId: sourceId,
          sourceType: analyses.title(sourceType),
          isSourceType: isSourceType,
          showSource: this.model.get('show_source') && letter !== '',
          sourceColor: sourceColor,
          layerName: escapeHTML(layerName)
        }));
        this._createHeaderView();
        this._createTorqueHistogramView();
        this._createDropdownView();
      }
  
      return this;
    },
  
    _createHeaderView: function () {
      if (this._headerView) {
        this._headerView.remove();
      }
  
      this._headerView = new TorqueHeaderView({
        el: this.$('.js-torque-header'),
        dataviewModel: this._dataviewModel,
        torqueLayerModel: this._layerModel,
        timeSeriesModel: this.model,
        selectedAmount: this._selectedAmount
      });
  
      this.addView(this._headerView);
      this._headerView.render();
    },
  
    _createTorqueHistogramView: function () {
      if (this._histogramView) {
        this._histogramView.remove();
      }
  
      this._histogramView = new TorqueHistogramView({
        timeSeriesModel: this.model,
        dataviewModel: this._dataviewModel,
        rangeFilter: this._dataviewModel.filter,
        torqueLayerModel: this._layerModel,
        layerModel: this._layerModel,
        displayShadowBars: !this.model.get('normalized'),
        normalized: !!this.model.get('normalized')
      });
      this.addView(this._histogramView);
      this.$el.append(this._histogramView.render().el);
    },
  
    _createDropdownView: function () {
      if (this._dropdownView) {
        this._dropdownView.remove();
      }
  
      this._dropdownView = new DropdownView({
        model: this.model,
        target: '.js-actions',
        container: this.$('.js-header'),
        flags: {
          localTimezone: this._dataviewModel.getColumnType() === 'date',
          normalizeHistogram: !!this.model.get('normalized'),
          canCollapse: false
        }
      });
      this.addView(this._dropdownView);
    },
  
    _initBinds: function () {
      this.listenTo(this._originalData, 'change:data', this._onOriginalDataChange);
  
      this.listenTo(this._dataviewModel, 'change:data', this.render);
      this.listenTo(this._dataviewModel, 'change:bins', this._onChangeBins);
  
      this.listenTo(this._layerModel, 'change:layer_name', this.render);
      this.add_related_model(this._layerModel);
    },
  
    _isDataEmpty: function () {
      var data = this._dataviewModel.getData();
      return _.isEmpty(data) || _.size(data) === 0;
    },
  
    _onOriginalDataChange: function () {
      // do an explicit fetch in order to get actual data
      // with the filters applied (e.g. bbox)
      this._dataviewModel.fetch();
    },
  
    _onChangeBins: function (mdl, bins) {
      this._originalData.setBins(bins);
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/time-series/torque-controls-view.js":
  /*!******************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/time-series/torque-controls-view.js ***!
    \******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var template = __webpack_require__(/*! ./torque-controls.tpl */ "./lib/assets/javascripts/deep-insights/widgets/time-series/torque-controls.tpl");
  
  /**
   * Torque animation controls, to manage run state
   */
  module.exports = CoreView.extend({
    events: {
      'click .CDB-Widget-controlButton': '_onClick'
    },
  
    initialize: function () {
      this._torqueLayerModel = this.options.torqueLayerModel;
      this._rangeFilter = this.options.rangeFilter;
      this.listenTo(this._torqueLayerModel, 'change:isRunning', this.render);
      this.listenTo(this._torqueLayerModel, 'change:start change.end', this.render);
    },
  
    render: function () {
      this.$el.html(
        template({
          running: this._torqueLayerModel.get('isRunning'),
          disabled: !this._rangeFilter.isEmpty()
        })
      );
  
      return this;
    },
  
    _onClick: function () {
      if (this._torqueLayerModel.get('isRunning')) {
        this._torqueLayerModel.pause();
      } else {
        this._torqueLayerModel.play();
      }
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/time-series/torque-header-view.js":
  /*!****************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/time-series/torque-header-view.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var TorqueTimeInfoView = __webpack_require__(/*! ./torque-time-info-view */ "./lib/assets/javascripts/deep-insights/widgets/time-series/torque-time-info-view.js");
  var TimeSeriesHeaderView = __webpack_require__(/*! ./time-series-header-view */ "./lib/assets/javascripts/deep-insights/widgets/time-series/time-series-header-view.js");
  var template = __webpack_require__(/*! ./torque-header-view.tpl */ "./lib/assets/javascripts/deep-insights/widgets/time-series/torque-header-view.tpl");
  
  /**
   * View for the header in the torque time-series view
   */
  module.exports = CoreView.extend({
    className: 'CDB-Widget-contentSpaced',
  
    initialize: function () {
      this._dataviewModel = this.options.dataviewModel;
      this._torqueLayerModel = this.options.torqueLayerModel;
      this._rangeFilter = this._dataviewModel.filter;
      this._selectedAmount = this.options.selectedAmount;
      this._timeSeriesModel = this.options.timeSeriesModel;
  
      this.listenTo(this._rangeFilter, 'change', this.render);
    },
  
    render: function () {
      var showClearButton = true;
      this.clearSubViews();
      this.$el.addClass(this.className);
      this.$el.html(template());
  
      if (this._rangeFilter.isEmpty()) {
        this._appendView('.js-torque-controls',
          new TorqueTimeInfoView({
            dataviewModel: this._dataviewModel,
            torqueLayerModel: this._torqueLayerModel,
            timeSeriesModel: this._timeSeriesModel
          })
        );
        showClearButton = false;
      }
      this._createTimeSeriesHeaderView(showClearButton);
  
      return this;
    },
  
    _createTimeSeriesHeaderView: function (showClearButton) {
      var headerView = new TimeSeriesHeaderView({
        dataviewModel: this._dataviewModel,
        layerModel: this._torqueLayerModel,
        rangeFilter: this._dataviewModel.filter,
        showClearButton: showClearButton,
        timeSeriesModel: this._timeSeriesModel,
        selectedAmount: this._selectedAmount
      });
      this._appendView('.js-time-series-header', headerView);
      headerView.on('resetFilter', this._resetFilter, this);
    },
  
    _resetFilter: function () {
      // Move it to 0 so it doesn't stutter as much
      this._torqueLayerModel.set({ step: 0 });
      this._torqueLayerModel.resetRenderRange();
    },
  
    _appendView: function (selector, view) {
      this.addView(view);
      this.$(selector).append(view.render().el);
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/time-series/torque-histogram-view.js":
  /*!*******************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/time-series/torque-histogram-view.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var HistogramView = __webpack_require__(/*! ./histogram-view */ "./lib/assets/javascripts/deep-insights/widgets/time-series/histogram-view.js");
  var TorqueTimeSliderView = __webpack_require__(/*! ./torque-time-slider-view */ "./lib/assets/javascripts/deep-insights/widgets/time-series/torque-time-slider-view.js");
  var TorqueControlsView = __webpack_require__(/*! ./torque-controls-view */ "./lib/assets/javascripts/deep-insights/widgets/time-series/torque-controls-view.js");
  
  /**
   * Torque time-series histogram view.
   * Extends the common histogram chart view with time-control
   * this.dataviewModel is a histogram model
   */
  module.exports = HistogramView.extend({
    defaults: _.extend({}, HistogramView.prototype.defaults, {offsetLeft: 34}),
  
    className: function () {
      return HistogramView.prototype.className + ' CDB-Widget-content CDB-Widget-content--torqueTimeSeries u-flex';
    },
  
    initialize: function () {
      if (!this.options.torqueLayerModel) throw new Error('torqeLayerModel is required');
      if (!this.options.rangeFilter) throw new Error('rangeFilter is required');
      if (!this.options.dataviewModel) throw new Error('dataviewModel is required');
      if (!this.options.timeSeriesModel) throw new Error('timeSeriesModel is required');
  
      this._torqueLayerModel = this.options.torqueLayerModel;
      this._dataviewModel = this.options.dataviewModel;
      this._timeSeriesModel = this.options.timeSeriesModel;
      HistogramView.prototype.initialize.call(this);
    },
  
    _initBinds: function () {
      HistogramView.prototype._initBinds.call(this);
  
      this.listenTo(this._torqueLayerModel, 'change:renderRange', this._onRenderRangeChanged);
      this.listenTo(this._torqueLayerModel, 'change:steps change:start change:end', this._reSelectRange);
      this.listenTo(this._torqueLayerModel, 'change:cartocss', this._onUpdateCartocss);
    },
  
    _createHistogramView: function () {
      this._chartType = this._torqueLayerModel.get('column_type') === 'date' ? 'time' : 'number';
      HistogramView.prototype._createHistogramView.call(this);
  
      this._torqueControls = new TorqueControlsView({
        torqueLayerModel: this._torqueLayerModel,
        rangeFilter: this._rangeFilter
      });
      this.addView(this._torqueControls);
  
      this.$el.prepend(this._torqueControls.render().el);
  
      this._chartView.setAnimated();
      this._chartView.bind('on_brush_click', this._onBrushClick, this);
  
      this._timeSliderView = new TorqueTimeSliderView({
        dataviewModel: this._dataviewModel, // a histogram model
        chartView: this._chartView,
        torqueLayerModel: this._torqueLayerModel,
        timeSeriesModel: this._timeSeriesModel,
        rangeFilter: this._rangeFilter
      });
      this.addView(this._timeSliderView);
      this._timeSliderView.render();
    },
  
    _onChangeData: function () {
      HistogramView.prototype._onChangeData.call(this);
  
      if (this._chartView) {
        this._reSelectRange();
      }
    },
  
    _onRenderRangeChanged: function (_model, range) {
      if (range.start === undefined && range.end === undefined) {
        this._chartView.removeSelection();
        this._rangeFilter.unsetRange();
      }
    },
  
    _onBrushClick: function (indexPct) {
      var steps = this._torqueLayerModel.get('steps');
      var step = Math.round(steps * indexPct);
  
      // Going to the last step causes a jump to the beginning immediately
      if (step === steps) step -= 1;
  
      HistogramView.prototype.resetFilter.apply(this);
  
      this._torqueLayerModel.set({ step: step });
    },
  
    _onBrushEnd: function () {
      HistogramView.prototype._onBrushEnd.apply(this, arguments);
      this._reSelectRange();
    },
  
    _timeToStep: function (timestamp, place) {
      var steps = this._torqueLayerModel.get('steps');
      var start = this._torqueLayerModel.get('start');
      var end = this._torqueLayerModel.get('end');
      var step = (end - start) === 0
        ? place === 'max'
          ? steps
          : 0
        : (steps * (1000 * timestamp - start)) / (end - start);
      step = Number(step.toFixed(2));
  
      return step;
    },
  
    _reSelectRange: function (model) {
      if (!this._rangeFilter.isEmpty()) {
        this._torqueLayerModel.pause();
  
        var min = this._rangeFilter.get('min');
        var max = this._rangeFilter.get('max');
        var loStep = this._timeToStep(min, 'min');
        var hiStep = this._timeToStep(max, 'max');
  
        // -- HACK: Reset filter if the min/max values are out of the scope
        var data = this._dataviewModel.get('data');
        var loBar = _.findWhere(data, { start: min });
        var hiBar = _.findWhere(data, { end: max });
        if (!loBar || !hiBar) {
          return this._torqueLayerModel.resetRenderRange();
        }
  
        // clamp values since the range can be outside of the current torque thing
        var steps = this._torqueLayerModel.get('steps');
        var ratio = this._chartView.getSelectionExtent() / 100;
        this._updateDuration(ratio);
        this._torqueLayerModel.renderRange(
          this._clampRangeVal(0, steps, loStep), // start
          this._clampRangeVal(0, steps, hiStep) // end
        );
      } else {
        this._torqueLayerModel.play();
        this._updateDuration(1);
      }
    },
  
    _updateDuration: function (ratio, cartocss) {
      if (!this._torqueLayerModel.getAnimationDuration) return;
      var duration = this._torqueLayerModel.getAnimationDuration(cartocss || this._torqueLayerModel.get('cartocss'));
  
      this._torqueLayerModel.set('customDuration', Math.round(duration * ratio));
    },
  
    _onUpdateCartocss: function (m, cartocss) {
      var ratio;
      if (!this._rangeFilter.isEmpty()) {
        var loStep = this._timeToStep(this._rangeFilter.get('min'));
        var hiStep = this._timeToStep(this._rangeFilter.get('max'));
        var steps = this._torqueLayerModel.get('steps');
        ratio = (hiStep - loStep) / steps;
      } else {
        ratio = 1;
      }
  
      // Update silently, when carto.js updates the cartoCSS for torque, it will apply the new duration.
      this._updateDuration(ratio, cartocss, { silent: true });
    },
  
    _clampRangeVal: function (a, b, t) {
      return Math.max(a, Math.min(b, t));
    },
  
    _getMarginLeft: function () {
      return 16;
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/time-series/torque-time-info-view.js":
  /*!*******************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/time-series/torque-time-info-view.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  var formatter = __webpack_require__(/*! ../../formatter */ "./lib/assets/javascripts/deep-insights/formatter.js");
  var template = __webpack_require__(/*! ./torque-time-info.tpl */ "./lib/assets/javascripts/deep-insights/widgets/time-series/torque-time-info.tpl");
  
  /**
   * View rendering the current step time
   */
  module.exports = CoreView.extend({
    className: 'CDB-Widget-timeSeriesTimeInfo',
  
    initialize: function (opts) {
      if (!opts.torqueLayerModel) throw new Error('torqueLayerModel is required');
      if (!opts.dataviewModel) throw new Error('dataviewModel is required');
      if (!opts.timeSeriesModel) throw new Error('timeSeriesModel is required');
  
      this._torqueLayerModel = this.options.torqueLayerModel;
      this._dataviewModel = this.options.dataviewModel;
      this._timeSeriesModel = this.options.timeSeriesModel;
  
      this._initBinds();
    },
  
    render: function () {
      var time = this._torqueLayerModel.get('time');
      var columnType = this._torqueLayerModel.get('column_type');
      var scale = d3.scale.linear()
        .domain([0, this._dataviewModel.get('data').length])
        .range([this._dataviewModel.get('start'), this._dataviewModel.get('end')]);
      var html = '';
      var timeFormatter = formatter.formatNumber;
  
      if (columnType === 'number') {
        html = template({
          time: timeFormatter(scale(this._torqueLayerModel.get('step')))
        });
      } else if (columnType === 'date' && !isNaN(time && time.getTime())) {
        timeFormatter = formatter.timestampFactory(this._dataviewModel.get('aggregation'), this._dataviewModel.getCurrentOffset());
  
        html = template({
          time: timeFormatter(moment(time).unix())
        });
      }
  
      this.$el.html(html);
  
      return this;
    },
  
    _initBinds: function () {
      this.listenTo(this._torqueLayerModel, 'change:step', this.render);
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/time-series/torque-time-slider-view.js":
  /*!*********************************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/time-series/torque-time-slider-view.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  var formatter = __webpack_require__(/*! ../../formatter */ "./lib/assets/javascripts/deep-insights/formatter.js");
  var viewportUtils = __webpack_require__(/*! ../../viewport-utils */ "./lib/assets/javascripts/deep-insights/viewport-utils.js");
  
  var TIP_RECT_HEIGHT = 17;
  var TIP_H_PADDING = 6;
  var CHART_MARGIN = 16;
  var MOBILE_BAR_HEIGHT = 3;
  var TOOLTIP_MARGIN = 2;
  
  /**
   * Time-slider, expected to be used in a histogram view
   */
  module.exports = CoreView.extend({
    defaults: {
      width: 6,
      height: 8
    },
  
    initialize: function () {
      if (!this.options.chartView) throw new Error('chartView is required');
      if (!this.options.torqueLayerModel) throw new Error('torqeLayerModel is required');
      if (!this.options.timeSeriesModel) throw new Error('timeSeriesModel is required');
  
      this.model = new cdb.core.Model();
  
      this._dataviewModel = this.options.dataviewModel;
      this._chartView = this.options.chartView;
      this._torqueLayerModel = this.options.torqueLayerModel;
      this._timeSeriesModel = this.options.timeSeriesModel;
  
      this._chartMargins = this._chartView.model.get('margin');
  
      this._initBinds();
      this._updateXScale();
      this._createFormatter();
    },
  
    render: function () {
      // Make the render call idempotent; only create time slider once
      if (!this.timeSlider) {
        var dragBehavior = d3.behavior.drag()
          .on('dragstart', this._onDragStart.bind(this))
          .on('drag', this._onDrag.bind(this))
          .on('dragend', this._onDragEnd.bind(this));
  
        var d3el = this._chartView.canvas.append('rect');
        this.timeSlider = d3el
          .attr('class', 'CDB-TimeSlider')
          .attr('width', this.defaults.width)
          .attr('height', this._calcHeight())
          .attr('rx', 3)
          .attr('ry', 3)
          .data([{ x: 0, y: 0 }])
          .attr('transform', this._translateXY)
          .call(dragBehavior);
  
        this.setElement(d3el.node());
      }
  
      if (this._isTabletViewport()) {
        this._generateTimeSliderTip();
      }
  
      return this;
    },
  
    _isTabletViewport: function () {
      return viewportUtils.isTabletViewport();
    },
  
    _generateTimeSliderTip: function () {
      var yPos = this._calcHeight() / 2 + MOBILE_BAR_HEIGHT + TOOLTIP_MARGIN;
      yPos = Math.floor(yPos);
  
      this.timeSliderTip = this._chartView.canvas.select('.CDB-WidgetCanvas').append('g')
        .attr('class', 'CDB-Chart-timeSliderTip')
        .data([{ x: CHART_MARGIN, y: yPos }])
        .attr('transform', this._translateXY);
  
      this.timeSliderTip.append('rect')
        .attr('class', 'CDB-Chart-timeSliderTipRect')
        .attr('rx', '2')
        .attr('ry', '2')
        .attr('height', TIP_RECT_HEIGHT);
  
      this.timeSliderTip.append('text')
        .attr('class', 'CDB-Text CDB-Size-small CDB-Chart-timeSliderTipText')
        .attr('dy', '11')
        .attr('dx', '0');
    },
  
    _onLocalTimezoneChanged: function () {
      this._createFormatter();
      this._updateTimeSliderTip();
    },
  
    _updateTimeSliderTip: function () {
      var self = this;
  
      var textLabelData = this._isDateTimeSeries() ? this._torqueLayerModel.get('time') : this._torqueLayerModel.get('step');
  
      if (textLabelData === void 0) {
        return;
      }
  
      var chart = this._chartView.canvas;
      var textLabel = chart.select('.CDB-Chart-timeSliderTipText');
  
      var scale = d3.scale.linear()
        .domain([0, this._dataviewModel.get('data').length])
        .range([this._dataviewModel.get('start'), this._dataviewModel.get('end')]);
  
      textLabel
        .data([textLabelData])
        .text(function (d) {
          return self._isDateTimeSeries() ? this.formatter(moment(d).unix()) : this.formatter(scale(d));
        }.bind(this));
  
      if (!textLabel.node()) {
        return;
      }
  
      var rectLabel = chart.select('.CDB-Chart-timeSliderTipRect');
      var textBBox = textLabel.node().getBBox();
      var width = textBBox.width;
      var rectWidth = width + TIP_H_PADDING;
      var chartWidth = this._chartView.chartWidth() + CHART_MARGIN;
  
      rectLabel.attr('width', rectWidth);
      textLabel.attr('dx', TIP_H_PADDING / 2);
      textLabel.attr('dy', textBBox.height - Math.abs((textBBox.height - TIP_RECT_HEIGHT) / 2));
  
      var timeSliderX = this._xScale(this._torqueLayerModel.get('step'));
      var xPos = timeSliderX + this.defaults.width - rectWidth / 2;
      var yPos = this._calcHeight() / 2 + MOBILE_BAR_HEIGHT + TOOLTIP_MARGIN;
      yPos = Math.floor(yPos);
  
      var timeSliderTipData = this.timeSliderTip.data();
      timeSliderTipData[0].y = yPos;
  
      var newX = xPos;
  
      if (xPos < CHART_MARGIN) {
        newX = CHART_MARGIN;
      } else if ((xPos + rectWidth) >= chartWidth) {
        newX = chartWidth - rectWidth;
      }
  
      if (!isNaN(newX)) {
        timeSliderTipData[0].x = newX;
  
        this.timeSliderTip
          .data(timeSliderTipData)
          .transition()
          .ease('linear')
          .attr('transform', this._translateXY);
      }
    },
  
    _initBinds: function () {
      this.listenTo(this._torqueLayerModel, 'change:start change:end', this._updateChartandTimeslider);
      this.listenTo(this._torqueLayerModel, 'change:step', this._onChangeStep);
      this.listenTo(this._torqueLayerModel, 'change:time', this._onChangeTime);
      this.listenTo(this._torqueLayerModel, 'change:steps', this._updateChartandTimeslider);
  
      this.listenTo(this._chartView.model, 'change:width', this._updateChartandTimeslider);
      this.listenTo(this._chartView.model, 'change:height', this._onChangeChartHeight);
  
      this.listenTo(this._dataviewModel, 'change:bins', this._updateChartandTimeslider);
      this.listenTo(this._dataviewModel, 'change:column_type', this._createFormatter);
      this.listenTo(this._dataviewModel.filter, 'change:min change:max', this._onFilterMinMaxChange);
  
      this.listenTo(this._timeSeriesModel, 'change:local_timezone', this._onLocalTimezoneChanged);
  
      this.listenTo(this._dataviewModel, 'change:start change:end', this._updateChartandTimeslider);
    },
  
    clean: function () {
      if (this.timeSlider) {
        this.timeSlider.remove();
      }
      CoreView.prototype.clean.call(this);
    },
  
    _onFilterMinMaxChange: function (m, isFiltering) {
      this.$el.toggle(!isFiltering);
    },
  
    _onDragStart: function () {
      var isRunning = this._torqueLayerModel.get('isRunning');
      if (isRunning) {
        this._torqueLayerModel.pause();
      }
      this.model.set({
        isDragging: true,
        wasRunning: isRunning
      });
    },
  
    _onDrag: function (d, i) {
      var nextX = d.x + d3.event.dx;
      if (this._isWithinRange(nextX)) {
        d.x = nextX;
        this.timeSlider.attr('transform', this._translateXY);
  
        var step = Math.round(this._xScale.invert(d.x));
        this._torqueLayerModel.setStep(step);
      }
    },
  
    _onDragEnd: function () {
      this.model.set('isDragging', false);
      if (this.model.get('wasRunning')) {
        this._torqueLayerModel.play();
      }
    },
  
    _translateXY: function (d) {
      return 'translate(' + [d.x, d.y] + ')';
    },
  
    _isWithinRange: function (x) {
      return x >= this._chartMargins.left && x <= this._width() - this._chartMargins.right;
    },
  
    _onChangeStep: function () {
      // Time slider might not be created when this method is first called
      if (this.timeSlider && !this.model.get('isDragging')) {
        var data = this.timeSlider.data();
        var newX = this._xScale(this._torqueLayerModel.get('step'));
  
        if (!isNaN(newX)) {
          data[0].x = newX;
  
          this.timeSlider
            .data(data)
            .transition()
            .ease('linear')
            .attr('transform', this._translateXY);
        }
      }
    },
  
    _onChangeChartHeight: function () {
      var height = this._isTabletViewport() ? this._calcHeight() / 2 + MOBILE_BAR_HEIGHT : this._calcHeight();
  
      this.timeSlider.attr('height', height);
    },
  
    _onChangeTime: function () {
      if (this._dataviewModel.filter.isEmpty() && this._isTabletViewport()) {
        var timeSliderTip = this._chartView.canvas.select('.CDB-Chart-timeSliderTip');
  
        if (!timeSliderTip.node()) {
          this._generateTimeSliderTip();
        }
  
        this._updateTimeSliderTip();
      } else {
        this._removeTimeSliderTip();
      }
    },
  
    _removeTimeSliderTip: function () {
      var timeSliderTip = this._chartView.canvas.select('.CDB-Chart-timeSliderTip');
  
      if (timeSliderTip.node()) {
        timeSliderTip.remove();
      }
    },
  
    _updateChartandTimeslider: function () {
      this._updateXScale();
      this._onChangeStep();
    },
  
    _calcHeight: function () {
      return this._chartView.chartHeight() + this.defaults.height;
    },
  
    _createFormatter: function () {
      this.formatter = formatter.formatNumber;
  
      if (this._isDateTimeSeries()) {
        this.formatter = formatter.timestampFactory(this._dataviewModel.get('aggregation'), this._dataviewModel.getCurrentOffset());
      }
    },
  
    _isDateTimeSeries: function () {
      return this._dataviewModel.getColumnType() === 'date';
    },
  
    _updateXScale: function () {
      // calculate range based on the torque layer bounds (that are not the same than the histogram ones)
      var range = 1000 * (this._dataviewModel.get('end') - this._dataviewModel.get('start'));
      // get normalized start and end
      var start = (this._torqueLayerModel.get('start') - 1000 * this._dataviewModel.get('start')) / range;
      var end = (this._torqueLayerModel.get('end') - 1000 * this._dataviewModel.get('start')) / range;
  
      // This function might be called in-between state changes, so just to be safe let's keep the range sane
      var scaleRangeMin = (start * this._width()) + this._chartMargins.left;
      var scaleRangeMax = (end * this._width()) - this._chartMargins.right;
  
      scaleRangeMin = scaleRangeMin < 0
        ? this._chartMargins.left
        : scaleRangeMin;
  
      scaleRangeMax = scaleRangeMax > this._width()
        ? this._width() - this._chartMargins.right
        : scaleRangeMax;
  
      this._xScale = d3.scale.linear()
        .domain([0, this._torqueLayerModel.get('steps')])
        .range([scaleRangeMin, scaleRangeMax]);
    },
  
    _width: function () {
      return this._chartView.model.get('width');
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/widget-error-view.js":
  /*!***************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/widget-error-view.js ***!
    \***************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var errorButtonTemplate = __webpack_require__(/*! ./widget-error-button-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/widget-error-button-template.tpl");
  var errorTextTemplate = __webpack_require__(/*! ./widget-error-text-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/widget-error-text-template.tpl");
  
  /**
   * Default widget error view:
   *
   * It will listen or not to dataviewModel changes when first load is done.
   */
  module.exports = CoreView.extend({
    className: 'CDB-Widget-body is-hidden',
  
    events: {
      'click .js-refresh': '_onRefreshClick'
    },
  
    initialize: function (opts) {
      this._title = opts.title;
      this._errorModel = opts.errorModel;
  
      this.listenTo(this._errorModel, 'change', this._onErrorModelChanged);
    },
  
    render: function () {
      var error = this._errorModel.get('error');
  
      if (error) {
        var placeholderTemplate = this._errorModel.get('placeholder');
        var placeholder = _.isFunction(placeholderTemplate) ? placeholderTemplate() : '';
        this.$el.addClass('CDB-Widget--' + error.level);
  
        var body = error.type
          ? errorTextTemplate({
            placeholder: placeholder,
            error: error.error,
            title: this._title,
            message: error.message,
            refresh: error.refresh
          })
          : errorButtonTemplate({ placeholder: placeholder });
  
        this.$el.html(body);
      }
  
      return this;
    },
  
    _onErrorModelChanged: function () {
      this._reset();
  
      _.isEmpty(this._errorModel.get('error'))
        ? this.$el.addClass('is-hidden')
        : this.$el.removeClass('is-hidden');
  
      this.render();
    },
  
    _onRefreshClick: function () {
      this._errorModel.get('model').refresh();
    },
  
    _reset: function () {
      this.$el.removeClass('CDB-Widget--alert CDB-Widget--error');
      this.$el.html('');
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/widget-loader-view.js":
  /*!****************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/widget-loader-view.js ***!
    \****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  
  /**
   *  Default widget loader view:
   *
   *  It will listen or not to dataviewModel changes when
   *  first load is done.
   */
  module.exports = CoreView.extend({
    className: 'CDB-Widget-loader',
  
    initialize: function () {
      this._initBinds();
    },
  
    render: function () {
      this.$el.append('<div class="CDB-Loader js-loader"></div>');
      return this;
    },
  
    show: function () {
      this.$('.js-loader').addClass('is-visible');
      clearTimeout(this._timeout);
    },
  
    hide: function () {
      var self = this;
      this._timeout = setTimeout(function () {
        self.$('.js-loader').removeClass('is-visible');
      }, 500);
    },
  
    _initBinds: function () {
      this.model.bind('loading', this.show, this);
      this.model.bind('error', function (mdl, err) {
        if (!err || (err && err.statusText !== 'abort')) {
          this.hide();
        }
      }, this);
      this.model.bind('loaded', this.hide, this);
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/widget-model.js":
  /*!**********************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/widget-model.js ***!
    \**********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var cdb = __webpack_require__(/*! internal-carto.js */ "./node_modules/internal-carto.js/src/index.js");
  var AutoStylerFactory = __webpack_require__(/*! ./auto-style/factory */ "./lib/assets/javascripts/deep-insights/widgets/auto-style/factory.js");
  
  var TIME_SERIES_TYPE = 'time-series';
  var HISTOGRAM_TYPE = 'histogram';
  
  /**
   * Default widget model
   *
   * Note: Currently all widgets have a dependency on a dataview, why it makes sense to have it here.
   * If you need a widget model that's backed up by a dataview model please implement your own model and adhere to the
   * public interface instead of extending/hacking this one.
   */
  module.exports = cdb.core.Model.extend({
    defaults: {
      attrsNames: [],
      show_stats: false,
      show_source: false
    },
  
    defaultState: {
      'collapsed': false
    },
  
    initialize: function (attrs, models, opts) {
      opts = opts || {};
      if (!models.dataviewModel) throw new Error('dataviewModel is required.');
      if (!models.layerModel) throw new Error('layerModel is required.');
  
      this.dataviewModel = models.dataviewModel;
      this.layerModel = models.layerModel;
  
      // Autostyle could be disabled initially if the styles have an aggregation
      // If no option, autoStyleEnabled by default
      this._autoStyleEnabledWhenCreated = opts.autoStyleEnabled === undefined ? true : opts.autoStyleEnabled;
  
      this.activeAutoStyler();
      this.listenTo(this, 'change:style', this.activeAutoStyler);
    },
  
    activeAutoStyler: function () {
      if (this.isAutoStyleEnabled() && !this.autoStyler) {
        this.autoStyler = AutoStylerFactory.get(this.dataviewModel, this.layerModel, this.get('style'));
      }
    },
  
    /**
     * @public
     * @param {Object} attrs, not that it should be
     * @return {Boolean} true if at least one attribute was changed
     * @throws {Error} Should throw an error if the attrs are invalid or inconsistent
     */
    update: function (attrs) {
      var wAttrs = _.pick(attrs, this.get('attrsNames'));
      this.set(wAttrs);
      this.dataviewModel.update(attrs);
      this._triggerChangesInAutoStyle();
      return !!(this.changedAttributes() || this.dataviewModel.changedAttributes());
    },
  
    _triggerChangesInAutoStyle: function () {
      var changed = this.changed && this.changed.style && this.changed.style.auto_style && this.changed.style.auto_style.definition;
      var previous = this.previousAttributes();
      var former = previous.style && previous.style.auto_style && previous.style.auto_style.definition;
  
      if (!_.isEqual(changed, former)) {
        this.trigger('customAutoStyle', this);
      }
    },
  
    /**
     * @public
     */
    remove: function () {
      this.dataviewModel.remove();
      this.trigger('destroy', this);
      this.stopListening();
    },
  
    isAutoStyleEnabled: function () {
      var styles = this.get('style');
  
      if (this.get('type') === 'category' || this.get('type') === 'histogram') {
        if (!styles || !styles.auto_style) {
          // Only when styles are undefined we check the autostyle option
          return this._autoStyleEnabledWhenCreated;
        }
  
        return styles && styles.auto_style && styles.auto_style.allowed;
      } else {
        return false;
      }
    },
  
    getWidgetColor: function () {
      var styles = this.get('style');
      var widgetStyle = styles && styles.widget_style;
      var widgetColor = widgetStyle && widgetStyle.definition &&
        widgetStyle.definition.color &&
        widgetStyle.definition.color.fixed;
      var widgetColorChanged = (widgetStyle && widgetStyle.widget_color_changed) ||
        (widgetStyle && !widgetStyle.widget_color_changed && widgetColor !== '#9DE0AD');
  
      return widgetColorChanged && widgetColor;
    },
  
    hasColorsAutoStyle: function () {
      var autoStyle = this.getAutoStyle();
      var hasDefinedColors = false;
  
      if (!autoStyle || _.isEmpty(autoStyle) || _.isEmpty(autoStyle.definition)) {
        return false;
      }
  
      // Check colors in all geometries
      _.each(autoStyle.definition, function (geometryStyle) {
        if (geometryStyle.color && geometryStyle.color.range && geometryStyle.color.range.length > 0) {
          hasDefinedColors = true;
        }
      }, this);
  
      return hasDefinedColors;
    },
  
    getColor: function (name) {
      if (this.isAutoStyleEnabled() && this.isAutoStyle() && this.get('type') === 'category') {
        return this.autoStyler.colors.getColorByCategory(name);
      } else {
        return this.getWidgetColor();
      }
    },
  
    isAutoStyle: function () {
      return this.get('autoStyle');
    },
  
    autoStyle: function () {
      if (!this.isAutoStyleEnabled()) return;
      if (!this.dataForAutoStyle()) return;
  
      var layer = this.layerModel;
      var initialStyle = layer.get('cartocss');
      if (!initialStyle && layer.get('meta')) {
        initialStyle = layer.get('meta').cartocss;
      }
      layer.set('initialStyle', initialStyle);
  
      var style = this.autoStyler.getStyle();
      layer.set('cartocss', style);
      this.set('autoStyle', true);
    },
  
    dataForAutoStyle: function () {
      return this.dataviewModel.get('data').length > 0;
    },
  
    reapplyAutoStyle: function () {
      var style = this.autoStyler.getStyle();
      this.layerModel.set('cartocss', style);
      this.set('autoStyle', true);
    },
  
    cancelAutoStyle: function (noRestore) {
      if (!noRestore) {
        this.layerModel.restoreCartoCSS();
      }
      this.set('autoStyle', false);
    },
  
    getAutoStyle: function () {
      var style = this.get('style');
      var layerModel = this.layerModel;
      var cartocss = layerModel.get('cartocss') || (layerModel.get('meta') && layerModel.get('meta').cartocss);
  
      if (this.isAutoStyleEnabled() && this.autoStyler) {
        if (style && style.auto_style && style.auto_style.definition) {
          var toRet = _.extend(style.auto_style, {cartocss: cartocss});
          return _.extend({}, toRet, {definition: this.autoStyler.getDef(cartocss)});
        } else {
          return {
            definition: this.autoStyler.getDef(cartocss),
            cartocss: cartocss
          };
        }
      }
  
      return {};
    },
  
    _updateAutoStyle: function (_model, style) {
      if (this.autoStyler) {
        this.autoStyler.updateStyle(style);
      }
      if (this.isAutoStyle()) {
        this.reapplyAutoStyle();
      }
    },
  
    setInitialState: function (state) {
      this.initialState = state || {};
    },
  
    applyInitialState: function () {
      var attrs = _.extend(
        this.initialState,
        {hasInitialState: true}
      );
  
      this.setState(attrs);
    },
  
    setState: function (state) {
      this.set(state);
    },
  
    getState: function () {
      var state = {};
      for (var key in this.defaultState) {
        var attribute = this.get(key);
        var defaultValue = this.defaultState[key];
        if (typeof defaultValue !== 'undefined' && typeof attribute !== 'undefined' && !_.isEqual(attribute, defaultValue)) {
          state[key] = attribute;
        }
      }
      return state;
    },
  
    forceResize: function () {
      var type = this.get('type');
      if (type === TIME_SERIES_TYPE ||
          type === HISTOGRAM_TYPE) {
        this.trigger('forceResize');
      }
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/widget-view-factory.js":
  /*!*****************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/widget-view-factory.js ***!
    \*****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var WidgetView = __webpack_require__(/*! ./widget-view */ "./lib/assets/javascripts/deep-insights/widgets/widget-view.js");
  
  var WidgetViewFactory = function (defs) {
    this.defs = [];
    _.each(defs, function (def) {
      this.addType(def);
    }, this);
  };
  
  WidgetViewFactory.prototype.DEFAULT_CLASS_NAMES = 'CDB-Widget CDB-Widget--light';
  
  WidgetViewFactory.prototype.addType = function (def) {
    if (!def.match) {
      if (def.type) {
        def.match = function (widget) {
          return widget.get('type') === this.type;
        };
      } else {
        throw new Error('def.type or def.match must be provided for createContentView to work');
      }
    }
    if (!_.isFunction(def.createContentView)) throw new Error('def.createContentView must be a function');
    this.defs.push(def);
  };
  
  /**
   * @returns {Object, undefined} Returns nothing if there is not matching view for the given model
   */
  WidgetViewFactory.prototype.createWidgetView = function (widget) {
    var def = _.find(this.defs, function (def) {
      return def.match(widget);
    });
  
    if (def) {
      var attrs = {
        className: this.DEFAULT_CLASS_NAMES,
        model: widget,
        contentView: def.createContentView(widget)
      };
  
      return new WidgetView(
        _.isFunction(def.customizeWidgetAttrs)
          ? def.customizeWidgetAttrs(attrs)
          : attrs
      );
    }
  };
  
  module.exports = WidgetViewFactory;
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/widget-view.js":
  /*!*********************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/widget-view.js ***!
    \*********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var CoreView = __webpack_require__(/*! backbone/core-view */ "./lib/assets/javascripts/vendor/backbone/core-view.js");
  var WidgetLoaderView = __webpack_require__(/*! ./widget-loader-view */ "./lib/assets/javascripts/deep-insights/widgets/widget-loader-view.js");
  var WidgetErrorView = __webpack_require__(/*! ./widget-error-view */ "./lib/assets/javascripts/deep-insights/widgets/widget-error-view.js");
  var errorEnhancer = __webpack_require__(/*! ../util/error-enhancer */ "./lib/assets/javascripts/deep-insights/util/error-enhancer.js");
  var getValue = __webpack_require__(/*! ../util/get-object-value */ "./lib/assets/javascripts/deep-insights/util/get-object-value.js");
  var Utils = __webpack_require__(/*! builder/helpers/utils */ "./lib/assets/javascripts/builder/helpers/utils.js");
  
  var PLACEHOLDER_TEMPLATES = {
    category: __webpack_require__(/*! ./category/list/items-placeholder-template.tpl */ "./lib/assets/javascripts/deep-insights/widgets/category/list/items-placeholder-template.tpl"),
    formula: __webpack_require__(/*! ./formula/placeholder.tpl */ "./lib/assets/javascripts/deep-insights/widgets/formula/placeholder.tpl"),
    histogram: __webpack_require__(/*! ./histogram/placeholder.tpl */ "./lib/assets/javascripts/deep-insights/widgets/histogram/placeholder.tpl")
  };
  
  var MAX_BUCKETS = 367;
  
  /**
   * Default widget view
   * The model is a expected to be widget model
   */
  module.exports = CoreView.extend({
    className: 'CDB-Widget CDB-Widget--light',
  
    options: {
      columns_title: []
    },
  
    initialize: function () {
      this.errorModel = new Backbone.Model({});
      var dataviewModel = this.model.dataviewModel;
  
      this.listenTo(this.model, 'destroy', this.clean);
      this.listenTo(this.model, 'error', this._onError);
      this.listenTo(this.model, 'setDisabled', this._setDisabled);
      this.listenTo(dataviewModel, 'statusError', this._onError);
      this.listenTo(dataviewModel, 'sync change:data', this._onDataChanged);
    },
  
    render: function () {
      this.clearSubViews();
      this.$el.empty();
  
      this._appendView(new WidgetLoaderView({
        model: this.model.dataviewModel
      }));
  
      this._appendView(new WidgetErrorView({
        title: this.model.get('title'),
        errorModel: this.errorModel
      }));
  
      this._appendView(this.options.contentView);
  
      return this;
    },
  
    _onDataChanged: function (model) {
      if (this._noDataAvailable()) {
        this.options.contentView.$el.addClass('is-hidden');
        return this.errorModel.set({
          model: model,
          error: errorEnhancer({ type: 'no_data_available' }),
          placeholder: this._getPlaceholder()
        });
      }
  
      if (this._dataHasTooManyBins()) {
        this.options.contentView.$el.addClass('is-hidden');
        return this.errorModel.set({
          model: model,
          error: errorEnhancer({ type: 'too_many_bins' }),
          placeholder: this._getPlaceholder()
        });
      }
  
      if (!_.isEmpty(this.errorModel.get('error'))) {
        this.errorModel.clear();
        this.options.contentView.render();
        this.options.contentView.$el.removeClass('is-hidden');
      }
    },
  
    _onError: function (model, error) {
      if (error && error.message === 'abort') {
        return;
      }
  
      var enhancedError = errorEnhancer(error);
  
      this.options.contentView.$el.addClass('is-hidden');
      this.errorModel.set({
        model: model,
        error: enhancedError,
        placeholder: this._getPlaceholder()
      });
    },
  
    _appendView: function (view) {
      this.$el.append(view.render().el);
      this.addView(view);
    },
  
    _noDataAvailable: function () {
      var valueToCheck = this._isHistogram() ? 'totalAmount' : 'data';
      var data = this.model.dataviewModel.get(valueToCheck);
  
      return !Utils.hasValue(data) || (_.isArray(data) && _.isEmpty(data));
    },
  
    _dataHasTooManyBins: function () {
      if (this._isHistogram()) {
        var data = this.model.dataviewModel.getUnfilteredData && this.model.dataviewModel.getUnfilteredData();
        return !_.isEmpty(data) && _.size(data) > MAX_BUCKETS;
      }
      return false;
    },
  
    _isHistogram: function () {
      return this.model.dataviewModel.get('type') === 'histogram';
    },
  
    _extractError: function (response) {
      // XmlHttpRequest error?
      var errors = getValue(response, 'responseJSON.errors_with_context', []);
      if (errors.length > 0) {
        return errors[0];
      } else if (response && response.message) {
        response.type = response.type || 'generic';
        return response;
      }
      return {};
    },
  
    _getPlaceholder: function () {
      var widgetType = this.model.dataviewModel.get('type');
      return PLACEHOLDER_TEMPLATES[widgetType];
    },
  
    _setDisabled: function (model, selectedWidgetId) {
      var differentWidget = model.get('id') !== selectedWidgetId;
  
      if (selectedWidgetId && !differentWidget) {
        this.el.scrollIntoView && this.el.scrollIntoView();
      }
  
      this.$el.toggleClass('is-disabled', selectedWidgetId !== null && differentWidget);
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/deep-insights/widgets/widgets-collection.js":
  /*!****************************************************************************!*\
    !*** ./lib/assets/javascripts/deep-insights/widgets/widgets-collection.js ***!
    \****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   * Collection of Dataviews
   */
  module.exports = Backbone.Collection.extend({
    comparator: 'order',
  
    initialize: function () {
      this._allDataviewsFetched = false;
      this._initBinds();
    },
  
    _initBinds: function () {
      this.bind('change:order', _.debounce(this._onChangeOrder.bind(this), 10), this);
      // If a category model applies the category colors, rest should remove/disable
      // the category colors applied before.
      this.bind('change:autoStyle', function (changedWidgetModel, autoStyle) {
        if (autoStyle) {
          this.each(function (widgetModel) {
            // Only set if model actually has the attr (i.e. it's a category model)
            if (widgetModel.layerModel && widgetModel !== changedWidgetModel && widgetModel.layerModel.get('layer_name') === changedWidgetModel.layerModel.get('layer_name') && widgetModel.get('autoStyle')) {
              widgetModel.set('autoStyle', false);
            }
          });
        }
      }, this);
    },
  
    _onChangeOrder: function () {
      this.sort();
      this.trigger('orderChanged', this);
    },
  
    getStates: function () {
      var state = {};
      this.each(function (widgetModel) {
        var widgetState = widgetModel.getState();
        if (!_.isEmpty(widgetState)) {
          state[widgetModel.get('id')] = widgetState;
        }
      });
      return state;
    },
  
    setStates: function (states) {
      for (var i in states) {
        var widget = this.at(i);
        widget.setState(states[i]);
      }
    },
  
    hasInitialState: function () {
      return this._allDataviewsFetched;
    },
  
    initialState: function () {
      this._allDataviewsFetched = true;
    }
  });
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/locale/index.js":
  /*!************************************************!*\
    !*** ./lib/assets/javascripts/locale/index.js ***!
    \************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  module.exports = {
    en: __webpack_require__(/*! ./en.json */ "./lib/assets/javascripts/locale/en.json"),
    sw: __webpack_require__(/*! ./sw.json */ "./lib/assets/javascripts/locale/sw.json"),
    es: __webpack_require__(/*! ./es.json */ "./lib/assets/javascripts/locale/es.json")
  };
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/core/configuration/filters.js":
  /*!****************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/core/configuration/filters.js ***!
    \****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.defaultParams = undefined;
  
  var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");
  
  var _keys2 = _interopRequireDefault(_keys);
  
  var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ "./node_modules/babel-runtime/helpers/extends.js");
  
  var _extends3 = _interopRequireDefault(_extends2);
  
  exports.isAllowed = isAllowed;
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  var defaultParams = {
    exclude_shared: false,
    per_page: 12,
    shared: 'no',
    locked: false,
    only_liked: false,
    deepInsights: false
  };
  
  var mine = (0, _extends3.default)({}, defaultParams);
  
  var locked = (0, _extends3.default)({}, defaultParams, {
    locked: true
  });
  
  var shared = (0, _extends3.default)({}, defaultParams, {
    shared: 'only'
  });
  
  var favorited = (0, _extends3.default)({}, defaultParams, {
    only_liked: true
  });
  
  var publicPrivacy = (0, _extends3.default)({}, defaultParams, {
    privacy: 'public'
  });
  
  var linkPrivacy = (0, _extends3.default)({}, defaultParams, {
    privacy: 'link'
  });
  
  var passwordPrivacy = (0, _extends3.default)({}, defaultParams, {
    privacy: 'password'
  });
  
  var privatePrivacy = (0, _extends3.default)({}, defaultParams, {
    privacy: 'private'
  });
  
  var filters = {
    mine: mine,
    locked: locked,
    shared: shared,
    favorited: favorited,
    public: publicPrivacy,
    link: linkPrivacy,
    password: passwordPrivacy,
    private: privatePrivacy
  };
  
  var allowedFilters = (0, _keys2.default)(filters);
  
  exports.default = filters;
  exports.defaultParams = defaultParams;
  function isAllowed(filter) {
    return allowedFilters.includes(filter);
  }
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/core/models/visualization.js":
  /*!***************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/core/models/visualization.js ***!
    \***************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");
  
  var _assign2 = _interopRequireDefault(_assign);
  
  exports.isSharedWithMe = isSharedWithMe;
  exports.getURL = getURL;
  exports.getThumbnailUrl = getThumbnailUrl;
  
  var _permissionModel = __webpack_require__(/*! dashboard/data/permission-model */ "./lib/assets/javascripts/dashboard/data/permission-model.js");
  
  var _permissionModel2 = _interopRequireDefault(_permissionModel);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  function isSharedWithMe(visualizationData, models) {
    return models.user.get('id') !== visualizationData.permission.owner.id;
  }
  
  function getURL(visualizationData, models) {
    var loggedUserBackboneModel = models.user;
    var loggedUserId = loggedUserBackboneModel.id || loggedUserBackboneModel.get('id');
    var permissionModel = new _permissionModel2.default(visualizationData.permission, { configModel: models.config });
  
    var id = visualizationData.id;
    var userUrl = permissionModel.owner.viewUrl();
  
    var isVisualization = visualizationData.type === 'derived' || typeof visualizationData.type === 'undefined';
    if (isVisualization) {
      if (loggedUserBackboneModel && loggedUserId !== permissionModel.owner.get('id') && permissionModel.hasAccess(loggedUserBackboneModel)) {
        userUrl = loggedUserBackboneModel.viewUrl();
        id = permissionModel.owner.get('username') + '.' + id;
      }
  
      return userUrl.urlToPath('viz', id).get('base_url');
    } else {
      if (loggedUserBackboneModel && permissionModel.hasAccess(loggedUserBackboneModel)) {
        userUrl = loggedUserBackboneModel.viewUrl();
      }
  
      return userUrl.urlToPath('tables', getUnquotedName(visualizationData.table.name)).get('base_url');
    }
  }
  
  function getThumbnailUrl(visualizationData, models, options) {
    var protocol = isHTTPS() ? 'https' : 'http';
    var cdnConfig = models.config.get('cdn_url');
    var username = visualizationData.permission.owner.username || models.user.get('username');
    var thumbnailOptions = {
      protocol: protocol,
      username: username,
      mapsApiResource: models.config.getMapsResourceName(username),
      tpl: _generateImageTemplate(visualizationData.id),
      width: options.width,
      height: options.height,
      authTokens: _generateAuthTokensParams(visualizationData.auth_tokens)
    };
  
    if (cdnConfig) {
      (0, _assign2.default)(thumbnailOptions, { cdn: cdnConfig[protocol] });
    }
  
    return interpolateTemplateUrl(cdnConfig ? 'cdn' : 'regular', thumbnailOptions);
  }
  
  var interpolateTemplateUrl = function interpolateTemplateUrl(type, options) {
    if (type === 'regular') {
      return options.protocol + '://' + options.mapsApiResource + '/api/v1/map/static/named/' + options.tpl + '/' + options.width + '/' + options.height + '.png' + options.authTokens;
    }
  
    if (type === 'cdn') {
      return options.protocol + '://' + options.cdn + '/' + options.username + '/api/v1/map/static/named/' + options.tpl + '/' + options.width + '/' + options.height + '.png' + options.authTokens;
    }
  };
  
  var _generateAuthTokensParams = function _generateAuthTokensParams(authTokens) {
    if (authTokens && authTokens.length > 0) {
      return '?' + authTokens.map(function (t) {
        return 'auth_token=' + t;
      }).join('&');
    }
  
    return '';
  };
  
  var _generateImageTemplate = function _generateImageTemplate(visualizationId) {
    return 'tpl_' + visualizationId.replace(/-/g, '_');
  };
  
  var isHTTPS = function isHTTPS() {
    return location.protocol.indexOf('https') === 0;
  };
  
  var getUnquotedName = function getUnquotedName() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  
    return name.replace(/"/g, '');
  };
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/directives/click-outside.js":
  /*!**************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/directives/click-outside.js ***!
    \**************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _vue = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
  
  var _vue2 = _interopRequireDefault(_vue);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  _vue2.default.directive('clickOutside', {
    bind: function bind(element, binding, vnode) {
      element.clickOutsideEvent = function (event) {
        if (!element.contains(event.target)) {
          vnode.context[binding.expression](event);
        }
      };
  
      element.addClickEvent = function (event) {
        document.body.addEventListener('click', element.clickOutsideEvent, { passive: true });
      };
  
      element.addEventListener('click', element.addClickEvent, { passive: true });
    },
    unbind: function unbind(element) {
      document.body.removeEventListener('click', element.clickOutsideEvent, { passive: true });
      element.removeEventListener('click', element.addClickEvent, { passive: true });
    }
  });
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/i18n/backbone-i18n.js":
  /*!********************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/i18n/backbone-i18n.js ***!
    \********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _deepObjectExtend = __webpack_require__(/*! new-dashboard/utils/deep-object-extend */ "./lib/assets/javascripts/new-dashboard/utils/deep-object-extend.js");
  
  var _deepObjectExtend2 = _interopRequireDefault(_deepObjectExtend);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  var ACTIVE_LOCALE = 'en';
  if (ACTIVE_LOCALE !== 'en') {
    __webpack_require__("./node_modules/moment/locale sync recursive ^\\.\\/.*$")("./" + ACTIVE_LOCALE);
  }
  
  var Locale = __webpack_require__(/*! locale/index */ "./lib/assets/javascripts/locale/index.js");
  var Polyglot = __webpack_require__(/*! node-polyglot */ "./node_modules/node-polyglot/index.js");
  
  // Override original translation strings
  var overrideTranslationStrings = __webpack_require__(/*! ./locales/en.overrides.json */ "./lib/assets/javascripts/new-dashboard/i18n/locales/en.overrides.json");
  Locale.en = (0, _deepObjectExtend2.default)(Locale.en, overrideTranslationStrings);
  
  var polyglot = new Polyglot({
    locale: ACTIVE_LOCALE, // Needed for pluralize behaviour
    phrases: Locale[ACTIVE_LOCALE]
  });
  
  window._t = polyglot.t.bind(polyglot);
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/i18n/index.js":
  /*!************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/i18n/index.js ***!
    \************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _vue = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
  
  var _vue2 = _interopRequireDefault(_vue);
  
  var _vueI18n = __webpack_require__(/*! vue-i18n */ "./node_modules/vue-i18n/dist/vue-i18n.esm.js");
  
  var _vueI18n2 = _interopRequireDefault(_vueI18n);
  
  __webpack_require__(/*! ./backbone-i18n */ "./lib/assets/javascripts/new-dashboard/i18n/backbone-i18n.js");
  
  var _en = __webpack_require__(/*! new-dashboard/i18n/locales/en */ "./lib/assets/javascripts/new-dashboard/i18n/locales/en.json");
  
  var _en2 = _interopRequireDefault(_en);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  _vue2.default.use(_vueI18n2.default);
  
  // Create VueI18n instance with options
  
  
  // Locales
  var i18n = new _vueI18n2.default({
    locale: 'en',
    messages: {
      en: _en2.default
    }
  });
  
  exports.default = i18n;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/plugins/backbone/backbone-core-models.js":
  /*!***************************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/plugins/backbone/backbone-core-models.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ "./node_modules/babel-runtime/helpers/extends.js");
  
  var _extends3 = _interopRequireDefault(_extends2);
  
  var _vue = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
  
  var _vue2 = _interopRequireDefault(_vue);
  
  var _configModel = __webpack_require__(/*! dashboard/data/config-model */ "./lib/assets/javascripts/dashboard/data/config-model.js");
  
  var _configModel2 = _interopRequireDefault(_configModel);
  
  var _userModel = __webpack_require__(/*! dashboard/data/user-model */ "./lib/assets/javascripts/dashboard/data/user-model.js");
  
  var _userModel2 = _interopRequireDefault(_userModel);
  
  var _organizationModel = __webpack_require__(/*! dashboard/data/organization-model */ "./lib/assets/javascripts/dashboard/data/organization-model.js");
  
  var _organizationModel2 = _interopRequireDefault(_organizationModel);
  
  var _userGroupsCollection = __webpack_require__(/*! dashboard/data/user-groups-collection */ "./lib/assets/javascripts/dashboard/data/user-groups-collection.js");
  
  var _userGroupsCollection2 = _interopRequireDefault(_userGroupsCollection);
  
  var _dashboardBackgroundPollingModel = __webpack_require__(/*! dashboard/data/background-polling/dashboard-background-polling-model */ "./lib/assets/javascripts/dashboard/data/background-polling/dashboard-background-polling-model.js");
  
  var _dashboardBackgroundPollingModel2 = _interopRequireDefault(_dashboardBackgroundPollingModel);
  
  var _getCARTOData = __webpack_require__(/*! new-dashboard/store/utils/getCARTOData */ "./lib/assets/javascripts/new-dashboard/store/utils/getCARTOData.js");
  
  var _getCARTOData2 = _interopRequireDefault(_getCARTOData);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  // Backbone Models
  var BackboneCoreModels = {};
  
  BackboneCoreModels.install = function (Vue, options) {
    Vue.mixin({
      beforeCreate: function beforeCreate() {
        this.$cartoModels = options;
      }
    });
  };
  
  var CARTOData = (0, _getCARTOData2.default)();
  
  var configModel = new _configModel2.default((0, _extends3.default)({}, CARTOData.config, {
    base_url: CARTOData.user_data.base_url
  }));
  var userModel = configureUserModel(CARTOData.user_data);
  
  var backgroundPollingModel = new _dashboardBackgroundPollingModel2.default({
    showGeocodingDatasetURLButton: true,
    geocodingsPolling: true,
    importsPolling: true
  }, { configModel: configModel, userModel: userModel });
  
  _vue2.default.use(BackboneCoreModels, {
    config: configModel,
    user: userModel,
    backgroundPolling: backgroundPollingModel
  });
  
  function configureUserModel(userData) {
    var userModel = new _userModel2.default(userData);
  
    if (userData.organization) {
      userModel.setOrganization(new _organizationModel2.default(userData.organization, { configModel: configModel }));
    }
  
    if (userData.groups) {
      userModel.setGroups(new _userGroupsCollection2.default(userData.groups, { configModel: configModel }));
    }
  
    return userModel;
  }
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/plugins/backbone/modal-model.js":
  /*!******************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/plugins/backbone/modal-model.js ***!
    \******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createModalModel;
  function createModalModel(handlers) {
    return {
      create: handlers.create,
      destroy: handlers.destroy
    };
  }
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/actions/apps.js":
  /*!********************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/actions/apps.js ***!
    \********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");
  
  var _promise2 = _interopRequireDefault(_promise);
  
  exports.fetch = fetch;
  exports.createOAuth = createOAuth;
  exports.updateOAuth = updateOAuth;
  exports.regenerateCredentials = regenerateCredentials;
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  function fetch(fetchFunctionName) {
    return function (context) {
      var apiKey = context.rootState.user.api_key;
  
      context.commit('setFetchingState');
  
      context.rootState.client[fetchFunctionName](apiKey, function (err, _, data) {
        if (err) {
          var error = data.responseJSON && data.responseJSON.errors || { message: data.responseText || data.statusText };
          context.commit('setRequestError', error);
          return;
        }
  
        context.commit('setApps', data.result);
      });
    };
  }
  
  function createOAuth(context, app) {
    var apiKey = context.rootState.user.api_key;
  
  
    return new _promise2.default(function (resolve, reject) {
      context.rootState.client.createApp(apiKey, app, function (err, _, data) {
        if (err) {
          var error = data.responseJSON && data.responseJSON.errors || { message: data.responseText || data.statusText };
          return reject(error);
        }
  
        context.commit('addApp', data);
        resolve(data);
      });
    });
  }
  
  function updateOAuth(context, app) {
    var apiKey = context.rootState.user.api_key;
  
  
    return new _promise2.default(function (resolve, reject) {
      context.rootState.client.updateApp(apiKey, app, function (err, _, data) {
        if (err) {
          var error = data.responseJSON && data.responseJSON.errors || { message: data.responseText || data.statusText };
          return reject(error);
        }
  
        context.commit('updateOAuthApp', data);
        resolve(data);
      });
    });
  }
  
  function regenerateCredentials(context, app) {
    var apiKey = context.rootState.user.api_key;
  
  
    context.rootState.client.regenerateClientSecret(apiKey, app, function (err, _, data) {
      if (err) {
        context.commit('setRequestError', [data.responseText]);
        return;
      }
  
      context.commit('updateOAuthApp', data);
    });
  }
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/actions/catalog.js":
  /*!***********************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/actions/catalog.js ***!
    \***********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ "./node_modules/babel-runtime/core-js/json/stringify.js");
  
  var _stringify2 = _interopRequireDefault(_stringify);
  
  var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");
  
  var _promise2 = _interopRequireDefault(_promise);
  
  exports.fetchCategories = fetchCategories;
  exports.fetchCountries = fetchCountries;
  exports.fetchDatasets = fetchDatasets;
  exports.setURLOptions = setURLOptions;
  exports.order = order;
  exports.clearList = clearList;
  exports.requestDataset = requestDataset;
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  function fetchCategories(context) {
    context.commit('setFetchingState');
  
    /* Using SQL API with observatory account
    https://{username}.carto.com/api/v2/sql?q={SQL statement} */
    var CONFIG_PATH = ['api/v2/sql?q='];
    var q = 'SELECT\n    DISTINCT category\n    FROM carto_do_catalog_master_datasets\n    WHERE include_in_public_web = true';
    var PATH = CONFIG_PATH + q;
    var opts = {
      baseUrl: 'https://observatory.carto.com',
      doNoSetDefaultContentType: true
    };
  
    return new _promise2.default(function (resolve, reject) {
      context.rootState.client.get([PATH], opts, function (err, _, data) {
        if (err) {
          context.commit('setRequestError', err);
          return reject(err);
        }
        context.commit('setCategories', data.rows);
        resolve();
      });
    });
  }
  
  function fetchCountries(context, category) {
    context.commit('setFetchingState');
  
    /* Using SQL API with observatory account
    https://{username}.carto.com/api/v2/sql?q={SQL statement} */
    var CONFIG_PATH = ['api/v2/sql?q='];
    var q = 'SELECT\n    country\n    FROM carto_do_catalog_master_datasets\n    WHERE category=\'' + category + '\'\n    and include_in_public_web = true\n    GROUP BY country\n    ORDER BY country ASC';
    var PATH = CONFIG_PATH + q;
    var opts = {
      baseUrl: 'https://observatory.carto.com',
      doNoSetDefaultContentType: true
    };
  
    return new _promise2.default(function (resolve, reject) {
      context.rootState.client.get([PATH], opts, function (err, _, data) {
        if (err) {
          context.commit('setRequestError', err);
          return reject(err);
        }
        context.commit('setCountries', data.rows);
        resolve();
      });
    });
  }
  
  function fetchDatasets(context, params) {
    context.commit('setFetchingState');
  
    /* Using SQL API with observatory account
    https://{username}.carto.com/api/v2/sql?q={SQL statement} */
    var CONFIG_PATH = ['api/v2/sql?q='];
    var q = 'SELECT dataset AS name,\n    category,\n    description,\n    country,\n    ARRAY_AGG(DISTINCT spatial_aggregations) AS spatial_aggregations,\n    ARRAY_AGG(DISTINCT temporal_aggregations) AS frequency,\n    ARRAY_AGG(DISTINCT provider) AS source,\n    ARRAY_AGG(DISTINCT variable_name) AS variable_name,\n    MIN(cartodb_id) AS id\n    FROM carto_do_catalog_master_datasets\n    WHERE category=\'' + params.category + '\'\n    and country=\'' + params.country + '\'\n    and include_in_public_web = true\n    GROUP BY(dataset, category, country, description)';
    var PATH = CONFIG_PATH + q;
    var opts = {
      baseUrl: 'https://observatory.carto.com',
      doNoSetDefaultContentType: true
    };
  
    return new _promise2.default(function (resolve, reject) {
      context.rootState.client.get([PATH], opts, function (err, _, data) {
        if (err) {
          context.commit('setRequestError', err);
          return reject(err);
        }
        context.commit('setDatasets', data.rows);
        context.commit('setPagination', context.state.page);
        resolve();
      });
    });
  }
  
  function setURLOptions(context, options) {
    context.commit('setPagination', parseInt(options.page || 1));
    context.commit('setOrder', { order: options.order, direction: options.order_direction });
  }
  
  function order(context, orderOptions) {
    context.commit('setPagination', 1);
    context.commit('setOrder', orderOptions);
    context.commit('orderDatasets');
  }
  
  function clearList(context) {
    context.commit('setDatasets', []);
    context.commit('setPagination', 1);
  }
  
  function requestDataset(context, _ref) {
    var user = _ref.user,
        dataset = _ref.dataset;
  
    /* Using V3 hubspot API
    https://api.hsforms.com/submissions/v3/integration/submit/:portalId/:formGuid */
    var hubspot_id = '474999';
    var form_id = '507ead6f-06d9-434a-95e1-a9616c576796';
    var CONFIG_PATH = ['submissions/v3/integration/submit/' + hubspot_id + '/' + form_id];
  
    var data = getFormData(user, dataset);
  
    var opts = {
      data: data,
      baseUrl: 'https://api.hsforms.com'
    };
  
    return new _promise2.default(function (resolve, reject) {
      context.rootState.client.post([CONFIG_PATH], opts, function (err, _, data) {
        if (err) {
          return reject(err);
        }
        resolve();
      });
    });
  }
  
  function getFormData(user, dataset) {
    return (0, _stringify2.default)({
      'fields': [{
        'name': 'email',
        'value': user.email
      }, {
        'name': 'lastname',
        'value': user.last_name || 'no_last_name'
      }, {
        'name': 'firstname',
        'value': user.name || 'no_firstname'
      }, {
        'name': 'jobtitle',
        'value': user.job_role || 'no_jobtitle'
      }, {
        'name': 'company',
        'value': user.company || 'no_company'
      }, {
        'name': 'phone',
        'value': user.phone || 'no_phone'
      }, {
        'name': 'country_data',
        'value': dataset.country
      }, {
        'name': 'data_category',
        'value': dataset.category
      }, {
        'name': 'datastream_name',
        'value': dataset.name
      }, {
        'name': 'data_purpose',
        'value': 'no_data_purpose'
      }],
      'context': {
        'pageUri': 'www.carto.com/dashboard/catalog',
        'pageName': 'Catalog page in Dashboard'
      }
    });
  }
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/actions/visualizations.js":
  /*!******************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/actions/visualizations.js ***!
    \******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.deleteLike = deleteLike;
  exports.fetchVisualizations = fetchVisualizations;
  exports.filter = filter;
  exports.like = like;
  exports.order = order;
  exports.resetFilters = resetFilters;
  exports.setResultsPerPage = setResultsPerPage;
  exports.setURLOptions = setURLOptions;
  exports.updateVisualization = updateVisualization;
  function deleteLike(context, visualization) {
    var currentLikeStatus = visualization.liked;
  
    context.dispatch('updateVisualization', {
      visualizationId: visualization.id,
      visualizationAttributes: {
        liked: false
      }
    });
  
    context.rootState.client.deleteLike(visualization.id, function (err, _, data) {
      if (err) {
        context.dispatch('updateVisualization', {
          visualizationId: visualization.id,
          visualizationAttributes: {
            liked: currentLikeStatus
          }
        });
        return;
      }
  
      context.commit('updateNumberLikes', {
        visualizationId: visualization.id,
        visualizationAttributes: {
          liked: data.liked
        }
      });
    });
  }
  
  function fetchVisualizations(context, parameters) {
    context.commit('setFetchingState');
  
    context.rootState.client.getVisualization('', parameters, function (err, _, data) {
      if (err) {
        context.commit('setRequestError', err);
        return;
      }
      context.commit('setVisualizations', data);
      context.commit('setPagination', context.state.page);
    });
  }
  
  function filter(context, filter) {
    context.commit('setPagination', 1);
    context.commit('setFilterType', filter);
    context.dispatch('fetch');
  }
  
  function like(context, visualization) {
    var currentLikeStatus = visualization.liked;
  
    context.dispatch('updateVisualization', {
      visualizationId: visualization.id,
      visualizationAttributes: {
        liked: true
      }
    });
  
    context.rootState.client.like(visualization.id, function (err, _, data) {
      if (err) {
        context.dispatch('updateVisualization', {
          visualizationId: visualization.id,
          visualizationAttributes: {
            liked: currentLikeStatus
          }
        });
  
        return;
      }
  
      context.commit('updateNumberLikes', {
        visualizationId: visualization.id,
        visualizationAttributes: {
          liked: data.liked
        }
      });
    });
  }
  
  function order(context, orderOptions) {
    context.commit('setPagination', 1);
    context.commit('setOrder', orderOptions);
    context.dispatch('fetch');
  }
  
  function resetFilters(DEFAULT_VALUES) {
    return function (context) {
      context.commit('setPagination', 1);
      context.commit('setFilterType', 'mine');
      context.commit('setResultsPerPage', 12);
      context.commit('setOrder', { order: DEFAULT_VALUES.order, direction: DEFAULT_VALUES.orderDirection });
    };
  }
  
  function setResultsPerPage(context, perPage) {
    context.commit('setResultsPerPage', perPage);
  }
  
  function setURLOptions(context, options) {
    context.commit('setPagination', parseInt(options.page || 1));
    context.commit('setFilterType', options.filter);
    context.commit('setOrder', { order: options.order, direction: options.order_direction });
    context.dispatch('fetch');
  }
  
  function updateVisualization(context, visualizationOptions) {
    context.commit('maps/updateVisualization', visualizationOptions, { root: true });
    context.commit('datasets/updateVisualization', visualizationOptions, { root: true });
    context.commit('recentContent/updateVisualization', visualizationOptions, { root: true });
    context.commit('search/updateVisualization', visualizationOptions, { root: true });
  }
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/index.js":
  /*!*************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/index.js ***!
    \*************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _vue = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
  
  var _vue2 = _interopRequireDefault(_vue);
  
  var _vuex = __webpack_require__(/*! vuex */ "./node_modules/vuex/dist/vuex.esm.js");
  
  var _vuex2 = _interopRequireDefault(_vuex);
  
  var _cartoNode = __webpack_require__(/*! carto-node */ "./lib/assets/javascripts/carto-node/index.js");
  
  var _cartoNode2 = _interopRequireDefault(_cartoNode);
  
  var _user = __webpack_require__(/*! ./modules/user */ "./lib/assets/javascripts/new-dashboard/store/modules/user/index.js");
  
  var _user2 = _interopRequireDefault(_user);
  
  var _config = __webpack_require__(/*! ./modules/config */ "./lib/assets/javascripts/new-dashboard/store/modules/config/index.js");
  
  var _config2 = _interopRequireDefault(_config);
  
  var _maps = __webpack_require__(/*! ./modules/maps */ "./lib/assets/javascripts/new-dashboard/store/modules/maps/index.js");
  
  var _maps2 = _interopRequireDefault(_maps);
  
  var _datasets = __webpack_require__(/*! ./modules/data/datasets */ "./lib/assets/javascripts/new-dashboard/store/modules/data/datasets/index.js");
  
  var _datasets2 = _interopRequireDefault(_datasets);
  
  var _catalog = __webpack_require__(/*! ./modules/data/catalog */ "./lib/assets/javascripts/new-dashboard/store/modules/data/catalog/index.js");
  
  var _catalog2 = _interopRequireDefault(_catalog);
  
  var _search = __webpack_require__(/*! ./modules/search */ "./lib/assets/javascripts/new-dashboard/store/modules/search/index.js");
  
  var _search2 = _interopRequireDefault(_search);
  
  var _notifications = __webpack_require__(/*! ./modules/notifications */ "./lib/assets/javascripts/new-dashboard/store/modules/notifications/index.js");
  
  var _notifications2 = _interopRequireDefault(_notifications);
  
  var _recentContent = __webpack_require__(/*! ./modules/recent-content */ "./lib/assets/javascripts/new-dashboard/store/modules/recent-content/index.js");
  
  var _recentContent2 = _interopRequireDefault(_recentContent);
  
  var _oAuth = __webpack_require__(/*! ./modules/apps/oAuth */ "./lib/assets/javascripts/new-dashboard/store/modules/apps/oAuth/index.js");
  
  var _oAuth2 = _interopRequireDefault(_oAuth);
  
  var _connected = __webpack_require__(/*! ./modules/apps/connected */ "./lib/assets/javascripts/new-dashboard/store/modules/apps/connected/index.js");
  
  var _connected2 = _interopRequireDefault(_connected);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  // Store Modules
  _vue2.default.use(_vuex2.default);
  
  var storeOptions = {
    state: {
      client: new _cartoNode2.default.AuthenticatedClient()
    },
    getters: {},
    modules: {
      config: _config2.default,
      user: _user2.default,
      maps: _maps2.default,
      datasets: _datasets2.default,
      catalog: _catalog2.default,
      search: _search2.default,
      notifications: _notifications2.default,
      recentContent: _recentContent2.default,
      oAuthApps: _oAuth2.default,
      connectedApps: _connected2.default
    }
  };
  
  exports.default = new _vuex2.default.Store(storeOptions);
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/modules/apps/connected/index.js":
  /*!************************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/modules/apps/connected/index.js ***!
    \************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");
  
  var _promise2 = _interopRequireDefault(_promise);
  
  var _apps = __webpack_require__(/*! ../../../mutations/apps */ "./lib/assets/javascripts/new-dashboard/store/mutations/apps.js");
  
  var AppsMutations = _interopRequireWildcard(_apps);
  
  var _apps2 = __webpack_require__(/*! ../../../actions/apps */ "./lib/assets/javascripts/new-dashboard/store/actions/apps.js");
  
  var AppsActions = _interopRequireWildcard(_apps2);
  
  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  var connectedApps = {
    namespaced: true,
    state: {
      isFetching: false,
      isErrored: false,
      error: [],
      list: {}
    },
    computed: {},
    getters: {},
    mutations: {
      setApps: AppsMutations.setApps,
      setRequestError: AppsMutations.setRequestError,
      setFetchingState: AppsMutations.setFetchingState
    },
    actions: {
      fetch: AppsActions.fetch('getConnectedApps'),
  
      revoke: function revoke(context, app) {
        var apiKey = context.rootState.user.api_key;
  
  
        return new _promise2.default(function (resolve, reject) {
          context.rootState.client.revokeOAuthApp(apiKey, app, function (err, _, data) {
            if (err) {
              return reject(data.responseJSON.errors);
            }
            resolve();
          });
        });
      }
    }
  };
  
  exports.default = connectedApps;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/modules/apps/oAuth/index.js":
  /*!********************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/modules/apps/oAuth/index.js ***!
    \********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");
  
  var _promise2 = _interopRequireDefault(_promise);
  
  var _apps = __webpack_require__(/*! ../../../mutations/apps */ "./lib/assets/javascripts/new-dashboard/store/mutations/apps.js");
  
  var AppsMutations = _interopRequireWildcard(_apps);
  
  var _apps2 = __webpack_require__(/*! ../../../actions/apps */ "./lib/assets/javascripts/new-dashboard/store/actions/apps.js");
  
  var AppsActions = _interopRequireWildcard(_apps2);
  
  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  var oAuthApps = {
    namespaced: true,
    state: {
      isFetching: false,
      isErrored: false,
      error: [],
      list: {}
    },
    computed: {},
    getters: {},
    mutations: {
      setApps: AppsMutations.setApps,
      addApp: AppsMutations.addApp,
      setFetchingState: AppsMutations.setFetchingState,
      setRequestError: AppsMutations.setRequestError,
      updateOAuthApp: AppsMutations.updateOAuthApp
    },
    actions: {
      fetch: AppsActions.fetch('getOAuthApps'),
      create: AppsActions.createOAuth,
      update: AppsActions.updateOAuth,
      setApps: AppsMutations.setApps,
      regenerateCredentials: AppsActions.regenerateCredentials,
  
      delete: function _delete(context, app) {
        var apiKey = context.rootState.user.api_key;
  
  
        return new _promise2.default(function (resolve, reject) {
          context.rootState.client.deleteApp(apiKey, app, function (err, _, data) {
            if (err) {
              return reject(data.responseJSON.errors);
            }
            resolve();
          });
        });
      }
    }
  };
  
  exports.default = oAuthApps;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/modules/config/index.js":
  /*!****************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/modules/config/index.js ***!
    \****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ "./node_modules/babel-runtime/helpers/extends.js");
  
  var _extends3 = _interopRequireDefault(_extends2);
  
  var _getCARTOData = __webpack_require__(/*! new-dashboard/store/utils/getCARTOData */ "./lib/assets/javascripts/new-dashboard/store/utils/getCARTOData.js");
  
  var _getCARTOData2 = _interopRequireDefault(_getCARTOData);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  // Data coming from Static Page Loading,
  // which requests user and config data from
  // /me API endpoint.
  var CARTOData = (0, _getCARTOData2.default)();
  var CARTOUserData = CARTOData.user_data;
  
  var config = {
    namespaced: true,
    state: (0, _extends3.default)({}, CARTOData.config, {
      base_url: CARTOUserData.base_url,
      default_fallback_basemap: CARTOData.default_fallback_basemap,
      isFirstTimeViewingDashboard: CARTOData.is_first_time_viewing_dashboard,
      url_prefix: CARTOUserData.base_url,
      plan_url: CARTOData.plan_url
    }),
    getters: {},
    mutations: {},
    actions: {}
  };
  
  exports.default = config;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/modules/data/catalog/index.js":
  /*!**********************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/modules/data/catalog/index.js ***!
    \**********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _catalog = __webpack_require__(/*! ../../../actions/catalog */ "./lib/assets/javascripts/new-dashboard/store/actions/catalog.js");
  
  var CatalogActions = _interopRequireWildcard(_catalog);
  
  var _catalog2 = __webpack_require__(/*! ../../../mutations/catalog */ "./lib/assets/javascripts/new-dashboard/store/mutations/catalog.js");
  
  var CatalogMutations = _interopRequireWildcard(_catalog2);
  
  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
  
  var DEFAULT_VALUES = {
    order: '',
    orderDirection: ''
  };
  
  var catalog = {
    namespaced: true,
    state: {
      isFetching: false,
      isErrored: false,
      error: [],
      list: [],
      categories: [],
      countries: [],
      page: 1,
      numPages: 1,
      resultsPerPage: 12,
      order: DEFAULT_VALUES.order,
      orderDirection: DEFAULT_VALUES.orderDirection
    },
    computed: {},
    getters: {},
    mutations: {
      setDatasets: CatalogMutations.setDatasets,
      setCategories: CatalogMutations.setCategories,
      setCountries: CatalogMutations.setCountries,
      setFetchingState: CatalogMutations.setFetchingState,
      setRequestError: CatalogMutations.setRequestError,
      setPagination: CatalogMutations.setPagination,
      setResultsPerPage: CatalogMutations.setResultsPerPage,
      setOrder: CatalogMutations.setOrder(DEFAULT_VALUES),
      orderDatasets: CatalogMutations.orderDatasets
    },
    actions: {
      setURLOptions: CatalogActions.setURLOptions,
      order: CatalogActions.order,
      fetchCountries: CatalogActions.fetchCountries,
      fetchDatasets: CatalogActions.fetchDatasets,
      clearList: CatalogActions.clearList,
      fetchCategories: CatalogActions.fetchCategories,
      requestDataset: CatalogActions.requestDataset
    }
  };
  
  exports.default = catalog;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/modules/data/datasets/index.js":
  /*!***********************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/modules/data/datasets/index.js ***!
    \***********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ "./node_modules/babel-runtime/helpers/extends.js");
  
  var _extends3 = _interopRequireDefault(_extends2);
  
  var _filters = __webpack_require__(/*! new-dashboard/core/configuration/filters */ "./lib/assets/javascripts/new-dashboard/core/configuration/filters.js");
  
  var _filters2 = _interopRequireDefault(_filters);
  
  var _visualizations = __webpack_require__(/*! ../../../actions/visualizations */ "./lib/assets/javascripts/new-dashboard/store/actions/visualizations.js");
  
  var VisualizationActions = _interopRequireWildcard(_visualizations);
  
  var _visualizations2 = __webpack_require__(/*! ../../../mutations/visualizations */ "./lib/assets/javascripts/new-dashboard/store/mutations/visualizations.js");
  
  var VisualizationMutations = _interopRequireWildcard(_visualizations2);
  
  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  var DEFAULT_VALUES = {
    filter: 'mine',
    order: 'favorited,updated_at',
    orderDirection: 'desc,desc'
  };
  
  var datasets = {
    namespaced: true,
    state: {
      isFetching: false,
      isFiltered: false,
      isErrored: false,
      error: {},
      filterType: DEFAULT_VALUES.filter,
      order: DEFAULT_VALUES.order,
      orderDirection: DEFAULT_VALUES.orderDirection,
      list: {},
      metadata: {},
      page: 1,
      numPages: 1,
      resultsPerPage: 1
    },
    mutations: {
      setFetchingState: VisualizationMutations.setFetchingState,
      setFilterType: VisualizationMutations.setFilterType,
      setOrder: VisualizationMutations.setOrder(DEFAULT_VALUES),
      setPagination: VisualizationMutations.setPagination,
      setResultsPerPage: VisualizationMutations.setResultsPerPage,
      setRequestError: VisualizationMutations.setRequestError,
      setVisualizations: VisualizationMutations.setVisualizations,
      updateNumberLikes: VisualizationMutations.updateNumberLikes,
      updateVisualization: VisualizationMutations.updateVisualization
    },
    actions: {
      deleteLike: VisualizationActions.deleteLike,
      filter: VisualizationActions.filter,
      like: VisualizationActions.like,
      order: VisualizationActions.order,
      resetFilters: VisualizationActions.resetFilters(DEFAULT_VALUES),
      setResultsPerPage: VisualizationActions.setResultsPerPage,
      setURLOptions: VisualizationActions.setURLOptions,
      updateVisualization: VisualizationActions.updateVisualization,
  
      fetch: function fetch(context) {
        var params = (0, _extends3.default)({}, _filters2.default[context.state.filterType], {
          types: 'table',
          page: context.state.page,
          order: context.state.order,
          order_direction: context.state.orderDirection,
          per_page: context.state.resultsPerPage,
          with_dependent_visualizations: 10
        });
  
        VisualizationActions.fetchVisualizations(context, params);
      }
    }
  };
  
  exports.default = datasets;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/modules/maps/featured-favorited-maps.js":
  /*!********************************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/modules/maps/featured-favorited-maps.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ "./node_modules/babel-runtime/helpers/extends.js");
  
  var _extends3 = _interopRequireDefault(_extends2);
  
  var _cartoNode = __webpack_require__(/*! carto-node */ "./lib/assets/javascripts/carto-node/index.js");
  
  var _cartoNode2 = _interopRequireDefault(_cartoNode);
  
  var _toObject = __webpack_require__(/*! new-dashboard/utils/to-object */ "./lib/assets/javascripts/new-dashboard/utils/to-object.js");
  
  var _toObject2 = _interopRequireDefault(_toObject);
  
  var _filters = __webpack_require__(/*! new-dashboard/core/configuration/filters */ "./lib/assets/javascripts/new-dashboard/core/configuration/filters.js");
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  var client = new _cartoNode2.default.AuthenticatedClient();
  
  var featuredFavoritedMaps = {
    namespaced: true,
    state: {
      isFetching: false,
      isFiltered: false,
      isErrored: false,
      error: {},
      list: {},
      metadata: {},
      order: 'updated_at',
      params: {
        per_page: 2,
        only_liked: true
      }
    },
    getters: {},
    mutations: {
      setRequestError: function setRequestError(state, error) {
        state.isFetching = false;
        state.isErrored = true;
        state.error = error;
      },
      setFeaturedFavoritedMaps: function setFeaturedFavoritedMaps(state, maps) {
        state.list = (0, _toObject2.default)(maps.visualizations, 'id');
        state.metadata = {
          total_entries: maps.total_entries,
          total_likes: maps.total_likes,
          total_shared: maps.total_shared,
          total_user_entries: maps.total_user_entries
        };
        state.isFetching = false;
      },
      setFetchingState: function setFetchingState(state) {
        state.isFetching = true;
        state.isErrored = false;
        state.error = {};
      }
    },
    actions: {
      fetchMaps: function fetchMaps(context) {
        var favoritedParams = (0, _extends3.default)({}, _filters.defaultParams, context.state.params, {
          order: context.state.order
        });
  
        context.commit('setFetchingState');
  
        client.getVisualization('', favoritedParams, function (err, _, data) {
          if (err) {
            context.commit('setRequestError', err);
            return;
          }
  
          context.commit('setFeaturedFavoritedMaps', data);
        });
      }
    }
  };
  
  exports.default = featuredFavoritedMaps;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/modules/maps/index.js":
  /*!**************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/modules/maps/index.js ***!
    \**************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ "./node_modules/babel-runtime/helpers/extends.js");
  
  var _extends3 = _interopRequireDefault(_extends2);
  
  var _featuredFavoritedMaps = __webpack_require__(/*! new-dashboard/store/modules/maps/featured-favorited-maps */ "./lib/assets/javascripts/new-dashboard/store/modules/maps/featured-favorited-maps.js");
  
  var _featuredFavoritedMaps2 = _interopRequireDefault(_featuredFavoritedMaps);
  
  var _filters = __webpack_require__(/*! new-dashboard/core/configuration/filters */ "./lib/assets/javascripts/new-dashboard/core/configuration/filters.js");
  
  var _filters2 = _interopRequireDefault(_filters);
  
  var _visualizations = __webpack_require__(/*! ../../actions/visualizations */ "./lib/assets/javascripts/new-dashboard/store/actions/visualizations.js");
  
  var VisualizationActions = _interopRequireWildcard(_visualizations);
  
  var _visualizations2 = __webpack_require__(/*! ../../mutations/visualizations */ "./lib/assets/javascripts/new-dashboard/store/mutations/visualizations.js");
  
  var VisualizationMutations = _interopRequireWildcard(_visualizations2);
  
  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  var DEFAULT_VALUES = {
    filter: 'mine',
    order: 'favorited,updated_at',
    orderDirection: 'desc,desc'
  };
  
  var maps = {
    namespaced: true,
    modules: {
      featuredFavoritedMaps: _featuredFavoritedMaps2.default
    },
    state: {
      isFetching: false,
      isFiltered: false,
      isErrored: false,
      error: {},
      filterType: DEFAULT_VALUES.filter,
      order: DEFAULT_VALUES.order,
      orderDirection: DEFAULT_VALUES.orderDirection,
      list: {},
      metadata: {},
      page: 1,
      numPages: 1,
      resultsPerPage: 12
    },
    getters: {},
    mutations: {
      setFetchingState: VisualizationMutations.setFetchingState,
      setFilterType: VisualizationMutations.setFilterType,
      setOrder: VisualizationMutations.setOrder(DEFAULT_VALUES),
      setPagination: VisualizationMutations.setPagination,
      setResultsPerPage: VisualizationMutations.setResultsPerPage,
      setRequestError: VisualizationMutations.setRequestError,
      setVisualizations: VisualizationMutations.setVisualizations,
      updateNumberLikes: VisualizationMutations.updateNumberLikes,
      updateVisualization: VisualizationMutations.updateVisualization
    },
    actions: {
      deleteLike: VisualizationActions.deleteLike,
      filter: VisualizationActions.filter,
      like: VisualizationActions.like,
      order: VisualizationActions.order,
      resetFilters: VisualizationActions.resetFilters(DEFAULT_VALUES),
      setResultsPerPage: VisualizationActions.setResultsPerPage,
      setURLOptions: VisualizationActions.setURLOptions,
      updateVisualization: VisualizationActions.updateVisualization,
  
      fetch: function fetch(context) {
        var params = (0, _extends3.default)({}, _filters2.default[context.state.filterType], {
          types: 'derived',
          page: context.state.page,
          order: context.state.order,
          order_direction: context.state.orderDirection,
          per_page: context.state.resultsPerPage
        });
  
        VisualizationActions.fetchVisualizations(context, params);
      }
    }
  };
  
  exports.default = maps;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/modules/notifications/index.js":
  /*!***********************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/modules/notifications/index.js ***!
    \***********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ "./node_modules/babel-runtime/helpers/extends.js");
  
  var _extends3 = _interopRequireDefault(_extends2);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  var notifications = {
    namespaced: true,
    state: {
      isFetching: false,
      isErrored: false,
      error: {},
      notifications: []
    },
    computed: {},
    getters: {},
    mutations: {
      setNotifications: function setNotifications(state, notifications) {
        state.notifications = notifications;
        state.isFetching = false;
        state.isErrored = false;
        state.error = [];
      },
      setRequestError: function setRequestError(state, error) {
        state.isFetching = false;
        state.isErrored = true;
        state.error = error;
        state.notifications = [];
      },
      setFetchingState: function setFetchingState(state) {
        state.isFetching = true;
        state.isErrored = false;
        state.error = [];
        state.notifications = [];
      }
    },
    actions: {
      fetchNotifications: function fetchNotifications(context, options) {
        context.commit('setFetchingState');
        context.rootState.client.getConfig(function (err, _, data) {
          if (err) {
            context.commit('setRequestError', err);
            return;
          }
  
          context.commit('setNotifications', data.unfiltered_organization_notifications);
          context.dispatch('markNotificationsAsRead', options);
        });
      },
      markNotificationsAsRead: function markNotificationsAsRead(context, options) {
        var nowString = new Date().toISOString();
        context.state.notifications.forEach(function (notification) {
          var userId = options.userId,
              apiKey = options.apiKey;
  
          if (!notification.read_at) {
            var notificationCopy = (0, _extends3.default)({}, notification, { read_at: nowString });
            context.rootState.client.updateNotification(userId, apiKey, notificationCopy, function () {});
          }
        });
      }
    }
  };
  
  exports.default = notifications;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/modules/recent-content/index.js":
  /*!************************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/modules/recent-content/index.js ***!
    \************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ "./node_modules/babel-runtime/helpers/extends.js");
  
  var _extends3 = _interopRequireDefault(_extends2);
  
  var _filters = __webpack_require__(/*! new-dashboard/core/configuration/filters */ "./lib/assets/javascripts/new-dashboard/core/configuration/filters.js");
  
  var _toObject = __webpack_require__(/*! new-dashboard/utils/to-object */ "./lib/assets/javascripts/new-dashboard/utils/to-object.js");
  
  var _toObject2 = _interopRequireDefault(_toObject);
  
  var _visualizations = __webpack_require__(/*! ../../actions/visualizations */ "./lib/assets/javascripts/new-dashboard/store/actions/visualizations.js");
  
  var VisualizationActions = _interopRequireWildcard(_visualizations);
  
  var _visualizations2 = __webpack_require__(/*! ../../mutations/visualizations */ "./lib/assets/javascripts/new-dashboard/store/mutations/visualizations.js");
  
  var VisualizationMutations = _interopRequireWildcard(_visualizations2);
  
  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  var recentContent = {
    namespaced: true,
    state: {
      isFetching: false,
      isErrored: false,
      error: {},
      list: {},
      metadata: {
        total_entries: 0
      }
    },
    getters: {
      hasRecentContent: function hasRecentContent(state) {
        return state.metadata.total_entries > 0;
      }
    },
    mutations: {
      setFetchingState: VisualizationMutations.setFetchingState,
      setRequestError: VisualizationMutations.setRequestError,
      updateNumberLikes: VisualizationMutations.updateNumberLikes,
      updateVisualization: VisualizationMutations.updateVisualization,
  
      setRecentContent: function setRecentContent(state, recentContent) {
        state.list = (0, _toObject2.default)(recentContent.visualizations, 'id');
        state.metadata = { total_entries: recentContent.total_entries };
        state.isFetching = false;
      }
    },
    actions: {
      like: VisualizationActions.like,
      deleteLike: VisualizationActions.deleteLike,
      updateVisualization: VisualizationActions.updateVisualization,
  
      fetch: function fetch(context) {
        context.commit('setFetchingState');
  
        var params = (0, _extends3.default)({}, _filters.defaultParams, {
          order: 'updated_at',
          order_direction: 'desc',
          types: 'table,derived',
          per_page: 3,
          page: 1
        });
  
        context.rootState.client.getVisualization('', params, function (err, _, data) {
          if (err) {
            context.commit('setRequestError', err);
            return;
          }
  
          context.commit('setRecentContent', data);
        });
      }
    }
  };
  
  exports.default = recentContent;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/modules/search/index.js":
  /*!****************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/modules/search/index.js ***!
    \****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ "./node_modules/babel-runtime/helpers/extends.js");
  
  var _extends3 = _interopRequireDefault(_extends2);
  
  var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");
  
  var _assign2 = _interopRequireDefault(_assign);
  
  var _toObject = __webpack_require__(/*! new-dashboard/utils/to-object */ "./lib/assets/javascripts/new-dashboard/utils/to-object.js");
  
  var _toObject2 = _interopRequireDefault(_toObject);
  
  var _visualizations = __webpack_require__(/*! ../../actions/visualizations */ "./lib/assets/javascripts/new-dashboard/store/actions/visualizations.js");
  
  var VisualizationActions = _interopRequireWildcard(_visualizations);
  
  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  var search = {
    namespaced: true,
    state: {
      searchTerm: '',
      tag: '',
      resultsPerPage: 6,
      maps: {
        isFetching: false,
        isErrored: false,
        results: {},
        error: {},
        page: 1,
        numPages: 1,
        numResults: 0
      },
      datasets: {
        isFetching: false,
        isErrored: false,
        results: {},
        error: {},
        page: 1,
        numPages: 1,
        numResults: 0
      },
      tags: {
        isFetching: false,
        isErrored: false,
        results: [],
        error: {},
        page: 1,
        numPages: 1,
        numResults: 0
      }
    },
    getters: {
      requestParameters: function requestParameters(state) {
        var parameters = {
          per_page: state.resultsPerPage,
          shared: 'yes',
          exclude_shared: false
        };
  
        if (state.searchTerm) {
          parameters.q = state.searchTerm;
        }
  
        if (state.tag) {
          parameters.tags = state.tag;
        }
  
        return parameters;
      }
    },
    mutations: {
      updatePage: function updatePage(state, _ref) {
        var section = _ref.section,
            page = _ref.page;
  
        state[section].page = page;
      },
      updateSearchTerm: function updateSearchTerm(state, _ref2) {
        var query = _ref2.query,
            tag = _ref2.tag;
  
        state.searchTerm = query;
        state.tag = tag;
      },
      setFetchingState: function setFetchingState(state, section) {
        state[section].isFetching = true;
      },
      setRequestError: function setRequestError(state, _ref3) {
        var requestType = _ref3.requestType,
            error = _ref3.error;
  
        state[requestType].error = error;
      },
      setMaps: function setMaps(state, maps) {
        state.maps.results = (0, _toObject2.default)(maps.visualizations, 'id');
        state.maps.numResults = maps.total_entries;
        state.maps.numPages = Math.ceil(maps.total_entries / state.resultsPerPage);
  
        state.maps.isFetching = false;
      },
      setDatasets: function setDatasets(state, datasets) {
        state.datasets.results = (0, _toObject2.default)(datasets.visualizations, 'id');
        state.datasets.numResults = datasets.total_entries;
        state.datasets.numPages = Math.ceil(datasets.total_entries / state.resultsPerPage);
  
        state.datasets.isFetching = false;
      },
      setTags: function setTags(state, tags) {
        state.tags.results = tags.result;
        state.tags.numResults = tags.total;
        state.tags.numPages = Math.ceil(tags.total / state.resultsPerPage);
  
        state.tags.isFetching = false;
      },
      updateNumberLikes: function updateNumberLikes() {
        // NOOP. This method avoids action not finding mutation.
      },
      updateVisualization: function updateVisualization(state, _ref4) {
        var visualizationId = _ref4.visualizationId,
            visualizationAttributes = _ref4.visualizationAttributes;
  
        var visualization = state.maps.results[visualizationId] || state.datasets.results[visualizationId];
  
        if (visualization) {
          (0, _assign2.default)(visualization, visualizationAttributes);
        }
      },
      resetState: function resetState(state) {
        state.searchTerm = '';
        state.tag = '';
  
        state.maps = {
          isFetching: false,
          isErrored: false,
          results: {},
          error: {},
          page: 1,
          numPages: 1,
          numResults: 0
        };
  
        state.datasets = {
          isFetching: false,
          isErrored: false,
          results: {},
          error: {},
          page: 1,
          numPages: 1,
          numResults: 0
        };
  
        state.tags = {
          isFetching: false,
          isErrored: false,
          results: [],
          error: {},
          page: 1,
          numPages: 1,
          numResults: 0
        };
      }
    },
    actions: {
      deleteLike: VisualizationActions.deleteLike,
      like: VisualizationActions.like,
      doSearch: function doSearch(context, searchParameters) {
        context.commit('updateSearchTerm', searchParameters);
        context.commit('setFetchingState', 'maps');
        context.commit('setFetchingState', 'datasets');
  
        context.dispatch('fetchMaps', context.getters.requestParameters);
        context.dispatch('fetchDatasets', context.getters.requestParameters);
  
        if (searchParameters.query) {
          context.dispatch('fetchTags', context.getters.requestParameters);
          context.commit('setFetchingState', 'tags');
        }
      },
      changeSectionPage: function changeSectionPage(context, pageOptions) {
        context.commit('setFetchingState', pageOptions.section);
  
        var sectionCapitalized = pageOptions.section[0].toUpperCase() + pageOptions.section.substr(1);
        context.commit('updatePage', pageOptions);
  
        context.dispatch('fetch' + sectionCapitalized, context.getters.requestParameters);
      },
      fetchMaps: function fetchMaps(context, parameters) {
        context.rootState.client.getVisualization('', (0, _extends3.default)({}, parameters, {
          type: 'derived',
          page: context.state.maps.page }), function (error, _, data) {
          if (error) {
            return context.commit('setRequestError', { requestType: 'maps', error: error });
          }
  
          context.commit('setMaps', data);
        });
      },
      fetchDatasets: function fetchDatasets(context, parameters) {
        context.rootState.client.getVisualization('', (0, _extends3.default)({}, parameters, {
          type: 'table',
          page: context.state.datasets.page,
          with_dependent_visualizations: 10
        }), function (error, _, data) {
          if (error) {
            return context.commit('setRequestError', { requestType: 'datasets', error: error });
          }
  
          context.commit('setDatasets', data);
        });
      },
      fetchTags: function fetchTags(context, parameters) {
        context.rootState.client.getTags((0, _extends3.default)({}, parameters, {
          types: 'table,derived',
          page: context.state.tags.page,
          include_shared: true
        }), function (error, _, data) {
          if (error) {
            return context.commit('setRequestError', { requestType: 'tags', error: error });
          }
  
          context.commit('setTags', data);
        });
      },
      resetState: function resetState(context) {
        context.commit('resetState');
      }
    }
  };
  
  exports.default = search;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/modules/user/getters.js":
  /*!****************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/modules/user/getters.js ***!
    \****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.canCreateDatasets = canCreateDatasets;
  exports.hasCreateDatasetsFeature = hasCreateDatasetsFeature;
  exports.isBuilder = isBuilder;
  exports.isViewer = isViewer;
  exports.hasEngine = hasEngine;
  exports.isNotificationVisible = isNotificationVisible;
  exports.userNotification = userNotification;
  exports.getPublicMapsCount = getPublicMapsCount;
  exports.getPublicMapsQuota = getPublicMapsQuota;
  exports.isOutOfPublicMapsQuota = isOutOfPublicMapsQuota;
  exports.getDatasetsCount = getDatasetsCount;
  exports.getDatasetsQuota = getDatasetsQuota;
  exports.isOutOfDatasetsQuota = isOutOfDatasetsQuota;
  exports.isOrganizationUser = isOrganizationUser;
  function canCreateDatasets(state) {
    if (!state.remaining_byte_quota || state.remaining_byte_quota <= 0 || isOutOfDatasetsQuota(state)) {
      return false;
    }
  
    return hasCreateDatasetsFeature(state);
  }
  
  function hasCreateDatasetsFeature(state) {
    return isBuilder(state);
  }
  
  function isBuilder(state) {
    return !isViewer(state);
  }
  
  function isViewer(state) {
    return state.viewer === true;
  }
  
  function hasEngine(state) {
    return state.actions.engine_enabled === true;
  }
  
  function isNotificationVisible(state) {
    return state.notification && state.showNotification;
  }
  
  function userNotification(state) {
    return state.notification ? state.notification : null;
  }
  
  function getPublicMapsCount(state) {
    return state.link_privacy_map_count + state.password_privacy_map_count + state.public_privacy_map_count || 0;
  }
  
  function getPublicMapsQuota(state) {
    return state.public_map_quota;
  }
  
  function isOutOfPublicMapsQuota(state) {
    return getPublicMapsQuota(state) && getPublicMapsCount(state) >= getPublicMapsQuota(state);
  }
  
  function getDatasetsCount(state) {
    return state.table_count;
  }
  
  function getDatasetsQuota(state) {
    return state.table_quota;
  }
  
  function isOutOfDatasetsQuota(state) {
    return getDatasetsQuota(state) && getDatasetsCount(state) >= getDatasetsQuota(state);
  }
  
  function isOrganizationUser(state) {
    return Boolean(state.organization);
  }
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/modules/user/index.js":
  /*!**************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/modules/user/index.js ***!
    \**************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");
  
  var _assign2 = _interopRequireDefault(_assign);
  
  var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ "./node_modules/babel-runtime/helpers/extends.js");
  
  var _extends3 = _interopRequireDefault(_extends2);
  
  var _cartoNode = __webpack_require__(/*! carto-node */ "./lib/assets/javascripts/carto-node/index.js");
  
  var _cartoNode2 = _interopRequireDefault(_cartoNode);
  
  var _getCARTOData = __webpack_require__(/*! new-dashboard/store/utils/getCARTOData */ "./lib/assets/javascripts/new-dashboard/store/utils/getCARTOData.js");
  
  var _getCARTOData2 = _interopRequireDefault(_getCARTOData);
  
  var _getters = __webpack_require__(/*! ./getters */ "./lib/assets/javascripts/new-dashboard/store/modules/user/getters.js");
  
  var getters = _interopRequireWildcard(_getters);
  
  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  var client = new _cartoNode2.default.AuthenticatedClient();
  
  // Data coming from Static Page Loading,
  // which requests user and config data from
  // /me API endpoint.
  var CARTOData = (0, _getCARTOData2.default)();
  
  var user = {
    namespaced: true,
    state: (0, _extends3.default)({}, CARTOData.user_data, {
      organizationNotifications: CARTOData.organization_notifications || [],
      showNotification: true
    }),
    getters: {
      canCreateDatasets: getters.canCreateDatasets,
      isViewer: getters.isViewer,
      hasEngine: getters.hasEngine,
      userNotification: getters.userNotification,
      isNotificationVisible: getters.isNotificationVisible,
      publicMapsCount: getters.getPublicMapsCount,
      publicMapsQuota: getters.getPublicMapsQuota,
      isOutOfPublicMapsQuota: getters.isOutOfPublicMapsQuota,
      datasetsCount: getters.getDatasetsCount,
      datasetsQuota: getters.getDatasetsQuota,
      isOutOfDatasetsQuota: getters.isOutOfDatasetsQuota,
      isOrganizationUser: getters.isOrganizationUser
    },
    mutations: {
      setUserData: function setUserData(state, userData) {
        (0, _assign2.default)(state, userData);
      },
      setOrganizationNotifications: function setOrganizationNotifications(state, organizationNotifications) {
        state.organizationNotifications = organizationNotifications;
      },
      setShowNotification: function setShowNotification(state, showNotification) {
        state.showNotification = showNotification;
      },
      updateTableCount: function updateTableCount(state, newTableCount) {
        state.table_count = newTableCount;
      }
    },
    actions: {
      updateData: function updateData(context) {
        client.getConfig(function (err, _, data) {
          if (err) {
            return;
          }
  
          context.commit('setUserData', data.user_data);
        });
      },
      resetOrganizationNotifications: function resetOrganizationNotifications(context) {
        context.commit('setOrganizationNotifications', []);
      },
      hideUserNotification: function hideUserNotification(context) {
        context.commit('setShowNotification', false);
      },
      updateTableCount: function updateTableCount(context, newTableCount) {
        context.commit('updateTableCount', newTableCount);
      }
    }
  };
  
  exports.default = user;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/mutations/apps.js":
  /*!**********************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/mutations/apps.js ***!
    \**********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");
  
  var _assign2 = _interopRequireDefault(_assign);
  
  var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ "./node_modules/babel-runtime/helpers/defineProperty.js");
  
  var _defineProperty3 = _interopRequireDefault(_defineProperty2);
  
  var _extends3 = __webpack_require__(/*! babel-runtime/helpers/extends */ "./node_modules/babel-runtime/helpers/extends.js");
  
  var _extends4 = _interopRequireDefault(_extends3);
  
  exports.setApps = setApps;
  exports.addApp = addApp;
  exports.updateOAuthApp = updateOAuthApp;
  exports.setRequestError = setRequestError;
  exports.setFetchingState = setFetchingState;
  
  var _toObject = __webpack_require__(/*! new-dashboard/utils/to-object */ "./lib/assets/javascripts/new-dashboard/utils/to-object.js");
  
  var _toObject2 = _interopRequireDefault(_toObject);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  function setApps(state, apps) {
    state.list = (0, _toObject2.default)(apps, 'id');
    state.isFetching = false;
    state.isErrored = false;
    state.error = [];
  }
  
  function addApp(state, app) {
    state.list = (0, _extends4.default)({}, state.list, (0, _defineProperty3.default)({}, app.id, app));
  }
  
  function updateOAuthApp(state, app) {
    var isOAuthAppPresent = state.list.hasOwnProperty(app.id);
  
    if (isOAuthAppPresent) {
      (0, _assign2.default)(state.list[app.id], app);
    }
  }
  
  function setRequestError(state, error) {
    state.isFetching = false;
    state.isErrored = true;
    state.error = error;
    state.list = {};
  }
  
  function setFetchingState(state) {
    state.isFetching = true;
    state.isErrored = false;
    state.error = [];
    state.list = {};
  }
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/mutations/catalog.js":
  /*!*************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/mutations/catalog.js ***!
    \*************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.setCategories = setCategories;
  exports.setCountries = setCountries;
  exports.setDatasets = setDatasets;
  exports.setRequestError = setRequestError;
  exports.setFetchingState = setFetchingState;
  exports.setPagination = setPagination;
  exports.setResultsPerPage = setResultsPerPage;
  exports.setOrder = setOrder;
  exports.orderDatasets = orderDatasets;
  function setCategories(state, data) {
    state.categories = data.map(function (c) {
      return c.category;
    });
    state.isFetching = false;
    state.isErrored = false;
    state.error = [];
  }
  
  function setCountries(state, data) {
    state.countries = data.map(function (c) {
      return c.country;
    });
    state.isFetching = false;
    state.isErrored = false;
    state.error = [];
  }
  
  function setDatasets(state, datasets) {
    state.list = datasets;
    state.isFetching = false;
    state.isErrored = false;
    state.error = [];
    state.numResults = datasets.length;
  }
  
  function setRequestError(state, error) {
    state.isFetching = false;
    state.isErrored = true;
    state.error = error;
    state.list = {};
    state.numResults = 0;
  }
  
  function setFetchingState(state) {
    state.isFetching = true;
    state.isErrored = false;
    state.error = [];
    state.list = {};
  }
  
  function setPagination(state) {
    var page = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  
    state.page = page;
    state.numPages = Math.ceil(state.numResults / state.resultsPerPage) || 1;
  }
  
  function setResultsPerPage(state) {
    var resultsPerPage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;
  
    state.resultsPerPage = resultsPerPage;
  }
  
  function setOrder(DEFAULT_VALUES) {
    return function (state, orderOptions) {
      state.order = orderOptions.order || DEFAULT_VALUES.order;
      state.orderDirection = orderOptions.direction || DEFAULT_VALUES.orderDirection;
    };
  }
  
  function orderDatasets(state) {
    var orderAsc = function orderAsc(list, order) {
      list.sort(function (a, b) {
        return a[order] > b[order] ? 1 : -1;
      });
    };
    var orderDesc = function orderDesc(list, order) {
      list.sort(function (a, b) {
        return a[order] < b[order] ? 1 : -1;
      });
    };
  
    var orderByDirection = {
      'asc': function asc() {
        return orderAsc(state.list, state.order);
      },
      'desc': function desc() {
        return orderDesc(state.list, state.order);
      }
    };
    return orderByDirection[state.orderDirection]();
  }
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/mutations/visualizations.js":
  /*!********************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/mutations/visualizations.js ***!
    \********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");
  
  var _assign2 = _interopRequireDefault(_assign);
  
  exports.setFetchingState = setFetchingState;
  exports.setFilterType = setFilterType;
  exports.setPagination = setPagination;
  exports.setOrder = setOrder;
  exports.setResultsPerPage = setResultsPerPage;
  exports.setRequestError = setRequestError;
  exports.setVisualizations = setVisualizations;
  exports.updateNumberLikes = updateNumberLikes;
  exports.updateVisualization = updateVisualization;
  
  var _toObject = __webpack_require__(/*! new-dashboard/utils/to-object */ "./lib/assets/javascripts/new-dashboard/utils/to-object.js");
  
  var _toObject2 = _interopRequireDefault(_toObject);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  function setFetchingState(state) {
    state.isFetching = true;
    state.isErrored = false;
    state.error = {};
  }
  
  function setFilterType(state) {
    var filterType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'mine';
  
    state.filterType = filterType;
  }
  
  function setPagination(state) {
    var page = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  
    state.page = page;
    state.numPages = Math.ceil(state.metadata.total_entries / state.resultsPerPage) || 1;
  }
  
  function setOrder(DEFAULT_VALUES) {
    return function (state, orderOptions) {
      state.order = orderOptions.order || DEFAULT_VALUES.order;
      state.orderDirection = orderOptions.direction || DEFAULT_VALUES.orderDirection;
    };
  }
  
  function setResultsPerPage(state) {
    var resultsPerPage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;
  
    state.resultsPerPage = resultsPerPage;
  }
  
  function setRequestError(state, error) {
    state.isFetching = false;
    state.isErrored = true;
    state.error = error;
  }
  
  function setVisualizations(state, visualizationsData) {
    state.list = (0, _toObject2.default)(visualizationsData.visualizations, 'id');
    state.metadata = {
      total_entries: visualizationsData.total_entries,
      total_likes: visualizationsData.total_likes,
      total_shared: visualizationsData.total_shared,
      total_locked: visualizationsData.total_locked,
      total_user_entries: visualizationsData.total_user_entries
    };
  
    state.isFetching = false;
  }
  
  function updateNumberLikes(state, _ref) {
    var visualizationAttributes = _ref.visualizationAttributes;
  
    state.metadata.total_likes += visualizationAttributes.liked ? 1 : -1;
  }
  
  function updateVisualization(state, _ref2) {
    var visualizationId = _ref2.visualizationId,
        visualizationAttributes = _ref2.visualizationAttributes;
  
    var isVisualizationPresent = state.list.hasOwnProperty(visualizationId);
  
    if (isVisualizationPresent) {
      (0, _assign2.default)(state.list[visualizationId], visualizationAttributes);
    }
  }
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/store/utils/getCARTOData.js":
  /*!**************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/store/utils/getCARTOData.js ***!
    \**************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getCARTOData;
  function getCARTOData() {
    if (window.CartoConfig) {
      return window.CartoConfig.data;
    }
  
    return {
      user_data: window.user_data,
      notification: window.user_data.notification,
      organization_notifications: window.organization_notifications || []
    };
  }
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/utils/deep-object-extend.js":
  /*!**************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/utils/deep-object-extend.js ***!
    \**************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ "./node_modules/babel-runtime/helpers/defineProperty.js");
  
  var _defineProperty3 = _interopRequireDefault(_defineProperty2);
  
  var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");
  
  var _assign2 = _interopRequireDefault(_assign);
  
  var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");
  
  var _typeof3 = _interopRequireDefault(_typeof2);
  
  exports.default = deepObjectExtend;
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  // Copied from https://stackoverflow.com/questions/38345937/object-assign-vs-extend/42740894#42740894
  
  function isObject(item) {
    return item && (typeof item === 'undefined' ? 'undefined' : (0, _typeof3.default)(item)) === 'object' && !Array.isArray(item);
  }
  
  function deepObjectExtend(target) {
    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }
  
    if (!sources.length) return target;
    var source = sources.shift();
  
    if (isObject(target) && isObject(source)) {
      for (var key in source) {
        if (isObject(source[key])) {
          if (!target[key]) (0, _assign2.default)(target, (0, _defineProperty3.default)({}, key, {}));
          deepObjectExtend(target[key], source[key]);
        } else {
          (0, _assign2.default)(target, (0, _defineProperty3.default)({}, key, source[key]));
        }
      }
    }
  
    return deepObjectExtend.apply(undefined, [target].concat(sources));
  }
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/utils/is-storage-available.js":
  /*!****************************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/utils/is-storage-available.js ***!
    \****************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = storageAvailable;
  function storageAvailable(type) {
    try {
      var storage = window[type];
      var x = '__storage_test__';
  
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    } catch (e) {
      return e instanceof DOMException && (
      // everything except Firefox
      e.code === 22 ||
      // Firefox
      e.code === 1014 ||
      // test name field too, because code might not be present
      // everything except Firefox
      e.name === 'QuotaExceededError' ||
      // Firefox
      e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&
      // acknowledge QuotaExceededError only if there's something already stored
      storage.length !== 0;
    }
  }
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/new-dashboard/utils/to-object.js":
  /*!*****************************************************************!*\
    !*** ./lib/assets/javascripts/new-dashboard/utils/to-object.js ***!
    \*****************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var toObject = function toObject(array, property) {
    return array.reduce(function (finalObject, currentElement) {
      finalObject[currentElement[property]] = currentElement;
      return finalObject;
    }, {});
  };
  
  exports.default = toObject;
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/vendor/backbone/core-model.js":
  /*!**************************************************************!*\
    !*** ./lib/assets/javascripts/vendor/backbone/core-model.js ***!
    \**************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   * Base Model for all CartoDB model.
   * DO NOT USE Backbone.Model directly
   */
  var Model = Backbone.Model.extend({
  
    initialize: function (options) {
      _.bindAll(this, 'fetch', 'save', 'retrigger');
      return Backbone.Model.prototype.initialize.call(this, options);
    },
    /**
    * We are redefining fetch to be able to trigger an event when the ajax call ends, no matter if there's
    * a change in the data or not. Why don't backbone does this by default? ahh, my friend, who knows.
    * @method fetch
    * @param args {Object}
    */
    fetch: function (args) {
      var self = this;
      // var date = new Date();
      this.trigger('loadModelStarted');
      $.when(Backbone.Model.prototype.fetch.call(this, args)).done(function (ev) {
        self.trigger('loadModelCompleted', ev, self);
        // var dateComplete = new Date()
        // console.log('completed in '+(dateComplete - date));
      }).fail(function (ev) {
        self.trigger('loadModelFailed', ev, self);
      });
    },
    /**
    * Changes the attribute used as Id
    * @method setIdAttribute
    * @param attr {String}
    */
    setIdAttribute: function (attr) {
      this.idAttribute = attr;
    },
    /**
    * Listen for an event on another object and triggers on itself, with the same name or a new one
    * @method retrigger
    * @param ev {String} event who triggers the action
    * @param obj {Object} object where the event happens
    * @param obj {Object} [optional] name of the retriggered event
    * @todo [xabel]: This method is repeated here and in the base view definition. There's should be a way to make it unique
    */
    retrigger: function (ev, obj, retrigEvent) {
      if (!retrigEvent) {
        retrigEvent = ev;
      }
      var self = this;
      obj.bind && obj.bind(ev, function () {
        self.trigger(retrigEvent);
      }, self);
    },
  
    /**
     * We need to override backbone save method to be able to introduce new kind of triggers that
     * for some reason are not present in the original library. Because you know, it would be nice
     * to be able to differenciate "a model has been updated" of "a model is being saved".
     * TODO: remove jquery from here
     * @param  {object} opt1
     * @param  {object} opt2
     * @return {$.Deferred}
     */
    save: function (opt1, opt2) {
      var self = this;
      if (!opt2 || !opt2.silent) this.trigger('saving');
      var promise = Backbone.Model.prototype.save.apply(this, arguments);
      $.when(promise).done(function () {
        if (!opt2 || !opt2.silent) self.trigger('saved');
      }).fail(function () {
        if (!opt2 || !opt2.silent) self.trigger('errorSaving');
      });
      return promise;
    }
  });
  
  module.exports = Model;
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/vendor/backbone/core-view.js":
  /*!*************************************************************!*\
    !*** ./lib/assets/javascripts/vendor/backbone/core-view.js ***!
    \*************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
  var Backbone = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
  
  /**
   * NOTE! Migrated as-is from https://github.com/CartoDB/cartodb.js/blob/470399abb12b40d5476ab6bbfd792d95aa819f50/src/core/view.js 2016-06-03
   * Base View for all CartoDB views.
   * DO NOT USE Backbone.View directly
   */
  var View = Backbone.View.extend({
    classLabel: 'cdb.core.View',
  
    constructor: function (options) {
      this.options = _.defaults(options, this.options);
      this._models = [];
      this._subviews = {};
      Backbone.View.call(this, options);
      View.viewCount++;
      View.views[this.cid] = this;
      this._created_at = new Date();
      if (false) {}
    },
  
    add_related_model: function (m) {
      if (!m) throw new Error('added non valid model');
      this._models.push(m);
    },
  
    addView: function (v) {
      this._subviews[v.cid] = v;
      v._parent = this;
    },
  
    removeView: function (v) {
      delete this._subviews[v.cid];
    },
  
    clearSubViews: function () {
      _(this._subviews).each(function (v) {
        v.clean();
      });
      this._subviews = {};
    },
  
    /**
     * this methid clean removes the view
     * and clean and events associated. call it when
     * the view is not going to be used anymore
     */
    clean: function () {
      this.trigger('clean');
      this.clearSubViews();
      // remove from parent
      if (this._parent) {
        this._parent.removeView(this);
        this._parent = null;
      }
      this.remove();
      this.allOff();
      View.viewCount--;
      delete View.views[this.cid];
      return this;
    },
  
    /**
     * Remove all event listeners on related models
     */
    allOff: function () {
      this.off();
  
      if (this.model && this.model.off) this.model.off(null, null, this);
  
      var self = this;
      _(this._models).each(function (m) {
        m.off(null, null, self);
      });
      this._models = [];
    },
  
    show: function () {
      this.$el.show();
    },
  
    hide: function () {
      this.$el.hide();
    },
  
    /**
    * Listen for an event on another object and triggers on itself, with the same name or a new one
    * @method retrigger
    * @param ev {String} event who triggers the action
    * @param obj {Object} object where the event happens
    * @param obj {Object} [optional] name of the retriggered event
    */
    retrigger: function (ev, obj, retrigEvent) {
      if (!retrigEvent) {
        retrigEvent = ev;
      }
      var self = this;
      obj.bind && obj.bind(ev, function () {
        self.trigger(retrigEvent);
      }, self);
      // add it as related model//object
      this.add_related_model(obj);
    },
    /**
    * Captures an event and prevents the default behaviour and stops it from bubbling
    * @method killEvent
    * @param event {Event}
    */
    killEvent: function (ev) {
      if (ev && ev.preventDefault) {
        ev.preventDefault();
      }
      if (ev && ev.stopPropagation) {
        ev.stopPropagation();
      }
    },
  
    /**
    * Remove all the tipsy tooltips from the document
    * @method cleanTooltips
    */
    cleanTooltips: function () {
      this.$('.tipsy').remove();
    }
  
  }, {
    viewCount: 0,
    views: {},
  
    /**
     * when a view with events is inherit and you want to add more events
     * this helper can be used:
     * var MyView = new core.View({
     *  events: View.extendEvents({
     *      'click': 'fn'
     *  })
     * })
     */
    extendEvents: function (newEvents) {
      return function () {
        return _.extend(newEvents, this.constructor.__super__.events);
      };
    },
  
    /**
     * search for views in a view and check if they are added as subviews
     */
    runChecker: function () {
      _.each(View.views, function (view) {
        _.each(view, function (prop, k) {
          if (k !== '_parent' &&
            view.hasOwnProperty(k) &&
            prop instanceof View &&
            view._subviews[prop.cid] === undefined) {
            console.log('=========');
            console.log('untracked view: ');
            console.log(prop.el);
            console.log('parent');
            console.log(view.el);
            console.log(' ');
          }
        });
      });
    }
  });
  
  module.exports = View;
  
  
  /***/ }),
  
  /***/ "./lib/assets/javascripts/vendor/jquery-ui.js":
  /*!****************************************************!*\
    !*** ./lib/assets/javascripts/vendor/jquery-ui.js ***!
    \****************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! jQuery UI - v1.11.4 - 2015-03-11
  * http://jqueryui.com
  * Includes: core.js, widget.js, mouse.js, position.js, accordion.js, autocomplete.js, button.js, datepicker.js, dialog.js, draggable.js, droppable.js, effect.js, effect-blind.js, effect-bounce.js, effect-clip.js, effect-drop.js, effect-explode.js, effect-fade.js, effect-fold.js, effect-highlight.js, effect-puff.js, effect-pulsate.js, effect-scale.js, effect-shake.js, effect-size.js, effect-slide.js, effect-transfer.js, menu.js, progressbar.js, resizable.js, selectable.js, selectmenu.js, slider.js, sortable.js, spinner.js, tabs.js, tooltip.js
  * Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */
  
  (function( factory ) {
    if ( true ) {
  
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
          __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
          (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  }(function( $ ) {
  /*!
   * jQuery UI Core 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/category/ui-core/
   */
  
  
  // $.ui might exist from components with no dependencies, e.g., $.ui.position
  $.ui = $.ui || {};
  
  $.extend( $.ui, {
    version: "1.11.4",
  
    keyCode: {
      BACKSPACE: 8,
      COMMA: 188,
      DELETE: 46,
      DOWN: 40,
      END: 35,
      ENTER: 13,
      ESCAPE: 27,
      HOME: 36,
      LEFT: 37,
      PAGE_DOWN: 34,
      PAGE_UP: 33,
      PERIOD: 190,
      RIGHT: 39,
      SPACE: 32,
      TAB: 9,
      UP: 38
    }
  });
  
  // plugins
  $.fn.extend({
    scrollParent: function( includeHidden ) {
      var position = this.css( "position" ),
        excludeStaticParent = position === "absolute",
        overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
        scrollParent = this.parents().filter( function() {
          var parent = $( this );
          if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
            return false;
          }
          return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) + parent.css( "overflow-x" ) );
        }).eq( 0 );
  
      return position === "fixed" || !scrollParent.length ? $( this[ 0 ].ownerDocument || document ) : scrollParent;
    },
  
    uniqueId: (function() {
      var uuid = 0;
  
      return function() {
        return this.each(function() {
          if ( !this.id ) {
            this.id = "ui-id-" + ( ++uuid );
          }
        });
      };
    })(),
  
    removeUniqueId: function() {
      return this.each(function() {
        if ( /^ui-id-\d+$/.test( this.id ) ) {
          $( this ).removeAttr( "id" );
        }
      });
    }
  });
  
  // selectors
  function focusable( element, isTabIndexNotNaN ) {
    var map, mapName, img,
      nodeName = element.nodeName.toLowerCase();
    if ( "area" === nodeName ) {
      map = element.parentNode;
      mapName = map.name;
      if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
        return false;
      }
      img = $( "img[usemap='#" + mapName + "']" )[ 0 ];
      return !!img && visible( img );
    }
    return ( /^(input|select|textarea|button|object)$/.test( nodeName ) ?
      !element.disabled :
      "a" === nodeName ?
        element.href || isTabIndexNotNaN :
        isTabIndexNotNaN) &&
      // the element and all of its ancestors must be visible
      visible( element );
  }
  
  function visible( element ) {
    return $.expr.filters.visible( element ) &&
      !$( element ).parents().addBack().filter(function() {
        return $.css( this, "visibility" ) === "hidden";
      }).length;
  }
  
  $.extend( $.expr[ ":" ], {
    data: $.expr.createPseudo ?
      $.expr.createPseudo(function( dataName ) {
        return function( elem ) {
          return !!$.data( elem, dataName );
        };
      }) :
      // support: jQuery <1.8
      function( elem, i, match ) {
        return !!$.data( elem, match[ 3 ] );
      },
  
    focusable: function( element ) {
      return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
    },
  
    tabbable: function( element ) {
      var tabIndex = $.attr( element, "tabindex" ),
        isTabIndexNaN = isNaN( tabIndex );
      return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
    }
  });
  
  // support: jQuery <1.8
  if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
    $.each( [ "Width", "Height" ], function( i, name ) {
      var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
        type = name.toLowerCase(),
        orig = {
          innerWidth: $.fn.innerWidth,
          innerHeight: $.fn.innerHeight,
          outerWidth: $.fn.outerWidth,
          outerHeight: $.fn.outerHeight
        };
  
      function reduce( elem, size, border, margin ) {
        $.each( side, function() {
          size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
          if ( border ) {
            size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
          }
          if ( margin ) {
            size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
          }
        });
        return size;
      }
  
      $.fn[ "inner" + name ] = function( size ) {
        if ( size === undefined ) {
          return orig[ "inner" + name ].call( this );
        }
  
        return this.each(function() {
          $( this ).css( type, reduce( this, size ) + "px" );
        });
      };
  
      $.fn[ "outer" + name] = function( size, margin ) {
        if ( typeof size !== "number" ) {
          return orig[ "outer" + name ].call( this, size );
        }
  
        return this.each(function() {
          $( this).css( type, reduce( this, size, true, margin ) + "px" );
        });
      };
    });
  }
  
  // support: jQuery <1.8
  if ( !$.fn.addBack ) {
    $.fn.addBack = function( selector ) {
      return this.add( selector == null ?
        this.prevObject : this.prevObject.filter( selector )
      );
    };
  }
  
  // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
  if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
    $.fn.removeData = (function( removeData ) {
      return function( key ) {
        if ( arguments.length ) {
          return removeData.call( this, $.camelCase( key ) );
        } else {
          return removeData.call( this );
        }
      };
    })( $.fn.removeData );
  }
  
  // deprecated
  $.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );
  
  $.fn.extend({
    focus: (function( orig ) {
      return function( delay, fn ) {
        return typeof delay === "number" ?
          this.each(function() {
            var elem = this;
            setTimeout(function() {
              $( elem ).focus();
              if ( fn ) {
                fn.call( elem );
              }
            }, delay );
          }) :
          orig.apply( this, arguments );
      };
    })( $.fn.focus ),
  
    disableSelection: (function() {
      var eventType = "onselectstart" in document.createElement( "div" ) ?
        "selectstart" :
        "mousedown";
  
      return function() {
        return this.bind( eventType + ".ui-disableSelection", function( event ) {
          event.preventDefault();
        });
      };
    })(),
  
    enableSelection: function() {
      return this.unbind( ".ui-disableSelection" );
    },
  
    zIndex: function( zIndex ) {
      if ( zIndex !== undefined ) {
        return this.css( "zIndex", zIndex );
      }
  
      if ( this.length ) {
        var elem = $( this[ 0 ] ), position, value;
        while ( elem.length && elem[ 0 ] !== document ) {
          // Ignore z-index if position is set to a value where z-index is ignored by the browser
          // This makes behavior of this function consistent across browsers
          // WebKit always returns auto if the element is positioned
          position = elem.css( "position" );
          if ( position === "absolute" || position === "relative" || position === "fixed" ) {
            // IE returns 0 when zIndex is not specified
            // other browsers return a string
            // we ignore the case of nested elements with an explicit value of 0
            // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
            value = parseInt( elem.css( "zIndex" ), 10 );
            if ( !isNaN( value ) && value !== 0 ) {
              return value;
            }
          }
          elem = elem.parent();
        }
      }
  
      return 0;
    }
  });
  
  // $.ui.plugin is deprecated. Use $.widget() extensions instead.
  $.ui.plugin = {
    add: function( module, option, set ) {
      var i,
        proto = $.ui[ module ].prototype;
      for ( i in set ) {
        proto.plugins[ i ] = proto.plugins[ i ] || [];
        proto.plugins[ i ].push( [ option, set[ i ] ] );
      }
    },
    call: function( instance, name, args, allowDisconnected ) {
      var i,
        set = instance.plugins[ name ];
  
      if ( !set ) {
        return;
      }
  
      if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
        return;
      }
  
      for ( i = 0; i < set.length; i++ ) {
        if ( instance.options[ set[ i ][ 0 ] ] ) {
          set[ i ][ 1 ].apply( instance.element, args );
        }
      }
    }
  };
  
  
  /*!
   * jQuery UI Widget 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/jQuery.widget/
   */
  
  
  var widget_uuid = 0,
    widget_slice = Array.prototype.slice;
  
  $.cleanData = (function( orig ) {
    return function( elems ) {
      var events, elem, i;
      for ( i = 0; (elem = elems[i]) != null; i++ ) {
        try {
  
          // Only trigger remove when necessary to save time
          events = $._data( elem, "events" );
          if ( events && events.remove ) {
            $( elem ).triggerHandler( "remove" );
          }
  
        // http://bugs.jquery.com/ticket/8235
        } catch ( e ) {}
      }
      orig( elems );
    };
  })( $.cleanData );
  
  $.widget = function( name, base, prototype ) {
    var fullName, existingConstructor, constructor, basePrototype,
      // proxiedPrototype allows the provided prototype to remain unmodified
      // so that it can be used as a mixin for multiple widgets (#8876)
      proxiedPrototype = {},
      namespace = name.split( "." )[ 0 ];
  
    name = name.split( "." )[ 1 ];
    fullName = namespace + "-" + name;
  
    if ( !prototype ) {
      prototype = base;
      base = $.Widget;
    }
  
    // create selector for plugin
    $.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
      return !!$.data( elem, fullName );
    };
  
    $[ namespace ] = $[ namespace ] || {};
    existingConstructor = $[ namespace ][ name ];
    constructor = $[ namespace ][ name ] = function( options, element ) {
      // allow instantiation without "new" keyword
      if ( !this._createWidget ) {
        return new constructor( options, element );
      }
  
      // allow instantiation without initializing for simple inheritance
      // must use "new" keyword (the code above always passes args)
      if ( arguments.length ) {
        this._createWidget( options, element );
      }
    };
    // extend with the existing constructor to carry over any static properties
    $.extend( constructor, existingConstructor, {
      version: prototype.version,
      // copy the object used to create the prototype in case we need to
      // redefine the widget later
      _proto: $.extend( {}, prototype ),
      // track widgets that inherit from this widget in case this widget is
      // redefined after a widget inherits from it
      _childConstructors: []
    });
  
    basePrototype = new base();
    // we need to make the options hash a property directly on the new instance
    // otherwise we'll modify the options hash on the prototype that we're
    // inheriting from
    basePrototype.options = $.widget.extend( {}, basePrototype.options );
    $.each( prototype, function( prop, value ) {
      if ( !$.isFunction( value ) ) {
        proxiedPrototype[ prop ] = value;
        return;
      }
      proxiedPrototype[ prop ] = (function() {
        var _super = function() {
            return base.prototype[ prop ].apply( this, arguments );
          },
          _superApply = function( args ) {
            return base.prototype[ prop ].apply( this, args );
          };
        return function() {
          var __super = this._super,
            __superApply = this._superApply,
            returnValue;
  
          this._super = _super;
          this._superApply = _superApply;
  
          returnValue = value.apply( this, arguments );
  
          this._super = __super;
          this._superApply = __superApply;
  
          return returnValue;
        };
      })();
    });
    constructor.prototype = $.widget.extend( basePrototype, {
      // TODO: remove support for widgetEventPrefix
      // always use the name + a colon as the prefix, e.g., draggable:start
      // don't prefix for widgets that aren't DOM-based
      widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
    }, proxiedPrototype, {
      constructor: constructor,
      namespace: namespace,
      widgetName: name,
      widgetFullName: fullName
    });
  
    // If this widget is being redefined then we need to find all widgets that
    // are inheriting from it and redefine all of them so that they inherit from
    // the new version of this widget. We're essentially trying to replace one
    // level in the prototype chain.
    if ( existingConstructor ) {
      $.each( existingConstructor._childConstructors, function( i, child ) {
        var childPrototype = child.prototype;
  
        // redefine the child widget using the same prototype that was
        // originally used, but inherit from the new version of the base
        $.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
      });
      // remove the list of existing child constructors from the old constructor
      // so the old child constructors can be garbage collected
      delete existingConstructor._childConstructors;
    } else {
      base._childConstructors.push( constructor );
    }
  
    $.widget.bridge( name, constructor );
  
    return constructor;
  };
  
  $.widget.extend = function( target ) {
    var input = widget_slice.call( arguments, 1 ),
      inputIndex = 0,
      inputLength = input.length,
      key,
      value;
    for ( ; inputIndex < inputLength; inputIndex++ ) {
      for ( key in input[ inputIndex ] ) {
        value = input[ inputIndex ][ key ];
        if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
          // Clone objects
          if ( $.isPlainObject( value ) ) {
            target[ key ] = $.isPlainObject( target[ key ] ) ?
              $.widget.extend( {}, target[ key ], value ) :
              // Don't extend strings, arrays, etc. with objects
              $.widget.extend( {}, value );
          // Copy everything else by reference
          } else {
            target[ key ] = value;
          }
        }
      }
    }
    return target;
  };
  
  $.widget.bridge = function( name, object ) {
    var fullName = object.prototype.widgetFullName || name;
    $.fn[ name ] = function( options ) {
      var isMethodCall = typeof options === "string",
        args = widget_slice.call( arguments, 1 ),
        returnValue = this;
  
      if ( isMethodCall ) {
        this.each(function() {
          var methodValue,
            instance = $.data( this, fullName );
          if ( options === "instance" ) {
            returnValue = instance;
            return false;
          }
          if ( !instance ) {
            return $.error( "cannot call methods on " + name + " prior to initialization; " +
              "attempted to call method '" + options + "'" );
          }
          if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
            return $.error( "no such method '" + options + "' for " + name + " widget instance" );
          }
          methodValue = instance[ options ].apply( instance, args );
          if ( methodValue !== instance && methodValue !== undefined ) {
            returnValue = methodValue && methodValue.jquery ?
              returnValue.pushStack( methodValue.get() ) :
              methodValue;
            return false;
          }
        });
      } else {
  
        // Allow multiple hashes to be passed on init
        if ( args.length ) {
          options = $.widget.extend.apply( null, [ options ].concat(args) );
        }
  
        this.each(function() {
          var instance = $.data( this, fullName );
          if ( instance ) {
            instance.option( options || {} );
            if ( instance._init ) {
              instance._init();
            }
          } else {
            $.data( this, fullName, new object( options, this ) );
          }
        });
      }
  
      return returnValue;
    };
  };
  
  $.Widget = function( /* options, element */ ) {};
  $.Widget._childConstructors = [];
  
  $.Widget.prototype = {
    widgetName: "widget",
    widgetEventPrefix: "",
    defaultElement: "<div>",
    options: {
      disabled: false,
  
      // callbacks
      create: null
    },
    _createWidget: function( options, element ) {
      element = $( element || this.defaultElement || this )[ 0 ];
      this.element = $( element );
      this.uuid = widget_uuid++;
      this.eventNamespace = "." + this.widgetName + this.uuid;
  
      this.bindings = $();
      this.hoverable = $();
      this.focusable = $();
  
      if ( element !== this ) {
        $.data( element, this.widgetFullName, this );
        this._on( true, this.element, {
          remove: function( event ) {
            if ( event.target === element ) {
              this.destroy();
            }
          }
        });
        this.document = $( element.style ?
          // element within the document
          element.ownerDocument :
          // element is window or document
          element.document || element );
        this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
      }
  
      this.options = $.widget.extend( {},
        this.options,
        this._getCreateOptions(),
        options );
  
      this._create();
      this._trigger( "create", null, this._getCreateEventData() );
      this._init();
    },
    _getCreateOptions: $.noop,
    _getCreateEventData: $.noop,
    _create: $.noop,
    _init: $.noop,
  
    destroy: function() {
      this._destroy();
      // we can probably remove the unbind calls in 2.0
      // all event bindings should go through this._on()
      this.element
        .unbind( this.eventNamespace )
        .removeData( this.widgetFullName )
        // support: jquery <1.6.3
        // http://bugs.jquery.com/ticket/9413
        .removeData( $.camelCase( this.widgetFullName ) );
      this.widget()
        .unbind( this.eventNamespace )
        .removeAttr( "aria-disabled" )
        .removeClass(
          this.widgetFullName + "-disabled " +
          "ui-state-disabled" );
  
      // clean up events and states
      this.bindings.unbind( this.eventNamespace );
      this.hoverable.removeClass( "ui-state-hover" );
      this.focusable.removeClass( "ui-state-focus" );
    },
    _destroy: $.noop,
  
    widget: function() {
      return this.element;
    },
  
    option: function( key, value ) {
      var options = key,
        parts,
        curOption,
        i;
  
      if ( arguments.length === 0 ) {
        // don't return a reference to the internal hash
        return $.widget.extend( {}, this.options );
      }
  
      if ( typeof key === "string" ) {
        // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
        options = {};
        parts = key.split( "." );
        key = parts.shift();
        if ( parts.length ) {
          curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
          for ( i = 0; i < parts.length - 1; i++ ) {
            curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
            curOption = curOption[ parts[ i ] ];
          }
          key = parts.pop();
          if ( arguments.length === 1 ) {
            return curOption[ key ] === undefined ? null : curOption[ key ];
          }
          curOption[ key ] = value;
        } else {
          if ( arguments.length === 1 ) {
            return this.options[ key ] === undefined ? null : this.options[ key ];
          }
          options[ key ] = value;
        }
      }
  
      this._setOptions( options );
  
      return this;
    },
    _setOptions: function( options ) {
      var key;
  
      for ( key in options ) {
        this._setOption( key, options[ key ] );
      }
  
      return this;
    },
    _setOption: function( key, value ) {
      this.options[ key ] = value;
  
      if ( key === "disabled" ) {
        this.widget()
          .toggleClass( this.widgetFullName + "-disabled", !!value );
  
        // If the widget is becoming disabled, then nothing is interactive
        if ( value ) {
          this.hoverable.removeClass( "ui-state-hover" );
          this.focusable.removeClass( "ui-state-focus" );
        }
      }
  
      return this;
    },
  
    enable: function() {
      return this._setOptions({ disabled: false });
    },
    disable: function() {
      return this._setOptions({ disabled: true });
    },
  
    _on: function( suppressDisabledCheck, element, handlers ) {
      var delegateElement,
        instance = this;
  
      // no suppressDisabledCheck flag, shuffle arguments
      if ( typeof suppressDisabledCheck !== "boolean" ) {
        handlers = element;
        element = suppressDisabledCheck;
        suppressDisabledCheck = false;
      }
  
      // no element argument, shuffle and use this.element
      if ( !handlers ) {
        handlers = element;
        element = this.element;
        delegateElement = this.widget();
      } else {
        element = delegateElement = $( element );
        this.bindings = this.bindings.add( element );
      }
  
      $.each( handlers, function( event, handler ) {
        function handlerProxy() {
          // allow widgets to customize the disabled handling
          // - disabled as an array instead of boolean
          // - disabled class as method for disabling individual parts
          if ( !suppressDisabledCheck &&
              ( instance.options.disabled === true ||
                $( this ).hasClass( "ui-state-disabled" ) ) ) {
            return;
          }
          return ( typeof handler === "string" ? instance[ handler ] : handler )
            .apply( instance, arguments );
        }
  
        // copy the guid so direct unbinding works
        if ( typeof handler !== "string" ) {
          handlerProxy.guid = handler.guid =
            handler.guid || handlerProxy.guid || $.guid++;
        }
  
        var match = event.match( /^([\w:-]*)\s*(.*)$/ ),
          eventName = match[1] + instance.eventNamespace,
          selector = match[2];
        if ( selector ) {
          delegateElement.delegate( selector, eventName, handlerProxy );
        } else {
          element.bind( eventName, handlerProxy );
        }
      });
    },
  
    _off: function( element, eventName ) {
      eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) +
        this.eventNamespace;
      element.unbind( eventName ).undelegate( eventName );
  
      // Clear the stack to avoid memory leaks (#10056)
      this.bindings = $( this.bindings.not( element ).get() );
      this.focusable = $( this.focusable.not( element ).get() );
      this.hoverable = $( this.hoverable.not( element ).get() );
    },
  
    _delay: function( handler, delay ) {
      function handlerProxy() {
        return ( typeof handler === "string" ? instance[ handler ] : handler )
          .apply( instance, arguments );
      }
      var instance = this;
      return setTimeout( handlerProxy, delay || 0 );
    },
  
    _hoverable: function( element ) {
      this.hoverable = this.hoverable.add( element );
      this._on( element, {
        mouseenter: function( event ) {
          $( event.currentTarget ).addClass( "ui-state-hover" );
        },
        mouseleave: function( event ) {
          $( event.currentTarget ).removeClass( "ui-state-hover" );
        }
      });
    },
  
    _focusable: function( element ) {
      this.focusable = this.focusable.add( element );
      this._on( element, {
        focusin: function( event ) {
          $( event.currentTarget ).addClass( "ui-state-focus" );
        },
        focusout: function( event ) {
          $( event.currentTarget ).removeClass( "ui-state-focus" );
        }
      });
    },
  
    _trigger: function( type, event, data ) {
      var prop, orig,
        callback = this.options[ type ];
  
      data = data || {};
      event = $.Event( event );
      event.type = ( type === this.widgetEventPrefix ?
        type :
        this.widgetEventPrefix + type ).toLowerCase();
      // the original event may come from any element
      // so we need to reset the target on the new event
      event.target = this.element[ 0 ];
  
      // copy original event properties over to the new event
      orig = event.originalEvent;
      if ( orig ) {
        for ( prop in orig ) {
          if ( !( prop in event ) ) {
            event[ prop ] = orig[ prop ];
          }
        }
      }
  
      this.element.trigger( event, data );
      return !( $.isFunction( callback ) &&
        callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
        event.isDefaultPrevented() );
    }
  };
  
  $.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
    $.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
      if ( typeof options === "string" ) {
        options = { effect: options };
      }
      var hasOptions,
        effectName = !options ?
          method :
          options === true || typeof options === "number" ?
            defaultEffect :
            options.effect || defaultEffect;
      options = options || {};
      if ( typeof options === "number" ) {
        options = { duration: options };
      }
      hasOptions = !$.isEmptyObject( options );
      options.complete = callback;
      if ( options.delay ) {
        element.delay( options.delay );
      }
      if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
        element[ method ]( options );
      } else if ( effectName !== method && element[ effectName ] ) {
        element[ effectName ]( options.duration, options.easing, callback );
      } else {
        element.queue(function( next ) {
          $( this )[ method ]();
          if ( callback ) {
            callback.call( element[ 0 ] );
          }
          next();
        });
      }
    };
  });
  
  var widget = $.widget;
  
  
  /*!
   * jQuery UI Mouse 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/mouse/
   */
  
  
  var mouseHandled = false;
  $( document ).mouseup( function() {
    mouseHandled = false;
  });
  
  var mouse = $.widget("ui.mouse", {
    version: "1.11.4",
    options: {
      cancel: "input,textarea,button,select,option",
      distance: 1,
      delay: 0
    },
    _mouseInit: function() {
      var that = this;
  
      this.element
        .bind("mousedown." + this.widgetName, function(event) {
          return that._mouseDown(event);
        })
        .bind("click." + this.widgetName, function(event) {
          if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
            $.removeData(event.target, that.widgetName + ".preventClickEvent");
            event.stopImmediatePropagation();
            return false;
          }
        });
  
      this.started = false;
    },
  
    // TODO: make sure destroying one instance of mouse doesn't mess with
    // other instances of mouse
    _mouseDestroy: function() {
      this.element.unbind("." + this.widgetName);
      if ( this._mouseMoveDelegate ) {
        this.document
          .unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
          .unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
      }
    },
  
    _mouseDown: function(event) {
      // don't let more than one widget handle mouseStart
      if ( mouseHandled ) {
        return;
      }
  
      this._mouseMoved = false;
  
      // we may have missed mouseup (out of window)
      (this._mouseStarted && this._mouseUp(event));
  
      this._mouseDownEvent = event;
  
      var that = this,
        btnIsLeft = (event.which === 1),
        // event.target.nodeName works around a bug in IE 8 with
        // disabled inputs (#7620)
        elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
      if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
        return true;
      }
  
      this.mouseDelayMet = !this.options.delay;
      if (!this.mouseDelayMet) {
        this._mouseDelayTimer = setTimeout(function() {
          that.mouseDelayMet = true;
        }, this.options.delay);
      }
  
      if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
        this._mouseStarted = (this._mouseStart(event) !== false);
        if (!this._mouseStarted) {
          event.preventDefault();
          return true;
        }
      }
  
      // Click event may never have fired (Gecko & Opera)
      if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
        $.removeData(event.target, this.widgetName + ".preventClickEvent");
      }
  
      // these delegates are required to keep context
      this._mouseMoveDelegate = function(event) {
        return that._mouseMove(event);
      };
      this._mouseUpDelegate = function(event) {
        return that._mouseUp(event);
      };
  
      this.document
        .bind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
        .bind( "mouseup." + this.widgetName, this._mouseUpDelegate );
  
      event.preventDefault();
  
      mouseHandled = true;
      return true;
    },
  
    _mouseMove: function(event) {
      // Only check for mouseups outside the document if you've moved inside the document
      // at least once. This prevents the firing of mouseup in the case of IE<9, which will
      // fire a mousemove event if content is placed under the cursor. See #7778
      // Support: IE <9
      if ( this._mouseMoved ) {
        // IE mouseup check - mouseup happened when mouse was out of window
        if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
          return this._mouseUp(event);
  
        // Iframe mouseup check - mouseup occurred in another document
        } else if ( !event.which ) {
          return this._mouseUp( event );
        }
      }
  
      if ( event.which || event.button ) {
        this._mouseMoved = true;
      }
  
      if (this._mouseStarted) {
        this._mouseDrag(event);
        return event.preventDefault();
      }
  
      if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
        this._mouseStarted =
          (this._mouseStart(this._mouseDownEvent, event) !== false);
        (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
      }
  
      return !this._mouseStarted;
    },
  
    _mouseUp: function(event) {
      this.document
        .unbind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
        .unbind( "mouseup." + this.widgetName, this._mouseUpDelegate );
  
      if (this._mouseStarted) {
        this._mouseStarted = false;
  
        if (event.target === this._mouseDownEvent.target) {
          $.data(event.target, this.widgetName + ".preventClickEvent", true);
        }
  
        this._mouseStop(event);
      }
  
      mouseHandled = false;
      return false;
    },
  
    _mouseDistanceMet: function(event) {
      return (Math.max(
          Math.abs(this._mouseDownEvent.pageX - event.pageX),
          Math.abs(this._mouseDownEvent.pageY - event.pageY)
        ) >= this.options.distance
      );
    },
  
    _mouseDelayMet: function(/* event */) {
      return this.mouseDelayMet;
    },
  
    // These are placeholder methods, to be overriden by extending plugin
    _mouseStart: function(/* event */) {},
    _mouseDrag: function(/* event */) {},
    _mouseStop: function(/* event */) {},
    _mouseCapture: function(/* event */) { return true; }
  });
  
  
  /*!
   * jQuery UI Position 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/position/
   */
  
  (function() {
  
  $.ui = $.ui || {};
  
  var cachedScrollbarWidth, supportsOffsetFractions,
    max = Math.max,
    abs = Math.abs,
    round = Math.round,
    rhorizontal = /left|center|right/,
    rvertical = /top|center|bottom/,
    roffset = /[\+\-]\d+(\.[\d]+)?%?/,
    rposition = /^\w+/,
    rpercent = /%$/,
    _position = $.fn.position;
  
  function getOffsets( offsets, width, height ) {
    return [
      parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
      parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
    ];
  }
  
  function parseCss( element, property ) {
    return parseInt( $.css( element, property ), 10 ) || 0;
  }
  
  function getDimensions( elem ) {
    var raw = elem[0];
    if ( raw.nodeType === 9 ) {
      return {
        width: elem.width(),
        height: elem.height(),
        offset: { top: 0, left: 0 }
      };
    }
    if ( $.isWindow( raw ) ) {
      return {
        width: elem.width(),
        height: elem.height(),
        offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
      };
    }
    if ( raw.preventDefault ) {
      return {
        width: 0,
        height: 0,
        offset: { top: raw.pageY, left: raw.pageX }
      };
    }
    return {
      width: elem.outerWidth(),
      height: elem.outerHeight(),
      offset: elem.offset()
    };
  }
  
  $.position = {
    scrollbarWidth: function() {
      if ( cachedScrollbarWidth !== undefined ) {
        return cachedScrollbarWidth;
      }
      var w1, w2,
        div = $( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
        innerDiv = div.children()[0];
  
      $( "body" ).append( div );
      w1 = innerDiv.offsetWidth;
      div.css( "overflow", "scroll" );
  
      w2 = innerDiv.offsetWidth;
  
      if ( w1 === w2 ) {
        w2 = div[0].clientWidth;
      }
  
      div.remove();
  
      return (cachedScrollbarWidth = w1 - w2);
    },
    getScrollInfo: function( within ) {
      var overflowX = within.isWindow || within.isDocument ? "" :
          within.element.css( "overflow-x" ),
        overflowY = within.isWindow || within.isDocument ? "" :
          within.element.css( "overflow-y" ),
        hasOverflowX = overflowX === "scroll" ||
          ( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
        hasOverflowY = overflowY === "scroll" ||
          ( overflowY === "auto" && within.height < within.element[0].scrollHeight );
      return {
        width: hasOverflowY ? $.position.scrollbarWidth() : 0,
        height: hasOverflowX ? $.position.scrollbarWidth() : 0
      };
    },
    getWithinInfo: function( element ) {
      var withinElement = $( element || window ),
        isWindow = $.isWindow( withinElement[0] ),
        isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;
      return {
        element: withinElement,
        isWindow: isWindow,
        isDocument: isDocument,
        offset: withinElement.offset() || { left: 0, top: 0 },
        scrollLeft: withinElement.scrollLeft(),
        scrollTop: withinElement.scrollTop(),
  
        // support: jQuery 1.6.x
        // jQuery 1.6 doesn't support .outerWidth/Height() on documents or windows
        width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
        height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
      };
    }
  };
  
  $.fn.position = function( options ) {
    if ( !options || !options.of ) {
      return _position.apply( this, arguments );
    }
  
    // make a copy, we don't want to modify arguments
    options = $.extend( {}, options );
  
    var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
      target = $( options.of ),
      within = $.position.getWithinInfo( options.within ),
      scrollInfo = $.position.getScrollInfo( within ),
      collision = ( options.collision || "flip" ).split( " " ),
      offsets = {};
  
    dimensions = getDimensions( target );
    if ( target[0].preventDefault ) {
      // force left top to allow flipping
      options.at = "left top";
    }
    targetWidth = dimensions.width;
    targetHeight = dimensions.height;
    targetOffset = dimensions.offset;
    // clone to reuse original targetOffset later
    basePosition = $.extend( {}, targetOffset );
  
    // force my and at to have valid horizontal and vertical positions
    // if a value is missing or invalid, it will be converted to center
    $.each( [ "my", "at" ], function() {
      var pos = ( options[ this ] || "" ).split( " " ),
        horizontalOffset,
        verticalOffset;
  
      if ( pos.length === 1) {
        pos = rhorizontal.test( pos[ 0 ] ) ?
          pos.concat( [ "center" ] ) :
          rvertical.test( pos[ 0 ] ) ?
            [ "center" ].concat( pos ) :
            [ "center", "center" ];
      }
      pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
      pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";
  
      // calculate offsets
      horizontalOffset = roffset.exec( pos[ 0 ] );
      verticalOffset = roffset.exec( pos[ 1 ] );
      offsets[ this ] = [
        horizontalOffset ? horizontalOffset[ 0 ] : 0,
        verticalOffset ? verticalOffset[ 0 ] : 0
      ];
  
      // reduce to just the positions without the offsets
      options[ this ] = [
        rposition.exec( pos[ 0 ] )[ 0 ],
        rposition.exec( pos[ 1 ] )[ 0 ]
      ];
    });
  
    // normalize collision option
    if ( collision.length === 1 ) {
      collision[ 1 ] = collision[ 0 ];
    }
  
    if ( options.at[ 0 ] === "right" ) {
      basePosition.left += targetWidth;
    } else if ( options.at[ 0 ] === "center" ) {
      basePosition.left += targetWidth / 2;
    }
  
    if ( options.at[ 1 ] === "bottom" ) {
      basePosition.top += targetHeight;
    } else if ( options.at[ 1 ] === "center" ) {
      basePosition.top += targetHeight / 2;
    }
  
    atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
    basePosition.left += atOffset[ 0 ];
    basePosition.top += atOffset[ 1 ];
  
    return this.each(function() {
      var collisionPosition, using,
        elem = $( this ),
        elemWidth = elem.outerWidth(),
        elemHeight = elem.outerHeight(),
        marginLeft = parseCss( this, "marginLeft" ),
        marginTop = parseCss( this, "marginTop" ),
        collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
        collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
        position = $.extend( {}, basePosition ),
        myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );
  
      if ( options.my[ 0 ] === "right" ) {
        position.left -= elemWidth;
      } else if ( options.my[ 0 ] === "center" ) {
        position.left -= elemWidth / 2;
      }
  
      if ( options.my[ 1 ] === "bottom" ) {
        position.top -= elemHeight;
      } else if ( options.my[ 1 ] === "center" ) {
        position.top -= elemHeight / 2;
      }
  
      position.left += myOffset[ 0 ];
      position.top += myOffset[ 1 ];
  
      // if the browser doesn't support fractions, then round for consistent results
      if ( !supportsOffsetFractions ) {
        position.left = round( position.left );
        position.top = round( position.top );
      }
  
      collisionPosition = {
        marginLeft: marginLeft,
        marginTop: marginTop
      };
  
      $.each( [ "left", "top" ], function( i, dir ) {
        if ( $.ui.position[ collision[ i ] ] ) {
          $.ui.position[ collision[ i ] ][ dir ]( position, {
            targetWidth: targetWidth,
            targetHeight: targetHeight,
            elemWidth: elemWidth,
            elemHeight: elemHeight,
            collisionPosition: collisionPosition,
            collisionWidth: collisionWidth,
            collisionHeight: collisionHeight,
            offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
            my: options.my,
            at: options.at,
            within: within,
            elem: elem
          });
        }
      });
  
      if ( options.using ) {
        // adds feedback as second argument to using callback, if present
        using = function( props ) {
          var left = targetOffset.left - position.left,
            right = left + targetWidth - elemWidth,
            top = targetOffset.top - position.top,
            bottom = top + targetHeight - elemHeight,
            feedback = {
              target: {
                element: target,
                left: targetOffset.left,
                top: targetOffset.top,
                width: targetWidth,
                height: targetHeight
              },
              element: {
                element: elem,
                left: position.left,
                top: position.top,
                width: elemWidth,
                height: elemHeight
              },
              horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
              vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
            };
          if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
            feedback.horizontal = "center";
          }
          if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
            feedback.vertical = "middle";
          }
          if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
            feedback.important = "horizontal";
          } else {
            feedback.important = "vertical";
          }
          options.using.call( this, props, feedback );
        };
      }
  
      elem.offset( $.extend( position, { using: using } ) );
    });
  };
  
  $.ui.position = {
    fit: {
      left: function( position, data ) {
        var within = data.within,
          withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
          outerWidth = within.width,
          collisionPosLeft = position.left - data.collisionPosition.marginLeft,
          overLeft = withinOffset - collisionPosLeft,
          overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
          newOverRight;
  
        // element is wider than within
        if ( data.collisionWidth > outerWidth ) {
          // element is initially over the left side of within
          if ( overLeft > 0 && overRight <= 0 ) {
            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
            position.left += overLeft - newOverRight;
          // element is initially over right side of within
          } else if ( overRight > 0 && overLeft <= 0 ) {
            position.left = withinOffset;
          // element is initially over both left and right sides of within
          } else {
            if ( overLeft > overRight ) {
              position.left = withinOffset + outerWidth - data.collisionWidth;
            } else {
              position.left = withinOffset;
            }
          }
        // too far left -> align with left edge
        } else if ( overLeft > 0 ) {
          position.left += overLeft;
        // too far right -> align with right edge
        } else if ( overRight > 0 ) {
          position.left -= overRight;
        // adjust based on position and margin
        } else {
          position.left = max( position.left - collisionPosLeft, position.left );
        }
      },
      top: function( position, data ) {
        var within = data.within,
          withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
          outerHeight = data.within.height,
          collisionPosTop = position.top - data.collisionPosition.marginTop,
          overTop = withinOffset - collisionPosTop,
          overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
          newOverBottom;
  
        // element is taller than within
        if ( data.collisionHeight > outerHeight ) {
          // element is initially over the top of within
          if ( overTop > 0 && overBottom <= 0 ) {
            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
            position.top += overTop - newOverBottom;
          // element is initially over bottom of within
          } else if ( overBottom > 0 && overTop <= 0 ) {
            position.top = withinOffset;
          // element is initially over both top and bottom of within
          } else {
            if ( overTop > overBottom ) {
              position.top = withinOffset + outerHeight - data.collisionHeight;
            } else {
              position.top = withinOffset;
            }
          }
        // too far up -> align with top
        } else if ( overTop > 0 ) {
          position.top += overTop;
        // too far down -> align with bottom edge
        } else if ( overBottom > 0 ) {
          position.top -= overBottom;
        // adjust based on position and margin
        } else {
          position.top = max( position.top - collisionPosTop, position.top );
        }
      }
    },
    flip: {
      left: function( position, data ) {
        var within = data.within,
          withinOffset = within.offset.left + within.scrollLeft,
          outerWidth = within.width,
          offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
          collisionPosLeft = position.left - data.collisionPosition.marginLeft,
          overLeft = collisionPosLeft - offsetLeft,
          overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
          myOffset = data.my[ 0 ] === "left" ?
            -data.elemWidth :
            data.my[ 0 ] === "right" ?
              data.elemWidth :
              0,
          atOffset = data.at[ 0 ] === "left" ?
            data.targetWidth :
            data.at[ 0 ] === "right" ?
              -data.targetWidth :
              0,
          offset = -2 * data.offset[ 0 ],
          newOverRight,
          newOverLeft;
  
        if ( overLeft < 0 ) {
          newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
          if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
            position.left += myOffset + atOffset + offset;
          }
        } else if ( overRight > 0 ) {
          newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
          if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
            position.left += myOffset + atOffset + offset;
          }
        }
      },
      top: function( position, data ) {
        var within = data.within,
          withinOffset = within.offset.top + within.scrollTop,
          outerHeight = within.height,
          offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
          collisionPosTop = position.top - data.collisionPosition.marginTop,
          overTop = collisionPosTop - offsetTop,
          overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
          top = data.my[ 1 ] === "top",
          myOffset = top ?
            -data.elemHeight :
            data.my[ 1 ] === "bottom" ?
              data.elemHeight :
              0,
          atOffset = data.at[ 1 ] === "top" ?
            data.targetHeight :
            data.at[ 1 ] === "bottom" ?
              -data.targetHeight :
              0,
          offset = -2 * data.offset[ 1 ],
          newOverTop,
          newOverBottom;
        if ( overTop < 0 ) {
          newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
          if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
            position.top += myOffset + atOffset + offset;
          }
        } else if ( overBottom > 0 ) {
          newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
          if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
            position.top += myOffset + atOffset + offset;
          }
        }
      }
    },
    flipfit: {
      left: function() {
        $.ui.position.flip.left.apply( this, arguments );
        $.ui.position.fit.left.apply( this, arguments );
      },
      top: function() {
        $.ui.position.flip.top.apply( this, arguments );
        $.ui.position.fit.top.apply( this, arguments );
      }
    }
  };
  
  // fraction support test
  (function() {
    var testElement, testElementParent, testElementStyle, offsetLeft, i,
      body = document.getElementsByTagName( "body" )[ 0 ],
      div = document.createElement( "div" );
  
    //Create a "fake body" for testing based on method used in jQuery.support
    testElement = document.createElement( body ? "div" : "body" );
    testElementStyle = {
      visibility: "hidden",
      width: 0,
      height: 0,
      border: 0,
      margin: 0,
      background: "none"
    };
    if ( body ) {
      $.extend( testElementStyle, {
        position: "absolute",
        left: "-1000px",
        top: "-1000px"
      });
    }
    for ( i in testElementStyle ) {
      testElement.style[ i ] = testElementStyle[ i ];
    }
    testElement.appendChild( div );
    testElementParent = body || document.documentElement;
    testElementParent.insertBefore( testElement, testElementParent.firstChild );
  
    div.style.cssText = "position: absolute; left: 10.7432222px;";
  
    offsetLeft = $( div ).offset().left;
    supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;
  
    testElement.innerHTML = "";
    testElementParent.removeChild( testElement );
  })();
  
  })();
  
  var position = $.ui.position;
  
  
  /*!
   * jQuery UI Accordion 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/accordion/
   */
  
  
  var accordion = $.widget( "ui.accordion", {
    version: "1.11.4",
    options: {
      active: 0,
      animate: {},
      collapsible: false,
      event: "click",
      header: "> li > :first-child,> :not(li):even",
      heightStyle: "auto",
      icons: {
        activeHeader: "ui-icon-triangle-1-s",
        header: "ui-icon-triangle-1-e"
      },
  
      // callbacks
      activate: null,
      beforeActivate: null
    },
  
    hideProps: {
      borderTopWidth: "hide",
      borderBottomWidth: "hide",
      paddingTop: "hide",
      paddingBottom: "hide",
      height: "hide"
    },
  
    showProps: {
      borderTopWidth: "show",
      borderBottomWidth: "show",
      paddingTop: "show",
      paddingBottom: "show",
      height: "show"
    },
  
    _create: function() {
      var options = this.options;
      this.prevShow = this.prevHide = $();
      this.element.addClass( "ui-accordion ui-widget ui-helper-reset" )
        // ARIA
        .attr( "role", "tablist" );
  
      // don't allow collapsible: false and active: false / null
      if ( !options.collapsible && (options.active === false || options.active == null) ) {
        options.active = 0;
      }
  
      this._processPanels();
      // handle negative values
      if ( options.active < 0 ) {
        options.active += this.headers.length;
      }
      this._refresh();
    },
  
    _getCreateEventData: function() {
      return {
        header: this.active,
        panel: !this.active.length ? $() : this.active.next()
      };
    },
  
    _createIcons: function() {
      var icons = this.options.icons;
      if ( icons ) {
        $( "<span>" )
          .addClass( "ui-accordion-header-icon ui-icon " + icons.header )
          .prependTo( this.headers );
        this.active.children( ".ui-accordion-header-icon" )
          .removeClass( icons.header )
          .addClass( icons.activeHeader );
        this.headers.addClass( "ui-accordion-icons" );
      }
    },
  
    _destroyIcons: function() {
      this.headers
        .removeClass( "ui-accordion-icons" )
        .children( ".ui-accordion-header-icon" )
          .remove();
    },
  
    _destroy: function() {
      var contents;
  
      // clean up main element
      this.element
        .removeClass( "ui-accordion ui-widget ui-helper-reset" )
        .removeAttr( "role" );
  
      // clean up headers
      this.headers
        .removeClass( "ui-accordion-header ui-accordion-header-active ui-state-default " +
          "ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
        .removeAttr( "role" )
        .removeAttr( "aria-expanded" )
        .removeAttr( "aria-selected" )
        .removeAttr( "aria-controls" )
        .removeAttr( "tabIndex" )
        .removeUniqueId();
  
      this._destroyIcons();
  
      // clean up content panels
      contents = this.headers.next()
        .removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom " +
          "ui-accordion-content ui-accordion-content-active ui-state-disabled" )
        .css( "display", "" )
        .removeAttr( "role" )
        .removeAttr( "aria-hidden" )
        .removeAttr( "aria-labelledby" )
        .removeUniqueId();
  
      if ( this.options.heightStyle !== "content" ) {
        contents.css( "height", "" );
      }
    },
  
    _setOption: function( key, value ) {
      if ( key === "active" ) {
        // _activate() will handle invalid values and update this.options
        this._activate( value );
        return;
      }
  
      if ( key === "event" ) {
        if ( this.options.event ) {
          this._off( this.headers, this.options.event );
        }
        this._setupEvents( value );
      }
  
      this._super( key, value );
  
      // setting collapsible: false while collapsed; open first panel
      if ( key === "collapsible" && !value && this.options.active === false ) {
        this._activate( 0 );
      }
  
      if ( key === "icons" ) {
        this._destroyIcons();
        if ( value ) {
          this._createIcons();
        }
      }
  
      // #5332 - opacity doesn't cascade to positioned elements in IE
      // so we need to add the disabled class to the headers and panels
      if ( key === "disabled" ) {
        this.element
          .toggleClass( "ui-state-disabled", !!value )
          .attr( "aria-disabled", value );
        this.headers.add( this.headers.next() )
          .toggleClass( "ui-state-disabled", !!value );
      }
    },
  
    _keydown: function( event ) {
      if ( event.altKey || event.ctrlKey ) {
        return;
      }
  
      var keyCode = $.ui.keyCode,
        length = this.headers.length,
        currentIndex = this.headers.index( event.target ),
        toFocus = false;
  
      switch ( event.keyCode ) {
        case keyCode.RIGHT:
        case keyCode.DOWN:
          toFocus = this.headers[ ( currentIndex + 1 ) % length ];
          break;
        case keyCode.LEFT:
        case keyCode.UP:
          toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
          break;
        case keyCode.SPACE:
        case keyCode.ENTER:
          this._eventHandler( event );
          break;
        case keyCode.HOME:
          toFocus = this.headers[ 0 ];
          break;
        case keyCode.END:
          toFocus = this.headers[ length - 1 ];
          break;
      }
  
      if ( toFocus ) {
        $( event.target ).attr( "tabIndex", -1 );
        $( toFocus ).attr( "tabIndex", 0 );
        toFocus.focus();
        event.preventDefault();
      }
    },
  
    _panelKeyDown: function( event ) {
      if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
        $( event.currentTarget ).prev().focus();
      }
    },
  
    refresh: function() {
      var options = this.options;
      this._processPanels();
  
      // was collapsed or no panel
      if ( ( options.active === false && options.collapsible === true ) || !this.headers.length ) {
        options.active = false;
        this.active = $();
      // active false only when collapsible is true
      } else if ( options.active === false ) {
        this._activate( 0 );
      // was active, but active panel is gone
      } else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
        // all remaining panel are disabled
        if ( this.headers.length === this.headers.find(".ui-state-disabled").length ) {
          options.active = false;
          this.active = $();
        // activate previous panel
        } else {
          this._activate( Math.max( 0, options.active - 1 ) );
        }
      // was active, active panel still exists
      } else {
        // make sure active index is correct
        options.active = this.headers.index( this.active );
      }
  
      this._destroyIcons();
  
      this._refresh();
    },
  
    _processPanels: function() {
      var prevHeaders = this.headers,
        prevPanels = this.panels;
  
      this.headers = this.element.find( this.options.header )
        .addClass( "ui-accordion-header ui-state-default ui-corner-all" );
  
      this.panels = this.headers.next()
        .addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" )
        .filter( ":not(.ui-accordion-content-active)" )
        .hide();
  
      // Avoid memory leaks (#10056)
      if ( prevPanels ) {
        this._off( prevHeaders.not( this.headers ) );
        this._off( prevPanels.not( this.panels ) );
      }
    },
  
    _refresh: function() {
      var maxHeight,
        options = this.options,
        heightStyle = options.heightStyle,
        parent = this.element.parent();
  
      this.active = this._findActive( options.active )
        .addClass( "ui-accordion-header-active ui-state-active ui-corner-top" )
        .removeClass( "ui-corner-all" );
      this.active.next()
        .addClass( "ui-accordion-content-active" )
        .show();
  
      this.headers
        .attr( "role", "tab" )
        .each(function() {
          var header = $( this ),
            headerId = header.uniqueId().attr( "id" ),
            panel = header.next(),
            panelId = panel.uniqueId().attr( "id" );
          header.attr( "aria-controls", panelId );
          panel.attr( "aria-labelledby", headerId );
        })
        .next()
          .attr( "role", "tabpanel" );
  
      this.headers
        .not( this.active )
        .attr({
          "aria-selected": "false",
          "aria-expanded": "false",
          tabIndex: -1
        })
        .next()
          .attr({
            "aria-hidden": "true"
          })
          .hide();
  
      // make sure at least one header is in the tab order
      if ( !this.active.length ) {
        this.headers.eq( 0 ).attr( "tabIndex", 0 );
      } else {
        this.active.attr({
          "aria-selected": "true",
          "aria-expanded": "true",
          tabIndex: 0
        })
        .next()
          .attr({
            "aria-hidden": "false"
          });
      }
  
      this._createIcons();
  
      this._setupEvents( options.event );
  
      if ( heightStyle === "fill" ) {
        maxHeight = parent.height();
        this.element.siblings( ":visible" ).each(function() {
          var elem = $( this ),
            position = elem.css( "position" );
  
          if ( position === "absolute" || position === "fixed" ) {
            return;
          }
          maxHeight -= elem.outerHeight( true );
        });
  
        this.headers.each(function() {
          maxHeight -= $( this ).outerHeight( true );
        });
  
        this.headers.next()
          .each(function() {
            $( this ).height( Math.max( 0, maxHeight -
              $( this ).innerHeight() + $( this ).height() ) );
          })
          .css( "overflow", "auto" );
      } else if ( heightStyle === "auto" ) {
        maxHeight = 0;
        this.headers.next()
          .each(function() {
            maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
          })
          .height( maxHeight );
      }
    },
  
    _activate: function( index ) {
      var active = this._findActive( index )[ 0 ];
  
      // trying to activate the already active panel
      if ( active === this.active[ 0 ] ) {
        return;
      }
  
      // trying to collapse, simulate a click on the currently active header
      active = active || this.active[ 0 ];
  
      this._eventHandler({
        target: active,
        currentTarget: active,
        preventDefault: $.noop
      });
    },
  
    _findActive: function( selector ) {
      return typeof selector === "number" ? this.headers.eq( selector ) : $();
    },
  
    _setupEvents: function( event ) {
      var events = {
        keydown: "_keydown"
      };
      if ( event ) {
        $.each( event.split( " " ), function( index, eventName ) {
          events[ eventName ] = "_eventHandler";
        });
      }
  
      this._off( this.headers.add( this.headers.next() ) );
      this._on( this.headers, events );
      this._on( this.headers.next(), { keydown: "_panelKeyDown" });
      this._hoverable( this.headers );
      this._focusable( this.headers );
    },
  
    _eventHandler: function( event ) {
      var options = this.options,
        active = this.active,
        clicked = $( event.currentTarget ),
        clickedIsActive = clicked[ 0 ] === active[ 0 ],
        collapsing = clickedIsActive && options.collapsible,
        toShow = collapsing ? $() : clicked.next(),
        toHide = active.next(),
        eventData = {
          oldHeader: active,
          oldPanel: toHide,
          newHeader: collapsing ? $() : clicked,
          newPanel: toShow
        };
  
      event.preventDefault();
  
      if (
          // click on active header, but not collapsible
          ( clickedIsActive && !options.collapsible ) ||
          // allow canceling activation
          ( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
        return;
      }
  
      options.active = collapsing ? false : this.headers.index( clicked );
  
      // when the call to ._toggle() comes after the class changes
      // it causes a very odd bug in IE 8 (see #6720)
      this.active = clickedIsActive ? $() : clicked;
      this._toggle( eventData );
  
      // switch classes
      // corner classes on the previously active header stay after the animation
      active.removeClass( "ui-accordion-header-active ui-state-active" );
      if ( options.icons ) {
        active.children( ".ui-accordion-header-icon" )
          .removeClass( options.icons.activeHeader )
          .addClass( options.icons.header );
      }
  
      if ( !clickedIsActive ) {
        clicked
          .removeClass( "ui-corner-all" )
          .addClass( "ui-accordion-header-active ui-state-active ui-corner-top" );
        if ( options.icons ) {
          clicked.children( ".ui-accordion-header-icon" )
            .removeClass( options.icons.header )
            .addClass( options.icons.activeHeader );
        }
  
        clicked
          .next()
          .addClass( "ui-accordion-content-active" );
      }
    },
  
    _toggle: function( data ) {
      var toShow = data.newPanel,
        toHide = this.prevShow.length ? this.prevShow : data.oldPanel;
  
      // handle activating a panel during the animation for another activation
      this.prevShow.add( this.prevHide ).stop( true, true );
      this.prevShow = toShow;
      this.prevHide = toHide;
  
      if ( this.options.animate ) {
        this._animate( toShow, toHide, data );
      } else {
        toHide.hide();
        toShow.show();
        this._toggleComplete( data );
      }
  
      toHide.attr({
        "aria-hidden": "true"
      });
      toHide.prev().attr({
        "aria-selected": "false",
        "aria-expanded": "false"
      });
      // if we're switching panels, remove the old header from the tab order
      // if we're opening from collapsed state, remove the previous header from the tab order
      // if we're collapsing, then keep the collapsing header in the tab order
      if ( toShow.length && toHide.length ) {
        toHide.prev().attr({
          "tabIndex": -1,
          "aria-expanded": "false"
        });
      } else if ( toShow.length ) {
        this.headers.filter(function() {
          return parseInt( $( this ).attr( "tabIndex" ), 10 ) === 0;
        })
        .attr( "tabIndex", -1 );
      }
  
      toShow
        .attr( "aria-hidden", "false" )
        .prev()
          .attr({
            "aria-selected": "true",
            "aria-expanded": "true",
            tabIndex: 0
          });
    },
  
    _animate: function( toShow, toHide, data ) {
      var total, easing, duration,
        that = this,
        adjust = 0,
        boxSizing = toShow.css( "box-sizing" ),
        down = toShow.length &&
          ( !toHide.length || ( toShow.index() < toHide.index() ) ),
        animate = this.options.animate || {},
        options = down && animate.down || animate,
        complete = function() {
          that._toggleComplete( data );
        };
  
      if ( typeof options === "number" ) {
        duration = options;
      }
      if ( typeof options === "string" ) {
        easing = options;
      }
      // fall back from options to animation in case of partial down settings
      easing = easing || options.easing || animate.easing;
      duration = duration || options.duration || animate.duration;
  
      if ( !toHide.length ) {
        return toShow.animate( this.showProps, duration, easing, complete );
      }
      if ( !toShow.length ) {
        return toHide.animate( this.hideProps, duration, easing, complete );
      }
  
      total = toShow.show().outerHeight();
      toHide.animate( this.hideProps, {
        duration: duration,
        easing: easing,
        step: function( now, fx ) {
          fx.now = Math.round( now );
        }
      });
      toShow
        .hide()
        .animate( this.showProps, {
          duration: duration,
          easing: easing,
          complete: complete,
          step: function( now, fx ) {
            fx.now = Math.round( now );
            if ( fx.prop !== "height" ) {
              if ( boxSizing === "content-box" ) {
                adjust += fx.now;
              }
            } else if ( that.options.heightStyle !== "content" ) {
              fx.now = Math.round( total - toHide.outerHeight() - adjust );
              adjust = 0;
            }
          }
        });
    },
  
    _toggleComplete: function( data ) {
      var toHide = data.oldPanel;
  
      toHide
        .removeClass( "ui-accordion-content-active" )
        .prev()
          .removeClass( "ui-corner-top" )
          .addClass( "ui-corner-all" );
  
      // Work around for rendering bug in IE (#5421)
      if ( toHide.length ) {
        toHide.parent()[ 0 ].className = toHide.parent()[ 0 ].className;
      }
      this._trigger( "activate", null, data );
    }
  });
  
  
  /*!
   * jQuery UI Menu 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/menu/
   */
  
  
  var menu = $.widget( "ui.menu", {
    version: "1.11.4",
    defaultElement: "<ul>",
    delay: 300,
    options: {
      icons: {
        submenu: "ui-icon-carat-1-e"
      },
      items: "> *",
      menus: "ul",
      position: {
        my: "left-1 top",
        at: "right top"
      },
      role: "menu",
  
      // callbacks
      blur: null,
      focus: null,
      select: null
    },
  
    _create: function() {
      this.activeMenu = this.element;
  
      // Flag used to prevent firing of the click handler
      // as the event bubbles up through nested menus
      this.mouseHandled = false;
      this.element
        .uniqueId()
        .addClass( "ui-menu ui-widget ui-widget-content" )
        .toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length )
        .attr({
          role: this.options.role,
          tabIndex: 0
        });
  
      if ( this.options.disabled ) {
        this.element
          .addClass( "ui-state-disabled" )
          .attr( "aria-disabled", "true" );
      }
  
      this._on({
        // Prevent focus from sticking to links inside menu after clicking
        // them (focus should always stay on UL during navigation).
        "mousedown .ui-menu-item": function( event ) {
          event.preventDefault();
        },
        "click .ui-menu-item": function( event ) {
          var target = $( event.target );
          if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {
            this.select( event );
  
            // Only set the mouseHandled flag if the event will bubble, see #9469.
            if ( !event.isPropagationStopped() ) {
              this.mouseHandled = true;
            }
  
            // Open submenu on click
            if ( target.has( ".ui-menu" ).length ) {
              this.expand( event );
            } else if ( !this.element.is( ":focus" ) && $( this.document[ 0 ].activeElement ).closest( ".ui-menu" ).length ) {
  
              // Redirect focus to the menu
              this.element.trigger( "focus", [ true ] );
  
              // If the active item is on the top level, let it stay active.
              // Otherwise, blur the active item since it is no longer visible.
              if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
                clearTimeout( this.timer );
              }
            }
          }
        },
        "mouseenter .ui-menu-item": function( event ) {
          // Ignore mouse events while typeahead is active, see #10458.
          // Prevents focusing the wrong item when typeahead causes a scroll while the mouse
          // is over an item in the menu
          if ( this.previousFilter ) {
            return;
          }
          var target = $( event.currentTarget );
          // Remove ui-state-active class from siblings of the newly focused menu item
          // to avoid a jump caused by adjacent elements both having a class with a border
          target.siblings( ".ui-state-active" ).removeClass( "ui-state-active" );
          this.focus( event, target );
        },
        mouseleave: "collapseAll",
        "mouseleave .ui-menu": "collapseAll",
        focus: function( event, keepActiveItem ) {
          // If there's already an active item, keep it active
          // If not, activate the first item
          var item = this.active || this.element.find( this.options.items ).eq( 0 );
  
          if ( !keepActiveItem ) {
            this.focus( event, item );
          }
        },
        blur: function( event ) {
          this._delay(function() {
            if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {
              this.collapseAll( event );
            }
          });
        },
        keydown: "_keydown"
      });
  
      this.refresh();
  
      // Clicks outside of a menu collapse any open menus
      this._on( this.document, {
        click: function( event ) {
          if ( this._closeOnDocumentClick( event ) ) {
            this.collapseAll( event );
          }
  
          // Reset the mouseHandled flag
          this.mouseHandled = false;
        }
      });
    },
  
    _destroy: function() {
      // Destroy (sub)menus
      this.element
        .removeAttr( "aria-activedescendant" )
        .find( ".ui-menu" ).addBack()
          .removeClass( "ui-menu ui-widget ui-widget-content ui-menu-icons ui-front" )
          .removeAttr( "role" )
          .removeAttr( "tabIndex" )
          .removeAttr( "aria-labelledby" )
          .removeAttr( "aria-expanded" )
          .removeAttr( "aria-hidden" )
          .removeAttr( "aria-disabled" )
          .removeUniqueId()
          .show();
  
      // Destroy menu items
      this.element.find( ".ui-menu-item" )
        .removeClass( "ui-menu-item" )
        .removeAttr( "role" )
        .removeAttr( "aria-disabled" )
        .removeUniqueId()
        .removeClass( "ui-state-hover" )
        .removeAttr( "tabIndex" )
        .removeAttr( "role" )
        .removeAttr( "aria-haspopup" )
        .children().each( function() {
          var elem = $( this );
          if ( elem.data( "ui-menu-submenu-carat" ) ) {
            elem.remove();
          }
        });
  
      // Destroy menu dividers
      this.element.find( ".ui-menu-divider" ).removeClass( "ui-menu-divider ui-widget-content" );
    },
  
    _keydown: function( event ) {
      var match, prev, character, skip,
        preventDefault = true;
  
      switch ( event.keyCode ) {
      case $.ui.keyCode.PAGE_UP:
        this.previousPage( event );
        break;
      case $.ui.keyCode.PAGE_DOWN:
        this.nextPage( event );
        break;
      case $.ui.keyCode.HOME:
        this._move( "first", "first", event );
        break;
      case $.ui.keyCode.END:
        this._move( "last", "last", event );
        break;
      case $.ui.keyCode.UP:
        this.previous( event );
        break;
      case $.ui.keyCode.DOWN:
        this.next( event );
        break;
      case $.ui.keyCode.LEFT:
        this.collapse( event );
        break;
      case $.ui.keyCode.RIGHT:
        if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
          this.expand( event );
        }
        break;
      case $.ui.keyCode.ENTER:
      case $.ui.keyCode.SPACE:
        this._activate( event );
        break;
      case $.ui.keyCode.ESCAPE:
        this.collapse( event );
        break;
      default:
        preventDefault = false;
        prev = this.previousFilter || "";
        character = String.fromCharCode( event.keyCode );
        skip = false;
  
        clearTimeout( this.filterTimer );
  
        if ( character === prev ) {
          skip = true;
        } else {
          character = prev + character;
        }
  
        match = this._filterMenuItems( character );
        match = skip && match.index( this.active.next() ) !== -1 ?
          this.active.nextAll( ".ui-menu-item" ) :
          match;
  
        // If no matches on the current filter, reset to the last character pressed
        // to move down the menu to the first item that starts with that character
        if ( !match.length ) {
          character = String.fromCharCode( event.keyCode );
          match = this._filterMenuItems( character );
        }
  
        if ( match.length ) {
          this.focus( event, match );
          this.previousFilter = character;
          this.filterTimer = this._delay(function() {
            delete this.previousFilter;
          }, 1000 );
        } else {
          delete this.previousFilter;
        }
      }
  
      if ( preventDefault ) {
        event.preventDefault();
      }
    },
  
    _activate: function( event ) {
      if ( !this.active.is( ".ui-state-disabled" ) ) {
        if ( this.active.is( "[aria-haspopup='true']" ) ) {
          this.expand( event );
        } else {
          this.select( event );
        }
      }
    },
  
    refresh: function() {
      var menus, items,
        that = this,
        icon = this.options.icons.submenu,
        submenus = this.element.find( this.options.menus );
  
      this.element.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length );
  
      // Initialize nested menus
      submenus.filter( ":not(.ui-menu)" )
        .addClass( "ui-menu ui-widget ui-widget-content ui-front" )
        .hide()
        .attr({
          role: this.options.role,
          "aria-hidden": "true",
          "aria-expanded": "false"
        })
        .each(function() {
          var menu = $( this ),
            item = menu.parent(),
            submenuCarat = $( "<span>" )
              .addClass( "ui-menu-icon ui-icon " + icon )
              .data( "ui-menu-submenu-carat", true );
  
          item
            .attr( "aria-haspopup", "true" )
            .prepend( submenuCarat );
          menu.attr( "aria-labelledby", item.attr( "id" ) );
        });
  
      menus = submenus.add( this.element );
      items = menus.find( this.options.items );
  
      // Initialize menu-items containing spaces and/or dashes only as dividers
      items.not( ".ui-menu-item" ).each(function() {
        var item = $( this );
        if ( that._isDivider( item ) ) {
          item.addClass( "ui-widget-content ui-menu-divider" );
        }
      });
  
      // Don't refresh list items that are already adapted
      items.not( ".ui-menu-item, .ui-menu-divider" )
        .addClass( "ui-menu-item" )
        .uniqueId()
        .attr({
          tabIndex: -1,
          role: this._itemRole()
        });
  
      // Add aria-disabled attribute to any disabled menu item
      items.filter( ".ui-state-disabled" ).attr( "aria-disabled", "true" );
  
      // If the active item has been removed, blur the menu
      if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
        this.blur();
      }
    },
  
    _itemRole: function() {
      return {
        menu: "menuitem",
        listbox: "option"
      }[ this.options.role ];
    },
  
    _setOption: function( key, value ) {
      if ( key === "icons" ) {
        this.element.find( ".ui-menu-icon" )
          .removeClass( this.options.icons.submenu )
          .addClass( value.submenu );
      }
      if ( key === "disabled" ) {
        this.element
          .toggleClass( "ui-state-disabled", !!value )
          .attr( "aria-disabled", value );
      }
      this._super( key, value );
    },
  
    focus: function( event, item ) {
      var nested, focused;
      this.blur( event, event && event.type === "focus" );
  
      this._scrollIntoView( item );
  
      this.active = item.first();
      focused = this.active.addClass( "ui-state-focus" ).removeClass( "ui-state-active" );
      // Only update aria-activedescendant if there's a role
      // otherwise we assume focus is managed elsewhere
      if ( this.options.role ) {
        this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
      }
  
      // Highlight active parent menu item, if any
      this.active
        .parent()
        .closest( ".ui-menu-item" )
        .addClass( "ui-state-active" );
  
      if ( event && event.type === "keydown" ) {
        this._close();
      } else {
        this.timer = this._delay(function() {
          this._close();
        }, this.delay );
      }
  
      nested = item.children( ".ui-menu" );
      if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {
        this._startOpening(nested);
      }
      this.activeMenu = item.parent();
  
      this._trigger( "focus", event, { item: item } );
    },
  
    _scrollIntoView: function( item ) {
      var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
      if ( this._hasScroll() ) {
        borderTop = parseFloat( $.css( this.activeMenu[0], "borderTopWidth" ) ) || 0;
        paddingTop = parseFloat( $.css( this.activeMenu[0], "paddingTop" ) ) || 0;
        offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
        scroll = this.activeMenu.scrollTop();
        elementHeight = this.activeMenu.height();
        itemHeight = item.outerHeight();
  
        if ( offset < 0 ) {
          this.activeMenu.scrollTop( scroll + offset );
        } else if ( offset + itemHeight > elementHeight ) {
          this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
        }
      }
    },
  
    blur: function( event, fromFocus ) {
      if ( !fromFocus ) {
        clearTimeout( this.timer );
      }
  
      if ( !this.active ) {
        return;
      }
  
      this.active.removeClass( "ui-state-focus" );
      this.active = null;
  
      this._trigger( "blur", event, { item: this.active } );
    },
  
    _startOpening: function( submenu ) {
      clearTimeout( this.timer );
  
      // Don't open if already open fixes a Firefox bug that caused a .5 pixel
      // shift in the submenu position when mousing over the carat icon
      if ( submenu.attr( "aria-hidden" ) !== "true" ) {
        return;
      }
  
      this.timer = this._delay(function() {
        this._close();
        this._open( submenu );
      }, this.delay );
    },
  
    _open: function( submenu ) {
      var position = $.extend({
        of: this.active
      }, this.options.position );
  
      clearTimeout( this.timer );
      this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
        .hide()
        .attr( "aria-hidden", "true" );
  
      submenu
        .show()
        .removeAttr( "aria-hidden" )
        .attr( "aria-expanded", "true" )
        .position( position );
    },
  
    collapseAll: function( event, all ) {
      clearTimeout( this.timer );
      this.timer = this._delay(function() {
        // If we were passed an event, look for the submenu that contains the event
        var currentMenu = all ? this.element :
          $( event && event.target ).closest( this.element.find( ".ui-menu" ) );
  
        // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
        if ( !currentMenu.length ) {
          currentMenu = this.element;
        }
  
        this._close( currentMenu );
  
        this.blur( event );
        this.activeMenu = currentMenu;
      }, this.delay );
    },
  
    // With no arguments, closes the currently active menu - if nothing is active
    // it closes all menus.  If passed an argument, it will search for menus BELOW
    _close: function( startMenu ) {
      if ( !startMenu ) {
        startMenu = this.active ? this.active.parent() : this.element;
      }
  
      startMenu
        .find( ".ui-menu" )
          .hide()
          .attr( "aria-hidden", "true" )
          .attr( "aria-expanded", "false" )
        .end()
        .find( ".ui-state-active" ).not( ".ui-state-focus" )
          .removeClass( "ui-state-active" );
    },
  
    _closeOnDocumentClick: function( event ) {
      return !$( event.target ).closest( ".ui-menu" ).length;
    },
  
    _isDivider: function( item ) {
  
      // Match hyphen, em dash, en dash
      return !/[^\-\u2014\u2013\s]/.test( item.text() );
    },
  
    collapse: function( event ) {
      var newItem = this.active &&
        this.active.parent().closest( ".ui-menu-item", this.element );
      if ( newItem && newItem.length ) {
        this._close();
        this.focus( event, newItem );
      }
    },
  
    expand: function( event ) {
      var newItem = this.active &&
        this.active
          .children( ".ui-menu " )
          .find( this.options.items )
          .first();
  
      if ( newItem && newItem.length ) {
        this._open( newItem.parent() );
  
        // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
        this._delay(function() {
          this.focus( event, newItem );
        });
      }
    },
  
    next: function( event ) {
      this._move( "next", "first", event );
    },
  
    previous: function( event ) {
      this._move( "prev", "last", event );
    },
  
    isFirstItem: function() {
      return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
    },
  
    isLastItem: function() {
      return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
    },
  
    _move: function( direction, filter, event ) {
      var next;
      if ( this.active ) {
        if ( direction === "first" || direction === "last" ) {
          next = this.active
            [ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
            .eq( -1 );
        } else {
          next = this.active
            [ direction + "All" ]( ".ui-menu-item" )
            .eq( 0 );
        }
      }
      if ( !next || !next.length || !this.active ) {
        next = this.activeMenu.find( this.options.items )[ filter ]();
      }
  
      this.focus( event, next );
    },
  
    nextPage: function( event ) {
      var item, base, height;
  
      if ( !this.active ) {
        this.next( event );
        return;
      }
      if ( this.isLastItem() ) {
        return;
      }
      if ( this._hasScroll() ) {
        base = this.active.offset().top;
        height = this.element.height();
        this.active.nextAll( ".ui-menu-item" ).each(function() {
          item = $( this );
          return item.offset().top - base - height < 0;
        });
  
        this.focus( event, item );
      } else {
        this.focus( event, this.activeMenu.find( this.options.items )
          [ !this.active ? "first" : "last" ]() );
      }
    },
  
    previousPage: function( event ) {
      var item, base, height;
      if ( !this.active ) {
        this.next( event );
        return;
      }
      if ( this.isFirstItem() ) {
        return;
      }
      if ( this._hasScroll() ) {
        base = this.active.offset().top;
        height = this.element.height();
        this.active.prevAll( ".ui-menu-item" ).each(function() {
          item = $( this );
          return item.offset().top - base + height > 0;
        });
  
        this.focus( event, item );
      } else {
        this.focus( event, this.activeMenu.find( this.options.items ).first() );
      }
    },
  
    _hasScroll: function() {
      return this.element.outerHeight() < this.element.prop( "scrollHeight" );
    },
  
    select: function( event ) {
      // TODO: It should never be possible to not have an active item at this
      // point, but the tests don't trigger mouseenter before click.
      this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
      var ui = { item: this.active };
      if ( !this.active.has( ".ui-menu" ).length ) {
        this.collapseAll( event, true );
      }
      this._trigger( "select", event, ui );
    },
  
    _filterMenuItems: function(character) {
      var escapedCharacter = character.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" ),
        regex = new RegExp( "^" + escapedCharacter, "i" );
  
      return this.activeMenu
        .find( this.options.items )
  
        // Only match on items, not dividers or other content (#10571)
        .filter( ".ui-menu-item" )
        .filter(function() {
          return regex.test( $.trim( $( this ).text() ) );
        });
    }
  });
  
  
  /*!
   * jQuery UI Autocomplete 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/autocomplete/
   */
  
  
  $.widget( "ui.autocomplete", {
    version: "1.11.4",
    defaultElement: "<input>",
    options: {
      appendTo: null,
      autoFocus: false,
      delay: 300,
      minLength: 1,
      position: {
        my: "left top",
        at: "left bottom",
        collision: "none"
      },
      source: null,
  
      // callbacks
      change: null,
      close: null,
      focus: null,
      open: null,
      response: null,
      search: null,
      select: null
    },
  
    requestIndex: 0,
    pending: 0,
  
    _create: function() {
      // Some browsers only repeat keydown events, not keypress events,
      // so we use the suppressKeyPress flag to determine if we've already
      // handled the keydown event. #7269
      // Unfortunately the code for & in keypress is the same as the up arrow,
      // so we use the suppressKeyPressRepeat flag to avoid handling keypress
      // events when we know the keydown event was used to modify the
      // search term. #7799
      var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
        nodeName = this.element[ 0 ].nodeName.toLowerCase(),
        isTextarea = nodeName === "textarea",
        isInput = nodeName === "input";
  
      this.isMultiLine =
        // Textareas are always multi-line
        isTextarea ? true :
        // Inputs are always single-line, even if inside a contentEditable element
        // IE also treats inputs as contentEditable
        isInput ? false :
        // All other element types are determined by whether or not they're contentEditable
        this.element.prop( "isContentEditable" );
  
      this.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ];
      this.isNewMenu = true;
  
      this.element
        .addClass( "ui-autocomplete-input" )
        .attr( "autocomplete", "off" );
  
      this._on( this.element, {
        keydown: function( event ) {
          if ( this.element.prop( "readOnly" ) ) {
            suppressKeyPress = true;
            suppressInput = true;
            suppressKeyPressRepeat = true;
            return;
          }
  
          suppressKeyPress = false;
          suppressInput = false;
          suppressKeyPressRepeat = false;
          var keyCode = $.ui.keyCode;
          switch ( event.keyCode ) {
          case keyCode.PAGE_UP:
            suppressKeyPress = true;
            this._move( "previousPage", event );
            break;
          case keyCode.PAGE_DOWN:
            suppressKeyPress = true;
            this._move( "nextPage", event );
            break;
          case keyCode.UP:
            suppressKeyPress = true;
            this._keyEvent( "previous", event );
            break;
          case keyCode.DOWN:
            suppressKeyPress = true;
            this._keyEvent( "next", event );
            break;
          case keyCode.ENTER:
            // when menu is open and has focus
            if ( this.menu.active ) {
              // #6055 - Opera still allows the keypress to occur
              // which causes forms to submit
              suppressKeyPress = true;
              event.preventDefault();
              this.menu.select( event );
            }
            break;
          case keyCode.TAB:
            if ( this.menu.active ) {
              this.menu.select( event );
            }
            break;
          case keyCode.ESCAPE:
            if ( this.menu.element.is( ":visible" ) ) {
              if ( !this.isMultiLine ) {
                this._value( this.term );
              }
              this.close( event );
              // Different browsers have different default behavior for escape
              // Single press can mean undo or clear
              // Double press in IE means clear the whole form
              event.preventDefault();
            }
            break;
          default:
            suppressKeyPressRepeat = true;
            // search timeout should be triggered before the input value is changed
            this._searchTimeout( event );
            break;
          }
        },
        keypress: function( event ) {
          if ( suppressKeyPress ) {
            suppressKeyPress = false;
            if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
              event.preventDefault();
            }
            return;
          }
          if ( suppressKeyPressRepeat ) {
            return;
          }
  
          // replicate some key handlers to allow them to repeat in Firefox and Opera
          var keyCode = $.ui.keyCode;
          switch ( event.keyCode ) {
          case keyCode.PAGE_UP:
            this._move( "previousPage", event );
            break;
          case keyCode.PAGE_DOWN:
            this._move( "nextPage", event );
            break;
          case keyCode.UP:
            this._keyEvent( "previous", event );
            break;
          case keyCode.DOWN:
            this._keyEvent( "next", event );
            break;
          }
        },
        input: function( event ) {
          if ( suppressInput ) {
            suppressInput = false;
            event.preventDefault();
            return;
          }
          this._searchTimeout( event );
        },
        focus: function() {
          this.selectedItem = null;
          this.previous = this._value();
        },
        blur: function( event ) {
          if ( this.cancelBlur ) {
            delete this.cancelBlur;
            return;
          }
  
          clearTimeout( this.searching );
          this.close( event );
          this._change( event );
        }
      });
  
      this._initSource();
      this.menu = $( "<ul>" )
        .addClass( "ui-autocomplete ui-front" )
        .appendTo( this._appendTo() )
        .menu({
          // disable ARIA support, the live region takes care of that
          role: null
        })
        .hide()
        .menu( "instance" );
  
      this._on( this.menu.element, {
        mousedown: function( event ) {
          // prevent moving focus out of the text field
          event.preventDefault();
  
          // IE doesn't prevent moving focus even with event.preventDefault()
          // so we set a flag to know when we should ignore the blur event
          this.cancelBlur = true;
          this._delay(function() {
            delete this.cancelBlur;
          });
  
          // clicking on the scrollbar causes focus to shift to the body
          // but we can't detect a mouseup or a click immediately afterward
          // so we have to track the next mousedown and close the menu if
          // the user clicks somewhere outside of the autocomplete
          var menuElement = this.menu.element[ 0 ];
          if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
            this._delay(function() {
              var that = this;
              this.document.one( "mousedown", function( event ) {
                if ( event.target !== that.element[ 0 ] &&
                    event.target !== menuElement &&
                    !$.contains( menuElement, event.target ) ) {
                  that.close();
                }
              });
            });
          }
        },
        menufocus: function( event, ui ) {
          var label, item;
          // support: Firefox
          // Prevent accidental activation of menu items in Firefox (#7024 #9118)
          if ( this.isNewMenu ) {
            this.isNewMenu = false;
            if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
              this.menu.blur();
  
              this.document.one( "mousemove", function() {
                $( event.target ).trigger( event.originalEvent );
              });
  
              return;
            }
          }
  
          item = ui.item.data( "ui-autocomplete-item" );
          if ( false !== this._trigger( "focus", event, { item: item } ) ) {
            // use value to match what will end up in the input, if it was a key event
            if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
              this._value( item.value );
            }
          }
  
          // Announce the value in the liveRegion
          label = ui.item.attr( "aria-label" ) || item.value;
          if ( label && $.trim( label ).length ) {
            this.liveRegion.children().hide();
            $( "<div>" ).text( label ).appendTo( this.liveRegion );
          }
        },
        menuselect: function( event, ui ) {
          var item = ui.item.data( "ui-autocomplete-item" ),
            previous = this.previous;
  
          // only trigger when focus was lost (click on menu)
          if ( this.element[ 0 ] !== this.document[ 0 ].activeElement ) {
            this.element.focus();
            this.previous = previous;
            // #6109 - IE triggers two focus events and the second
            // is asynchronous, so we need to reset the previous
            // term synchronously and asynchronously :-(
            this._delay(function() {
              this.previous = previous;
              this.selectedItem = item;
            });
          }
  
          if ( false !== this._trigger( "select", event, { item: item } ) ) {
            this._value( item.value );
          }
          // reset the term after the select event
          // this allows custom select handling to work properly
          this.term = this._value();
  
          this.close( event );
          this.selectedItem = item;
        }
      });
  
      this.liveRegion = $( "<span>", {
          role: "status",
          "aria-live": "assertive",
          "aria-relevant": "additions"
        })
        .addClass( "ui-helper-hidden-accessible" )
        .appendTo( this.document[ 0 ].body );
  
      // turning off autocomplete prevents the browser from remembering the
      // value when navigating through history, so we re-enable autocomplete
      // if the page is unloaded before the widget is destroyed. #7790
      this._on( this.window, {
        beforeunload: function() {
          this.element.removeAttr( "autocomplete" );
        }
      });
    },
  
    _destroy: function() {
      clearTimeout( this.searching );
      this.element
        .removeClass( "ui-autocomplete-input" )
        .removeAttr( "autocomplete" );
      this.menu.element.remove();
      this.liveRegion.remove();
    },
  
    _setOption: function( key, value ) {
      this._super( key, value );
      if ( key === "source" ) {
        this._initSource();
      }
      if ( key === "appendTo" ) {
        this.menu.element.appendTo( this._appendTo() );
      }
      if ( key === "disabled" && value && this.xhr ) {
        this.xhr.abort();
      }
    },
  
    _appendTo: function() {
      var element = this.options.appendTo;
  
      if ( element ) {
        element = element.jquery || element.nodeType ?
          $( element ) :
          this.document.find( element ).eq( 0 );
      }
  
      if ( !element || !element[ 0 ] ) {
        element = this.element.closest( ".ui-front" );
      }
  
      if ( !element.length ) {
        element = this.document[ 0 ].body;
      }
  
      return element;
    },
  
    _initSource: function() {
      var array, url,
        that = this;
      if ( $.isArray( this.options.source ) ) {
        array = this.options.source;
        this.source = function( request, response ) {
          response( $.ui.autocomplete.filter( array, request.term ) );
        };
      } else if ( typeof this.options.source === "string" ) {
        url = this.options.source;
        this.source = function( request, response ) {
          if ( that.xhr ) {
            that.xhr.abort();
          }
          that.xhr = $.ajax({
            url: url,
            data: request,
            dataType: "json",
            success: function( data ) {
              response( data );
            },
            error: function() {
              response([]);
            }
          });
        };
      } else {
        this.source = this.options.source;
      }
    },
  
    _searchTimeout: function( event ) {
      clearTimeout( this.searching );
      this.searching = this._delay(function() {
  
        // Search if the value has changed, or if the user retypes the same value (see #7434)
        var equalValues = this.term === this._value(),
          menuVisible = this.menu.element.is( ":visible" ),
          modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;
  
        if ( !equalValues || ( equalValues && !menuVisible && !modifierKey ) ) {
          this.selectedItem = null;
          this.search( null, event );
        }
      }, this.options.delay );
    },
  
    search: function( value, event ) {
      value = value != null ? value : this._value();
  
      // always save the actual value, not the one passed as an argument
      this.term = this._value();
  
      if ( value.length < this.options.minLength ) {
        return this.close( event );
      }
  
      if ( this._trigger( "search", event ) === false ) {
        return;
      }
  
      return this._search( value );
    },
  
    _search: function( value ) {
      this.pending++;
      this.element.addClass( "ui-autocomplete-loading" );
      this.cancelSearch = false;
  
      this.source( { term: value }, this._response() );
    },
  
    _response: function() {
      var index = ++this.requestIndex;
  
      return $.proxy(function( content ) {
        if ( index === this.requestIndex ) {
          this.__response( content );
        }
  
        this.pending--;
        if ( !this.pending ) {
          this.element.removeClass( "ui-autocomplete-loading" );
        }
      }, this );
    },
  
    __response: function( content ) {
      if ( content ) {
        content = this._normalize( content );
      }
      this._trigger( "response", null, { content: content } );
      if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
        this._suggest( content );
        this._trigger( "open" );
      } else {
        // use ._close() instead of .close() so we don't cancel future searches
        this._close();
      }
    },
  
    close: function( event ) {
      this.cancelSearch = true;
      this._close( event );
    },
  
    _close: function( event ) {
      if ( this.menu.element.is( ":visible" ) ) {
        this.menu.element.hide();
        this.menu.blur();
        this.isNewMenu = true;
        this._trigger( "close", event );
      }
    },
  
    _change: function( event ) {
      if ( this.previous !== this._value() ) {
        this._trigger( "change", event, { item: this.selectedItem } );
      }
    },
  
    _normalize: function( items ) {
      // assume all items have the right format when the first item is complete
      if ( items.length && items[ 0 ].label && items[ 0 ].value ) {
        return items;
      }
      return $.map( items, function( item ) {
        if ( typeof item === "string" ) {
          return {
            label: item,
            value: item
          };
        }
        return $.extend( {}, item, {
          label: item.label || item.value,
          value: item.value || item.label
        });
      });
    },
  
    _suggest: function( items ) {
      var ul = this.menu.element.empty();
      this._renderMenu( ul, items );
      this.isNewMenu = true;
      this.menu.refresh();
  
      // size and position menu
      ul.show();
      this._resizeMenu();
      ul.position( $.extend({
        of: this.element
      }, this.options.position ) );
  
      if ( this.options.autoFocus ) {
        this.menu.next();
      }
    },
  
    _resizeMenu: function() {
      var ul = this.menu.element;
      ul.outerWidth( Math.max(
        // Firefox wraps long text (possibly a rounding bug)
        // so we add 1px to avoid the wrapping (#7513)
        ul.width( "" ).outerWidth() + 1,
        this.element.outerWidth()
      ) );
    },
  
    _renderMenu: function( ul, items ) {
      var that = this;
      $.each( items, function( index, item ) {
        that._renderItemData( ul, item );
      });
    },
  
    _renderItemData: function( ul, item ) {
      return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
    },
  
    _renderItem: function( ul, item ) {
      return $( "<li>" ).text( item.label ).appendTo( ul );
    },
  
    _move: function( direction, event ) {
      if ( !this.menu.element.is( ":visible" ) ) {
        this.search( null, event );
        return;
      }
      if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
          this.menu.isLastItem() && /^next/.test( direction ) ) {
  
        if ( !this.isMultiLine ) {
          this._value( this.term );
        }
  
        this.menu.blur();
        return;
      }
      this.menu[ direction ]( event );
    },
  
    widget: function() {
      return this.menu.element;
    },
  
    _value: function() {
      return this.valueMethod.apply( this.element, arguments );
    },
  
    _keyEvent: function( keyEvent, event ) {
      if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
        this._move( keyEvent, event );
  
        // prevents moving cursor to beginning/end of the text field in some browsers
        event.preventDefault();
      }
    }
  });
  
  $.extend( $.ui.autocomplete, {
    escapeRegex: function( value ) {
      return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
    },
    filter: function( array, term ) {
      var matcher = new RegExp( $.ui.autocomplete.escapeRegex( term ), "i" );
      return $.grep( array, function( value ) {
        return matcher.test( value.label || value.value || value );
      });
    }
  });
  
  // live region extension, adding a `messages` option
  // NOTE: This is an experimental API. We are still investigating
  // a full solution for string manipulation and internationalization.
  $.widget( "ui.autocomplete", $.ui.autocomplete, {
    options: {
      messages: {
        noResults: "No search results.",
        results: function( amount ) {
          return amount + ( amount > 1 ? " results are" : " result is" ) +
            " available, use up and down arrow keys to navigate.";
        }
      }
    },
  
    __response: function( content ) {
      var message;
      this._superApply( arguments );
      if ( this.options.disabled || this.cancelSearch ) {
        return;
      }
      if ( content && content.length ) {
        message = this.options.messages.results( content.length );
      } else {
        message = this.options.messages.noResults;
      }
      this.liveRegion.children().hide();
      $( "<div>" ).text( message ).appendTo( this.liveRegion );
    }
  });
  
  var autocomplete = $.ui.autocomplete;
  
  
  /*!
   * jQuery UI Button 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/button/
   */
  
  
  var lastActive,
    baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
    typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
    formResetHandler = function() {
      var form = $( this );
      setTimeout(function() {
        form.find( ":ui-button" ).button( "refresh" );
      }, 1 );
    },
    radioGroup = function( radio ) {
      var name = radio.name,
        form = radio.form,
        radios = $( [] );
      if ( name ) {
        name = name.replace( /'/g, "\\'" );
        if ( form ) {
          radios = $( form ).find( "[name='" + name + "'][type=radio]" );
        } else {
          radios = $( "[name='" + name + "'][type=radio]", radio.ownerDocument )
            .filter(function() {
              return !this.form;
            });
        }
      }
      return radios;
    };
  
  $.widget( "ui.button", {
    version: "1.11.4",
    defaultElement: "<button>",
    options: {
      disabled: null,
      text: true,
      label: null,
      icons: {
        primary: null,
        secondary: null
      }
    },
    _create: function() {
      this.element.closest( "form" )
        .unbind( "reset" + this.eventNamespace )
        .bind( "reset" + this.eventNamespace, formResetHandler );
  
      if ( typeof this.options.disabled !== "boolean" ) {
        this.options.disabled = !!this.element.prop( "disabled" );
      } else {
        this.element.prop( "disabled", this.options.disabled );
      }
  
      this._determineButtonType();
      this.hasTitle = !!this.buttonElement.attr( "title" );
  
      var that = this,
        options = this.options,
        toggleButton = this.type === "checkbox" || this.type === "radio",
        activeClass = !toggleButton ? "ui-state-active" : "";
  
      if ( options.label === null ) {
        options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
      }
  
      this._hoverable( this.buttonElement );
  
      this.buttonElement
        .addClass( baseClasses )
        .attr( "role", "button" )
        .bind( "mouseenter" + this.eventNamespace, function() {
          if ( options.disabled ) {
            return;
          }
          if ( this === lastActive ) {
            $( this ).addClass( "ui-state-active" );
          }
        })
        .bind( "mouseleave" + this.eventNamespace, function() {
          if ( options.disabled ) {
            return;
          }
          $( this ).removeClass( activeClass );
        })
        .bind( "click" + this.eventNamespace, function( event ) {
          if ( options.disabled ) {
            event.preventDefault();
            event.stopImmediatePropagation();
          }
        });
  
      // Can't use _focusable() because the element that receives focus
      // and the element that gets the ui-state-focus class are different
      this._on({
        focus: function() {
          this.buttonElement.addClass( "ui-state-focus" );
        },
        blur: function() {
          this.buttonElement.removeClass( "ui-state-focus" );
        }
      });
  
      if ( toggleButton ) {
        this.element.bind( "change" + this.eventNamespace, function() {
          that.refresh();
        });
      }
  
      if ( this.type === "checkbox" ) {
        this.buttonElement.bind( "click" + this.eventNamespace, function() {
          if ( options.disabled ) {
            return false;
          }
        });
      } else if ( this.type === "radio" ) {
        this.buttonElement.bind( "click" + this.eventNamespace, function() {
          if ( options.disabled ) {
            return false;
          }
          $( this ).addClass( "ui-state-active" );
          that.buttonElement.attr( "aria-pressed", "true" );
  
          var radio = that.element[ 0 ];
          radioGroup( radio )
            .not( radio )
            .map(function() {
              return $( this ).button( "widget" )[ 0 ];
            })
            .removeClass( "ui-state-active" )
            .attr( "aria-pressed", "false" );
        });
      } else {
        this.buttonElement
          .bind( "mousedown" + this.eventNamespace, function() {
            if ( options.disabled ) {
              return false;
            }
            $( this ).addClass( "ui-state-active" );
            lastActive = this;
            that.document.one( "mouseup", function() {
              lastActive = null;
            });
          })
          .bind( "mouseup" + this.eventNamespace, function() {
            if ( options.disabled ) {
              return false;
            }
            $( this ).removeClass( "ui-state-active" );
          })
          .bind( "keydown" + this.eventNamespace, function(event) {
            if ( options.disabled ) {
              return false;
            }
            if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {
              $( this ).addClass( "ui-state-active" );
            }
          })
          // see #8559, we bind to blur here in case the button element loses
          // focus between keydown and keyup, it would be left in an "active" state
          .bind( "keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
            $( this ).removeClass( "ui-state-active" );
          });
  
        if ( this.buttonElement.is("a") ) {
          this.buttonElement.keyup(function(event) {
            if ( event.keyCode === $.ui.keyCode.SPACE ) {
              // TODO pass through original event correctly (just as 2nd argument doesn't work)
              $( this ).click();
            }
          });
        }
      }
  
      this._setOption( "disabled", options.disabled );
      this._resetButton();
    },
  
    _determineButtonType: function() {
      var ancestor, labelSelector, checked;
  
      if ( this.element.is("[type=checkbox]") ) {
        this.type = "checkbox";
      } else if ( this.element.is("[type=radio]") ) {
        this.type = "radio";
      } else if ( this.element.is("input") ) {
        this.type = "input";
      } else {
        this.type = "button";
      }
  
      if ( this.type === "checkbox" || this.type === "radio" ) {
        // we don't search against the document in case the element
        // is disconnected from the DOM
        ancestor = this.element.parents().last();
        labelSelector = "label[for='" + this.element.attr("id") + "']";
        this.buttonElement = ancestor.find( labelSelector );
        if ( !this.buttonElement.length ) {
          ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
          this.buttonElement = ancestor.filter( labelSelector );
          if ( !this.buttonElement.length ) {
            this.buttonElement = ancestor.find( labelSelector );
          }
        }
        this.element.addClass( "ui-helper-hidden-accessible" );
  
        checked = this.element.is( ":checked" );
        if ( checked ) {
          this.buttonElement.addClass( "ui-state-active" );
        }
        this.buttonElement.prop( "aria-pressed", checked );
      } else {
        this.buttonElement = this.element;
      }
    },
  
    widget: function() {
      return this.buttonElement;
    },
  
    _destroy: function() {
      this.element
        .removeClass( "ui-helper-hidden-accessible" );
      this.buttonElement
        .removeClass( baseClasses + " ui-state-active " + typeClasses )
        .removeAttr( "role" )
        .removeAttr( "aria-pressed" )
        .html( this.buttonElement.find(".ui-button-text").html() );
  
      if ( !this.hasTitle ) {
        this.buttonElement.removeAttr( "title" );
      }
    },
  
    _setOption: function( key, value ) {
      this._super( key, value );
      if ( key === "disabled" ) {
        this.widget().toggleClass( "ui-state-disabled", !!value );
        this.element.prop( "disabled", !!value );
        if ( value ) {
          if ( this.type === "checkbox" || this.type === "radio" ) {
            this.buttonElement.removeClass( "ui-state-focus" );
          } else {
            this.buttonElement.removeClass( "ui-state-focus ui-state-active" );
          }
        }
        return;
      }
      this._resetButton();
    },
  
    refresh: function() {
      //See #8237 & #8828
      var isDisabled = this.element.is( "input, button" ) ? this.element.is( ":disabled" ) : this.element.hasClass( "ui-button-disabled" );
  
      if ( isDisabled !== this.options.disabled ) {
        this._setOption( "disabled", isDisabled );
      }
      if ( this.type === "radio" ) {
        radioGroup( this.element[0] ).each(function() {
          if ( $( this ).is( ":checked" ) ) {
            $( this ).button( "widget" )
              .addClass( "ui-state-active" )
              .attr( "aria-pressed", "true" );
          } else {
            $( this ).button( "widget" )
              .removeClass( "ui-state-active" )
              .attr( "aria-pressed", "false" );
          }
        });
      } else if ( this.type === "checkbox" ) {
        if ( this.element.is( ":checked" ) ) {
          this.buttonElement
            .addClass( "ui-state-active" )
            .attr( "aria-pressed", "true" );
        } else {
          this.buttonElement
            .removeClass( "ui-state-active" )
            .attr( "aria-pressed", "false" );
        }
      }
    },
  
    _resetButton: function() {
      if ( this.type === "input" ) {
        if ( this.options.label ) {
          this.element.val( this.options.label );
        }
        return;
      }
      var buttonElement = this.buttonElement.removeClass( typeClasses ),
        buttonText = $( "<span></span>", this.document[0] )
          .addClass( "ui-button-text" )
          .html( this.options.label )
          .appendTo( buttonElement.empty() )
          .text(),
        icons = this.options.icons,
        multipleIcons = icons.primary && icons.secondary,
        buttonClasses = [];
  
      if ( icons.primary || icons.secondary ) {
        if ( this.options.text ) {
          buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
        }
  
        if ( icons.primary ) {
          buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>" );
        }
  
        if ( icons.secondary ) {
          buttonElement.append( "<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>" );
        }
  
        if ( !this.options.text ) {
          buttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );
  
          if ( !this.hasTitle ) {
            buttonElement.attr( "title", $.trim( buttonText ) );
          }
        }
      } else {
        buttonClasses.push( "ui-button-text-only" );
      }
      buttonElement.addClass( buttonClasses.join( " " ) );
    }
  });
  
  $.widget( "ui.buttonset", {
    version: "1.11.4",
    options: {
      items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
    },
  
    _create: function() {
      this.element.addClass( "ui-buttonset" );
    },
  
    _init: function() {
      this.refresh();
    },
  
    _setOption: function( key, value ) {
      if ( key === "disabled" ) {
        this.buttons.button( "option", key, value );
      }
  
      this._super( key, value );
    },
  
    refresh: function() {
      var rtl = this.element.css( "direction" ) === "rtl",
        allButtons = this.element.find( this.options.items ),
        existingButtons = allButtons.filter( ":ui-button" );
  
      // Initialize new buttons
      allButtons.not( ":ui-button" ).button();
  
      // Refresh existing buttons
      existingButtons.button( "refresh" );
  
      this.buttons = allButtons
        .map(function() {
          return $( this ).button( "widget" )[ 0 ];
        })
          .removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
          .filter( ":first" )
            .addClass( rtl ? "ui-corner-right" : "ui-corner-left" )
          .end()
          .filter( ":last" )
            .addClass( rtl ? "ui-corner-left" : "ui-corner-right" )
          .end()
        .end();
    },
  
    _destroy: function() {
      this.element.removeClass( "ui-buttonset" );
      this.buttons
        .map(function() {
          return $( this ).button( "widget" )[ 0 ];
        })
          .removeClass( "ui-corner-left ui-corner-right" )
        .end()
        .button( "destroy" );
    }
  });
  
  var button = $.ui.button;
  
  
  /*!
   * jQuery UI Datepicker 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/datepicker/
   */
  
  
  $.extend($.ui, { datepicker: { version: "1.11.4" } });
  
  var datepicker_instActive;
  
  function datepicker_getZindex( elem ) {
    var position, value;
    while ( elem.length && elem[ 0 ] !== document ) {
      // Ignore z-index if position is set to a value where z-index is ignored by the browser
      // This makes behavior of this function consistent across browsers
      // WebKit always returns auto if the element is positioned
      position = elem.css( "position" );
      if ( position === "absolute" || position === "relative" || position === "fixed" ) {
        // IE returns 0 when zIndex is not specified
        // other browsers return a string
        // we ignore the case of nested elements with an explicit value of 0
        // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
        value = parseInt( elem.css( "zIndex" ), 10 );
        if ( !isNaN( value ) && value !== 0 ) {
          return value;
        }
      }
      elem = elem.parent();
    }
  
    return 0;
  }
  /* Date picker manager.
     Use the singleton instance of this class, $.datepicker, to interact with the date picker.
     Settings for (groups of) date pickers are maintained in an instance object,
     allowing multiple different settings on the same page. */
  
  function Datepicker() {
    this._curInst = null; // The current instance in use
    this._keyEvent = false; // If the last event was a key event
    this._disabledInputs = []; // List of date picker inputs that have been disabled
    this._datepickerShowing = false; // True if the popup picker is showing , false if not
    this._inDialog = false; // True if showing within a "dialog", false if not
    this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
    this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
    this._appendClass = "ui-datepicker-append"; // The name of the append marker class
    this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
    this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
    this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
    this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
    this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
    this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
    this.regional = []; // Available regional settings, indexed by language code
    this.regional[""] = { // Default regional settings
      closeText: "Done", // Display text for close link
      prevText: "Prev", // Display text for previous month link
      nextText: "Next", // Display text for next month link
      currentText: "Today", // Display text for current month link
      monthNames: ["January","February","March","April","May","June",
        "July","August","September","October","November","December"], // Names of months for drop-down and formatting
      monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
      dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
      dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
      dayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings for days starting at Sunday
      weekHeader: "Wk", // Column header for week of the year
      dateFormat: "mm/dd/yy", // See format options on parseDate
      firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
      isRTL: false, // True if right-to-left language, false if left-to-right
      showMonthAfterYear: false, // True if the year select precedes month, false for month then year
      yearSuffix: "" // Additional text to append to the year in the month headers
    };
    this._defaults = { // Global defaults for all the date picker instances
      showOn: "focus", // "focus" for popup on focus,
        // "button" for trigger button, or "both" for either
      showAnim: "fadeIn", // Name of jQuery animation for popup
      showOptions: {}, // Options for enhanced animations
      defaultDate: null, // Used when field is blank: actual date,
        // +/-number for offset from today, null for today
      appendText: "", // Display text following the input box, e.g. showing the format
      buttonText: "...", // Text for trigger button
      buttonImage: "", // URL for trigger button image
      buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
      hideIfNoPrevNext: false, // True to hide next/previous month links
        // if not applicable, false to just disable them
      navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
      gotoCurrent: false, // True if today link goes back to current selection instead
      changeMonth: false, // True if month can be selected directly, false if only prev/next
      changeYear: false, // True if year can be selected directly, false if only prev/next
      yearRange: "c-10:c+10", // Range of years to display in drop-down,
        // either relative to today's year (-nn:+nn), relative to currently displayed year
        // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
      showOtherMonths: false, // True to show dates in other months, false to leave blank
      selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
      showWeek: false, // True to show week of the year, false to not show it
      calculateWeek: this.iso8601Week, // How to calculate the week of the year,
        // takes a Date and returns the number of the week for it
      shortYearCutoff: "+10", // Short year values < this are in the current century,
        // > this are in the previous century,
        // string value starting with "+" for current year + value
      minDate: null, // The earliest selectable date, or null for no limit
      maxDate: null, // The latest selectable date, or null for no limit
      duration: "fast", // Duration of display/closure
      beforeShowDay: null, // Function that takes a date and returns an array with
        // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
        // [2] = cell title (optional), e.g. $.datepicker.noWeekends
      beforeShow: null, // Function that takes an input field and
        // returns a set of custom settings for the date picker
      onSelect: null, // Define a callback function when a date is selected
      onChangeMonthYear: null, // Define a callback function when the month or year is changed
      onClose: null, // Define a callback function when the datepicker is closed
      numberOfMonths: 1, // Number of months to show at a time
      showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
      stepMonths: 1, // Number of months to step back/forward
      stepBigMonths: 12, // Number of months to step back/forward for the big links
      altField: "", // Selector for an alternate field to store selected dates into
      altFormat: "", // The date format to use for the alternate field
      constrainInput: true, // The input is constrained by the current date format
      showButtonPanel: false, // True to show button panel, false to not show it
      autoSize: false, // True to size the input for the date format, false to leave as is
      disabled: false // The initial disabled state
    };
    $.extend(this._defaults, this.regional[""]);
    this.regional.en = $.extend( true, {}, this.regional[ "" ]);
    this.regional[ "en-US" ] = $.extend( true, {}, this.regional.en );
    this.dpDiv = datepicker_bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
  }
  
  $.extend(Datepicker.prototype, {
    /* Class name added to elements to indicate already configured with a date picker. */
    markerClassName: "hasDatepicker",
  
    //Keep track of the maximum number of rows displayed (see #7043)
    maxRows: 4,
  
    // TODO rename to "widget" when switching to widget factory
    _widgetDatepicker: function() {
      return this.dpDiv;
    },
  
    /* Override the default settings for all instances of the date picker.
     * @param  settings  object - the new settings to use as defaults (anonymous object)
     * @return the manager object
     */
    setDefaults: function(settings) {
      datepicker_extendRemove(this._defaults, settings || {});
      return this;
    },
  
    /* Attach the date picker to a jQuery selection.
     * @param  target	element - the target input field or division or span
     * @param  settings  object - the new settings to use for this date picker instance (anonymous)
     */
    _attachDatepicker: function(target, settings) {
      var nodeName, inline, inst;
      nodeName = target.nodeName.toLowerCase();
      inline = (nodeName === "div" || nodeName === "span");
      if (!target.id) {
        this.uuid += 1;
        target.id = "dp" + this.uuid;
      }
      inst = this._newInst($(target), inline);
      inst.settings = $.extend({}, settings || {});
      if (nodeName === "input") {
        this._connectDatepicker(target, inst);
      } else if (inline) {
        this._inlineDatepicker(target, inst);
      }
    },
  
    /* Create a new instance object. */
    _newInst: function(target, inline) {
      var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
      return {id: id, input: target, // associated target
        selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
        drawMonth: 0, drawYear: 0, // month being drawn
        inline: inline, // is datepicker inline or not
        dpDiv: (!inline ? this.dpDiv : // presentation div
        datepicker_bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))};
    },
  
    /* Attach the date picker to an input field. */
    _connectDatepicker: function(target, inst) {
      var input = $(target);
      inst.append = $([]);
      inst.trigger = $([]);
      if (input.hasClass(this.markerClassName)) {
        return;
      }
      this._attachments(input, inst);
      input.addClass(this.markerClassName).keydown(this._doKeyDown).
        keypress(this._doKeyPress).keyup(this._doKeyUp);
      this._autoSize(inst);
      $.data(target, "datepicker", inst);
      //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
      if( inst.settings.disabled ) {
        this._disableDatepicker( target );
      }
    },
  
    /* Make attachments based on settings. */
    _attachments: function(input, inst) {
      var showOn, buttonText, buttonImage,
        appendText = this._get(inst, "appendText"),
        isRTL = this._get(inst, "isRTL");
  
      if (inst.append) {
        inst.append.remove();
      }
      if (appendText) {
        inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
        input[isRTL ? "before" : "after"](inst.append);
      }
  
      input.unbind("focus", this._showDatepicker);
  
      if (inst.trigger) {
        inst.trigger.remove();
      }
  
      showOn = this._get(inst, "showOn");
      if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
        input.focus(this._showDatepicker);
      }
      if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
        buttonText = this._get(inst, "buttonText");
        buttonImage = this._get(inst, "buttonImage");
        inst.trigger = $(this._get(inst, "buttonImageOnly") ?
          $("<img/>").addClass(this._triggerClass).
            attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
          $("<button type='button'></button>").addClass(this._triggerClass).
            html(!buttonImage ? buttonText : $("<img/>").attr(
            { src:buttonImage, alt:buttonText, title:buttonText })));
        input[isRTL ? "before" : "after"](inst.trigger);
        inst.trigger.click(function() {
          if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
            $.datepicker._hideDatepicker();
          } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
            $.datepicker._hideDatepicker();
            $.datepicker._showDatepicker(input[0]);
          } else {
            $.datepicker._showDatepicker(input[0]);
          }
          return false;
        });
      }
    },
  
    /* Apply the maximum length for the date format. */
    _autoSize: function(inst) {
      if (this._get(inst, "autoSize") && !inst.inline) {
        var findMax, max, maxI, i,
          date = new Date(2009, 12 - 1, 20), // Ensure double digits
          dateFormat = this._get(inst, "dateFormat");
  
        if (dateFormat.match(/[DM]/)) {
          findMax = function(names) {
            max = 0;
            maxI = 0;
            for (i = 0; i < names.length; i++) {
              if (names[i].length > max) {
                max = names[i].length;
                maxI = i;
              }
            }
            return maxI;
          };
          date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
            "monthNames" : "monthNamesShort"))));
          date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
            "dayNames" : "dayNamesShort"))) + 20 - date.getDay());
        }
        inst.input.attr("size", this._formatDate(inst, date).length);
      }
    },
  
    /* Attach an inline date picker to a div. */
    _inlineDatepicker: function(target, inst) {
      var divSpan = $(target);
      if (divSpan.hasClass(this.markerClassName)) {
        return;
      }
      divSpan.addClass(this.markerClassName).append(inst.dpDiv);
      $.data(target, "datepicker", inst);
      this._setDate(inst, this._getDefaultDate(inst), true);
      this._updateDatepicker(inst);
      this._updateAlternate(inst);
      //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
      if( inst.settings.disabled ) {
        this._disableDatepicker( target );
      }
      // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
      // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
      inst.dpDiv.css( "display", "block" );
    },
  
    /* Pop-up the date picker in a "dialog" box.
     * @param  input element - ignored
     * @param  date	string or Date - the initial date to display
     * @param  onSelect  function - the function to call when a date is selected
     * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
     * @param  pos int[2] - coordinates for the dialog's position within the screen or
     *					event - with x/y coordinates or
     *					leave empty for default (screen centre)
     * @return the manager object
     */
    _dialogDatepicker: function(input, date, onSelect, settings, pos) {
      var id, browserWidth, browserHeight, scrollX, scrollY,
        inst = this._dialogInst; // internal instance
  
      if (!inst) {
        this.uuid += 1;
        id = "dp" + this.uuid;
        this._dialogInput = $("<input type='text' id='" + id +
          "' style='position: absolute; top: -100px; width: 0px;'/>");
        this._dialogInput.keydown(this._doKeyDown);
        $("body").append(this._dialogInput);
        inst = this._dialogInst = this._newInst(this._dialogInput, false);
        inst.settings = {};
        $.data(this._dialogInput[0], "datepicker", inst);
      }
      datepicker_extendRemove(inst.settings, settings || {});
      date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
      this._dialogInput.val(date);
  
      this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
      if (!this._pos) {
        browserWidth = document.documentElement.clientWidth;
        browserHeight = document.documentElement.clientHeight;
        scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
        scrollY = document.documentElement.scrollTop || document.body.scrollTop;
        this._pos = // should use actual width/height below
          [(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
      }
  
      // move input on screen for focus, but hidden behind dialog
      this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
      inst.settings.onSelect = onSelect;
      this._inDialog = true;
      this.dpDiv.addClass(this._dialogClass);
      this._showDatepicker(this._dialogInput[0]);
      if ($.blockUI) {
        $.blockUI(this.dpDiv);
      }
      $.data(this._dialogInput[0], "datepicker", inst);
      return this;
    },
  
    /* Detach a datepicker from its control.
     * @param  target	element - the target input field or division or span
     */
    _destroyDatepicker: function(target) {
      var nodeName,
        $target = $(target),
        inst = $.data(target, "datepicker");
  
      if (!$target.hasClass(this.markerClassName)) {
        return;
      }
  
      nodeName = target.nodeName.toLowerCase();
      $.removeData(target, "datepicker");
      if (nodeName === "input") {
        inst.append.remove();
        inst.trigger.remove();
        $target.removeClass(this.markerClassName).
          unbind("focus", this._showDatepicker).
          unbind("keydown", this._doKeyDown).
          unbind("keypress", this._doKeyPress).
          unbind("keyup", this._doKeyUp);
      } else if (nodeName === "div" || nodeName === "span") {
        $target.removeClass(this.markerClassName).empty();
      }
  
      if ( datepicker_instActive === inst ) {
        datepicker_instActive = null;
      }
    },
  
    /* Enable the date picker to a jQuery selection.
     * @param  target	element - the target input field or division or span
     */
    _enableDatepicker: function(target) {
      var nodeName, inline,
        $target = $(target),
        inst = $.data(target, "datepicker");
  
      if (!$target.hasClass(this.markerClassName)) {
        return;
      }
  
      nodeName = target.nodeName.toLowerCase();
      if (nodeName === "input") {
        target.disabled = false;
        inst.trigger.filter("button").
          each(function() { this.disabled = false; }).end().
          filter("img").css({opacity: "1.0", cursor: ""});
      } else if (nodeName === "div" || nodeName === "span") {
        inline = $target.children("." + this._inlineClass);
        inline.children().removeClass("ui-state-disabled");
        inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
          prop("disabled", false);
      }
      this._disabledInputs = $.map(this._disabledInputs,
        function(value) { return (value === target ? null : value); }); // delete entry
    },
  
    /* Disable the date picker to a jQuery selection.
     * @param  target	element - the target input field or division or span
     */
    _disableDatepicker: function(target) {
      var nodeName, inline,
        $target = $(target),
        inst = $.data(target, "datepicker");
  
      if (!$target.hasClass(this.markerClassName)) {
        return;
      }
  
      nodeName = target.nodeName.toLowerCase();
      if (nodeName === "input") {
        target.disabled = true;
        inst.trigger.filter("button").
          each(function() { this.disabled = true; }).end().
          filter("img").css({opacity: "0.5", cursor: "default"});
      } else if (nodeName === "div" || nodeName === "span") {
        inline = $target.children("." + this._inlineClass);
        inline.children().addClass("ui-state-disabled");
        inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
          prop("disabled", true);
      }
      this._disabledInputs = $.map(this._disabledInputs,
        function(value) { return (value === target ? null : value); }); // delete entry
      this._disabledInputs[this._disabledInputs.length] = target;
    },
  
    /* Is the first field in a jQuery collection disabled as a datepicker?
     * @param  target	element - the target input field or division or span
     * @return boolean - true if disabled, false if enabled
     */
    _isDisabledDatepicker: function(target) {
      if (!target) {
        return false;
      }
      for (var i = 0; i < this._disabledInputs.length; i++) {
        if (this._disabledInputs[i] === target) {
          return true;
        }
      }
      return false;
    },
  
    /* Retrieve the instance data for the target control.
     * @param  target  element - the target input field or division or span
     * @return  object - the associated instance data
     * @throws  error if a jQuery problem getting data
     */
    _getInst: function(target) {
      try {
        return $.data(target, "datepicker");
      }
      catch (err) {
        throw "Missing instance data for this datepicker";
      }
    },
  
    /* Update or retrieve the settings for a date picker attached to an input field or division.
     * @param  target  element - the target input field or division or span
     * @param  name	object - the new settings to update or
     *				string - the name of the setting to change or retrieve,
     *				when retrieving also "all" for all instance settings or
     *				"defaults" for all global defaults
     * @param  value   any - the new value for the setting
     *				(omit if above is an object or to retrieve a value)
     */
    _optionDatepicker: function(target, name, value) {
      var settings, date, minDate, maxDate,
        inst = this._getInst(target);
  
      if (arguments.length === 2 && typeof name === "string") {
        return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
          (inst ? (name === "all" ? $.extend({}, inst.settings) :
          this._get(inst, name)) : null));
      }
  
      settings = name || {};
      if (typeof name === "string") {
        settings = {};
        settings[name] = value;
      }
  
      if (inst) {
        if (this._curInst === inst) {
          this._hideDatepicker();
        }
  
        date = this._getDateDatepicker(target, true);
        minDate = this._getMinMaxDate(inst, "min");
        maxDate = this._getMinMaxDate(inst, "max");
        datepicker_extendRemove(inst.settings, settings);
        // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
        if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
          inst.settings.minDate = this._formatDate(inst, minDate);
        }
        if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
          inst.settings.maxDate = this._formatDate(inst, maxDate);
        }
        if ( "disabled" in settings ) {
          if ( settings.disabled ) {
            this._disableDatepicker(target);
          } else {
            this._enableDatepicker(target);
          }
        }
        this._attachments($(target), inst);
        this._autoSize(inst);
        this._setDate(inst, date);
        this._updateAlternate(inst);
        this._updateDatepicker(inst);
      }
    },
  
    // change method deprecated
    _changeDatepicker: function(target, name, value) {
      this._optionDatepicker(target, name, value);
    },
  
    /* Redraw the date picker attached to an input field or division.
     * @param  target  element - the target input field or division or span
     */
    _refreshDatepicker: function(target) {
      var inst = this._getInst(target);
      if (inst) {
        this._updateDatepicker(inst);
      }
    },
  
    /* Set the dates for a jQuery selection.
     * @param  target element - the target input field or division or span
     * @param  date	Date - the new date
     */
    _setDateDatepicker: function(target, date) {
      var inst = this._getInst(target);
      if (inst) {
        this._setDate(inst, date);
        this._updateDatepicker(inst);
        this._updateAlternate(inst);
      }
    },
  
    /* Get the date(s) for the first entry in a jQuery selection.
     * @param  target element - the target input field or division or span
     * @param  noDefault boolean - true if no default date is to be used
     * @return Date - the current date
     */
    _getDateDatepicker: function(target, noDefault) {
      var inst = this._getInst(target);
      if (inst && !inst.inline) {
        this._setDateFromField(inst, noDefault);
      }
      return (inst ? this._getDate(inst) : null);
    },
  
    /* Handle keystrokes. */
    _doKeyDown: function(event) {
      var onSelect, dateStr, sel,
        inst = $.datepicker._getInst(event.target),
        handled = true,
        isRTL = inst.dpDiv.is(".ui-datepicker-rtl");
  
      inst._keyEvent = true;
      if ($.datepicker._datepickerShowing) {
        switch (event.keyCode) {
          case 9: $.datepicker._hideDatepicker();
              handled = false;
              break; // hide on tab out
          case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
                    $.datepicker._currentClass + ")", inst.dpDiv);
              if (sel[0]) {
                $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
              }
  
              onSelect = $.datepicker._get(inst, "onSelect");
              if (onSelect) {
                dateStr = $.datepicker._formatDate(inst);
  
                // trigger custom callback
                onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
              } else {
                $.datepicker._hideDatepicker();
              }
  
              return false; // don't submit the form
          case 27: $.datepicker._hideDatepicker();
              break; // hide on escape
          case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                -$.datepicker._get(inst, "stepBigMonths") :
                -$.datepicker._get(inst, "stepMonths")), "M");
              break; // previous month/year on page up/+ ctrl
          case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                +$.datepicker._get(inst, "stepBigMonths") :
                +$.datepicker._get(inst, "stepMonths")), "M");
              break; // next month/year on page down/+ ctrl
          case 35: if (event.ctrlKey || event.metaKey) {
                $.datepicker._clearDate(event.target);
              }
              handled = event.ctrlKey || event.metaKey;
              break; // clear on ctrl or command +end
          case 36: if (event.ctrlKey || event.metaKey) {
                $.datepicker._gotoToday(event.target);
              }
              handled = event.ctrlKey || event.metaKey;
              break; // current on ctrl or command +home
          case 37: if (event.ctrlKey || event.metaKey) {
                $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
              }
              handled = event.ctrlKey || event.metaKey;
              // -1 day on ctrl or command +left
              if (event.originalEvent.altKey) {
                $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                  -$.datepicker._get(inst, "stepBigMonths") :
                  -$.datepicker._get(inst, "stepMonths")), "M");
              }
              // next month/year on alt +left on Mac
              break;
          case 38: if (event.ctrlKey || event.metaKey) {
                $.datepicker._adjustDate(event.target, -7, "D");
              }
              handled = event.ctrlKey || event.metaKey;
              break; // -1 week on ctrl or command +up
          case 39: if (event.ctrlKey || event.metaKey) {
                $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
              }
              handled = event.ctrlKey || event.metaKey;
              // +1 day on ctrl or command +right
              if (event.originalEvent.altKey) {
                $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                  +$.datepicker._get(inst, "stepBigMonths") :
                  +$.datepicker._get(inst, "stepMonths")), "M");
              }
              // next month/year on alt +right
              break;
          case 40: if (event.ctrlKey || event.metaKey) {
                $.datepicker._adjustDate(event.target, +7, "D");
              }
              handled = event.ctrlKey || event.metaKey;
              break; // +1 week on ctrl or command +down
          default: handled = false;
        }
      } else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
        $.datepicker._showDatepicker(this);
      } else {
        handled = false;
      }
  
      if (handled) {
        event.preventDefault();
        event.stopPropagation();
      }
    },
  
    /* Filter entered characters - based on date format. */
    _doKeyPress: function(event) {
      var chars, chr,
        inst = $.datepicker._getInst(event.target);
  
      if ($.datepicker._get(inst, "constrainInput")) {
        chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
        chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
        return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
      }
    },
  
    /* Synchronise manual entry and field/alternate field. */
    _doKeyUp: function(event) {
      var date,
        inst = $.datepicker._getInst(event.target);
  
      if (inst.input.val() !== inst.lastVal) {
        try {
          date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
            (inst.input ? inst.input.val() : null),
            $.datepicker._getFormatConfig(inst));
  
          if (date) { // only if valid
            $.datepicker._setDateFromField(inst);
            $.datepicker._updateAlternate(inst);
            $.datepicker._updateDatepicker(inst);
          }
        }
        catch (err) {
        }
      }
      return true;
    },
  
    /* Pop-up the date picker for a given input field.
     * If false returned from beforeShow event handler do not show.
     * @param  input  element - the input field attached to the date picker or
     *					event - if triggered by focus
     */
    _showDatepicker: function(input) {
      input = input.target || input;
      if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
        input = $("input", input.parentNode)[0];
      }
  
      if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
        return;
      }
  
      var inst, beforeShow, beforeShowSettings, isFixed,
        offset, showAnim, duration;
  
      inst = $.datepicker._getInst(input);
      if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
        $.datepicker._curInst.dpDiv.stop(true, true);
        if ( inst && $.datepicker._datepickerShowing ) {
          $.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
        }
      }
  
      beforeShow = $.datepicker._get(inst, "beforeShow");
      beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
      if(beforeShowSettings === false){
        return;
      }
      datepicker_extendRemove(inst.settings, beforeShowSettings);
  
      inst.lastVal = null;
      $.datepicker._lastInput = input;
      $.datepicker._setDateFromField(inst);
  
      if ($.datepicker._inDialog) { // hide cursor
        input.value = "";
      }
      if (!$.datepicker._pos) { // position below input
        $.datepicker._pos = $.datepicker._findPos(input);
        $.datepicker._pos[1] += input.offsetHeight; // add the height
      }
  
      isFixed = false;
      $(input).parents().each(function() {
        isFixed |= $(this).css("position") === "fixed";
        return !isFixed;
      });
  
      offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
      $.datepicker._pos = null;
      //to avoid flashes on Firefox
      inst.dpDiv.empty();
      // determine sizing offscreen
      inst.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});
      $.datepicker._updateDatepicker(inst);
      // fix width for dynamic number of date pickers
      // and adjust position before showing
      offset = $.datepicker._checkOffset(inst, offset, isFixed);
      inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
        "static" : (isFixed ? "fixed" : "absolute")), display: "none",
        left: offset.left + "px", top: offset.top + "px"});
  
      if (!inst.inline) {
        showAnim = $.datepicker._get(inst, "showAnim");
        duration = $.datepicker._get(inst, "duration");
        inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );
        $.datepicker._datepickerShowing = true;
  
        if ( $.effects && $.effects.effect[ showAnim ] ) {
          inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
        } else {
          inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
        }
  
        if ( $.datepicker._shouldFocusInput( inst ) ) {
          inst.input.focus();
        }
  
        $.datepicker._curInst = inst;
      }
    },
  
    /* Generate the date picker content. */
    _updateDatepicker: function(inst) {
      this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
      datepicker_instActive = inst; // for delegate hover events
      inst.dpDiv.empty().append(this._generateHTML(inst));
      this._attachHandlers(inst);
  
      var origyearshtml,
        numMonths = this._getNumberOfMonths(inst),
        cols = numMonths[1],
        width = 17,
        activeCell = inst.dpDiv.find( "." + this._dayOverClass + " a" );
  
      if ( activeCell.length > 0 ) {
        datepicker_handleMouseover.apply( activeCell.get( 0 ) );
      }
  
      inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
      if (cols > 1) {
        inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
      }
      inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
        "Class"]("ui-datepicker-multi");
      inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
        "Class"]("ui-datepicker-rtl");
  
      if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
        inst.input.focus();
      }
  
      // deffered render of the years select (to avoid flashes on Firefox)
      if( inst.yearshtml ){
        origyearshtml = inst.yearshtml;
        setTimeout(function(){
          //assure that inst.yearshtml didn't change.
          if( origyearshtml === inst.yearshtml && inst.yearshtml ){
            inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
          }
          origyearshtml = inst.yearshtml = null;
        }, 0);
      }
    },
  
    // #6694 - don't focus the input if it's already focused
    // this breaks the change event in IE
    // Support: IE and jQuery <1.9
    _shouldFocusInput: function( inst ) {
      return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
    },
  
    /* Check positioning to remain on screen. */
    _checkOffset: function(inst, offset, isFixed) {
      var dpWidth = inst.dpDiv.outerWidth(),
        dpHeight = inst.dpDiv.outerHeight(),
        inputWidth = inst.input ? inst.input.outerWidth() : 0,
        inputHeight = inst.input ? inst.input.outerHeight() : 0,
        viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
        viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
  
      offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
      offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
      offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;
  
      // now check if datepicker is showing outside window viewport - move to a better place if so.
      offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
        Math.abs(offset.left + dpWidth - viewWidth) : 0);
      offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
        Math.abs(dpHeight + inputHeight) : 0);
  
      return offset;
    },
  
    /* Find an object's position on the screen. */
    _findPos: function(obj) {
      var position,
        inst = this._getInst(obj),
        isRTL = this._get(inst, "isRTL");
  
      while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
        obj = obj[isRTL ? "previousSibling" : "nextSibling"];
      }
  
      position = $(obj).offset();
      return [position.left, position.top];
    },
  
    /* Hide the date picker from view.
     * @param  input  element - the input field attached to the date picker
     */
    _hideDatepicker: function(input) {
      var showAnim, duration, postProcess, onClose,
        inst = this._curInst;
  
      if (!inst || (input && inst !== $.data(input, "datepicker"))) {
        return;
      }
  
      if (this._datepickerShowing) {
        showAnim = this._get(inst, "showAnim");
        duration = this._get(inst, "duration");
        postProcess = function() {
          $.datepicker._tidyDialog(inst);
        };
  
        // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
        if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
          inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
        } else {
          inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
            (showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
        }
  
        if (!showAnim) {
          postProcess();
        }
        this._datepickerShowing = false;
  
        onClose = this._get(inst, "onClose");
        if (onClose) {
          onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
        }
  
        this._lastInput = null;
        if (this._inDialog) {
          this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
          if ($.blockUI) {
            $.unblockUI();
            $("body").append(this.dpDiv);
          }
        }
        this._inDialog = false;
      }
    },
  
    /* Tidy up after a dialog display. */
    _tidyDialog: function(inst) {
      inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
    },
  
    /* Close date picker if clicked elsewhere. */
    _checkExternalClick: function(event) {
      if (!$.datepicker._curInst) {
        return;
      }
  
      var $target = $(event.target),
        inst = $.datepicker._getInst($target[0]);
  
      if ( ( ( $target[0].id !== $.datepicker._mainDivId &&
          $target.parents("#" + $.datepicker._mainDivId).length === 0 &&
          !$target.hasClass($.datepicker.markerClassName) &&
          !$target.closest("." + $.datepicker._triggerClass).length &&
          $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
        ( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {
          $.datepicker._hideDatepicker();
      }
    },
  
    /* Adjust one of the date sub-fields. */
    _adjustDate: function(id, offset, period) {
      var target = $(id),
        inst = this._getInst(target[0]);
  
      if (this._isDisabledDatepicker(target[0])) {
        return;
      }
      this._adjustInstDate(inst, offset +
        (period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
        period);
      this._updateDatepicker(inst);
    },
  
    /* Action for current link. */
    _gotoToday: function(id) {
      var date,
        target = $(id),
        inst = this._getInst(target[0]);
  
      if (this._get(inst, "gotoCurrent") && inst.currentDay) {
        inst.selectedDay = inst.currentDay;
        inst.drawMonth = inst.selectedMonth = inst.currentMonth;
        inst.drawYear = inst.selectedYear = inst.currentYear;
      } else {
        date = new Date();
        inst.selectedDay = date.getDate();
        inst.drawMonth = inst.selectedMonth = date.getMonth();
        inst.drawYear = inst.selectedYear = date.getFullYear();
      }
      this._notifyChange(inst);
      this._adjustDate(target);
    },
  
    /* Action for selecting a new month/year. */
    _selectMonthYear: function(id, select, period) {
      var target = $(id),
        inst = this._getInst(target[0]);
  
      inst["selected" + (period === "M" ? "Month" : "Year")] =
      inst["draw" + (period === "M" ? "Month" : "Year")] =
        parseInt(select.options[select.selectedIndex].value,10);
  
      this._notifyChange(inst);
      this._adjustDate(target);
    },
  
    /* Action for selecting a day. */
    _selectDay: function(id, month, year, td) {
      var inst,
        target = $(id);
  
      if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
        return;
      }
  
      inst = this._getInst(target[0]);
      inst.selectedDay = inst.currentDay = $("a", td).html();
      inst.selectedMonth = inst.currentMonth = month;
      inst.selectedYear = inst.currentYear = year;
      this._selectDate(id, this._formatDate(inst,
        inst.currentDay, inst.currentMonth, inst.currentYear));
    },
  
    /* Erase the input field and hide the date picker. */
    _clearDate: function(id) {
      var target = $(id);
      this._selectDate(target, "");
    },
  
    /* Update the input field with the selected date. */
    _selectDate: function(id, dateStr) {
      var onSelect,
        target = $(id),
        inst = this._getInst(target[0]);
  
      dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
      if (inst.input) {
        inst.input.val(dateStr);
      }
      this._updateAlternate(inst);
  
      onSelect = this._get(inst, "onSelect");
      if (onSelect) {
        onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
      } else if (inst.input) {
        inst.input.trigger("change"); // fire the change event
      }
  
      if (inst.inline){
        this._updateDatepicker(inst);
      } else {
        this._hideDatepicker();
        this._lastInput = inst.input[0];
        if (typeof(inst.input[0]) !== "object") {
          inst.input.focus(); // restore focus
        }
        this._lastInput = null;
      }
    },
  
    /* Update any alternate field to synchronise with the main field. */
    _updateAlternate: function(inst) {
      var altFormat, date, dateStr,
        altField = this._get(inst, "altField");
  
      if (altField) { // update alternate field too
        altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
        date = this._getDate(inst);
        dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
        $(altField).each(function() { $(this).val(dateStr); });
      }
    },
  
    /* Set as beforeShowDay function to prevent selection of weekends.
     * @param  date  Date - the date to customise
     * @return [boolean, string] - is this date selectable?, what is its CSS class?
     */
    noWeekends: function(date) {
      var day = date.getDay();
      return [(day > 0 && day < 6), ""];
    },
  
    /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
     * @param  date  Date - the date to get the week for
     * @return  number - the number of the week within the year that contains this date
     */
    iso8601Week: function(date) {
      var time,
        checkDate = new Date(date.getTime());
  
      // Find Thursday of this week starting on Monday
      checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
  
      time = checkDate.getTime();
      checkDate.setMonth(0); // Compare with Jan 1
      checkDate.setDate(1);
      return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
    },
  
    /* Parse a string value into a date object.
     * See formatDate below for the possible formats.
     *
     * @param  format string - the expected format of the date
     * @param  value string - the date in the above format
     * @param  settings Object - attributes include:
     *					shortYearCutoff  number - the cutoff year for determining the century (optional)
     *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
     *					dayNames		string[7] - names of the days from Sunday (optional)
     *					monthNamesShort string[12] - abbreviated names of the months (optional)
     *					monthNames		string[12] - names of the months (optional)
     * @return  Date - the extracted date value or null if value is blank
     */
    parseDate: function (format, value, settings) {
      if (format == null || value == null) {
        throw "Invalid arguments";
      }
  
      value = (typeof value === "object" ? value.toString() : value + "");
      if (value === "") {
        return null;
      }
  
      var iFormat, dim, extra,
        iValue = 0,
        shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
        shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
          new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
        dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
        dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
        monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
        monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
        year = -1,
        month = -1,
        day = -1,
        doy = -1,
        literal = false,
        date,
        // Check whether a format character is doubled
        lookAhead = function(match) {
          var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
          if (matches) {
            iFormat++;
          }
          return matches;
        },
        // Extract a number from the string value
        getNumber = function(match) {
          var isDoubled = lookAhead(match),
            size = (match === "@" ? 14 : (match === "!" ? 20 :
            (match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
            minSize = (match === "y" ? size : 1),
            digits = new RegExp("^\\d{" + minSize + "," + size + "}"),
            num = value.substring(iValue).match(digits);
          if (!num) {
            throw "Missing number at position " + iValue;
          }
          iValue += num[0].length;
          return parseInt(num[0], 10);
        },
        // Extract a name from the string value and convert to an index
        getName = function(match, shortNames, longNames) {
          var index = -1,
            names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
              return [ [k, v] ];
            }).sort(function (a, b) {
              return -(a[1].length - b[1].length);
            });
  
          $.each(names, function (i, pair) {
            var name = pair[1];
            if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
              index = pair[0];
              iValue += name.length;
              return false;
            }
          });
          if (index !== -1) {
            return index + 1;
          } else {
            throw "Unknown name at position " + iValue;
          }
        },
        // Confirm that a literal character matches the string value
        checkLiteral = function() {
          if (value.charAt(iValue) !== format.charAt(iFormat)) {
            throw "Unexpected literal at position " + iValue;
          }
          iValue++;
        };
  
      for (iFormat = 0; iFormat < format.length; iFormat++) {
        if (literal) {
          if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
            literal = false;
          } else {
            checkLiteral();
          }
        } else {
          switch (format.charAt(iFormat)) {
            case "d":
              day = getNumber("d");
              break;
            case "D":
              getName("D", dayNamesShort, dayNames);
              break;
            case "o":
              doy = getNumber("o");
              break;
            case "m":
              month = getNumber("m");
              break;
            case "M":
              month = getName("M", monthNamesShort, monthNames);
              break;
            case "y":
              year = getNumber("y");
              break;
            case "@":
              date = new Date(getNumber("@"));
              year = date.getFullYear();
              month = date.getMonth() + 1;
              day = date.getDate();
              break;
            case "!":
              date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
              year = date.getFullYear();
              month = date.getMonth() + 1;
              day = date.getDate();
              break;
            case "'":
              if (lookAhead("'")){
                checkLiteral();
              } else {
                literal = true;
              }
              break;
            default:
              checkLiteral();
          }
        }
      }
  
      if (iValue < value.length){
        extra = value.substr(iValue);
        if (!/^\s+/.test(extra)) {
          throw "Extra/unparsed characters found in date: " + extra;
        }
      }
  
      if (year === -1) {
        year = new Date().getFullYear();
      } else if (year < 100) {
        year += new Date().getFullYear() - new Date().getFullYear() % 100 +
          (year <= shortYearCutoff ? 0 : -100);
      }
  
      if (doy > -1) {
        month = 1;
        day = doy;
        do {
          dim = this._getDaysInMonth(year, month - 1);
          if (day <= dim) {
            break;
          }
          month++;
          day -= dim;
        } while (true);
      }
  
      date = this._daylightSavingAdjust(new Date(year, month - 1, day));
      if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
        throw "Invalid date"; // E.g. 31/02/00
      }
      return date;
    },
  
    /* Standard date formats. */
    ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
    COOKIE: "D, dd M yy",
    ISO_8601: "yy-mm-dd",
    RFC_822: "D, d M y",
    RFC_850: "DD, dd-M-y",
    RFC_1036: "D, d M y",
    RFC_1123: "D, d M yy",
    RFC_2822: "D, d M yy",
    RSS: "D, d M y", // RFC 822
    TICKS: "!",
    TIMESTAMP: "@",
    W3C: "yy-mm-dd", // ISO 8601
  
    _ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
      Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),
  
    /* Format a date object into a string value.
     * The format can be combinations of the following:
     * d  - day of month (no leading zero)
     * dd - day of month (two digit)
     * o  - day of year (no leading zeros)
     * oo - day of year (three digit)
     * D  - day name short
     * DD - day name long
     * m  - month of year (no leading zero)
     * mm - month of year (two digit)
     * M  - month name short
     * MM - month name long
     * y  - year (two digit)
     * yy - year (four digit)
     * @ - Unix timestamp (ms since 01/01/1970)
     * ! - Windows ticks (100ns since 01/01/0001)
     * "..." - literal text
     * '' - single quote
     *
     * @param  format string - the desired format of the date
     * @param  date Date - the date value to format
     * @param  settings Object - attributes include:
     *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
     *					dayNames		string[7] - names of the days from Sunday (optional)
     *					monthNamesShort string[12] - abbreviated names of the months (optional)
     *					monthNames		string[12] - names of the months (optional)
     * @return  string - the date in the above format
     */
    formatDate: function (format, date, settings) {
      if (!date) {
        return "";
      }
  
      var iFormat,
        dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
        dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
        monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
        monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
        // Check whether a format character is doubled
        lookAhead = function(match) {
          var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
          if (matches) {
            iFormat++;
          }
          return matches;
        },
        // Format a number, with leading zero if necessary
        formatNumber = function(match, value, len) {
          var num = "" + value;
          if (lookAhead(match)) {
            while (num.length < len) {
              num = "0" + num;
            }
          }
          return num;
        },
        // Format a name, short or long as requested
        formatName = function(match, value, shortNames, longNames) {
          return (lookAhead(match) ? longNames[value] : shortNames[value]);
        },
        output = "",
        literal = false;
  
      if (date) {
        for (iFormat = 0; iFormat < format.length; iFormat++) {
          if (literal) {
            if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
              literal = false;
            } else {
              output += format.charAt(iFormat);
            }
          } else {
            switch (format.charAt(iFormat)) {
              case "d":
                output += formatNumber("d", date.getDate(), 2);
                break;
              case "D":
                output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                break;
              case "o":
                output += formatNumber("o",
                  Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
                break;
              case "m":
                output += formatNumber("m", date.getMonth() + 1, 2);
                break;
              case "M":
                output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                break;
              case "y":
                output += (lookAhead("y") ? date.getFullYear() :
                  (date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
                break;
              case "@":
                output += date.getTime();
                break;
              case "!":
                output += date.getTime() * 10000 + this._ticksTo1970;
                break;
              case "'":
                if (lookAhead("'")) {
                  output += "'";
                } else {
                  literal = true;
                }
                break;
              default:
                output += format.charAt(iFormat);
            }
          }
        }
      }
      return output;
    },
  
    /* Extract all possible characters from the date format. */
    _possibleChars: function (format) {
      var iFormat,
        chars = "",
        literal = false,
        // Check whether a format character is doubled
        lookAhead = function(match) {
          var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
          if (matches) {
            iFormat++;
          }
          return matches;
        };
  
      for (iFormat = 0; iFormat < format.length; iFormat++) {
        if (literal) {
          if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
            literal = false;
          } else {
            chars += format.charAt(iFormat);
          }
        } else {
          switch (format.charAt(iFormat)) {
            case "d": case "m": case "y": case "@":
              chars += "0123456789";
              break;
            case "D": case "M":
              return null; // Accept anything
            case "'":
              if (lookAhead("'")) {
                chars += "'";
              } else {
                literal = true;
              }
              break;
            default:
              chars += format.charAt(iFormat);
          }
        }
      }
      return chars;
    },
  
    /* Get a setting value, defaulting if necessary. */
    _get: function(inst, name) {
      return inst.settings[name] !== undefined ?
        inst.settings[name] : this._defaults[name];
    },
  
    /* Parse existing date and initialise date picker. */
    _setDateFromField: function(inst, noDefault) {
      if (inst.input.val() === inst.lastVal) {
        return;
      }
  
      var dateFormat = this._get(inst, "dateFormat"),
        dates = inst.lastVal = inst.input ? inst.input.val() : null,
        defaultDate = this._getDefaultDate(inst),
        date = defaultDate,
        settings = this._getFormatConfig(inst);
  
      try {
        date = this.parseDate(dateFormat, dates, settings) || defaultDate;
      } catch (event) {
        dates = (noDefault ? "" : dates);
      }
      inst.selectedDay = date.getDate();
      inst.drawMonth = inst.selectedMonth = date.getMonth();
      inst.drawYear = inst.selectedYear = date.getFullYear();
      inst.currentDay = (dates ? date.getDate() : 0);
      inst.currentMonth = (dates ? date.getMonth() : 0);
      inst.currentYear = (dates ? date.getFullYear() : 0);
      this._adjustInstDate(inst);
    },
  
    /* Retrieve the default date shown on opening. */
    _getDefaultDate: function(inst) {
      return this._restrictMinMax(inst,
        this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
    },
  
    /* A date may be specified as an exact value or a relative one. */
    _determineDate: function(inst, date, defaultDate) {
      var offsetNumeric = function(offset) {
          var date = new Date();
          date.setDate(date.getDate() + offset);
          return date;
        },
        offsetString = function(offset) {
          try {
            return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
              offset, $.datepicker._getFormatConfig(inst));
          }
          catch (e) {
            // Ignore
          }
  
          var date = (offset.toLowerCase().match(/^c/) ?
            $.datepicker._getDate(inst) : null) || new Date(),
            year = date.getFullYear(),
            month = date.getMonth(),
            day = date.getDate(),
            pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
            matches = pattern.exec(offset);
  
          while (matches) {
            switch (matches[2] || "d") {
              case "d" : case "D" :
                day += parseInt(matches[1],10); break;
              case "w" : case "W" :
                day += parseInt(matches[1],10) * 7; break;
              case "m" : case "M" :
                month += parseInt(matches[1],10);
                day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                break;
              case "y": case "Y" :
                year += parseInt(matches[1],10);
                day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                break;
            }
            matches = pattern.exec(offset);
          }
          return new Date(year, month, day);
        },
        newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
          (typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
  
      newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
      if (newDate) {
        newDate.setHours(0);
        newDate.setMinutes(0);
        newDate.setSeconds(0);
        newDate.setMilliseconds(0);
      }
      return this._daylightSavingAdjust(newDate);
    },
  
    /* Handle switch to/from daylight saving.
     * Hours may be non-zero on daylight saving cut-over:
     * > 12 when midnight changeover, but then cannot generate
     * midnight datetime, so jump to 1AM, otherwise reset.
     * @param  date  (Date) the date to check
     * @return  (Date) the corrected date
     */
    _daylightSavingAdjust: function(date) {
      if (!date) {
        return null;
      }
      date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
      return date;
    },
  
    /* Set the date(s) directly. */
    _setDate: function(inst, date, noChange) {
      var clear = !date,
        origMonth = inst.selectedMonth,
        origYear = inst.selectedYear,
        newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
  
      inst.selectedDay = inst.currentDay = newDate.getDate();
      inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
      inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
      if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
        this._notifyChange(inst);
      }
      this._adjustInstDate(inst);
      if (inst.input) {
        inst.input.val(clear ? "" : this._formatDate(inst));
      }
    },
  
    /* Retrieve the date(s) directly. */
    _getDate: function(inst) {
      var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
        this._daylightSavingAdjust(new Date(
        inst.currentYear, inst.currentMonth, inst.currentDay)));
        return startDate;
    },
  
    /* Attach the onxxx handlers.  These are declared statically so
     * they work with static code transformers like Caja.
     */
    _attachHandlers: function(inst) {
      var stepMonths = this._get(inst, "stepMonths"),
        id = "#" + inst.id.replace( /\\\\/g, "\\" );
      inst.dpDiv.find("[data-handler]").map(function () {
        var handler = {
          prev: function () {
            $.datepicker._adjustDate(id, -stepMonths, "M");
          },
          next: function () {
            $.datepicker._adjustDate(id, +stepMonths, "M");
          },
          hide: function () {
            $.datepicker._hideDatepicker();
          },
          today: function () {
            $.datepicker._gotoToday(id);
          },
          selectDay: function () {
            $.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
            return false;
          },
          selectMonth: function () {
            $.datepicker._selectMonthYear(id, this, "M");
            return false;
          },
          selectYear: function () {
            $.datepicker._selectMonthYear(id, this, "Y");
            return false;
          }
        };
        $(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
      });
    },
  
    /* Generate the HTML for the current state of the date picker. */
    _generateHTML: function(inst) {
      var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
        controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
        monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
        selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
        cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
        printDate, dRow, tbody, daySettings, otherMonth, unselectable,
        tempDate = new Date(),
        today = this._daylightSavingAdjust(
          new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
        isRTL = this._get(inst, "isRTL"),
        showButtonPanel = this._get(inst, "showButtonPanel"),
        hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
        navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
        numMonths = this._getNumberOfMonths(inst),
        showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
        stepMonths = this._get(inst, "stepMonths"),
        isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
        currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
          new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
        minDate = this._getMinMaxDate(inst, "min"),
        maxDate = this._getMinMaxDate(inst, "max"),
        drawMonth = inst.drawMonth - showCurrentAtPos,
        drawYear = inst.drawYear;
  
      if (drawMonth < 0) {
        drawMonth += 12;
        drawYear--;
      }
      if (maxDate) {
        maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
          maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
        maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
        while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
          drawMonth--;
          if (drawMonth < 0) {
            drawMonth = 11;
            drawYear--;
          }
        }
      }
      inst.drawMonth = drawMonth;
      inst.drawYear = drawYear;
  
      prevText = this._get(inst, "prevText");
      prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
        this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
        this._getFormatConfig(inst)));
  
      prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
        "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
        " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
        (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+ prevText +"'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));
  
      nextText = this._get(inst, "nextText");
      nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
        this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
        this._getFormatConfig(inst)));
  
      next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
        "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
        " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
        (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+ nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));
  
      currentText = this._get(inst, "currentText");
      gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
      currentText = (!navigationAsDateFormat ? currentText :
        this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
  
      controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
        this._get(inst, "closeText") + "</button>" : "");
  
      buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
        (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
        ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";
  
      firstDay = parseInt(this._get(inst, "firstDay"),10);
      firstDay = (isNaN(firstDay) ? 0 : firstDay);
  
      showWeek = this._get(inst, "showWeek");
      dayNames = this._get(inst, "dayNames");
      dayNamesMin = this._get(inst, "dayNamesMin");
      monthNames = this._get(inst, "monthNames");
      monthNamesShort = this._get(inst, "monthNamesShort");
      beforeShowDay = this._get(inst, "beforeShowDay");
      showOtherMonths = this._get(inst, "showOtherMonths");
      selectOtherMonths = this._get(inst, "selectOtherMonths");
      defaultDate = this._getDefaultDate(inst);
      html = "";
      dow;
      for (row = 0; row < numMonths[0]; row++) {
        group = "";
        this.maxRows = 4;
        for (col = 0; col < numMonths[1]; col++) {
          selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
          cornerClass = " ui-corner-all";
          calender = "";
          if (isMultiMonth) {
            calender += "<div class='ui-datepicker-group";
            if (numMonths[1] > 1) {
              switch (col) {
                case 0: calender += " ui-datepicker-group-first";
                  cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
                case numMonths[1]-1: calender += " ui-datepicker-group-last";
                  cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
                default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
              }
            }
            calender += "'>";
          }
          calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
            (/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
            (/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
            this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
            row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
            "</div><table class='ui-datepicker-calendar'><thead>" +
            "<tr>";
          thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
          for (dow = 0; dow < 7; dow++) { // days of the week
            day = (dow + firstDay) % 7;
            thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
              "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
          }
          calender += thead + "</tr></thead><tbody>";
          daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
          if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
            inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
          }
          leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
          curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
          numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
          this.maxRows = numRows;
          printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
          for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
            calender += "<tr>";
            tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
              this._get(inst, "calculateWeek")(printDate) + "</td>");
            for (dow = 0; dow < 7; dow++) { // create date picker days
              daySettings = (beforeShowDay ?
                beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
              otherMonth = (printDate.getMonth() !== drawMonth);
              unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
                (minDate && printDate < minDate) || (maxDate && printDate > maxDate);
              tbody += "<td class='" +
                ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
                (otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
                ((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
                (defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
                // or defaultDate is current printedDate and defaultDate is selectedDate
                " " + this._dayOverClass : "") + // highlight selected day
                (unselectable ? " " + this._unselectableClass + " ui-state-disabled": "") +  // highlight unselectable days
                (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
                (printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
                (printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
                ((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
                (unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
                (otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
                (unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
                (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
                (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
                (otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
                "' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
              printDate.setDate(printDate.getDate() + 1);
              printDate = this._daylightSavingAdjust(printDate);
            }
            calender += tbody + "</tr>";
          }
          drawMonth++;
          if (drawMonth > 11) {
            drawMonth = 0;
            drawYear++;
          }
          calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
                ((numMonths[0] > 0 && col === numMonths[1]-1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
          group += calender;
        }
        html += group;
      }
      html += buttonPanel;
      inst._keyEvent = false;
      return html;
    },
  
    /* Generate the month and year header. */
    _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
        secondary, monthNames, monthNamesShort) {
  
      var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
        changeMonth = this._get(inst, "changeMonth"),
        changeYear = this._get(inst, "changeYear"),
        showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
        html = "<div class='ui-datepicker-title'>",
        monthHtml = "";
  
      // month selection
      if (secondary || !changeMonth) {
        monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
      } else {
        inMinYear = (minDate && minDate.getFullYear() === drawYear);
        inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
        monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
        for ( month = 0; month < 12; month++) {
          if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
            monthHtml += "<option value='" + month + "'" +
              (month === drawMonth ? " selected='selected'" : "") +
              ">" + monthNamesShort[month] + "</option>";
          }
        }
        monthHtml += "</select>";
      }
  
      if (!showMonthAfterYear) {
        html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
      }
  
      // year selection
      if ( !inst.yearshtml ) {
        inst.yearshtml = "";
        if (secondary || !changeYear) {
          html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
        } else {
          // determine range of years to display
          years = this._get(inst, "yearRange").split(":");
          thisYear = new Date().getFullYear();
          determineYear = function(value) {
            var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
              (value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
              parseInt(value, 10)));
            return (isNaN(year) ? thisYear : year);
          };
          year = determineYear(years[0]);
          endYear = Math.max(year, determineYear(years[1] || ""));
          year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
          endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
          inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
          for (; year <= endYear; year++) {
            inst.yearshtml += "<option value='" + year + "'" +
              (year === drawYear ? " selected='selected'" : "") +
              ">" + year + "</option>";
          }
          inst.yearshtml += "</select>";
  
          html += inst.yearshtml;
          inst.yearshtml = null;
        }
      }
  
      html += this._get(inst, "yearSuffix");
      if (showMonthAfterYear) {
        html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
      }
      html += "</div>"; // Close datepicker_header
      return html;
    },
  
    /* Adjust one of the date sub-fields. */
    _adjustInstDate: function(inst, offset, period) {
      var year = inst.drawYear + (period === "Y" ? offset : 0),
        month = inst.drawMonth + (period === "M" ? offset : 0),
        day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
        date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
  
      inst.selectedDay = date.getDate();
      inst.drawMonth = inst.selectedMonth = date.getMonth();
      inst.drawYear = inst.selectedYear = date.getFullYear();
      if (period === "M" || period === "Y") {
        this._notifyChange(inst);
      }
    },
  
    /* Ensure a date is within any min/max bounds. */
    _restrictMinMax: function(inst, date) {
      var minDate = this._getMinMaxDate(inst, "min"),
        maxDate = this._getMinMaxDate(inst, "max"),
        newDate = (minDate && date < minDate ? minDate : date);
      return (maxDate && newDate > maxDate ? maxDate : newDate);
    },
  
    /* Notify change of month/year. */
    _notifyChange: function(inst) {
      var onChange = this._get(inst, "onChangeMonthYear");
      if (onChange) {
        onChange.apply((inst.input ? inst.input[0] : null),
          [inst.selectedYear, inst.selectedMonth + 1, inst]);
      }
    },
  
    /* Determine the number of months to show. */
    _getNumberOfMonths: function(inst) {
      var numMonths = this._get(inst, "numberOfMonths");
      return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
    },
  
    /* Determine the current maximum date - ensure no time components are set. */
    _getMinMaxDate: function(inst, minMax) {
      return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
    },
  
    /* Find the number of days in a given month. */
    _getDaysInMonth: function(year, month) {
      return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
    },
  
    /* Find the day of the week of the first of a month. */
    _getFirstDayOfMonth: function(year, month) {
      return new Date(year, month, 1).getDay();
    },
  
    /* Determines if we should allow a "next/prev" month display change. */
    _canAdjustMonth: function(inst, offset, curYear, curMonth) {
      var numMonths = this._getNumberOfMonths(inst),
        date = this._daylightSavingAdjust(new Date(curYear,
        curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
  
      if (offset < 0) {
        date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
      }
      return this._isInRange(inst, date);
    },
  
    /* Is the given date in the accepted range? */
    _isInRange: function(inst, date) {
      var yearSplit, currentYear,
        minDate = this._getMinMaxDate(inst, "min"),
        maxDate = this._getMinMaxDate(inst, "max"),
        minYear = null,
        maxYear = null,
        years = this._get(inst, "yearRange");
        if (years){
          yearSplit = years.split(":");
          currentYear = new Date().getFullYear();
          minYear = parseInt(yearSplit[0], 10);
          maxYear = parseInt(yearSplit[1], 10);
          if ( yearSplit[0].match(/[+\-].*/) ) {
            minYear += currentYear;
          }
          if ( yearSplit[1].match(/[+\-].*/) ) {
            maxYear += currentYear;
          }
        }
  
      return ((!minDate || date.getTime() >= minDate.getTime()) &&
        (!maxDate || date.getTime() <= maxDate.getTime()) &&
        (!minYear || date.getFullYear() >= minYear) &&
        (!maxYear || date.getFullYear() <= maxYear));
    },
  
    /* Provide the configuration settings for formatting/parsing. */
    _getFormatConfig: function(inst) {
      var shortYearCutoff = this._get(inst, "shortYearCutoff");
      shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
        new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
      return {shortYearCutoff: shortYearCutoff,
        dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
        monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")};
    },
  
    /* Format the given date for display. */
    _formatDate: function(inst, day, month, year) {
      if (!day) {
        inst.currentDay = inst.selectedDay;
        inst.currentMonth = inst.selectedMonth;
        inst.currentYear = inst.selectedYear;
      }
      var date = (day ? (typeof day === "object" ? day :
        this._daylightSavingAdjust(new Date(year, month, day))) :
        this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
      return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
    }
  });
  
  /*
   * Bind hover events for datepicker elements.
   * Done via delegate so the binding only occurs once in the lifetime of the parent div.
   * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
   */
  function datepicker_bindHover(dpDiv) {
    var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
    return dpDiv.delegate(selector, "mouseout", function() {
        $(this).removeClass("ui-state-hover");
        if (this.className.indexOf("ui-datepicker-prev") !== -1) {
          $(this).removeClass("ui-datepicker-prev-hover");
        }
        if (this.className.indexOf("ui-datepicker-next") !== -1) {
          $(this).removeClass("ui-datepicker-next-hover");
        }
      })
      .delegate( selector, "mouseover", datepicker_handleMouseover );
  }
  
  function datepicker_handleMouseover() {
    if (!$.datepicker._isDisabledDatepicker( datepicker_instActive.inline? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {
      $(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
      $(this).addClass("ui-state-hover");
      if (this.className.indexOf("ui-datepicker-prev") !== -1) {
        $(this).addClass("ui-datepicker-prev-hover");
      }
      if (this.className.indexOf("ui-datepicker-next") !== -1) {
        $(this).addClass("ui-datepicker-next-hover");
      }
    }
  }
  
  /* jQuery extend now ignores nulls! */
  function datepicker_extendRemove(target, props) {
    $.extend(target, props);
    for (var name in props) {
      if (props[name] == null) {
        target[name] = props[name];
      }
    }
    return target;
  }
  
  /* Invoke the datepicker functionality.
     @param  options  string - a command, optionally followed by additional parameters or
            Object - settings for attaching new datepicker functionality
     @return  jQuery object */
  $.fn.datepicker = function(options){
  
    /* Verify an empty collection wasn't passed - Fixes #6976 */
    if ( !this.length ) {
      return this;
    }
  
    /* Initialise the date picker. */
    if (!$.datepicker.initialized) {
      $(document).mousedown($.datepicker._checkExternalClick);
      $.datepicker.initialized = true;
    }
  
    /* Append datepicker main container to body if not exist. */
    if ($("#"+$.datepicker._mainDivId).length === 0) {
      $("body").append($.datepicker.dpDiv);
    }
  
    var otherArgs = Array.prototype.slice.call(arguments, 1);
    if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
      return $.datepicker["_" + options + "Datepicker"].
        apply($.datepicker, [this[0]].concat(otherArgs));
    }
    if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
      return $.datepicker["_" + options + "Datepicker"].
        apply($.datepicker, [this[0]].concat(otherArgs));
    }
    return this.each(function() {
      typeof options === "string" ?
        $.datepicker["_" + options + "Datepicker"].
          apply($.datepicker, [this].concat(otherArgs)) :
        $.datepicker._attachDatepicker(this, options);
    });
  };
  
  $.datepicker = new Datepicker(); // singleton instance
  $.datepicker.initialized = false;
  $.datepicker.uuid = new Date().getTime();
  $.datepicker.version = "1.11.4";
  
  var datepicker = $.datepicker;
  
  
  /*!
   * jQuery UI Draggable 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/draggable/
   */
  
  
  $.widget("ui.draggable", $.ui.mouse, {
    version: "1.11.4",
    widgetEventPrefix: "drag",
    options: {
      addClasses: true,
      appendTo: "parent",
      axis: false,
      connectToSortable: false,
      containment: false,
      cursor: "auto",
      cursorAt: false,
      grid: false,
      handle: false,
      helper: "original",
      iframeFix: false,
      opacity: false,
      refreshPositions: false,
      revert: false,
      revertDuration: 500,
      scope: "default",
      scroll: true,
      scrollSensitivity: 20,
      scrollSpeed: 20,
      snap: false,
      snapMode: "both",
      snapTolerance: 20,
      stack: false,
      zIndex: false,
  
      // callbacks
      drag: null,
      start: null,
      stop: null
    },
    _create: function() {
  
      if ( this.options.helper === "original" ) {
        this._setPositionRelative();
      }
      if (this.options.addClasses){
        this.element.addClass("ui-draggable");
      }
      if (this.options.disabled){
        this.element.addClass("ui-draggable-disabled");
      }
      this._setHandleClassName();
  
      this._mouseInit();
    },
  
    _setOption: function( key, value ) {
      this._super( key, value );
      if ( key === "handle" ) {
        this._removeHandleClassName();
        this._setHandleClassName();
      }
    },
  
    _destroy: function() {
      if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
        this.destroyOnClear = true;
        return;
      }
      this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
      this._removeHandleClassName();
      this._mouseDestroy();
    },
  
    _mouseCapture: function(event) {
      var o = this.options;
  
      this._blurActiveElement( event );
  
      // among others, prevent a drag on a resizable-handle
      if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
        return false;
      }
  
      //Quit if we're not on a valid handle
      this.handle = this._getHandle(event);
      if (!this.handle) {
        return false;
      }
  
      this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );
  
      return true;
  
    },
  
    _blockFrames: function( selector ) {
      this.iframeBlocks = this.document.find( selector ).map(function() {
        var iframe = $( this );
  
        return $( "<div>" )
          .css( "position", "absolute" )
          .appendTo( iframe.parent() )
          .outerWidth( iframe.outerWidth() )
          .outerHeight( iframe.outerHeight() )
          .offset( iframe.offset() )[ 0 ];
      });
    },
  
    _unblockFrames: function() {
      if ( this.iframeBlocks ) {
        this.iframeBlocks.remove();
        delete this.iframeBlocks;
      }
    },
  
    _blurActiveElement: function( event ) {
      var document = this.document[ 0 ];
  
      // Only need to blur if the event occurred on the draggable itself, see #10527
      if ( !this.handleElement.is( event.target ) ) {
        return;
      }
  
      // support: IE9
      // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
      try {
  
        // Support: IE9, IE10
        // If the <body> is blurred, IE will switch windows, see #9520
        if ( document.activeElement && document.activeElement.nodeName.toLowerCase() !== "body" ) {
  
          // Blur any element that currently has focus, see #4261
          $( document.activeElement ).blur();
        }
      } catch ( error ) {}
    },
  
    _mouseStart: function(event) {
  
      var o = this.options;
  
      //Create and append the visible helper
      this.helper = this._createHelper(event);
  
      this.helper.addClass("ui-draggable-dragging");
  
      //Cache the helper size
      this._cacheHelperProportions();
  
      //If ddmanager is used for droppables, set the global draggable
      if ($.ui.ddmanager) {
        $.ui.ddmanager.current = this;
      }
  
      /*
       * - Position generation -
       * This block generates everything position related - it's the core of draggables.
       */
  
      //Cache the margins of the original element
      this._cacheMargins();
  
      //Store the helper's css position
      this.cssPosition = this.helper.css( "position" );
      this.scrollParent = this.helper.scrollParent( true );
      this.offsetParent = this.helper.offsetParent();
      this.hasFixedAncestor = this.helper.parents().filter(function() {
          return $( this ).css( "position" ) === "fixed";
        }).length > 0;
  
      //The element's absolute position on the page minus margins
      this.positionAbs = this.element.offset();
      this._refreshOffsets( event );
  
      //Generate the original position
      this.originalPosition = this.position = this._generatePosition( event, false );
      this.originalPageX = event.pageX;
      this.originalPageY = event.pageY;
  
      //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
      (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));
  
      //Set a containment if given in the options
      this._setContainment();
  
      //Trigger event + callbacks
      if (this._trigger("start", event) === false) {
        this._clear();
        return false;
      }
  
      //Recache the helper size
      this._cacheHelperProportions();
  
      //Prepare the droppable offsets
      if ($.ui.ddmanager && !o.dropBehaviour) {
        $.ui.ddmanager.prepareOffsets(this, event);
      }
  
      // Reset helper's right/bottom css if they're set and set explicit width/height instead
      // as this prevents resizing of elements with right/bottom set (see #7772)
      this._normalizeRightBottom();
  
      this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position
  
      //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
      if ( $.ui.ddmanager ) {
        $.ui.ddmanager.dragStart(this, event);
      }
  
      return true;
    },
  
    _refreshOffsets: function( event ) {
      this.offset = {
        top: this.positionAbs.top - this.margins.top,
        left: this.positionAbs.left - this.margins.left,
        scroll: false,
        parent: this._getParentOffset(),
        relative: this._getRelativeOffset()
      };
  
      this.offset.click = {
        left: event.pageX - this.offset.left,
        top: event.pageY - this.offset.top
      };
    },
  
    _mouseDrag: function(event, noPropagation) {
      // reset any necessary cached properties (see #5009)
      if ( this.hasFixedAncestor ) {
        this.offset.parent = this._getParentOffset();
      }
  
      //Compute the helpers position
      this.position = this._generatePosition( event, true );
      this.positionAbs = this._convertPositionTo("absolute");
  
      //Call plugins and callbacks and use the resulting position if something is returned
      if (!noPropagation) {
        var ui = this._uiHash();
        if (this._trigger("drag", event, ui) === false) {
          this._mouseUp({});
          return false;
        }
        this.position = ui.position;
      }
  
      this.helper[ 0 ].style.left = this.position.left + "px";
      this.helper[ 0 ].style.top = this.position.top + "px";
  
      if ($.ui.ddmanager) {
        $.ui.ddmanager.drag(this, event);
      }
  
      return false;
    },
  
    _mouseStop: function(event) {
  
      //If we are using droppables, inform the manager about the drop
      var that = this,
        dropped = false;
      if ($.ui.ddmanager && !this.options.dropBehaviour) {
        dropped = $.ui.ddmanager.drop(this, event);
      }
  
      //if a drop comes from outside (a sortable)
      if (this.dropped) {
        dropped = this.dropped;
        this.dropped = false;
      }
  
      if ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
        $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
          if (that._trigger("stop", event) !== false) {
            that._clear();
          }
        });
      } else {
        if (this._trigger("stop", event) !== false) {
          this._clear();
        }
      }
  
      return false;
    },
  
    _mouseUp: function( event ) {
      this._unblockFrames();
  
      //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
      if ( $.ui.ddmanager ) {
        $.ui.ddmanager.dragStop(this, event);
      }
  
      // Only need to focus if the event occurred on the draggable itself, see #10527
      if ( this.handleElement.is( event.target ) ) {
        // The interaction is over; whether or not the click resulted in a drag, focus the element
        this.element.focus();
      }
  
      return $.ui.mouse.prototype._mouseUp.call(this, event);
    },
  
    cancel: function() {
  
      if (this.helper.is(".ui-draggable-dragging")) {
        this._mouseUp({});
      } else {
        this._clear();
      }
  
      return this;
  
    },
  
    _getHandle: function(event) {
      return this.options.handle ?
        !!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
        true;
    },
  
    _setHandleClassName: function() {
      this.handleElement = this.options.handle ?
        this.element.find( this.options.handle ) : this.element;
      this.handleElement.addClass( "ui-draggable-handle" );
    },
  
    _removeHandleClassName: function() {
      this.handleElement.removeClass( "ui-draggable-handle" );
    },
  
    _createHelper: function(event) {
  
      var o = this.options,
        helperIsFunction = $.isFunction( o.helper ),
        helper = helperIsFunction ?
          $( o.helper.apply( this.element[ 0 ], [ event ] ) ) :
          ( o.helper === "clone" ?
            this.element.clone().removeAttr( "id" ) :
            this.element );
  
      if (!helper.parents("body").length) {
        helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
      }
  
      // http://bugs.jqueryui.com/ticket/9446
      // a helper function can return the original element
      // which wouldn't have been set to relative in _create
      if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {
        this._setPositionRelative();
      }
  
      if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
        helper.css("position", "absolute");
      }
  
      return helper;
  
    },
  
    _setPositionRelative: function() {
      if ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {
        this.element[ 0 ].style.position = "relative";
      }
    },
  
    _adjustOffsetFromHelper: function(obj) {
      if (typeof obj === "string") {
        obj = obj.split(" ");
      }
      if ($.isArray(obj)) {
        obj = { left: +obj[0], top: +obj[1] || 0 };
      }
      if ("left" in obj) {
        this.offset.click.left = obj.left + this.margins.left;
      }
      if ("right" in obj) {
        this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
      }
      if ("top" in obj) {
        this.offset.click.top = obj.top + this.margins.top;
      }
      if ("bottom" in obj) {
        this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
      }
    },
  
    _isRootNode: function( element ) {
      return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
    },
  
    _getParentOffset: function() {
  
      //Get the offsetParent and cache its position
      var po = this.offsetParent.offset(),
        document = this.document[ 0 ];
  
      // This is a special case where we need to modify a offset calculated on start, since the following happened:
      // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
      // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
      //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
      if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
        po.left += this.scrollParent.scrollLeft();
        po.top += this.scrollParent.scrollTop();
      }
  
      if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
        po = { top: 0, left: 0 };
      }
  
      return {
        top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
        left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
      };
  
    },
  
    _getRelativeOffset: function() {
      if ( this.cssPosition !== "relative" ) {
        return { top: 0, left: 0 };
      }
  
      var p = this.element.position(),
        scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );
  
      return {
        top: p.top - ( parseInt(this.helper.css( "top" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
        left: p.left - ( parseInt(this.helper.css( "left" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
      };
  
    },
  
    _cacheMargins: function() {
      this.margins = {
        left: (parseInt(this.element.css("marginLeft"), 10) || 0),
        top: (parseInt(this.element.css("marginTop"), 10) || 0),
        right: (parseInt(this.element.css("marginRight"), 10) || 0),
        bottom: (parseInt(this.element.css("marginBottom"), 10) || 0)
      };
    },
  
    _cacheHelperProportions: function() {
      this.helperProportions = {
        width: this.helper.outerWidth(),
        height: this.helper.outerHeight()
      };
    },
  
    _setContainment: function() {
  
      var isUserScrollable, c, ce,
        o = this.options,
        document = this.document[ 0 ];
  
      this.relativeContainer = null;
  
      if ( !o.containment ) {
        this.containment = null;
        return;
      }
  
      if ( o.containment === "window" ) {
        this.containment = [
          $( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
          $( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
          $( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
          $( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
        ];
        return;
      }
  
      if ( o.containment === "document") {
        this.containment = [
          0,
          0,
          $( document ).width() - this.helperProportions.width - this.margins.left,
          ( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
        ];
        return;
      }
  
      if ( o.containment.constructor === Array ) {
        this.containment = o.containment;
        return;
      }
  
      if ( o.containment === "parent" ) {
        o.containment = this.helper[ 0 ].parentNode;
      }
  
      c = $( o.containment );
      ce = c[ 0 ];
  
      if ( !ce ) {
        return;
      }
  
      isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );
  
      this.containment = [
        ( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
        ( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
        ( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
          ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -
          ( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -
          this.helperProportions.width -
          this.margins.left -
          this.margins.right,
        ( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
          ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -
          ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -
          this.helperProportions.height -
          this.margins.top -
          this.margins.bottom
      ];
      this.relativeContainer = c;
    },
  
    _convertPositionTo: function(d, pos) {
  
      if (!pos) {
        pos = this.position;
      }
  
      var mod = d === "absolute" ? 1 : -1,
        scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );
  
      return {
        top: (
          pos.top	+																// The absolute mouse position
          this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
          ( ( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod)
        ),
        left: (
          pos.left +																// The absolute mouse position
          this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
          ( ( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod)
        )
      };
  
    },
  
    _generatePosition: function( event, constrainPosition ) {
  
      var containment, co, top, left,
        o = this.options,
        scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
        pageX = event.pageX,
        pageY = event.pageY;
  
      // Cache the scroll
      if ( !scrollIsRootNode || !this.offset.scroll ) {
        this.offset.scroll = {
          top: this.scrollParent.scrollTop(),
          left: this.scrollParent.scrollLeft()
        };
      }
  
      /*
       * - Position constraining -
       * Constrain the position to a mix of grid, containment.
       */
  
      // If we are not dragging yet, we won't check for options
      if ( constrainPosition ) {
        if ( this.containment ) {
          if ( this.relativeContainer ){
            co = this.relativeContainer.offset();
            containment = [
              this.containment[ 0 ] + co.left,
              this.containment[ 1 ] + co.top,
              this.containment[ 2 ] + co.left,
              this.containment[ 3 ] + co.top
            ];
          } else {
            containment = this.containment;
          }
  
          if (event.pageX - this.offset.click.left < containment[0]) {
            pageX = containment[0] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top < containment[1]) {
            pageY = containment[1] + this.offset.click.top;
          }
          if (event.pageX - this.offset.click.left > containment[2]) {
            pageX = containment[2] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top > containment[3]) {
            pageY = containment[3] + this.offset.click.top;
          }
        }
  
        if (o.grid) {
          //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
          top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
          pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;
  
          left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
          pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
        }
  
        if ( o.axis === "y" ) {
          pageX = this.originalPageX;
        }
  
        if ( o.axis === "x" ) {
          pageY = this.originalPageY;
        }
      }
  
      return {
        top: (
          pageY -																	// The absolute mouse position
          this.offset.click.top	-												// Click offset (relative to the element)
          this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
          ( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
        ),
        left: (
          pageX -																	// The absolute mouse position
          this.offset.click.left -												// Click offset (relative to the element)
          this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
          ( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
        )
      };
  
    },
  
    _clear: function() {
      this.helper.removeClass("ui-draggable-dragging");
      if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
        this.helper.remove();
      }
      this.helper = null;
      this.cancelHelperRemoval = false;
      if ( this.destroyOnClear ) {
        this.destroy();
      }
    },
  
    _normalizeRightBottom: function() {
      if ( this.options.axis !== "y" && this.helper.css( "right" ) !== "auto" ) {
        this.helper.width( this.helper.width() );
        this.helper.css( "right", "auto" );
      }
      if ( this.options.axis !== "x" && this.helper.css( "bottom" ) !== "auto" ) {
        this.helper.height( this.helper.height() );
        this.helper.css( "bottom", "auto" );
      }
    },
  
    // From now on bulk stuff - mainly helpers
  
    _trigger: function( type, event, ui ) {
      ui = ui || this._uiHash();
      $.ui.plugin.call( this, type, [ event, ui, this ], true );
  
      // Absolute position and offset (see #6884 ) have to be recalculated after plugins
      if ( /^(drag|start|stop)/.test( type ) ) {
        this.positionAbs = this._convertPositionTo( "absolute" );
        ui.offset = this.positionAbs;
      }
      return $.Widget.prototype._trigger.call( this, type, event, ui );
    },
  
    plugins: {},
  
    _uiHash: function() {
      return {
        helper: this.helper,
        position: this.position,
        originalPosition: this.originalPosition,
        offset: this.positionAbs
      };
    }
  
  });
  
  $.ui.plugin.add( "draggable", "connectToSortable", {
    start: function( event, ui, draggable ) {
      var uiSortable = $.extend( {}, ui, {
        item: draggable.element
      });
  
      draggable.sortables = [];
      $( draggable.options.connectToSortable ).each(function() {
        var sortable = $( this ).sortable( "instance" );
  
        if ( sortable && !sortable.options.disabled ) {
          draggable.sortables.push( sortable );
  
          // refreshPositions is called at drag start to refresh the containerCache
          // which is used in drag. This ensures it's initialized and synchronized
          // with any changes that might have happened on the page since initialization.
          sortable.refreshPositions();
          sortable._trigger("activate", event, uiSortable);
        }
      });
    },
    stop: function( event, ui, draggable ) {
      var uiSortable = $.extend( {}, ui, {
        item: draggable.element
      });
  
      draggable.cancelHelperRemoval = false;
  
      $.each( draggable.sortables, function() {
        var sortable = this;
  
        if ( sortable.isOver ) {
          sortable.isOver = 0;
  
          // Allow this sortable to handle removing the helper
          draggable.cancelHelperRemoval = true;
          sortable.cancelHelperRemoval = false;
  
          // Use _storedCSS To restore properties in the sortable,
          // as this also handles revert (#9675) since the draggable
          // may have modified them in unexpected ways (#8809)
          sortable._storedCSS = {
            position: sortable.placeholder.css( "position" ),
            top: sortable.placeholder.css( "top" ),
            left: sortable.placeholder.css( "left" )
          };
  
          sortable._mouseStop(event);
  
          // Once drag has ended, the sortable should return to using
          // its original helper, not the shared helper from draggable
          sortable.options.helper = sortable.options._helper;
        } else {
          // Prevent this Sortable from removing the helper.
          // However, don't set the draggable to remove the helper
          // either as another connected Sortable may yet handle the removal.
          sortable.cancelHelperRemoval = true;
  
          sortable._trigger( "deactivate", event, uiSortable );
        }
      });
    },
    drag: function( event, ui, draggable ) {
      $.each( draggable.sortables, function() {
        var innermostIntersecting = false,
          sortable = this;
  
        // Copy over variables that sortable's _intersectsWith uses
        sortable.positionAbs = draggable.positionAbs;
        sortable.helperProportions = draggable.helperProportions;
        sortable.offset.click = draggable.offset.click;
  
        if ( sortable._intersectsWith( sortable.containerCache ) ) {
          innermostIntersecting = true;
  
          $.each( draggable.sortables, function() {
            // Copy over variables that sortable's _intersectsWith uses
            this.positionAbs = draggable.positionAbs;
            this.helperProportions = draggable.helperProportions;
            this.offset.click = draggable.offset.click;
  
            if ( this !== sortable &&
                this._intersectsWith( this.containerCache ) &&
                $.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {
              innermostIntersecting = false;
            }
  
            return innermostIntersecting;
          });
        }
  
        if ( innermostIntersecting ) {
          // If it intersects, we use a little isOver variable and set it once,
          // so that the move-in stuff gets fired only once.
          if ( !sortable.isOver ) {
            sortable.isOver = 1;
  
            // Store draggable's parent in case we need to reappend to it later.
            draggable._parent = ui.helper.parent();
  
            sortable.currentItem = ui.helper
              .appendTo( sortable.element )
              .data( "ui-sortable-item", true );
  
            // Store helper option to later restore it
            sortable.options._helper = sortable.options.helper;
  
            sortable.options.helper = function() {
              return ui.helper[ 0 ];
            };
  
            // Fire the start events of the sortable with our passed browser event,
            // and our own helper (so it doesn't create a new one)
            event.target = sortable.currentItem[ 0 ];
            sortable._mouseCapture( event, true );
            sortable._mouseStart( event, true, true );
  
            // Because the browser event is way off the new appended portlet,
            // modify necessary variables to reflect the changes
            sortable.offset.click.top = draggable.offset.click.top;
            sortable.offset.click.left = draggable.offset.click.left;
            sortable.offset.parent.left -= draggable.offset.parent.left -
              sortable.offset.parent.left;
            sortable.offset.parent.top -= draggable.offset.parent.top -
              sortable.offset.parent.top;
  
            draggable._trigger( "toSortable", event );
  
            // Inform draggable that the helper is in a valid drop zone,
            // used solely in the revert option to handle "valid/invalid".
            draggable.dropped = sortable.element;
  
            // Need to refreshPositions of all sortables in the case that
            // adding to one sortable changes the location of the other sortables (#9675)
            $.each( draggable.sortables, function() {
              this.refreshPositions();
            });
  
            // hack so receive/update callbacks work (mostly)
            draggable.currentItem = draggable.element;
            sortable.fromOutside = draggable;
          }
  
          if ( sortable.currentItem ) {
            sortable._mouseDrag( event );
            // Copy the sortable's position because the draggable's can potentially reflect
            // a relative position, while sortable is always absolute, which the dragged
            // element has now become. (#8809)
            ui.position = sortable.position;
          }
        } else {
          // If it doesn't intersect with the sortable, and it intersected before,
          // we fake the drag stop of the sortable, but make sure it doesn't remove
          // the helper by using cancelHelperRemoval.
          if ( sortable.isOver ) {
  
            sortable.isOver = 0;
            sortable.cancelHelperRemoval = true;
  
            // Calling sortable's mouseStop would trigger a revert,
            // so revert must be temporarily false until after mouseStop is called.
            sortable.options._revert = sortable.options.revert;
            sortable.options.revert = false;
  
            sortable._trigger( "out", event, sortable._uiHash( sortable ) );
            sortable._mouseStop( event, true );
  
            // restore sortable behaviors that were modfied
            // when the draggable entered the sortable area (#9481)
            sortable.options.revert = sortable.options._revert;
            sortable.options.helper = sortable.options._helper;
  
            if ( sortable.placeholder ) {
              sortable.placeholder.remove();
            }
  
            // Restore and recalculate the draggable's offset considering the sortable
            // may have modified them in unexpected ways. (#8809, #10669)
            ui.helper.appendTo( draggable._parent );
            draggable._refreshOffsets( event );
            ui.position = draggable._generatePosition( event, true );
  
            draggable._trigger( "fromSortable", event );
  
            // Inform draggable that the helper is no longer in a valid drop zone
            draggable.dropped = false;
  
            // Need to refreshPositions of all sortables just in case removing
            // from one sortable changes the location of other sortables (#9675)
            $.each( draggable.sortables, function() {
              this.refreshPositions();
            });
          }
        }
      });
    }
  });
  
  $.ui.plugin.add("draggable", "cursor", {
    start: function( event, ui, instance ) {
      var t = $( "body" ),
        o = instance.options;
  
      if (t.css("cursor")) {
        o._cursor = t.css("cursor");
      }
      t.css("cursor", o.cursor);
    },
    stop: function( event, ui, instance ) {
      var o = instance.options;
      if (o._cursor) {
        $("body").css("cursor", o._cursor);
      }
    }
  });
  
  $.ui.plugin.add("draggable", "opacity", {
    start: function( event, ui, instance ) {
      var t = $( ui.helper ),
        o = instance.options;
      if (t.css("opacity")) {
        o._opacity = t.css("opacity");
      }
      t.css("opacity", o.opacity);
    },
    stop: function( event, ui, instance ) {
      var o = instance.options;
      if (o._opacity) {
        $(ui.helper).css("opacity", o._opacity);
      }
    }
  });
  
  $.ui.plugin.add("draggable", "scroll", {
    start: function( event, ui, i ) {
      if ( !i.scrollParentNotHidden ) {
        i.scrollParentNotHidden = i.helper.scrollParent( false );
      }
  
      if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] && i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {
        i.overflowOffset = i.scrollParentNotHidden.offset();
      }
    },
    drag: function( event, ui, i  ) {
  
      var o = i.options,
        scrolled = false,
        scrollParent = i.scrollParentNotHidden[ 0 ],
        document = i.document[ 0 ];
  
      if ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {
        if ( !o.axis || o.axis !== "x" ) {
          if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY < o.scrollSensitivity ) {
            scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
          } else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {
            scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
          }
        }
  
        if ( !o.axis || o.axis !== "y" ) {
          if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX < o.scrollSensitivity ) {
            scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
          } else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {
            scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
          }
        }
  
      } else {
  
        if (!o.axis || o.axis !== "x") {
          if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
            scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
          } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
            scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
          }
        }
  
        if (!o.axis || o.axis !== "y") {
          if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
            scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
          } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
            scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
          }
        }
  
      }
  
      if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
        $.ui.ddmanager.prepareOffsets(i, event);
      }
  
    }
  });
  
  $.ui.plugin.add("draggable", "snap", {
    start: function( event, ui, i ) {
  
      var o = i.options;
  
      i.snapElements = [];
  
      $(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
        var $t = $(this),
          $o = $t.offset();
        if (this !== i.element[0]) {
          i.snapElements.push({
            item: this,
            width: $t.outerWidth(), height: $t.outerHeight(),
            top: $o.top, left: $o.left
          });
        }
      });
  
    },
    drag: function( event, ui, inst ) {
  
      var ts, bs, ls, rs, l, r, t, b, i, first,
        o = inst.options,
        d = o.snapTolerance,
        x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
        y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;
  
      for (i = inst.snapElements.length - 1; i >= 0; i--){
  
        l = inst.snapElements[i].left - inst.margins.left;
        r = l + inst.snapElements[i].width;
        t = inst.snapElements[i].top - inst.margins.top;
        b = t + inst.snapElements[i].height;
  
        if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
          if (inst.snapElements[i].snapping) {
            (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
          }
          inst.snapElements[i].snapping = false;
          continue;
        }
  
        if (o.snapMode !== "inner") {
          ts = Math.abs(t - y2) <= d;
          bs = Math.abs(b - y1) <= d;
          ls = Math.abs(l - x2) <= d;
          rs = Math.abs(r - x1) <= d;
          if (ts) {
            ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top;
          }
          if (bs) {
            ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top;
          }
          if (ls) {
            ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left;
          }
          if (rs) {
            ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left;
          }
        }
  
        first = (ts || bs || ls || rs);
  
        if (o.snapMode !== "outer") {
          ts = Math.abs(t - y1) <= d;
          bs = Math.abs(b - y2) <= d;
          ls = Math.abs(l - x1) <= d;
          rs = Math.abs(r - x2) <= d;
          if (ts) {
            ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top;
          }
          if (bs) {
            ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top;
          }
          if (ls) {
            ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left;
          }
          if (rs) {
            ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left;
          }
        }
  
        if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
          (inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
        }
        inst.snapElements[i].snapping = (ts || bs || ls || rs || first);
  
      }
  
    }
  });
  
  $.ui.plugin.add("draggable", "stack", {
    start: function( event, ui, instance ) {
      var min,
        o = instance.options,
        group = $.makeArray($(o.stack)).sort(function(a, b) {
          return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
        });
  
      if (!group.length) { return; }
  
      min = parseInt($(group[0]).css("zIndex"), 10) || 0;
      $(group).each(function(i) {
        $(this).css("zIndex", min + i);
      });
      this.css("zIndex", (min + group.length));
    }
  });
  
  $.ui.plugin.add("draggable", "zIndex", {
    start: function( event, ui, instance ) {
      var t = $( ui.helper ),
        o = instance.options;
  
      if (t.css("zIndex")) {
        o._zIndex = t.css("zIndex");
      }
      t.css("zIndex", o.zIndex);
    },
    stop: function( event, ui, instance ) {
      var o = instance.options;
  
      if (o._zIndex) {
        $(ui.helper).css("zIndex", o._zIndex);
      }
    }
  });
  
  var draggable = $.ui.draggable;
  
  
  /*!
   * jQuery UI Resizable 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/resizable/
   */
  
  
  $.widget("ui.resizable", $.ui.mouse, {
    version: "1.11.4",
    widgetEventPrefix: "resize",
    options: {
      alsoResize: false,
      animate: false,
      animateDuration: "slow",
      animateEasing: "swing",
      aspectRatio: false,
      autoHide: false,
      containment: false,
      ghost: false,
      grid: false,
      handles: "e,s,se",
      helper: false,
      maxHeight: null,
      maxWidth: null,
      minHeight: 10,
      minWidth: 10,
      // See #7960
      zIndex: 90,
  
      // callbacks
      resize: null,
      start: null,
      stop: null
    },
  
    _num: function( value ) {
      return parseInt( value, 10 ) || 0;
    },
  
    _isNumber: function( value ) {
      return !isNaN( parseInt( value, 10 ) );
    },
  
    _hasScroll: function( el, a ) {
  
      if ( $( el ).css( "overflow" ) === "hidden") {
        return false;
      }
  
      var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
        has = false;
  
      if ( el[ scroll ] > 0 ) {
        return true;
      }
  
      // TODO: determine which cases actually cause this to happen
      // if the element doesn't have the scroll set, see if it's possible to
      // set the scroll
      el[ scroll ] = 1;
      has = ( el[ scroll ] > 0 );
      el[ scroll ] = 0;
      return has;
    },
  
    _create: function() {
  
      var n, i, handle, axis, hname,
        that = this,
        o = this.options;
      this.element.addClass("ui-resizable");
  
      $.extend(this, {
        _aspectRatio: !!(o.aspectRatio),
        aspectRatio: o.aspectRatio,
        originalElement: this.element,
        _proportionallyResizeElements: [],
        _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
      });
  
      // Wrap the element if it cannot hold child nodes
      if (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {
  
        this.element.wrap(
          $("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
            position: this.element.css("position"),
            width: this.element.outerWidth(),
            height: this.element.outerHeight(),
            top: this.element.css("top"),
            left: this.element.css("left")
          })
        );
  
        this.element = this.element.parent().data(
          "ui-resizable", this.element.resizable( "instance" )
        );
  
        this.elementIsWrapper = true;
  
        this.element.css({
          marginLeft: this.originalElement.css("marginLeft"),
          marginTop: this.originalElement.css("marginTop"),
          marginRight: this.originalElement.css("marginRight"),
          marginBottom: this.originalElement.css("marginBottom")
        });
        this.originalElement.css({
          marginLeft: 0,
          marginTop: 0,
          marginRight: 0,
          marginBottom: 0
        });
        // support: Safari
        // Prevent Safari textarea resize
        this.originalResizeStyle = this.originalElement.css("resize");
        this.originalElement.css("resize", "none");
  
        this._proportionallyResizeElements.push( this.originalElement.css({
          position: "static",
          zoom: 1,
          display: "block"
        }) );
  
        // support: IE9
        // avoid IE jump (hard set the margin)
        this.originalElement.css({ margin: this.originalElement.css("margin") });
  
        this._proportionallyResize();
      }
  
      this.handles = o.handles ||
        ( !$(".ui-resizable-handle", this.element).length ?
          "e,s,se" : {
            n: ".ui-resizable-n",
            e: ".ui-resizable-e",
            s: ".ui-resizable-s",
            w: ".ui-resizable-w",
            se: ".ui-resizable-se",
            sw: ".ui-resizable-sw",
            ne: ".ui-resizable-ne",
            nw: ".ui-resizable-nw"
          } );
  
      this._handles = $();
      if ( this.handles.constructor === String ) {
  
        if ( this.handles === "all") {
          this.handles = "n,e,s,w,se,sw,ne,nw";
        }
  
        n = this.handles.split(",");
        this.handles = {};
  
        for (i = 0; i < n.length; i++) {
  
          handle = $.trim(n[i]);
          hname = "ui-resizable-" + handle;
          axis = $("<div class='ui-resizable-handle " + hname + "'></div>");
  
          axis.css({ zIndex: o.zIndex });
  
          // TODO : What's going on here?
          if ("se" === handle) {
            axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
          }
  
          this.handles[handle] = ".ui-resizable-" + handle;
          this.element.append(axis);
        }
  
      }
  
      this._renderAxis = function(target) {
  
        var i, axis, padPos, padWrapper;
  
        target = target || this.element;
  
        for (i in this.handles) {
  
          if (this.handles[i].constructor === String) {
            this.handles[i] = this.element.children( this.handles[ i ] ).first().show();
          } else if ( this.handles[ i ].jquery || this.handles[ i ].nodeType ) {
            this.handles[ i ] = $( this.handles[ i ] );
            this._on( this.handles[ i ], { "mousedown": that._mouseDown });
          }
  
          if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {
  
            axis = $(this.handles[i], this.element);
  
            padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();
  
            padPos = [ "padding",
              /ne|nw|n/.test(i) ? "Top" :
              /se|sw|s/.test(i) ? "Bottom" :
              /^e$/.test(i) ? "Right" : "Left" ].join("");
  
            target.css(padPos, padWrapper);
  
            this._proportionallyResize();
          }
  
          this._handles = this._handles.add( this.handles[ i ] );
        }
      };
  
      // TODO: make renderAxis a prototype function
      this._renderAxis(this.element);
  
      this._handles = this._handles.add( this.element.find( ".ui-resizable-handle" ) );
      this._handles.disableSelection();
  
      this._handles.mouseover(function() {
        if (!that.resizing) {
          if (this.className) {
            axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
          }
          that.axis = axis && axis[1] ? axis[1] : "se";
        }
      });
  
      if (o.autoHide) {
        this._handles.hide();
        $(this.element)
          .addClass("ui-resizable-autohide")
          .mouseenter(function() {
            if (o.disabled) {
              return;
            }
            $(this).removeClass("ui-resizable-autohide");
            that._handles.show();
          })
          .mouseleave(function() {
            if (o.disabled) {
              return;
            }
            if (!that.resizing) {
              $(this).addClass("ui-resizable-autohide");
              that._handles.hide();
            }
          });
      }
  
      this._mouseInit();
    },
  
    _destroy: function() {
  
      this._mouseDestroy();
  
      var wrapper,
        _destroy = function(exp) {
          $(exp)
            .removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
            .removeData("resizable")
            .removeData("ui-resizable")
            .unbind(".resizable")
            .find(".ui-resizable-handle")
              .remove();
        };
  
      // TODO: Unwrap at same DOM position
      if (this.elementIsWrapper) {
        _destroy(this.element);
        wrapper = this.element;
        this.originalElement.css({
          position: wrapper.css("position"),
          width: wrapper.outerWidth(),
          height: wrapper.outerHeight(),
          top: wrapper.css("top"),
          left: wrapper.css("left")
        }).insertAfter( wrapper );
        wrapper.remove();
      }
  
      this.originalElement.css("resize", this.originalResizeStyle);
      _destroy(this.originalElement);
  
      return this;
    },
  
    _mouseCapture: function(event) {
      var i, handle,
        capture = false;
  
      for (i in this.handles) {
        handle = $(this.handles[i])[0];
        if (handle === event.target || $.contains(handle, event.target)) {
          capture = true;
        }
      }
  
      return !this.options.disabled && capture;
    },
  
    _mouseStart: function(event) {
  
      var curleft, curtop, cursor,
        o = this.options,
        el = this.element;
  
      this.resizing = true;
  
      this._renderProxy();
  
      curleft = this._num(this.helper.css("left"));
      curtop = this._num(this.helper.css("top"));
  
      if (o.containment) {
        curleft += $(o.containment).scrollLeft() || 0;
        curtop += $(o.containment).scrollTop() || 0;
      }
  
      this.offset = this.helper.offset();
      this.position = { left: curleft, top: curtop };
  
      this.size = this._helper ? {
          width: this.helper.width(),
          height: this.helper.height()
        } : {
          width: el.width(),
          height: el.height()
        };
  
      this.originalSize = this._helper ? {
          width: el.outerWidth(),
          height: el.outerHeight()
        } : {
          width: el.width(),
          height: el.height()
        };
  
      this.sizeDiff = {
        width: el.outerWidth() - el.width(),
        height: el.outerHeight() - el.height()
      };
  
      this.originalPosition = { left: curleft, top: curtop };
      this.originalMousePosition = { left: event.pageX, top: event.pageY };
  
      this.aspectRatio = (typeof o.aspectRatio === "number") ?
        o.aspectRatio :
        ((this.originalSize.width / this.originalSize.height) || 1);
  
      cursor = $(".ui-resizable-" + this.axis).css("cursor");
      $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);
  
      el.addClass("ui-resizable-resizing");
      this._propagate("start", event);
      return true;
    },
  
    _mouseDrag: function(event) {
  
      var data, props,
        smp = this.originalMousePosition,
        a = this.axis,
        dx = (event.pageX - smp.left) || 0,
        dy = (event.pageY - smp.top) || 0,
        trigger = this._change[a];
  
      this._updatePrevProperties();
  
      if (!trigger) {
        return false;
      }
  
      data = trigger.apply(this, [ event, dx, dy ]);
  
      this._updateVirtualBoundaries(event.shiftKey);
      if (this._aspectRatio || event.shiftKey) {
        data = this._updateRatio(data, event);
      }
  
      data = this._respectSize(data, event);
  
      this._updateCache(data);
  
      this._propagate("resize", event);
  
      props = this._applyChanges();
  
      if ( !this._helper && this._proportionallyResizeElements.length ) {
        this._proportionallyResize();
      }
  
      if ( !$.isEmptyObject( props ) ) {
        this._updatePrevProperties();
        this._trigger( "resize", event, this.ui() );
        this._applyChanges();
      }
  
      return false;
    },
  
    _mouseStop: function(event) {
  
      this.resizing = false;
      var pr, ista, soffseth, soffsetw, s, left, top,
        o = this.options, that = this;
  
      if (this._helper) {
  
        pr = this._proportionallyResizeElements;
        ista = pr.length && (/textarea/i).test(pr[0].nodeName);
        soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
        soffsetw = ista ? 0 : that.sizeDiff.width;
  
        s = {
          width: (that.helper.width()  - soffsetw),
          height: (that.helper.height() - soffseth)
        };
        left = (parseInt(that.element.css("left"), 10) +
          (that.position.left - that.originalPosition.left)) || null;
        top = (parseInt(that.element.css("top"), 10) +
          (that.position.top - that.originalPosition.top)) || null;
  
        if (!o.animate) {
          this.element.css($.extend(s, { top: top, left: left }));
        }
  
        that.helper.height(that.size.height);
        that.helper.width(that.size.width);
  
        if (this._helper && !o.animate) {
          this._proportionallyResize();
        }
      }
  
      $("body").css("cursor", "auto");
  
      this.element.removeClass("ui-resizable-resizing");
  
      this._propagate("stop", event);
  
      if (this._helper) {
        this.helper.remove();
      }
  
      return false;
  
    },
  
    _updatePrevProperties: function() {
      this.prevPosition = {
        top: this.position.top,
        left: this.position.left
      };
      this.prevSize = {
        width: this.size.width,
        height: this.size.height
      };
    },
  
    _applyChanges: function() {
      var props = {};
  
      if ( this.position.top !== this.prevPosition.top ) {
        props.top = this.position.top + "px";
      }
      if ( this.position.left !== this.prevPosition.left ) {
        props.left = this.position.left + "px";
      }
      if ( this.size.width !== this.prevSize.width ) {
        props.width = this.size.width + "px";
      }
      if ( this.size.height !== this.prevSize.height ) {
        props.height = this.size.height + "px";
      }
  
      this.helper.css( props );
  
      return props;
    },
  
    _updateVirtualBoundaries: function(forceAspectRatio) {
      var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
        o = this.options;
  
      b = {
        minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
        maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
        minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
        maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
      };
  
      if (this._aspectRatio || forceAspectRatio) {
        pMinWidth = b.minHeight * this.aspectRatio;
        pMinHeight = b.minWidth / this.aspectRatio;
        pMaxWidth = b.maxHeight * this.aspectRatio;
        pMaxHeight = b.maxWidth / this.aspectRatio;
  
        if (pMinWidth > b.minWidth) {
          b.minWidth = pMinWidth;
        }
        if (pMinHeight > b.minHeight) {
          b.minHeight = pMinHeight;
        }
        if (pMaxWidth < b.maxWidth) {
          b.maxWidth = pMaxWidth;
        }
        if (pMaxHeight < b.maxHeight) {
          b.maxHeight = pMaxHeight;
        }
      }
      this._vBoundaries = b;
    },
  
    _updateCache: function(data) {
      this.offset = this.helper.offset();
      if (this._isNumber(data.left)) {
        this.position.left = data.left;
      }
      if (this._isNumber(data.top)) {
        this.position.top = data.top;
      }
      if (this._isNumber(data.height)) {
        this.size.height = data.height;
      }
      if (this._isNumber(data.width)) {
        this.size.width = data.width;
      }
    },
  
    _updateRatio: function( data ) {
  
      var cpos = this.position,
        csize = this.size,
        a = this.axis;
  
      if (this._isNumber(data.height)) {
        data.width = (data.height * this.aspectRatio);
      } else if (this._isNumber(data.width)) {
        data.height = (data.width / this.aspectRatio);
      }
  
      if (a === "sw") {
        data.left = cpos.left + (csize.width - data.width);
        data.top = null;
      }
      if (a === "nw") {
        data.top = cpos.top + (csize.height - data.height);
        data.left = cpos.left + (csize.width - data.width);
      }
  
      return data;
    },
  
    _respectSize: function( data ) {
  
      var o = this._vBoundaries,
        a = this.axis,
        ismaxw = this._isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width),
        ismaxh = this._isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
        isminw = this._isNumber(data.width) && o.minWidth && (o.minWidth > data.width),
        isminh = this._isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
        dw = this.originalPosition.left + this.originalSize.width,
        dh = this.position.top + this.size.height,
        cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
      if (isminw) {
        data.width = o.minWidth;
      }
      if (isminh) {
        data.height = o.minHeight;
      }
      if (ismaxw) {
        data.width = o.maxWidth;
      }
      if (ismaxh) {
        data.height = o.maxHeight;
      }
  
      if (isminw && cw) {
        data.left = dw - o.minWidth;
      }
      if (ismaxw && cw) {
        data.left = dw - o.maxWidth;
      }
      if (isminh && ch) {
        data.top = dh - o.minHeight;
      }
      if (ismaxh && ch) {
        data.top = dh - o.maxHeight;
      }
  
      // Fixing jump error on top/left - bug #2330
      if (!data.width && !data.height && !data.left && data.top) {
        data.top = null;
      } else if (!data.width && !data.height && !data.top && data.left) {
        data.left = null;
      }
  
      return data;
    },
  
    _getPaddingPlusBorderDimensions: function( element ) {
      var i = 0,
        widths = [],
        borders = [
          element.css( "borderTopWidth" ),
          element.css( "borderRightWidth" ),
          element.css( "borderBottomWidth" ),
          element.css( "borderLeftWidth" )
        ],
        paddings = [
          element.css( "paddingTop" ),
          element.css( "paddingRight" ),
          element.css( "paddingBottom" ),
          element.css( "paddingLeft" )
        ];
  
      for ( ; i < 4; i++ ) {
        widths[ i ] = ( parseInt( borders[ i ], 10 ) || 0 );
        widths[ i ] += ( parseInt( paddings[ i ], 10 ) || 0 );
      }
  
      return {
        height: widths[ 0 ] + widths[ 2 ],
        width: widths[ 1 ] + widths[ 3 ]
      };
    },
  
    _proportionallyResize: function() {
  
      if (!this._proportionallyResizeElements.length) {
        return;
      }
  
      var prel,
        i = 0,
        element = this.helper || this.element;
  
      for ( ; i < this._proportionallyResizeElements.length; i++) {
  
        prel = this._proportionallyResizeElements[i];
  
        // TODO: Seems like a bug to cache this.outerDimensions
        // considering that we are in a loop.
        if (!this.outerDimensions) {
          this.outerDimensions = this._getPaddingPlusBorderDimensions( prel );
        }
  
        prel.css({
          height: (element.height() - this.outerDimensions.height) || 0,
          width: (element.width() - this.outerDimensions.width) || 0
        });
  
      }
  
    },
  
    _renderProxy: function() {
  
      var el = this.element, o = this.options;
      this.elementOffset = el.offset();
  
      if (this._helper) {
  
        this.helper = this.helper || $("<div style='overflow:hidden;'></div>");
  
        this.helper.addClass(this._helper).css({
          width: this.element.outerWidth() - 1,
          height: this.element.outerHeight() - 1,
          position: "absolute",
          left: this.elementOffset.left + "px",
          top: this.elementOffset.top + "px",
          zIndex: ++o.zIndex //TODO: Don't modify option
        });
  
        this.helper
          .appendTo("body")
          .disableSelection();
  
      } else {
        this.helper = this.element;
      }
  
    },
  
    _change: {
      e: function(event, dx) {
        return { width: this.originalSize.width + dx };
      },
      w: function(event, dx) {
        var cs = this.originalSize, sp = this.originalPosition;
        return { left: sp.left + dx, width: cs.width - dx };
      },
      n: function(event, dx, dy) {
        var cs = this.originalSize, sp = this.originalPosition;
        return { top: sp.top + dy, height: cs.height - dy };
      },
      s: function(event, dx, dy) {
        return { height: this.originalSize.height + dy };
      },
      se: function(event, dx, dy) {
        return $.extend(this._change.s.apply(this, arguments),
          this._change.e.apply(this, [ event, dx, dy ]));
      },
      sw: function(event, dx, dy) {
        return $.extend(this._change.s.apply(this, arguments),
          this._change.w.apply(this, [ event, dx, dy ]));
      },
      ne: function(event, dx, dy) {
        return $.extend(this._change.n.apply(this, arguments),
          this._change.e.apply(this, [ event, dx, dy ]));
      },
      nw: function(event, dx, dy) {
        return $.extend(this._change.n.apply(this, arguments),
          this._change.w.apply(this, [ event, dx, dy ]));
      }
    },
  
    _propagate: function(n, event) {
      $.ui.plugin.call(this, n, [ event, this.ui() ]);
      (n !== "resize" && this._trigger(n, event, this.ui()));
    },
  
    plugins: {},
  
    ui: function() {
      return {
        originalElement: this.originalElement,
        element: this.element,
        helper: this.helper,
        position: this.position,
        size: this.size,
        originalSize: this.originalSize,
        originalPosition: this.originalPosition
      };
    }
  
  });
  
  /*
   * Resizable Extensions
   */
  
  $.ui.plugin.add("resizable", "animate", {
  
    stop: function( event ) {
      var that = $(this).resizable( "instance" ),
        o = that.options,
        pr = that._proportionallyResizeElements,
        ista = pr.length && (/textarea/i).test(pr[0].nodeName),
        soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height,
        soffsetw = ista ? 0 : that.sizeDiff.width,
        style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
        left = (parseInt(that.element.css("left"), 10) +
          (that.position.left - that.originalPosition.left)) || null,
        top = (parseInt(that.element.css("top"), 10) +
          (that.position.top - that.originalPosition.top)) || null;
  
      that.element.animate(
        $.extend(style, top && left ? { top: top, left: left } : {}), {
          duration: o.animateDuration,
          easing: o.animateEasing,
          step: function() {
  
            var data = {
              width: parseInt(that.element.css("width"), 10),
              height: parseInt(that.element.css("height"), 10),
              top: parseInt(that.element.css("top"), 10),
              left: parseInt(that.element.css("left"), 10)
            };
  
            if (pr && pr.length) {
              $(pr[0]).css({ width: data.width, height: data.height });
            }
  
            // propagating resize, and updating values for each animation step
            that._updateCache(data);
            that._propagate("resize", event);
  
          }
        }
      );
    }
  
  });
  
  $.ui.plugin.add( "resizable", "containment", {
  
    start: function() {
      var element, p, co, ch, cw, width, height,
        that = $( this ).resizable( "instance" ),
        o = that.options,
        el = that.element,
        oc = o.containment,
        ce = ( oc instanceof $ ) ? oc.get( 0 ) : ( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;
  
      if ( !ce ) {
        return;
      }
  
      that.containerElement = $( ce );
  
      if ( /document/.test( oc ) || oc === document ) {
        that.containerOffset = {
          left: 0,
          top: 0
        };
        that.containerPosition = {
          left: 0,
          top: 0
        };
  
        that.parentData = {
          element: $( document ),
          left: 0,
          top: 0,
          width: $( document ).width(),
          height: $( document ).height() || document.body.parentNode.scrollHeight
        };
      } else {
        element = $( ce );
        p = [];
        $([ "Top", "Right", "Left", "Bottom" ]).each(function( i, name ) {
          p[ i ] = that._num( element.css( "padding" + name ) );
        });
  
        that.containerOffset = element.offset();
        that.containerPosition = element.position();
        that.containerSize = {
          height: ( element.innerHeight() - p[ 3 ] ),
          width: ( element.innerWidth() - p[ 1 ] )
        };
  
        co = that.containerOffset;
        ch = that.containerSize.height;
        cw = that.containerSize.width;
        width = ( that._hasScroll ( ce, "left" ) ? ce.scrollWidth : cw );
        height = ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;
  
        that.parentData = {
          element: ce,
          left: co.left,
          top: co.top,
          width: width,
          height: height
        };
      }
    },
  
    resize: function( event ) {
      var woset, hoset, isParent, isOffsetRelative,
        that = $( this ).resizable( "instance" ),
        o = that.options,
        co = that.containerOffset,
        cp = that.position,
        pRatio = that._aspectRatio || event.shiftKey,
        cop = {
          top: 0,
          left: 0
        },
        ce = that.containerElement,
        continueResize = true;
  
      if ( ce[ 0 ] !== document && ( /static/ ).test( ce.css( "position" ) ) ) {
        cop = co;
      }
  
      if ( cp.left < ( that._helper ? co.left : 0 ) ) {
        that.size.width = that.size.width +
          ( that._helper ?
            ( that.position.left - co.left ) :
            ( that.position.left - cop.left ) );
  
        if ( pRatio ) {
          that.size.height = that.size.width / that.aspectRatio;
          continueResize = false;
        }
        that.position.left = o.helper ? co.left : 0;
      }
  
      if ( cp.top < ( that._helper ? co.top : 0 ) ) {
        that.size.height = that.size.height +
          ( that._helper ?
            ( that.position.top - co.top ) :
            that.position.top );
  
        if ( pRatio ) {
          that.size.width = that.size.height * that.aspectRatio;
          continueResize = false;
        }
        that.position.top = that._helper ? co.top : 0;
      }
  
      isParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );
      isOffsetRelative = /relative|absolute/.test( that.containerElement.css( "position" ) );
  
      if ( isParent && isOffsetRelative ) {
        that.offset.left = that.parentData.left + that.position.left;
        that.offset.top = that.parentData.top + that.position.top;
      } else {
        that.offset.left = that.element.offset().left;
        that.offset.top = that.element.offset().top;
      }
  
      woset = Math.abs( that.sizeDiff.width +
        (that._helper ?
          that.offset.left - cop.left :
          (that.offset.left - co.left)) );
  
      hoset = Math.abs( that.sizeDiff.height +
        (that._helper ?
          that.offset.top - cop.top :
          (that.offset.top - co.top)) );
  
      if ( woset + that.size.width >= that.parentData.width ) {
        that.size.width = that.parentData.width - woset;
        if ( pRatio ) {
          that.size.height = that.size.width / that.aspectRatio;
          continueResize = false;
        }
      }
  
      if ( hoset + that.size.height >= that.parentData.height ) {
        that.size.height = that.parentData.height - hoset;
        if ( pRatio ) {
          that.size.width = that.size.height * that.aspectRatio;
          continueResize = false;
        }
      }
  
      if ( !continueResize ) {
        that.position.left = that.prevPosition.left;
        that.position.top = that.prevPosition.top;
        that.size.width = that.prevSize.width;
        that.size.height = that.prevSize.height;
      }
    },
  
    stop: function() {
      var that = $( this ).resizable( "instance" ),
        o = that.options,
        co = that.containerOffset,
        cop = that.containerPosition,
        ce = that.containerElement,
        helper = $( that.helper ),
        ho = helper.offset(),
        w = helper.outerWidth() - that.sizeDiff.width,
        h = helper.outerHeight() - that.sizeDiff.height;
  
      if ( that._helper && !o.animate && ( /relative/ ).test( ce.css( "position" ) ) ) {
        $( this ).css({
          left: ho.left - cop.left - co.left,
          width: w,
          height: h
        });
      }
  
      if ( that._helper && !o.animate && ( /static/ ).test( ce.css( "position" ) ) ) {
        $( this ).css({
          left: ho.left - cop.left - co.left,
          width: w,
          height: h
        });
      }
    }
  });
  
  $.ui.plugin.add("resizable", "alsoResize", {
  
    start: function() {
      var that = $(this).resizable( "instance" ),
        o = that.options;
  
      $(o.alsoResize).each(function() {
        var el = $(this);
        el.data("ui-resizable-alsoresize", {
          width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
          left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
        });
      });
    },
  
    resize: function(event, ui) {
      var that = $(this).resizable( "instance" ),
        o = that.options,
        os = that.originalSize,
        op = that.originalPosition,
        delta = {
          height: (that.size.height - os.height) || 0,
          width: (that.size.width - os.width) || 0,
          top: (that.position.top - op.top) || 0,
          left: (that.position.left - op.left) || 0
        };
  
        $(o.alsoResize).each(function() {
          var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
            css = el.parents(ui.originalElement[0]).length ?
                [ "width", "height" ] :
                [ "width", "height", "top", "left" ];
  
          $.each(css, function(i, prop) {
            var sum = (start[prop] || 0) + (delta[prop] || 0);
            if (sum && sum >= 0) {
              style[prop] = sum || null;
            }
          });
  
          el.css(style);
        });
    },
  
    stop: function() {
      $(this).removeData("resizable-alsoresize");
    }
  });
  
  $.ui.plugin.add("resizable", "ghost", {
  
    start: function() {
  
      var that = $(this).resizable( "instance" ), o = that.options, cs = that.size;
  
      that.ghost = that.originalElement.clone();
      that.ghost
        .css({
          opacity: 0.25,
          display: "block",
          position: "relative",
          height: cs.height,
          width: cs.width,
          margin: 0,
          left: 0,
          top: 0
        })
        .addClass("ui-resizable-ghost")
        .addClass(typeof o.ghost === "string" ? o.ghost : "");
  
      that.ghost.appendTo(that.helper);
  
    },
  
    resize: function() {
      var that = $(this).resizable( "instance" );
      if (that.ghost) {
        that.ghost.css({
          position: "relative",
          height: that.size.height,
          width: that.size.width
        });
      }
    },
  
    stop: function() {
      var that = $(this).resizable( "instance" );
      if (that.ghost && that.helper) {
        that.helper.get(0).removeChild(that.ghost.get(0));
      }
    }
  
  });
  
  $.ui.plugin.add("resizable", "grid", {
  
    resize: function() {
      var outerDimensions,
        that = $(this).resizable( "instance" ),
        o = that.options,
        cs = that.size,
        os = that.originalSize,
        op = that.originalPosition,
        a = that.axis,
        grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid,
        gridX = (grid[0] || 1),
        gridY = (grid[1] || 1),
        ox = Math.round((cs.width - os.width) / gridX) * gridX,
        oy = Math.round((cs.height - os.height) / gridY) * gridY,
        newWidth = os.width + ox,
        newHeight = os.height + oy,
        isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
        isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
        isMinWidth = o.minWidth && (o.minWidth > newWidth),
        isMinHeight = o.minHeight && (o.minHeight > newHeight);
  
      o.grid = grid;
  
      if (isMinWidth) {
        newWidth += gridX;
      }
      if (isMinHeight) {
        newHeight += gridY;
      }
      if (isMaxWidth) {
        newWidth -= gridX;
      }
      if (isMaxHeight) {
        newHeight -= gridY;
      }
  
      if (/^(se|s|e)$/.test(a)) {
        that.size.width = newWidth;
        that.size.height = newHeight;
      } else if (/^(ne)$/.test(a)) {
        that.size.width = newWidth;
        that.size.height = newHeight;
        that.position.top = op.top - oy;
      } else if (/^(sw)$/.test(a)) {
        that.size.width = newWidth;
        that.size.height = newHeight;
        that.position.left = op.left - ox;
      } else {
        if ( newHeight - gridY <= 0 || newWidth - gridX <= 0) {
          outerDimensions = that._getPaddingPlusBorderDimensions( this );
        }
  
        if ( newHeight - gridY > 0 ) {
          that.size.height = newHeight;
          that.position.top = op.top - oy;
        } else {
          newHeight = gridY - outerDimensions.height;
          that.size.height = newHeight;
          that.position.top = op.top + os.height - newHeight;
        }
        if ( newWidth - gridX > 0 ) {
          that.size.width = newWidth;
          that.position.left = op.left - ox;
        } else {
          newWidth = gridX - outerDimensions.width;
          that.size.width = newWidth;
          that.position.left = op.left + os.width - newWidth;
        }
      }
    }
  
  });
  
  var resizable = $.ui.resizable;
  
  
  /*!
   * jQuery UI Dialog 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/dialog/
   */
  
  
  var dialog = $.widget( "ui.dialog", {
    version: "1.11.4",
    options: {
      appendTo: "body",
      autoOpen: true,
      buttons: [],
      closeOnEscape: true,
      closeText: "Close",
      dialogClass: "",
      draggable: true,
      hide: null,
      height: "auto",
      maxHeight: null,
      maxWidth: null,
      minHeight: 150,
      minWidth: 150,
      modal: false,
      position: {
        my: "center",
        at: "center",
        of: window,
        collision: "fit",
        // Ensure the titlebar is always visible
        using: function( pos ) {
          var topOffset = $( this ).css( pos ).offset().top;
          if ( topOffset < 0 ) {
            $( this ).css( "top", pos.top - topOffset );
          }
        }
      },
      resizable: true,
      show: null,
      title: null,
      width: 300,
  
      // callbacks
      beforeClose: null,
      close: null,
      drag: null,
      dragStart: null,
      dragStop: null,
      focus: null,
      open: null,
      resize: null,
      resizeStart: null,
      resizeStop: null
    },
  
    sizeRelatedOptions: {
      buttons: true,
      height: true,
      maxHeight: true,
      maxWidth: true,
      minHeight: true,
      minWidth: true,
      width: true
    },
  
    resizableRelatedOptions: {
      maxHeight: true,
      maxWidth: true,
      minHeight: true,
      minWidth: true
    },
  
    _create: function() {
      this.originalCss = {
        display: this.element[ 0 ].style.display,
        width: this.element[ 0 ].style.width,
        minHeight: this.element[ 0 ].style.minHeight,
        maxHeight: this.element[ 0 ].style.maxHeight,
        height: this.element[ 0 ].style.height
      };
      this.originalPosition = {
        parent: this.element.parent(),
        index: this.element.parent().children().index( this.element )
      };
      this.originalTitle = this.element.attr( "title" );
      this.options.title = this.options.title || this.originalTitle;
  
      this._createWrapper();
  
      this.element
        .show()
        .removeAttr( "title" )
        .addClass( "ui-dialog-content ui-widget-content" )
        .appendTo( this.uiDialog );
  
      this._createTitlebar();
      this._createButtonPane();
  
      if ( this.options.draggable && $.fn.draggable ) {
        this._makeDraggable();
      }
      if ( this.options.resizable && $.fn.resizable ) {
        this._makeResizable();
      }
  
      this._isOpen = false;
  
      this._trackFocus();
    },
  
    _init: function() {
      if ( this.options.autoOpen ) {
        this.open();
      }
    },
  
    _appendTo: function() {
      var element = this.options.appendTo;
      if ( element && (element.jquery || element.nodeType) ) {
        return $( element );
      }
      return this.document.find( element || "body" ).eq( 0 );
    },
  
    _destroy: function() {
      var next,
        originalPosition = this.originalPosition;
  
      this._untrackInstance();
      this._destroyOverlay();
  
      this.element
        .removeUniqueId()
        .removeClass( "ui-dialog-content ui-widget-content" )
        .css( this.originalCss )
        // Without detaching first, the following becomes really slow
        .detach();
  
      this.uiDialog.stop( true, true ).remove();
  
      if ( this.originalTitle ) {
        this.element.attr( "title", this.originalTitle );
      }
  
      next = originalPosition.parent.children().eq( originalPosition.index );
      // Don't try to place the dialog next to itself (#8613)
      if ( next.length && next[ 0 ] !== this.element[ 0 ] ) {
        next.before( this.element );
      } else {
        originalPosition.parent.append( this.element );
      }
    },
  
    widget: function() {
      return this.uiDialog;
    },
  
    disable: $.noop,
    enable: $.noop,
  
    close: function( event ) {
      var activeElement,
        that = this;
  
      if ( !this._isOpen || this._trigger( "beforeClose", event ) === false ) {
        return;
      }
  
      this._isOpen = false;
      this._focusedElement = null;
      this._destroyOverlay();
      this._untrackInstance();
  
      if ( !this.opener.filter( ":focusable" ).focus().length ) {
  
        // support: IE9
        // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
        try {
          activeElement = this.document[ 0 ].activeElement;
  
          // Support: IE9, IE10
          // If the <body> is blurred, IE will switch windows, see #4520
          if ( activeElement && activeElement.nodeName.toLowerCase() !== "body" ) {
  
            // Hiding a focused element doesn't trigger blur in WebKit
            // so in case we have nothing to focus on, explicitly blur the active element
            // https://bugs.webkit.org/show_bug.cgi?id=47182
            $( activeElement ).blur();
          }
        } catch ( error ) {}
      }
  
      this._hide( this.uiDialog, this.options.hide, function() {
        that._trigger( "close", event );
      });
    },
  
    isOpen: function() {
      return this._isOpen;
    },
  
    moveToTop: function() {
      this._moveToTop();
    },
  
    _moveToTop: function( event, silent ) {
      var moved = false,
        zIndices = this.uiDialog.siblings( ".ui-front:visible" ).map(function() {
          return +$( this ).css( "z-index" );
        }).get(),
        zIndexMax = Math.max.apply( null, zIndices );
  
      if ( zIndexMax >= +this.uiDialog.css( "z-index" ) ) {
        this.uiDialog.css( "z-index", zIndexMax + 1 );
        moved = true;
      }
  
      if ( moved && !silent ) {
        this._trigger( "focus", event );
      }
      return moved;
    },
  
    open: function() {
      var that = this;
      if ( this._isOpen ) {
        if ( this._moveToTop() ) {
          this._focusTabbable();
        }
        return;
      }
  
      this._isOpen = true;
      this.opener = $( this.document[ 0 ].activeElement );
  
      this._size();
      this._position();
      this._createOverlay();
      this._moveToTop( null, true );
  
      // Ensure the overlay is moved to the top with the dialog, but only when
      // opening. The overlay shouldn't move after the dialog is open so that
      // modeless dialogs opened after the modal dialog stack properly.
      if ( this.overlay ) {
        this.overlay.css( "z-index", this.uiDialog.css( "z-index" ) - 1 );
      }
  
      this._show( this.uiDialog, this.options.show, function() {
        that._focusTabbable();
        that._trigger( "focus" );
      });
  
      // Track the dialog immediately upon openening in case a focus event
      // somehow occurs outside of the dialog before an element inside the
      // dialog is focused (#10152)
      this._makeFocusTarget();
  
      this._trigger( "open" );
    },
  
    _focusTabbable: function() {
      // Set focus to the first match:
      // 1. An element that was focused previously
      // 2. First element inside the dialog matching [autofocus]
      // 3. Tabbable element inside the content element
      // 4. Tabbable element inside the buttonpane
      // 5. The close button
      // 6. The dialog itself
      var hasFocus = this._focusedElement;
      if ( !hasFocus ) {
        hasFocus = this.element.find( "[autofocus]" );
      }
      if ( !hasFocus.length ) {
        hasFocus = this.element.find( ":tabbable" );
      }
      if ( !hasFocus.length ) {
        hasFocus = this.uiDialogButtonPane.find( ":tabbable" );
      }
      if ( !hasFocus.length ) {
        hasFocus = this.uiDialogTitlebarClose.filter( ":tabbable" );
      }
      if ( !hasFocus.length ) {
        hasFocus = this.uiDialog;
      }
      hasFocus.eq( 0 ).focus();
    },
  
    _keepFocus: function( event ) {
      function checkFocus() {
        var activeElement = this.document[0].activeElement,
          isActive = this.uiDialog[0] === activeElement ||
            $.contains( this.uiDialog[0], activeElement );
        if ( !isActive ) {
          this._focusTabbable();
        }
      }
      event.preventDefault();
      checkFocus.call( this );
      // support: IE
      // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
      // so we check again later
      this._delay( checkFocus );
    },
  
    _createWrapper: function() {
      this.uiDialog = $("<div>")
        .addClass( "ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " +
          this.options.dialogClass )
        .hide()
        .attr({
          // Setting tabIndex makes the div focusable
          tabIndex: -1,
          role: "dialog"
        })
        .appendTo( this._appendTo() );
  
      this._on( this.uiDialog, {
        keydown: function( event ) {
          if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
              event.keyCode === $.ui.keyCode.ESCAPE ) {
            event.preventDefault();
            this.close( event );
            return;
          }
  
          // prevent tabbing out of dialogs
          if ( event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented() ) {
            return;
          }
          var tabbables = this.uiDialog.find( ":tabbable" ),
            first = tabbables.filter( ":first" ),
            last = tabbables.filter( ":last" );
  
          if ( ( event.target === last[0] || event.target === this.uiDialog[0] ) && !event.shiftKey ) {
            this._delay(function() {
              first.focus();
            });
            event.preventDefault();
          } else if ( ( event.target === first[0] || event.target === this.uiDialog[0] ) && event.shiftKey ) {
            this._delay(function() {
              last.focus();
            });
            event.preventDefault();
          }
        },
        mousedown: function( event ) {
          if ( this._moveToTop( event ) ) {
            this._focusTabbable();
          }
        }
      });
  
      // We assume that any existing aria-describedby attribute means
      // that the dialog content is marked up properly
      // otherwise we brute force the content as the description
      if ( !this.element.find( "[aria-describedby]" ).length ) {
        this.uiDialog.attr({
          "aria-describedby": this.element.uniqueId().attr( "id" )
        });
      }
    },
  
    _createTitlebar: function() {
      var uiDialogTitle;
  
      this.uiDialogTitlebar = $( "<div>" )
        .addClass( "ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix" )
        .prependTo( this.uiDialog );
      this._on( this.uiDialogTitlebar, {
        mousedown: function( event ) {
          // Don't prevent click on close button (#8838)
          // Focusing a dialog that is partially scrolled out of view
          // causes the browser to scroll it into view, preventing the click event
          if ( !$( event.target ).closest( ".ui-dialog-titlebar-close" ) ) {
            // Dialog isn't getting focus when dragging (#8063)
            this.uiDialog.focus();
          }
        }
      });
  
      // support: IE
      // Use type="button" to prevent enter keypresses in textboxes from closing the
      // dialog in IE (#9312)
      this.uiDialogTitlebarClose = $( "<button type='button'></button>" )
        .button({
          label: this.options.closeText,
          icons: {
            primary: "ui-icon-closethick"
          },
          text: false
        })
        .addClass( "ui-dialog-titlebar-close" )
        .appendTo( this.uiDialogTitlebar );
      this._on( this.uiDialogTitlebarClose, {
        click: function( event ) {
          event.preventDefault();
          this.close( event );
        }
      });
  
      uiDialogTitle = $( "<span>" )
        .uniqueId()
        .addClass( "ui-dialog-title" )
        .prependTo( this.uiDialogTitlebar );
      this._title( uiDialogTitle );
  
      this.uiDialog.attr({
        "aria-labelledby": uiDialogTitle.attr( "id" )
      });
    },
  
    _title: function( title ) {
      if ( !this.options.title ) {
        title.html( "&#160;" );
      }
      title.text( this.options.title );
    },
  
    _createButtonPane: function() {
      this.uiDialogButtonPane = $( "<div>" )
        .addClass( "ui-dialog-buttonpane ui-widget-content ui-helper-clearfix" );
  
      this.uiButtonSet = $( "<div>" )
        .addClass( "ui-dialog-buttonset" )
        .appendTo( this.uiDialogButtonPane );
  
      this._createButtons();
    },
  
    _createButtons: function() {
      var that = this,
        buttons = this.options.buttons;
  
      // if we already have a button pane, remove it
      this.uiDialogButtonPane.remove();
      this.uiButtonSet.empty();
  
      if ( $.isEmptyObject( buttons ) || ($.isArray( buttons ) && !buttons.length) ) {
        this.uiDialog.removeClass( "ui-dialog-buttons" );
        return;
      }
  
      $.each( buttons, function( name, props ) {
        var click, buttonOptions;
        props = $.isFunction( props ) ?
          { click: props, text: name } :
          props;
        // Default to a non-submitting button
        props = $.extend( { type: "button" }, props );
        // Change the context for the click callback to be the main element
        click = props.click;
        props.click = function() {
          click.apply( that.element[ 0 ], arguments );
        };
        buttonOptions = {
          icons: props.icons,
          text: props.showText
        };
        delete props.icons;
        delete props.showText;
        $( "<button></button>", props )
          .button( buttonOptions )
          .appendTo( that.uiButtonSet );
      });
      this.uiDialog.addClass( "ui-dialog-buttons" );
      this.uiDialogButtonPane.appendTo( this.uiDialog );
    },
  
    _makeDraggable: function() {
      var that = this,
        options = this.options;
  
      function filteredUi( ui ) {
        return {
          position: ui.position,
          offset: ui.offset
        };
      }
  
      this.uiDialog.draggable({
        cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
        handle: ".ui-dialog-titlebar",
        containment: "document",
        start: function( event, ui ) {
          $( this ).addClass( "ui-dialog-dragging" );
          that._blockFrames();
          that._trigger( "dragStart", event, filteredUi( ui ) );
        },
        drag: function( event, ui ) {
          that._trigger( "drag", event, filteredUi( ui ) );
        },
        stop: function( event, ui ) {
          var left = ui.offset.left - that.document.scrollLeft(),
            top = ui.offset.top - that.document.scrollTop();
  
          options.position = {
            my: "left top",
            at: "left" + (left >= 0 ? "+" : "") + left + " " +
              "top" + (top >= 0 ? "+" : "") + top,
            of: that.window
          };
          $( this ).removeClass( "ui-dialog-dragging" );
          that._unblockFrames();
          that._trigger( "dragStop", event, filteredUi( ui ) );
        }
      });
    },
  
    _makeResizable: function() {
      var that = this,
        options = this.options,
        handles = options.resizable,
        // .ui-resizable has position: relative defined in the stylesheet
        // but dialogs have to use absolute or fixed positioning
        position = this.uiDialog.css("position"),
        resizeHandles = typeof handles === "string" ?
          handles	:
          "n,e,s,w,se,sw,ne,nw";
  
      function filteredUi( ui ) {
        return {
          originalPosition: ui.originalPosition,
          originalSize: ui.originalSize,
          position: ui.position,
          size: ui.size
        };
      }
  
      this.uiDialog.resizable({
        cancel: ".ui-dialog-content",
        containment: "document",
        alsoResize: this.element,
        maxWidth: options.maxWidth,
        maxHeight: options.maxHeight,
        minWidth: options.minWidth,
        minHeight: this._minHeight(),
        handles: resizeHandles,
        start: function( event, ui ) {
          $( this ).addClass( "ui-dialog-resizing" );
          that._blockFrames();
          that._trigger( "resizeStart", event, filteredUi( ui ) );
        },
        resize: function( event, ui ) {
          that._trigger( "resize", event, filteredUi( ui ) );
        },
        stop: function( event, ui ) {
          var offset = that.uiDialog.offset(),
            left = offset.left - that.document.scrollLeft(),
            top = offset.top - that.document.scrollTop();
  
          options.height = that.uiDialog.height();
          options.width = that.uiDialog.width();
          options.position = {
            my: "left top",
            at: "left" + (left >= 0 ? "+" : "") + left + " " +
              "top" + (top >= 0 ? "+" : "") + top,
            of: that.window
          };
          $( this ).removeClass( "ui-dialog-resizing" );
          that._unblockFrames();
          that._trigger( "resizeStop", event, filteredUi( ui ) );
        }
      })
      .css( "position", position );
    },
  
    _trackFocus: function() {
      this._on( this.widget(), {
        focusin: function( event ) {
          this._makeFocusTarget();
          this._focusedElement = $( event.target );
        }
      });
    },
  
    _makeFocusTarget: function() {
      this._untrackInstance();
      this._trackingInstances().unshift( this );
    },
  
    _untrackInstance: function() {
      var instances = this._trackingInstances(),
        exists = $.inArray( this, instances );
      if ( exists !== -1 ) {
        instances.splice( exists, 1 );
      }
    },
  
    _trackingInstances: function() {
      var instances = this.document.data( "ui-dialog-instances" );
      if ( !instances ) {
        instances = [];
        this.document.data( "ui-dialog-instances", instances );
      }
      return instances;
    },
  
    _minHeight: function() {
      var options = this.options;
  
      return options.height === "auto" ?
        options.minHeight :
        Math.min( options.minHeight, options.height );
    },
  
    _position: function() {
      // Need to show the dialog to get the actual offset in the position plugin
      var isVisible = this.uiDialog.is( ":visible" );
      if ( !isVisible ) {
        this.uiDialog.show();
      }
      this.uiDialog.position( this.options.position );
      if ( !isVisible ) {
        this.uiDialog.hide();
      }
    },
  
    _setOptions: function( options ) {
      var that = this,
        resize = false,
        resizableOptions = {};
  
      $.each( options, function( key, value ) {
        that._setOption( key, value );
  
        if ( key in that.sizeRelatedOptions ) {
          resize = true;
        }
        if ( key in that.resizableRelatedOptions ) {
          resizableOptions[ key ] = value;
        }
      });
  
      if ( resize ) {
        this._size();
        this._position();
      }
      if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
        this.uiDialog.resizable( "option", resizableOptions );
      }
    },
  
    _setOption: function( key, value ) {
      var isDraggable, isResizable,
        uiDialog = this.uiDialog;
  
      if ( key === "dialogClass" ) {
        uiDialog
          .removeClass( this.options.dialogClass )
          .addClass( value );
      }
  
      if ( key === "disabled" ) {
        return;
      }
  
      this._super( key, value );
  
      if ( key === "appendTo" ) {
        this.uiDialog.appendTo( this._appendTo() );
      }
  
      if ( key === "buttons" ) {
        this._createButtons();
      }
  
      if ( key === "closeText" ) {
        this.uiDialogTitlebarClose.button({
          // Ensure that we always pass a string
          label: "" + value
        });
      }
  
      if ( key === "draggable" ) {
        isDraggable = uiDialog.is( ":data(ui-draggable)" );
        if ( isDraggable && !value ) {
          uiDialog.draggable( "destroy" );
        }
  
        if ( !isDraggable && value ) {
          this._makeDraggable();
        }
      }
  
      if ( key === "position" ) {
        this._position();
      }
  
      if ( key === "resizable" ) {
        // currently resizable, becoming non-resizable
        isResizable = uiDialog.is( ":data(ui-resizable)" );
        if ( isResizable && !value ) {
          uiDialog.resizable( "destroy" );
        }
  
        // currently resizable, changing handles
        if ( isResizable && typeof value === "string" ) {
          uiDialog.resizable( "option", "handles", value );
        }
  
        // currently non-resizable, becoming resizable
        if ( !isResizable && value !== false ) {
          this._makeResizable();
        }
      }
  
      if ( key === "title" ) {
        this._title( this.uiDialogTitlebar.find( ".ui-dialog-title" ) );
      }
    },
  
    _size: function() {
      // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
      // divs will both have width and height set, so we need to reset them
      var nonContentHeight, minContentHeight, maxContentHeight,
        options = this.options;
  
      // Reset content sizing
      this.element.show().css({
        width: "auto",
        minHeight: 0,
        maxHeight: "none",
        height: 0
      });
  
      if ( options.minWidth > options.width ) {
        options.width = options.minWidth;
      }
  
      // reset wrapper sizing
      // determine the height of all the non-content elements
      nonContentHeight = this.uiDialog.css({
          height: "auto",
          width: options.width
        })
        .outerHeight();
      minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
      maxContentHeight = typeof options.maxHeight === "number" ?
        Math.max( 0, options.maxHeight - nonContentHeight ) :
        "none";
  
      if ( options.height === "auto" ) {
        this.element.css({
          minHeight: minContentHeight,
          maxHeight: maxContentHeight,
          height: "auto"
        });
      } else {
        this.element.height( Math.max( 0, options.height - nonContentHeight ) );
      }
  
      if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
        this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
      }
    },
  
    _blockFrames: function() {
      this.iframeBlocks = this.document.find( "iframe" ).map(function() {
        var iframe = $( this );
  
        return $( "<div>" )
          .css({
            position: "absolute",
            width: iframe.outerWidth(),
            height: iframe.outerHeight()
          })
          .appendTo( iframe.parent() )
          .offset( iframe.offset() )[0];
      });
    },
  
    _unblockFrames: function() {
      if ( this.iframeBlocks ) {
        this.iframeBlocks.remove();
        delete this.iframeBlocks;
      }
    },
  
    _allowInteraction: function( event ) {
      if ( $( event.target ).closest( ".ui-dialog" ).length ) {
        return true;
      }
  
      // TODO: Remove hack when datepicker implements
      // the .ui-front logic (#8989)
      return !!$( event.target ).closest( ".ui-datepicker" ).length;
    },
  
    _createOverlay: function() {
      if ( !this.options.modal ) {
        return;
      }
  
      // We use a delay in case the overlay is created from an
      // event that we're going to be cancelling (#2804)
      var isOpening = true;
      this._delay(function() {
        isOpening = false;
      });
  
      if ( !this.document.data( "ui-dialog-overlays" ) ) {
  
        // Prevent use of anchors and inputs
        // Using _on() for an event handler shared across many instances is
        // safe because the dialogs stack and must be closed in reverse order
        this._on( this.document, {
          focusin: function( event ) {
            if ( isOpening ) {
              return;
            }
  
            if ( !this._allowInteraction( event ) ) {
              event.preventDefault();
              this._trackingInstances()[ 0 ]._focusTabbable();
            }
          }
        });
      }
  
      this.overlay = $( "<div>" )
        .addClass( "ui-widget-overlay ui-front" )
        .appendTo( this._appendTo() );
      this._on( this.overlay, {
        mousedown: "_keepFocus"
      });
      this.document.data( "ui-dialog-overlays",
        (this.document.data( "ui-dialog-overlays" ) || 0) + 1 );
    },
  
    _destroyOverlay: function() {
      if ( !this.options.modal ) {
        return;
      }
  
      if ( this.overlay ) {
        var overlays = this.document.data( "ui-dialog-overlays" ) - 1;
  
        if ( !overlays ) {
          this.document
            .unbind( "focusin" )
            .removeData( "ui-dialog-overlays" );
        } else {
          this.document.data( "ui-dialog-overlays", overlays );
        }
  
        this.overlay.remove();
        this.overlay = null;
      }
    }
  });
  
  
  /*!
   * jQuery UI Droppable 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/droppable/
   */
  
  
  $.widget( "ui.droppable", {
    version: "1.11.4",
    widgetEventPrefix: "drop",
    options: {
      accept: "*",
      activeClass: false,
      addClasses: true,
      greedy: false,
      hoverClass: false,
      scope: "default",
      tolerance: "intersect",
  
      // callbacks
      activate: null,
      deactivate: null,
      drop: null,
      out: null,
      over: null
    },
    _create: function() {
  
      var proportions,
        o = this.options,
        accept = o.accept;
  
      this.isover = false;
      this.isout = true;
  
      this.accept = $.isFunction( accept ) ? accept : function( d ) {
        return d.is( accept );
      };
  
      this.proportions = function( /* valueToWrite */ ) {
        if ( arguments.length ) {
          // Store the droppable's proportions
          proportions = arguments[ 0 ];
        } else {
          // Retrieve or derive the droppable's proportions
          return proportions ?
            proportions :
            proportions = {
              width: this.element[ 0 ].offsetWidth,
              height: this.element[ 0 ].offsetHeight
            };
        }
      };
  
      this._addToManager( o.scope );
  
      o.addClasses && this.element.addClass( "ui-droppable" );
  
    },
  
    _addToManager: function( scope ) {
      // Add the reference and positions to the manager
      $.ui.ddmanager.droppables[ scope ] = $.ui.ddmanager.droppables[ scope ] || [];
      $.ui.ddmanager.droppables[ scope ].push( this );
    },
  
    _splice: function( drop ) {
      var i = 0;
      for ( ; i < drop.length; i++ ) {
        if ( drop[ i ] === this ) {
          drop.splice( i, 1 );
        }
      }
    },
  
    _destroy: function() {
      var drop = $.ui.ddmanager.droppables[ this.options.scope ];
  
      this._splice( drop );
  
      this.element.removeClass( "ui-droppable ui-droppable-disabled" );
    },
  
    _setOption: function( key, value ) {
  
      if ( key === "accept" ) {
        this.accept = $.isFunction( value ) ? value : function( d ) {
          return d.is( value );
        };
      } else if ( key === "scope" ) {
        var drop = $.ui.ddmanager.droppables[ this.options.scope ];
  
        this._splice( drop );
        this._addToManager( value );
      }
  
      this._super( key, value );
    },
  
    _activate: function( event ) {
      var draggable = $.ui.ddmanager.current;
      if ( this.options.activeClass ) {
        this.element.addClass( this.options.activeClass );
      }
      if ( draggable ){
        this._trigger( "activate", event, this.ui( draggable ) );
      }
    },
  
    _deactivate: function( event ) {
      var draggable = $.ui.ddmanager.current;
      if ( this.options.activeClass ) {
        this.element.removeClass( this.options.activeClass );
      }
      if ( draggable ){
        this._trigger( "deactivate", event, this.ui( draggable ) );
      }
    },
  
    _over: function( event ) {
  
      var draggable = $.ui.ddmanager.current;
  
      // Bail if draggable and droppable are same element
      if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
        return;
      }
  
      if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
        if ( this.options.hoverClass ) {
          this.element.addClass( this.options.hoverClass );
        }
        this._trigger( "over", event, this.ui( draggable ) );
      }
  
    },
  
    _out: function( event ) {
  
      var draggable = $.ui.ddmanager.current;
  
      // Bail if draggable and droppable are same element
      if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
        return;
      }
  
      if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
        if ( this.options.hoverClass ) {
          this.element.removeClass( this.options.hoverClass );
        }
        this._trigger( "out", event, this.ui( draggable ) );
      }
  
    },
  
    _drop: function( event, custom ) {
  
      var draggable = custom || $.ui.ddmanager.current,
        childrenIntersection = false;
  
      // Bail if draggable and droppable are same element
      if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
        return false;
      }
  
      this.element.find( ":data(ui-droppable)" ).not( ".ui-draggable-dragging" ).each(function() {
        var inst = $( this ).droppable( "instance" );
        if (
          inst.options.greedy &&
          !inst.options.disabled &&
          inst.options.scope === draggable.options.scope &&
          inst.accept.call( inst.element[ 0 ], ( draggable.currentItem || draggable.element ) ) &&
          $.ui.intersect( draggable, $.extend( inst, { offset: inst.element.offset() } ), inst.options.tolerance, event )
        ) { childrenIntersection = true; return false; }
      });
      if ( childrenIntersection ) {
        return false;
      }
  
      if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
        if ( this.options.activeClass ) {
          this.element.removeClass( this.options.activeClass );
        }
        if ( this.options.hoverClass ) {
          this.element.removeClass( this.options.hoverClass );
        }
        this._trigger( "drop", event, this.ui( draggable ) );
        return this.element;
      }
  
      return false;
  
    },
  
    ui: function( c ) {
      return {
        draggable: ( c.currentItem || c.element ),
        helper: c.helper,
        position: c.position,
        offset: c.positionAbs
      };
    }
  
  });
  
  $.ui.intersect = (function() {
    function isOverAxis( x, reference, size ) {
      return ( x >= reference ) && ( x < ( reference + size ) );
    }
  
    return function( draggable, droppable, toleranceMode, event ) {
  
      if ( !droppable.offset ) {
        return false;
      }
  
      var x1 = ( draggable.positionAbs || draggable.position.absolute ).left + draggable.margins.left,
        y1 = ( draggable.positionAbs || draggable.position.absolute ).top + draggable.margins.top,
        x2 = x1 + draggable.helperProportions.width,
        y2 = y1 + draggable.helperProportions.height,
        l = droppable.offset.left,
        t = droppable.offset.top,
        r = l + droppable.proportions().width,
        b = t + droppable.proportions().height;
  
      switch ( toleranceMode ) {
      case "fit":
        return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );
      case "intersect":
        return ( l < x1 + ( draggable.helperProportions.width / 2 ) && // Right Half
          x2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half
          t < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half
          y2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half
      case "pointer":
        return isOverAxis( event.pageY, t, droppable.proportions().height ) && isOverAxis( event.pageX, l, droppable.proportions().width );
      case "touch":
        return (
          ( y1 >= t && y1 <= b ) || // Top edge touching
          ( y2 >= t && y2 <= b ) || // Bottom edge touching
          ( y1 < t && y2 > b ) // Surrounded vertically
        ) && (
          ( x1 >= l && x1 <= r ) || // Left edge touching
          ( x2 >= l && x2 <= r ) || // Right edge touching
          ( x1 < l && x2 > r ) // Surrounded horizontally
        );
      default:
        return false;
      }
    };
  })();
  
  /*
    This manager tracks offsets of draggables and droppables
  */
  $.ui.ddmanager = {
    current: null,
    droppables: { "default": [] },
    prepareOffsets: function( t, event ) {
  
      var i, j,
        m = $.ui.ddmanager.droppables[ t.options.scope ] || [],
        type = event ? event.type : null, // workaround for #2317
        list = ( t.currentItem || t.element ).find( ":data(ui-droppable)" ).addBack();
  
      droppablesLoop: for ( i = 0; i < m.length; i++ ) {
  
        // No disabled and non-accepted
        if ( m[ i ].options.disabled || ( t && !m[ i ].accept.call( m[ i ].element[ 0 ], ( t.currentItem || t.element ) ) ) ) {
          continue;
        }
  
        // Filter out elements in the current dragged item
        for ( j = 0; j < list.length; j++ ) {
          if ( list[ j ] === m[ i ].element[ 0 ] ) {
            m[ i ].proportions().height = 0;
            continue droppablesLoop;
          }
        }
  
        m[ i ].visible = m[ i ].element.css( "display" ) !== "none";
        if ( !m[ i ].visible ) {
          continue;
        }
  
        // Activate the droppable if used directly from draggables
        if ( type === "mousedown" ) {
          m[ i ]._activate.call( m[ i ], event );
        }
  
        m[ i ].offset = m[ i ].element.offset();
        m[ i ].proportions({ width: m[ i ].element[ 0 ].offsetWidth, height: m[ i ].element[ 0 ].offsetHeight });
  
      }
  
    },
    drop: function( draggable, event ) {
  
      var dropped = false;
      // Create a copy of the droppables in case the list changes during the drop (#9116)
      $.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] ).slice(), function() {
  
        if ( !this.options ) {
          return;
        }
        if ( !this.options.disabled && this.visible && $.ui.intersect( draggable, this, this.options.tolerance, event ) ) {
          dropped = this._drop.call( this, event ) || dropped;
        }
  
        if ( !this.options.disabled && this.visible && this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
          this.isout = true;
          this.isover = false;
          this._deactivate.call( this, event );
        }
  
      });
      return dropped;
  
    },
    dragStart: function( draggable, event ) {
      // Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
      draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
        if ( !draggable.options.refreshPositions ) {
          $.ui.ddmanager.prepareOffsets( draggable, event );
        }
      });
    },
    drag: function( draggable, event ) {
  
      // If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
      if ( draggable.options.refreshPositions ) {
        $.ui.ddmanager.prepareOffsets( draggable, event );
      }
  
      // Run through all droppables and check their positions based on specific tolerance options
      $.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], function() {
  
        if ( this.options.disabled || this.greedyChild || !this.visible ) {
          return;
        }
  
        var parentInstance, scope, parent,
          intersects = $.ui.intersect( draggable, this, this.options.tolerance, event ),
          c = !intersects && this.isover ? "isout" : ( intersects && !this.isover ? "isover" : null );
        if ( !c ) {
          return;
        }
  
        if ( this.options.greedy ) {
          // find droppable parents with same scope
          scope = this.options.scope;
          parent = this.element.parents( ":data(ui-droppable)" ).filter(function() {
            return $( this ).droppable( "instance" ).options.scope === scope;
          });
  
          if ( parent.length ) {
            parentInstance = $( parent[ 0 ] ).droppable( "instance" );
            parentInstance.greedyChild = ( c === "isover" );
          }
        }
  
        // we just moved into a greedy child
        if ( parentInstance && c === "isover" ) {
          parentInstance.isover = false;
          parentInstance.isout = true;
          parentInstance._out.call( parentInstance, event );
        }
  
        this[ c ] = true;
        this[c === "isout" ? "isover" : "isout"] = false;
        this[c === "isover" ? "_over" : "_out"].call( this, event );
  
        // we just moved out of a greedy child
        if ( parentInstance && c === "isout" ) {
          parentInstance.isout = false;
          parentInstance.isover = true;
          parentInstance._over.call( parentInstance, event );
        }
      });
  
    },
    dragStop: function( draggable, event ) {
      draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
      // Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
      if ( !draggable.options.refreshPositions ) {
        $.ui.ddmanager.prepareOffsets( draggable, event );
      }
    }
  };
  
  var droppable = $.ui.droppable;
  
  
  /*!
   * jQuery UI Effects 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/category/effects-core/
   */
  
  
  var dataSpace = "ui-effects-",
  
    // Create a local jQuery because jQuery Color relies on it and the
    // global may not exist with AMD and a custom build (#10199)
    jQuery = $;
  
  $.effects = {
    effect: {}
  };
  
  /*!
   * jQuery Color Animations v2.1.2
   * https://github.com/jquery/jquery-color
   *
   * Copyright 2014 jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * Date: Wed Jan 16 08:47:09 2013 -0600
   */
  (function( jQuery, undefined ) {
  
    var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",
  
    // plusequals test for += 100 -= 100
    rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
    // a set of RE's that can match strings and generate color tuples.
    stringParsers = [ {
        re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
        parse: function( execResult ) {
          return [
            execResult[ 1 ],
            execResult[ 2 ],
            execResult[ 3 ],
            execResult[ 4 ]
          ];
        }
      }, {
        re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
        parse: function( execResult ) {
          return [
            execResult[ 1 ] * 2.55,
            execResult[ 2 ] * 2.55,
            execResult[ 3 ] * 2.55,
            execResult[ 4 ]
          ];
        }
      }, {
        // this regex ignores A-F because it's compared against an already lowercased string
        re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
        parse: function( execResult ) {
          return [
            parseInt( execResult[ 1 ], 16 ),
            parseInt( execResult[ 2 ], 16 ),
            parseInt( execResult[ 3 ], 16 )
          ];
        }
      }, {
        // this regex ignores A-F because it's compared against an already lowercased string
        re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
        parse: function( execResult ) {
          return [
            parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
            parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
            parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
          ];
        }
      }, {
        re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
        space: "hsla",
        parse: function( execResult ) {
          return [
            execResult[ 1 ],
            execResult[ 2 ] / 100,
            execResult[ 3 ] / 100,
            execResult[ 4 ]
          ];
        }
      } ],
  
    // jQuery.Color( )
    color = jQuery.Color = function( color, green, blue, alpha ) {
      return new jQuery.Color.fn.parse( color, green, blue, alpha );
    },
    spaces = {
      rgba: {
        props: {
          red: {
            idx: 0,
            type: "byte"
          },
          green: {
            idx: 1,
            type: "byte"
          },
          blue: {
            idx: 2,
            type: "byte"
          }
        }
      },
  
      hsla: {
        props: {
          hue: {
            idx: 0,
            type: "degrees"
          },
          saturation: {
            idx: 1,
            type: "percent"
          },
          lightness: {
            idx: 2,
            type: "percent"
          }
        }
      }
    },
    propTypes = {
      "byte": {
        floor: true,
        max: 255
      },
      "percent": {
        max: 1
      },
      "degrees": {
        mod: 360,
        floor: true
      }
    },
    support = color.support = {},
  
    // element for support tests
    supportElem = jQuery( "<p>" )[ 0 ],
  
    // colors = jQuery.Color.names
    colors,
  
    // local aliases of functions called often
    each = jQuery.each;
  
  // determine rgba support immediately
  supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
  support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;
  
  // define cache name and alpha properties
  // for rgba and hsla spaces
  each( spaces, function( spaceName, space ) {
    space.cache = "_" + spaceName;
    space.props.alpha = {
      idx: 3,
      type: "percent",
      def: 1
    };
  });
  
  function clamp( value, prop, allowEmpty ) {
    var type = propTypes[ prop.type ] || {};
  
    if ( value == null ) {
      return (allowEmpty || !prop.def) ? null : prop.def;
    }
  
    // ~~ is an short way of doing floor for positive numbers
    value = type.floor ? ~~value : parseFloat( value );
  
    // IE will pass in empty strings as value for alpha,
    // which will hit this case
    if ( isNaN( value ) ) {
      return prop.def;
    }
  
    if ( type.mod ) {
      // we add mod before modding to make sure that negatives values
      // get converted properly: -10 -> 350
      return (value + type.mod) % type.mod;
    }
  
    // for now all property types without mod have min and max
    return 0 > value ? 0 : type.max < value ? type.max : value;
  }
  
  function stringParse( string ) {
    var inst = color(),
      rgba = inst._rgba = [];
  
    string = string.toLowerCase();
  
    each( stringParsers, function( i, parser ) {
      var parsed,
        match = parser.re.exec( string ),
        values = match && parser.parse( match ),
        spaceName = parser.space || "rgba";
  
      if ( values ) {
        parsed = inst[ spaceName ]( values );
  
        // if this was an rgba parse the assignment might happen twice
        // oh well....
        inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
        rgba = inst._rgba = parsed._rgba;
  
        // exit each( stringParsers ) here because we matched
        return false;
      }
    });
  
    // Found a stringParser that handled it
    if ( rgba.length ) {
  
      // if this came from a parsed string, force "transparent" when alpha is 0
      // chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
      if ( rgba.join() === "0,0,0,0" ) {
        jQuery.extend( rgba, colors.transparent );
      }
      return inst;
    }
  
    // named colors
    return colors[ string ];
  }
  
  color.fn = jQuery.extend( color.prototype, {
    parse: function( red, green, blue, alpha ) {
      if ( red === undefined ) {
        this._rgba = [ null, null, null, null ];
        return this;
      }
      if ( red.jquery || red.nodeType ) {
        red = jQuery( red ).css( green );
        green = undefined;
      }
  
      var inst = this,
        type = jQuery.type( red ),
        rgba = this._rgba = [];
  
      // more than 1 argument specified - assume ( red, green, blue, alpha )
      if ( green !== undefined ) {
        red = [ red, green, blue, alpha ];
        type = "array";
      }
  
      if ( type === "string" ) {
        return this.parse( stringParse( red ) || colors._default );
      }
  
      if ( type === "array" ) {
        each( spaces.rgba.props, function( key, prop ) {
          rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
        });
        return this;
      }
  
      if ( type === "object" ) {
        if ( red instanceof color ) {
          each( spaces, function( spaceName, space ) {
            if ( red[ space.cache ] ) {
              inst[ space.cache ] = red[ space.cache ].slice();
            }
          });
        } else {
          each( spaces, function( spaceName, space ) {
            var cache = space.cache;
            each( space.props, function( key, prop ) {
  
              // if the cache doesn't exist, and we know how to convert
              if ( !inst[ cache ] && space.to ) {
  
                // if the value was null, we don't need to copy it
                // if the key was alpha, we don't need to copy it either
                if ( key === "alpha" || red[ key ] == null ) {
                  return;
                }
                inst[ cache ] = space.to( inst._rgba );
              }
  
              // this is the only case where we allow nulls for ALL properties.
              // call clamp with alwaysAllowEmpty
              inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
            });
  
            // everything defined but alpha?
            if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
              // use the default of 1
              inst[ cache ][ 3 ] = 1;
              if ( space.from ) {
                inst._rgba = space.from( inst[ cache ] );
              }
            }
          });
        }
        return this;
      }
    },
    is: function( compare ) {
      var is = color( compare ),
        same = true,
        inst = this;
  
      each( spaces, function( _, space ) {
        var localCache,
          isCache = is[ space.cache ];
        if (isCache) {
          localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
          each( space.props, function( _, prop ) {
            if ( isCache[ prop.idx ] != null ) {
              same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
              return same;
            }
          });
        }
        return same;
      });
      return same;
    },
    _space: function() {
      var used = [],
        inst = this;
      each( spaces, function( spaceName, space ) {
        if ( inst[ space.cache ] ) {
          used.push( spaceName );
        }
      });
      return used.pop();
    },
    transition: function( other, distance ) {
      var end = color( other ),
        spaceName = end._space(),
        space = spaces[ spaceName ],
        startColor = this.alpha() === 0 ? color( "transparent" ) : this,
        start = startColor[ space.cache ] || space.to( startColor._rgba ),
        result = start.slice();
  
      end = end[ space.cache ];
      each( space.props, function( key, prop ) {
        var index = prop.idx,
          startValue = start[ index ],
          endValue = end[ index ],
          type = propTypes[ prop.type ] || {};
  
        // if null, don't override start value
        if ( endValue === null ) {
          return;
        }
        // if null - use end
        if ( startValue === null ) {
          result[ index ] = endValue;
        } else {
          if ( type.mod ) {
            if ( endValue - startValue > type.mod / 2 ) {
              startValue += type.mod;
            } else if ( startValue - endValue > type.mod / 2 ) {
              startValue -= type.mod;
            }
          }
          result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
        }
      });
      return this[ spaceName ]( result );
    },
    blend: function( opaque ) {
      // if we are already opaque - return ourself
      if ( this._rgba[ 3 ] === 1 ) {
        return this;
      }
  
      var rgb = this._rgba.slice(),
        a = rgb.pop(),
        blend = color( opaque )._rgba;
  
      return color( jQuery.map( rgb, function( v, i ) {
        return ( 1 - a ) * blend[ i ] + a * v;
      }));
    },
    toRgbaString: function() {
      var prefix = "rgba(",
        rgba = jQuery.map( this._rgba, function( v, i ) {
          return v == null ? ( i > 2 ? 1 : 0 ) : v;
        });
  
      if ( rgba[ 3 ] === 1 ) {
        rgba.pop();
        prefix = "rgb(";
      }
  
      return prefix + rgba.join() + ")";
    },
    toHslaString: function() {
      var prefix = "hsla(",
        hsla = jQuery.map( this.hsla(), function( v, i ) {
          if ( v == null ) {
            v = i > 2 ? 1 : 0;
          }
  
          // catch 1 and 2
          if ( i && i < 3 ) {
            v = Math.round( v * 100 ) + "%";
          }
          return v;
        });
  
      if ( hsla[ 3 ] === 1 ) {
        hsla.pop();
        prefix = "hsl(";
      }
      return prefix + hsla.join() + ")";
    },
    toHexString: function( includeAlpha ) {
      var rgba = this._rgba.slice(),
        alpha = rgba.pop();
  
      if ( includeAlpha ) {
        rgba.push( ~~( alpha * 255 ) );
      }
  
      return "#" + jQuery.map( rgba, function( v ) {
  
        // default to 0 when nulls exist
        v = ( v || 0 ).toString( 16 );
        return v.length === 1 ? "0" + v : v;
      }).join("");
    },
    toString: function() {
      return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
    }
  });
  color.fn.parse.prototype = color.fn;
  
  // hsla conversions adapted from:
  // https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021
  
  function hue2rgb( p, q, h ) {
    h = ( h + 1 ) % 1;
    if ( h * 6 < 1 ) {
      return p + ( q - p ) * h * 6;
    }
    if ( h * 2 < 1) {
      return q;
    }
    if ( h * 3 < 2 ) {
      return p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;
    }
    return p;
  }
  
  spaces.hsla.to = function( rgba ) {
    if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
      return [ null, null, null, rgba[ 3 ] ];
    }
    var r = rgba[ 0 ] / 255,
      g = rgba[ 1 ] / 255,
      b = rgba[ 2 ] / 255,
      a = rgba[ 3 ],
      max = Math.max( r, g, b ),
      min = Math.min( r, g, b ),
      diff = max - min,
      add = max + min,
      l = add * 0.5,
      h, s;
  
    if ( min === max ) {
      h = 0;
    } else if ( r === max ) {
      h = ( 60 * ( g - b ) / diff ) + 360;
    } else if ( g === max ) {
      h = ( 60 * ( b - r ) / diff ) + 120;
    } else {
      h = ( 60 * ( r - g ) / diff ) + 240;
    }
  
    // chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
    // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
    if ( diff === 0 ) {
      s = 0;
    } else if ( l <= 0.5 ) {
      s = diff / add;
    } else {
      s = diff / ( 2 - add );
    }
    return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
  };
  
  spaces.hsla.from = function( hsla ) {
    if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
      return [ null, null, null, hsla[ 3 ] ];
    }
    var h = hsla[ 0 ] / 360,
      s = hsla[ 1 ],
      l = hsla[ 2 ],
      a = hsla[ 3 ],
      q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
      p = 2 * l - q;
  
    return [
      Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
      Math.round( hue2rgb( p, q, h ) * 255 ),
      Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
      a
    ];
  };
  
  each( spaces, function( spaceName, space ) {
    var props = space.props,
      cache = space.cache,
      to = space.to,
      from = space.from;
  
    // makes rgba() and hsla()
    color.fn[ spaceName ] = function( value ) {
  
      // generate a cache for this space if it doesn't exist
      if ( to && !this[ cache ] ) {
        this[ cache ] = to( this._rgba );
      }
      if ( value === undefined ) {
        return this[ cache ].slice();
      }
  
      var ret,
        type = jQuery.type( value ),
        arr = ( type === "array" || type === "object" ) ? value : arguments,
        local = this[ cache ].slice();
  
      each( props, function( key, prop ) {
        var val = arr[ type === "object" ? key : prop.idx ];
        if ( val == null ) {
          val = local[ prop.idx ];
        }
        local[ prop.idx ] = clamp( val, prop );
      });
  
      if ( from ) {
        ret = color( from( local ) );
        ret[ cache ] = local;
        return ret;
      } else {
        return color( local );
      }
    };
  
    // makes red() green() blue() alpha() hue() saturation() lightness()
    each( props, function( key, prop ) {
      // alpha is included in more than one space
      if ( color.fn[ key ] ) {
        return;
      }
      color.fn[ key ] = function( value ) {
        var vtype = jQuery.type( value ),
          fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
          local = this[ fn ](),
          cur = local[ prop.idx ],
          match;
  
        if ( vtype === "undefined" ) {
          return cur;
        }
  
        if ( vtype === "function" ) {
          value = value.call( this, cur );
          vtype = jQuery.type( value );
        }
        if ( value == null && prop.empty ) {
          return this;
        }
        if ( vtype === "string" ) {
          match = rplusequals.exec( value );
          if ( match ) {
            value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
          }
        }
        local[ prop.idx ] = value;
        return this[ fn ]( local );
      };
    });
  });
  
  // add cssHook and .fx.step function for each named hook.
  // accept a space separated string of properties
  color.hook = function( hook ) {
    var hooks = hook.split( " " );
    each( hooks, function( i, hook ) {
      jQuery.cssHooks[ hook ] = {
        set: function( elem, value ) {
          var parsed, curElem,
            backgroundColor = "";
  
          if ( value !== "transparent" && ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) ) {
            value = color( parsed || value );
            if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
              curElem = hook === "backgroundColor" ? elem.parentNode : elem;
              while (
                (backgroundColor === "" || backgroundColor === "transparent") &&
                curElem && curElem.style
              ) {
                try {
                  backgroundColor = jQuery.css( curElem, "backgroundColor" );
                  curElem = curElem.parentNode;
                } catch ( e ) {
                }
              }
  
              value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
                backgroundColor :
                "_default" );
            }
  
            value = value.toRgbaString();
          }
          try {
            elem.style[ hook ] = value;
          } catch ( e ) {
            // wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
          }
        }
      };
      jQuery.fx.step[ hook ] = function( fx ) {
        if ( !fx.colorInit ) {
          fx.start = color( fx.elem, hook );
          fx.end = color( fx.end );
          fx.colorInit = true;
        }
        jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
      };
    });
  
  };
  
  color.hook( stepHooks );
  
  jQuery.cssHooks.borderColor = {
    expand: function( value ) {
      var expanded = {};
  
      each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
        expanded[ "border" + part + "Color" ] = value;
      });
      return expanded;
    }
  };
  
  // Basic color names only.
  // Usage of any of the other color names requires adding yourself or including
  // jquery.color.svg-names.js.
  colors = jQuery.Color.names = {
    // 4.1. Basic color keywords
    aqua: "#00ffff",
    black: "#000000",
    blue: "#0000ff",
    fuchsia: "#ff00ff",
    gray: "#808080",
    green: "#008000",
    lime: "#00ff00",
    maroon: "#800000",
    navy: "#000080",
    olive: "#808000",
    purple: "#800080",
    red: "#ff0000",
    silver: "#c0c0c0",
    teal: "#008080",
    white: "#ffffff",
    yellow: "#ffff00",
  
    // 4.2.3. "transparent" color keyword
    transparent: [ null, null, null, 0 ],
  
    _default: "#ffffff"
  };
  
  })( jQuery );
  
  /******************************************************************************/
  /****************************** CLASS ANIMATIONS ******************************/
  /******************************************************************************/
  (function() {
  
  var classAnimationActions = [ "add", "remove", "toggle" ],
    shorthandStyles = {
      border: 1,
      borderBottom: 1,
      borderColor: 1,
      borderLeft: 1,
      borderRight: 1,
      borderTop: 1,
      borderWidth: 1,
      margin: 1,
      padding: 1
    };
  
  $.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
    $.fx.step[ prop ] = function( fx ) {
      if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
        jQuery.style( fx.elem, prop, fx.end );
        fx.setAttr = true;
      }
    };
  });
  
  function getElementStyles( elem ) {
    var key, len,
      style = elem.ownerDocument.defaultView ?
        elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
        elem.currentStyle,
      styles = {};
  
    if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
      len = style.length;
      while ( len-- ) {
        key = style[ len ];
        if ( typeof style[ key ] === "string" ) {
          styles[ $.camelCase( key ) ] = style[ key ];
        }
      }
    // support: Opera, IE <9
    } else {
      for ( key in style ) {
        if ( typeof style[ key ] === "string" ) {
          styles[ key ] = style[ key ];
        }
      }
    }
  
    return styles;
  }
  
  function styleDifference( oldStyle, newStyle ) {
    var diff = {},
      name, value;
  
    for ( name in newStyle ) {
      value = newStyle[ name ];
      if ( oldStyle[ name ] !== value ) {
        if ( !shorthandStyles[ name ] ) {
          if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
            diff[ name ] = value;
          }
        }
      }
    }
  
    return diff;
  }
  
  // support: jQuery <1.8
  if ( !$.fn.addBack ) {
    $.fn.addBack = function( selector ) {
      return this.add( selector == null ?
        this.prevObject : this.prevObject.filter( selector )
      );
    };
  }
  
  $.effects.animateClass = function( value, duration, easing, callback ) {
    var o = $.speed( duration, easing, callback );
  
    return this.queue( function() {
      var animated = $( this ),
        baseClass = animated.attr( "class" ) || "",
        applyClassChange,
        allAnimations = o.children ? animated.find( "*" ).addBack() : animated;
  
      // map the animated objects to store the original styles.
      allAnimations = allAnimations.map(function() {
        var el = $( this );
        return {
          el: el,
          start: getElementStyles( this )
        };
      });
  
      // apply class change
      applyClassChange = function() {
        $.each( classAnimationActions, function(i, action) {
          if ( value[ action ] ) {
            animated[ action + "Class" ]( value[ action ] );
          }
        });
      };
      applyClassChange();
  
      // map all animated objects again - calculate new styles and diff
      allAnimations = allAnimations.map(function() {
        this.end = getElementStyles( this.el[ 0 ] );
        this.diff = styleDifference( this.start, this.end );
        return this;
      });
  
      // apply original class
      animated.attr( "class", baseClass );
  
      // map all animated objects again - this time collecting a promise
      allAnimations = allAnimations.map(function() {
        var styleInfo = this,
          dfd = $.Deferred(),
          opts = $.extend({}, o, {
            queue: false,
            complete: function() {
              dfd.resolve( styleInfo );
            }
          });
  
        this.el.animate( this.diff, opts );
        return dfd.promise();
      });
  
      // once all animations have completed:
      $.when.apply( $, allAnimations.get() ).done(function() {
  
        // set the final class
        applyClassChange();
  
        // for each animated element,
        // clear all css properties that were animated
        $.each( arguments, function() {
          var el = this.el;
          $.each( this.diff, function(key) {
            el.css( key, "" );
          });
        });
  
        // this is guarnteed to be there if you use jQuery.speed()
        // it also handles dequeuing the next anim...
        o.complete.call( animated[ 0 ] );
      });
    });
  };
  
  $.fn.extend({
    addClass: (function( orig ) {
      return function( classNames, speed, easing, callback ) {
        return speed ?
          $.effects.animateClass.call( this,
            { add: classNames }, speed, easing, callback ) :
          orig.apply( this, arguments );
      };
    })( $.fn.addClass ),
  
    removeClass: (function( orig ) {
      return function( classNames, speed, easing, callback ) {
        return arguments.length > 1 ?
          $.effects.animateClass.call( this,
            { remove: classNames }, speed, easing, callback ) :
          orig.apply( this, arguments );
      };
    })( $.fn.removeClass ),
  
    toggleClass: (function( orig ) {
      return function( classNames, force, speed, easing, callback ) {
        if ( typeof force === "boolean" || force === undefined ) {
          if ( !speed ) {
            // without speed parameter
            return orig.apply( this, arguments );
          } else {
            return $.effects.animateClass.call( this,
              (force ? { add: classNames } : { remove: classNames }),
              speed, easing, callback );
          }
        } else {
          // without force parameter
          return $.effects.animateClass.call( this,
            { toggle: classNames }, force, speed, easing );
        }
      };
    })( $.fn.toggleClass ),
  
    switchClass: function( remove, add, speed, easing, callback) {
      return $.effects.animateClass.call( this, {
        add: add,
        remove: remove
      }, speed, easing, callback );
    }
  });
  
  })();
  
  /******************************************************************************/
  /*********************************** EFFECTS **********************************/
  /******************************************************************************/
  
  (function() {
  
  $.extend( $.effects, {
    version: "1.11.4",
  
    // Saves a set of properties in a data storage
    save: function( element, set ) {
      for ( var i = 0; i < set.length; i++ ) {
        if ( set[ i ] !== null ) {
          element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
        }
      }
    },
  
    // Restores a set of previously saved properties from a data storage
    restore: function( element, set ) {
      var val, i;
      for ( i = 0; i < set.length; i++ ) {
        if ( set[ i ] !== null ) {
          val = element.data( dataSpace + set[ i ] );
          // support: jQuery 1.6.2
          // http://bugs.jquery.com/ticket/9917
          // jQuery 1.6.2 incorrectly returns undefined for any falsy value.
          // We can't differentiate between "" and 0 here, so we just assume
          // empty string since it's likely to be a more common value...
          if ( val === undefined ) {
            val = "";
          }
          element.css( set[ i ], val );
        }
      }
    },
  
    setMode: function( el, mode ) {
      if (mode === "toggle") {
        mode = el.is( ":hidden" ) ? "show" : "hide";
      }
      return mode;
    },
  
    // Translates a [top,left] array into a baseline value
    // this should be a little more flexible in the future to handle a string & hash
    getBaseline: function( origin, original ) {
      var y, x;
      switch ( origin[ 0 ] ) {
        case "top": y = 0; break;
        case "middle": y = 0.5; break;
        case "bottom": y = 1; break;
        default: y = origin[ 0 ] / original.height;
      }
      switch ( origin[ 1 ] ) {
        case "left": x = 0; break;
        case "center": x = 0.5; break;
        case "right": x = 1; break;
        default: x = origin[ 1 ] / original.width;
      }
      return {
        x: x,
        y: y
      };
    },
  
    // Wraps the element around a wrapper that copies position properties
    createWrapper: function( element ) {
  
      // if the element is already wrapped, return it
      if ( element.parent().is( ".ui-effects-wrapper" )) {
        return element.parent();
      }
  
      // wrap the element
      var props = {
          width: element.outerWidth(true),
          height: element.outerHeight(true),
          "float": element.css( "float" )
        },
        wrapper = $( "<div></div>" )
          .addClass( "ui-effects-wrapper" )
          .css({
            fontSize: "100%",
            background: "transparent",
            border: "none",
            margin: 0,
            padding: 0
          }),
        // Store the size in case width/height are defined in % - Fixes #5245
        size = {
          width: element.width(),
          height: element.height()
        },
        active = document.activeElement;
  
      // support: Firefox
      // Firefox incorrectly exposes anonymous content
      // https://bugzilla.mozilla.org/show_bug.cgi?id=561664
      try {
        active.id;
      } catch ( e ) {
        active = document.body;
      }
  
      element.wrap( wrapper );
  
      // Fixes #7595 - Elements lose focus when wrapped.
      if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
        $( active ).focus();
      }
  
      wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element
  
      // transfer positioning properties to the wrapper
      if ( element.css( "position" ) === "static" ) {
        wrapper.css({ position: "relative" });
        element.css({ position: "relative" });
      } else {
        $.extend( props, {
          position: element.css( "position" ),
          zIndex: element.css( "z-index" )
        });
        $.each([ "top", "left", "bottom", "right" ], function(i, pos) {
          props[ pos ] = element.css( pos );
          if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
            props[ pos ] = "auto";
          }
        });
        element.css({
          position: "relative",
          top: 0,
          left: 0,
          right: "auto",
          bottom: "auto"
        });
      }
      element.css(size);
  
      return wrapper.css( props ).show();
    },
  
    removeWrapper: function( element ) {
      var active = document.activeElement;
  
      if ( element.parent().is( ".ui-effects-wrapper" ) ) {
        element.parent().replaceWith( element );
  
        // Fixes #7595 - Elements lose focus when wrapped.
        if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
          $( active ).focus();
        }
      }
  
      return element;
    },
  
    setTransition: function( element, list, factor, value ) {
      value = value || {};
      $.each( list, function( i, x ) {
        var unit = element.cssUnit( x );
        if ( unit[ 0 ] > 0 ) {
          value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
        }
      });
      return value;
    }
  });
  
  // return an effect options object for the given parameters:
  function _normalizeArguments( effect, options, speed, callback ) {
  
    // allow passing all options as the first parameter
    if ( $.isPlainObject( effect ) ) {
      options = effect;
      effect = effect.effect;
    }
  
    // convert to an object
    effect = { effect: effect };
  
    // catch (effect, null, ...)
    if ( options == null ) {
      options = {};
    }
  
    // catch (effect, callback)
    if ( $.isFunction( options ) ) {
      callback = options;
      speed = null;
      options = {};
    }
  
    // catch (effect, speed, ?)
    if ( typeof options === "number" || $.fx.speeds[ options ] ) {
      callback = speed;
      speed = options;
      options = {};
    }
  
    // catch (effect, options, callback)
    if ( $.isFunction( speed ) ) {
      callback = speed;
      speed = null;
    }
  
    // add options to effect
    if ( options ) {
      $.extend( effect, options );
    }
  
    speed = speed || options.duration;
    effect.duration = $.fx.off ? 0 :
      typeof speed === "number" ? speed :
      speed in $.fx.speeds ? $.fx.speeds[ speed ] :
      $.fx.speeds._default;
  
    effect.complete = callback || options.complete;
  
    return effect;
  }
  
  function standardAnimationOption( option ) {
    // Valid standard speeds (nothing, number, named speed)
    if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
      return true;
    }
  
    // Invalid strings - treat as "normal" speed
    if ( typeof option === "string" && !$.effects.effect[ option ] ) {
      return true;
    }
  
    // Complete callback
    if ( $.isFunction( option ) ) {
      return true;
    }
  
    // Options hash (but not naming an effect)
    if ( typeof option === "object" && !option.effect ) {
      return true;
    }
  
    // Didn't match any standard API
    return false;
  }
  
  $.fn.extend({
    effect: function( /* effect, options, speed, callback */ ) {
      var args = _normalizeArguments.apply( this, arguments ),
        mode = args.mode,
        queue = args.queue,
        effectMethod = $.effects.effect[ args.effect ];
  
      if ( $.fx.off || !effectMethod ) {
        // delegate to the original method (e.g., .show()) if possible
        if ( mode ) {
          return this[ mode ]( args.duration, args.complete );
        } else {
          return this.each( function() {
            if ( args.complete ) {
              args.complete.call( this );
            }
          });
        }
      }
  
      function run( next ) {
        var elem = $( this ),
          complete = args.complete,
          mode = args.mode;
  
        function done() {
          if ( $.isFunction( complete ) ) {
            complete.call( elem[0] );
          }
          if ( $.isFunction( next ) ) {
            next();
          }
        }
  
        // If the element already has the correct final state, delegate to
        // the core methods so the internal tracking of "olddisplay" works.
        if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
          elem[ mode ]();
          done();
        } else {
          effectMethod.call( elem[0], args, done );
        }
      }
  
      return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
    },
  
    show: (function( orig ) {
      return function( option ) {
        if ( standardAnimationOption( option ) ) {
          return orig.apply( this, arguments );
        } else {
          var args = _normalizeArguments.apply( this, arguments );
          args.mode = "show";
          return this.effect.call( this, args );
        }
      };
    })( $.fn.show ),
  
    hide: (function( orig ) {
      return function( option ) {
        if ( standardAnimationOption( option ) ) {
          return orig.apply( this, arguments );
        } else {
          var args = _normalizeArguments.apply( this, arguments );
          args.mode = "hide";
          return this.effect.call( this, args );
        }
      };
    })( $.fn.hide ),
  
    toggle: (function( orig ) {
      return function( option ) {
        if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
          return orig.apply( this, arguments );
        } else {
          var args = _normalizeArguments.apply( this, arguments );
          args.mode = "toggle";
          return this.effect.call( this, args );
        }
      };
    })( $.fn.toggle ),
  
    // helper functions
    cssUnit: function(key) {
      var style = this.css( key ),
        val = [];
  
      $.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
        if ( style.indexOf( unit ) > 0 ) {
          val = [ parseFloat( style ), unit ];
        }
      });
      return val;
    }
  });
  
  })();
  
  /******************************************************************************/
  /*********************************** EASING ***********************************/
  /******************************************************************************/
  
  (function() {
  
  // based on easing equations from Robert Penner (http://www.robertpenner.com/easing)
  
  var baseEasings = {};
  
  $.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
    baseEasings[ name ] = function( p ) {
      return Math.pow( p, i + 2 );
    };
  });
  
  $.extend( baseEasings, {
    Sine: function( p ) {
      return 1 - Math.cos( p * Math.PI / 2 );
    },
    Circ: function( p ) {
      return 1 - Math.sqrt( 1 - p * p );
    },
    Elastic: function( p ) {
      return p === 0 || p === 1 ? p :
        -Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
    },
    Back: function( p ) {
      return p * p * ( 3 * p - 2 );
    },
    Bounce: function( p ) {
      var pow2,
        bounce = 4;
  
      while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
      return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
    }
  });
  
  $.each( baseEasings, function( name, easeIn ) {
    $.easing[ "easeIn" + name ] = easeIn;
    $.easing[ "easeOut" + name ] = function( p ) {
      return 1 - easeIn( 1 - p );
    };
    $.easing[ "easeInOut" + name ] = function( p ) {
      return p < 0.5 ?
        easeIn( p * 2 ) / 2 :
        1 - easeIn( p * -2 + 2 ) / 2;
    };
  });
  
  })();
  
  var effect = $.effects;
  
  
  /*!
   * jQuery UI Effects Blind 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/blind-effect/
   */
  
  
  var effectBlind = $.effects.effect.blind = function( o, done ) {
    // Create element
    var el = $( this ),
      rvertical = /up|down|vertical/,
      rpositivemotion = /up|left|vertical|horizontal/,
      props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
      mode = $.effects.setMode( el, o.mode || "hide" ),
      direction = o.direction || "up",
      vertical = rvertical.test( direction ),
      ref = vertical ? "height" : "width",
      ref2 = vertical ? "top" : "left",
      motion = rpositivemotion.test( direction ),
      animation = {},
      show = mode === "show",
      wrapper, distance, margin;
  
    // if already wrapped, the wrapper's properties are my property. #6245
    if ( el.parent().is( ".ui-effects-wrapper" ) ) {
      $.effects.save( el.parent(), props );
    } else {
      $.effects.save( el, props );
    }
    el.show();
    wrapper = $.effects.createWrapper( el ).css({
      overflow: "hidden"
    });
  
    distance = wrapper[ ref ]();
    margin = parseFloat( wrapper.css( ref2 ) ) || 0;
  
    animation[ ref ] = show ? distance : 0;
    if ( !motion ) {
      el
        .css( vertical ? "bottom" : "right", 0 )
        .css( vertical ? "top" : "left", "auto" )
        .css({ position: "absolute" });
  
      animation[ ref2 ] = show ? margin : distance + margin;
    }
  
    // start at 0 if we are showing
    if ( show ) {
      wrapper.css( ref, 0 );
      if ( !motion ) {
        wrapper.css( ref2, margin + distance );
      }
    }
  
    // Animate
    wrapper.animate( animation, {
      duration: o.duration,
      easing: o.easing,
      queue: false,
      complete: function() {
        if ( mode === "hide" ) {
          el.hide();
        }
        $.effects.restore( el, props );
        $.effects.removeWrapper( el );
        done();
      }
    });
  };
  
  
  /*!
   * jQuery UI Effects Bounce 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/bounce-effect/
   */
  
  
  var effectBounce = $.effects.effect.bounce = function( o, done ) {
    var el = $( this ),
      props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
  
      // defaults:
      mode = $.effects.setMode( el, o.mode || "effect" ),
      hide = mode === "hide",
      show = mode === "show",
      direction = o.direction || "up",
      distance = o.distance,
      times = o.times || 5,
  
      // number of internal animations
      anims = times * 2 + ( show || hide ? 1 : 0 ),
      speed = o.duration / anims,
      easing = o.easing,
  
      // utility:
      ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
      motion = ( direction === "up" || direction === "left" ),
      i,
      upAnim,
      downAnim,
  
      // we will need to re-assemble the queue to stack our animations in place
      queue = el.queue(),
      queuelen = queue.length;
  
    // Avoid touching opacity to prevent clearType and PNG issues in IE
    if ( show || hide ) {
      props.push( "opacity" );
    }
  
    $.effects.save( el, props );
    el.show();
    $.effects.createWrapper( el ); // Create Wrapper
  
    // default distance for the BIGGEST bounce is the outer Distance / 3
    if ( !distance ) {
      distance = el[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
    }
  
    if ( show ) {
      downAnim = { opacity: 1 };
      downAnim[ ref ] = 0;
  
      // if we are showing, force opacity 0 and set the initial position
      // then do the "first" animation
      el.css( "opacity", 0 )
        .css( ref, motion ? -distance * 2 : distance * 2 )
        .animate( downAnim, speed, easing );
    }
  
    // start at the smallest distance if we are hiding
    if ( hide ) {
      distance = distance / Math.pow( 2, times - 1 );
    }
  
    downAnim = {};
    downAnim[ ref ] = 0;
    // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
    for ( i = 0; i < times; i++ ) {
      upAnim = {};
      upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;
  
      el.animate( upAnim, speed, easing )
        .animate( downAnim, speed, easing );
  
      distance = hide ? distance * 2 : distance / 2;
    }
  
    // Last Bounce when Hiding
    if ( hide ) {
      upAnim = { opacity: 0 };
      upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;
  
      el.animate( upAnim, speed, easing );
    }
  
    el.queue(function() {
      if ( hide ) {
        el.hide();
      }
      $.effects.restore( el, props );
      $.effects.removeWrapper( el );
      done();
    });
  
    // inject all the animations we just queued to be first in line (after "inprogress")
    if ( queuelen > 1) {
      queue.splice.apply( queue,
        [ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
    }
    el.dequeue();
  
  };
  
  
  /*!
   * jQuery UI Effects Clip 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/clip-effect/
   */
  
  
  var effectClip = $.effects.effect.clip = function( o, done ) {
    // Create element
    var el = $( this ),
      props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
      mode = $.effects.setMode( el, o.mode || "hide" ),
      show = mode === "show",
      direction = o.direction || "vertical",
      vert = direction === "vertical",
      size = vert ? "height" : "width",
      position = vert ? "top" : "left",
      animation = {},
      wrapper, animate, distance;
  
    // Save & Show
    $.effects.save( el, props );
    el.show();
  
    // Create Wrapper
    wrapper = $.effects.createWrapper( el ).css({
      overflow: "hidden"
    });
    animate = ( el[0].tagName === "IMG" ) ? wrapper : el;
    distance = animate[ size ]();
  
    // Shift
    if ( show ) {
      animate.css( size, 0 );
      animate.css( position, distance / 2 );
    }
  
    // Create Animation Object:
    animation[ size ] = show ? distance : 0;
    animation[ position ] = show ? 0 : distance / 2;
  
    // Animate
    animate.animate( animation, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: function() {
        if ( !show ) {
          el.hide();
        }
        $.effects.restore( el, props );
        $.effects.removeWrapper( el );
        done();
      }
    });
  
  };
  
  
  /*!
   * jQuery UI Effects Drop 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/drop-effect/
   */
  
  
  var effectDrop = $.effects.effect.drop = function( o, done ) {
  
    var el = $( this ),
      props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ],
      mode = $.effects.setMode( el, o.mode || "hide" ),
      show = mode === "show",
      direction = o.direction || "left",
      ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
      motion = ( direction === "up" || direction === "left" ) ? "pos" : "neg",
      animation = {
        opacity: show ? 1 : 0
      },
      distance;
  
    // Adjust
    $.effects.save( el, props );
    el.show();
    $.effects.createWrapper( el );
  
    distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ) / 2;
  
    if ( show ) {
      el
        .css( "opacity", 0 )
        .css( ref, motion === "pos" ? -distance : distance );
    }
  
    // Animation
    animation[ ref ] = ( show ?
      ( motion === "pos" ? "+=" : "-=" ) :
      ( motion === "pos" ? "-=" : "+=" ) ) +
      distance;
  
    // Animate
    el.animate( animation, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: function() {
        if ( mode === "hide" ) {
          el.hide();
        }
        $.effects.restore( el, props );
        $.effects.removeWrapper( el );
        done();
      }
    });
  };
  
  
  /*!
   * jQuery UI Effects Explode 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/explode-effect/
   */
  
  
  var effectExplode = $.effects.effect.explode = function( o, done ) {
  
    var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
      cells = rows,
      el = $( this ),
      mode = $.effects.setMode( el, o.mode || "hide" ),
      show = mode === "show",
  
      // show and then visibility:hidden the element before calculating offset
      offset = el.show().css( "visibility", "hidden" ).offset(),
  
      // width and height of a piece
      width = Math.ceil( el.outerWidth() / cells ),
      height = Math.ceil( el.outerHeight() / rows ),
      pieces = [],
  
      // loop
      i, j, left, top, mx, my;
  
    // children animate complete:
    function childComplete() {
      pieces.push( this );
      if ( pieces.length === rows * cells ) {
        animComplete();
      }
    }
  
    // clone the element for each row and cell.
    for ( i = 0; i < rows ; i++ ) { // ===>
      top = offset.top + i * height;
      my = i - ( rows - 1 ) / 2 ;
  
      for ( j = 0; j < cells ; j++ ) { // |||
        left = offset.left + j * width;
        mx = j - ( cells - 1 ) / 2 ;
  
        // Create a clone of the now hidden main element that will be absolute positioned
        // within a wrapper div off the -left and -top equal to size of our pieces
        el
          .clone()
          .appendTo( "body" )
          .wrap( "<div></div>" )
          .css({
            position: "absolute",
            visibility: "visible",
            left: -j * width,
            top: -i * height
          })
  
        // select the wrapper - make it overflow: hidden and absolute positioned based on
        // where the original was located +left and +top equal to the size of pieces
          .parent()
          .addClass( "ui-effects-explode" )
          .css({
            position: "absolute",
            overflow: "hidden",
            width: width,
            height: height,
            left: left + ( show ? mx * width : 0 ),
            top: top + ( show ? my * height : 0 ),
            opacity: show ? 0 : 1
          }).animate({
            left: left + ( show ? 0 : mx * width ),
            top: top + ( show ? 0 : my * height ),
            opacity: show ? 1 : 0
          }, o.duration || 500, o.easing, childComplete );
      }
    }
  
    function animComplete() {
      el.css({
        visibility: "visible"
      });
      $( pieces ).remove();
      if ( !show ) {
        el.hide();
      }
      done();
    }
  };
  
  
  /*!
   * jQuery UI Effects Fade 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/fade-effect/
   */
  
  
  var effectFade = $.effects.effect.fade = function( o, done ) {
    var el = $( this ),
      mode = $.effects.setMode( el, o.mode || "toggle" );
  
    el.animate({
      opacity: mode
    }, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: done
    });
  };
  
  
  /*!
   * jQuery UI Effects Fold 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/fold-effect/
   */
  
  
  var effectFold = $.effects.effect.fold = function( o, done ) {
  
    // Create element
    var el = $( this ),
      props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
      mode = $.effects.setMode( el, o.mode || "hide" ),
      show = mode === "show",
      hide = mode === "hide",
      size = o.size || 15,
      percent = /([0-9]+)%/.exec( size ),
      horizFirst = !!o.horizFirst,
      widthFirst = show !== horizFirst,
      ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ],
      duration = o.duration / 2,
      wrapper, distance,
      animation1 = {},
      animation2 = {};
  
    $.effects.save( el, props );
    el.show();
  
    // Create Wrapper
    wrapper = $.effects.createWrapper( el ).css({
      overflow: "hidden"
    });
    distance = widthFirst ?
      [ wrapper.width(), wrapper.height() ] :
      [ wrapper.height(), wrapper.width() ];
  
    if ( percent ) {
      size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
    }
    if ( show ) {
      wrapper.css( horizFirst ? {
        height: 0,
        width: size
      } : {
        height: size,
        width: 0
      });
    }
  
    // Animation
    animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
    animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;
  
    // Animate
    wrapper
      .animate( animation1, duration, o.easing )
      .animate( animation2, duration, o.easing, function() {
        if ( hide ) {
          el.hide();
        }
        $.effects.restore( el, props );
        $.effects.removeWrapper( el );
        done();
      });
  
  };
  
  
  /*!
   * jQuery UI Effects Highlight 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/highlight-effect/
   */
  
  
  var effectHighlight = $.effects.effect.highlight = function( o, done ) {
    var elem = $( this ),
      props = [ "backgroundImage", "backgroundColor", "opacity" ],
      mode = $.effects.setMode( elem, o.mode || "show" ),
      animation = {
        backgroundColor: elem.css( "backgroundColor" )
      };
  
    if (mode === "hide") {
      animation.opacity = 0;
    }
  
    $.effects.save( elem, props );
  
    elem
      .show()
      .css({
        backgroundImage: "none",
        backgroundColor: o.color || "#ffff99"
      })
      .animate( animation, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: function() {
          if ( mode === "hide" ) {
            elem.hide();
          }
          $.effects.restore( elem, props );
          done();
        }
      });
  };
  
  
  /*!
   * jQuery UI Effects Size 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/size-effect/
   */
  
  
  var effectSize = $.effects.effect.size = function( o, done ) {
  
    // Create element
    var original, baseline, factor,
      el = $( this ),
      props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ],
  
      // Always restore
      props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ],
  
      // Copy for children
      props2 = [ "width", "height", "overflow" ],
      cProps = [ "fontSize" ],
      vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
      hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],
  
      // Set options
      mode = $.effects.setMode( el, o.mode || "effect" ),
      restore = o.restore || mode !== "effect",
      scale = o.scale || "both",
      origin = o.origin || [ "middle", "center" ],
      position = el.css( "position" ),
      props = restore ? props0 : props1,
      zero = {
        height: 0,
        width: 0,
        outerHeight: 0,
        outerWidth: 0
      };
  
    if ( mode === "show" ) {
      el.show();
    }
    original = {
      height: el.height(),
      width: el.width(),
      outerHeight: el.outerHeight(),
      outerWidth: el.outerWidth()
    };
  
    if ( o.mode === "toggle" && mode === "show" ) {
      el.from = o.to || zero;
      el.to = o.from || original;
    } else {
      el.from = o.from || ( mode === "show" ? zero : original );
      el.to = o.to || ( mode === "hide" ? zero : original );
    }
  
    // Set scaling factor
    factor = {
      from: {
        y: el.from.height / original.height,
        x: el.from.width / original.width
      },
      to: {
        y: el.to.height / original.height,
        x: el.to.width / original.width
      }
    };
  
    // Scale the css box
    if ( scale === "box" || scale === "both" ) {
  
      // Vertical props scaling
      if ( factor.from.y !== factor.to.y ) {
        props = props.concat( vProps );
        el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
        el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
      }
  
      // Horizontal props scaling
      if ( factor.from.x !== factor.to.x ) {
        props = props.concat( hProps );
        el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
        el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
      }
    }
  
    // Scale the content
    if ( scale === "content" || scale === "both" ) {
  
      // Vertical props scaling
      if ( factor.from.y !== factor.to.y ) {
        props = props.concat( cProps ).concat( props2 );
        el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
        el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
      }
    }
  
    $.effects.save( el, props );
    el.show();
    $.effects.createWrapper( el );
    el.css( "overflow", "hidden" ).css( el.from );
  
    // Adjust
    if (origin) { // Calculate baseline shifts
      baseline = $.effects.getBaseline( origin, original );
      el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
      el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
      el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
      el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
    }
    el.css( el.from ); // set top & left
  
    // Animate
    if ( scale === "content" || scale === "both" ) { // Scale the children
  
      // Add margins/font-size
      vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
      hProps = hProps.concat([ "marginLeft", "marginRight" ]);
      props2 = props0.concat(vProps).concat(hProps);
  
      el.find( "*[width]" ).each( function() {
        var child = $( this ),
          c_original = {
            height: child.height(),
            width: child.width(),
            outerHeight: child.outerHeight(),
            outerWidth: child.outerWidth()
          };
        if (restore) {
          $.effects.save(child, props2);
        }
  
        child.from = {
          height: c_original.height * factor.from.y,
          width: c_original.width * factor.from.x,
          outerHeight: c_original.outerHeight * factor.from.y,
          outerWidth: c_original.outerWidth * factor.from.x
        };
        child.to = {
          height: c_original.height * factor.to.y,
          width: c_original.width * factor.to.x,
          outerHeight: c_original.height * factor.to.y,
          outerWidth: c_original.width * factor.to.x
        };
  
        // Vertical props scaling
        if ( factor.from.y !== factor.to.y ) {
          child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
          child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
        }
  
        // Horizontal props scaling
        if ( factor.from.x !== factor.to.x ) {
          child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
          child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
        }
  
        // Animate children
        child.css( child.from );
        child.animate( child.to, o.duration, o.easing, function() {
  
          // Restore children
          if ( restore ) {
            $.effects.restore( child, props2 );
          }
        });
      });
    }
  
    // Animate
    el.animate( el.to, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: function() {
        if ( el.to.opacity === 0 ) {
          el.css( "opacity", el.from.opacity );
        }
        if ( mode === "hide" ) {
          el.hide();
        }
        $.effects.restore( el, props );
        if ( !restore ) {
  
          // we need to calculate our new positioning based on the scaling
          if ( position === "static" ) {
            el.css({
              position: "relative",
              top: el.to.top,
              left: el.to.left
            });
          } else {
            $.each([ "top", "left" ], function( idx, pos ) {
              el.css( pos, function( _, str ) {
                var val = parseInt( str, 10 ),
                  toRef = idx ? el.to.left : el.to.top;
  
                // if original was "auto", recalculate the new value from wrapper
                if ( str === "auto" ) {
                  return toRef + "px";
                }
  
                return val + toRef + "px";
              });
            });
          }
        }
  
        $.effects.removeWrapper( el );
        done();
      }
    });
  
  };
  
  
  /*!
   * jQuery UI Effects Scale 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/scale-effect/
   */
  
  
  var effectScale = $.effects.effect.scale = function( o, done ) {
  
    // Create element
    var el = $( this ),
      options = $.extend( true, {}, o ),
      mode = $.effects.setMode( el, o.mode || "effect" ),
      percent = parseInt( o.percent, 10 ) ||
        ( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === "hide" ? 0 : 100 ) ),
      direction = o.direction || "both",
      origin = o.origin,
      original = {
        height: el.height(),
        width: el.width(),
        outerHeight: el.outerHeight(),
        outerWidth: el.outerWidth()
      },
      factor = {
        y: direction !== "horizontal" ? (percent / 100) : 1,
        x: direction !== "vertical" ? (percent / 100) : 1
      };
  
    // We are going to pass this effect to the size effect:
    options.effect = "size";
    options.queue = false;
    options.complete = done;
  
    // Set default origin and restore for show/hide
    if ( mode !== "effect" ) {
      options.origin = origin || [ "middle", "center" ];
      options.restore = true;
    }
  
    options.from = o.from || ( mode === "show" ? {
      height: 0,
      width: 0,
      outerHeight: 0,
      outerWidth: 0
    } : original );
    options.to = {
      height: original.height * factor.y,
      width: original.width * factor.x,
      outerHeight: original.outerHeight * factor.y,
      outerWidth: original.outerWidth * factor.x
    };
  
    // Fade option to support puff
    if ( options.fade ) {
      if ( mode === "show" ) {
        options.from.opacity = 0;
        options.to.opacity = 1;
      }
      if ( mode === "hide" ) {
        options.from.opacity = 1;
        options.to.opacity = 0;
      }
    }
  
    // Animate
    el.effect( options );
  
  };
  
  
  /*!
   * jQuery UI Effects Puff 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/puff-effect/
   */
  
  
  var effectPuff = $.effects.effect.puff = function( o, done ) {
    var elem = $( this ),
      mode = $.effects.setMode( elem, o.mode || "hide" ),
      hide = mode === "hide",
      percent = parseInt( o.percent, 10 ) || 150,
      factor = percent / 100,
      original = {
        height: elem.height(),
        width: elem.width(),
        outerHeight: elem.outerHeight(),
        outerWidth: elem.outerWidth()
      };
  
    $.extend( o, {
      effect: "scale",
      queue: false,
      fade: true,
      mode: mode,
      complete: done,
      percent: hide ? percent : 100,
      from: hide ?
        original :
        {
          height: original.height * factor,
          width: original.width * factor,
          outerHeight: original.outerHeight * factor,
          outerWidth: original.outerWidth * factor
        }
    });
  
    elem.effect( o );
  };
  
  
  /*!
   * jQuery UI Effects Pulsate 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/pulsate-effect/
   */
  
  
  var effectPulsate = $.effects.effect.pulsate = function( o, done ) {
    var elem = $( this ),
      mode = $.effects.setMode( elem, o.mode || "show" ),
      show = mode === "show",
      hide = mode === "hide",
      showhide = ( show || mode === "hide" ),
  
      // showing or hiding leaves of the "last" animation
      anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
      duration = o.duration / anims,
      animateTo = 0,
      queue = elem.queue(),
      queuelen = queue.length,
      i;
  
    if ( show || !elem.is(":visible")) {
      elem.css( "opacity", 0 ).show();
      animateTo = 1;
    }
  
    // anims - 1 opacity "toggles"
    for ( i = 1; i < anims; i++ ) {
      elem.animate({
        opacity: animateTo
      }, duration, o.easing );
      animateTo = 1 - animateTo;
    }
  
    elem.animate({
      opacity: animateTo
    }, duration, o.easing);
  
    elem.queue(function() {
      if ( hide ) {
        elem.hide();
      }
      done();
    });
  
    // We just queued up "anims" animations, we need to put them next in the queue
    if ( queuelen > 1 ) {
      queue.splice.apply( queue,
        [ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
    }
    elem.dequeue();
  };
  
  
  /*!
   * jQuery UI Effects Shake 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/shake-effect/
   */
  
  
  var effectShake = $.effects.effect.shake = function( o, done ) {
  
    var el = $( this ),
      props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
      mode = $.effects.setMode( el, o.mode || "effect" ),
      direction = o.direction || "left",
      distance = o.distance || 20,
      times = o.times || 3,
      anims = times * 2 + 1,
      speed = Math.round( o.duration / anims ),
      ref = (direction === "up" || direction === "down") ? "top" : "left",
      positiveMotion = (direction === "up" || direction === "left"),
      animation = {},
      animation1 = {},
      animation2 = {},
      i,
  
      // we will need to re-assemble the queue to stack our animations in place
      queue = el.queue(),
      queuelen = queue.length;
  
    $.effects.save( el, props );
    el.show();
    $.effects.createWrapper( el );
  
    // Animation
    animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
    animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
    animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;
  
    // Animate
    el.animate( animation, speed, o.easing );
  
    // Shakes
    for ( i = 1; i < times; i++ ) {
      el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
    }
    el
      .animate( animation1, speed, o.easing )
      .animate( animation, speed / 2, o.easing )
      .queue(function() {
        if ( mode === "hide" ) {
          el.hide();
        }
        $.effects.restore( el, props );
        $.effects.removeWrapper( el );
        done();
      });
  
    // inject all the animations we just queued to be first in line (after "inprogress")
    if ( queuelen > 1) {
      queue.splice.apply( queue,
        [ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
    }
    el.dequeue();
  
  };
  
  
  /*!
   * jQuery UI Effects Slide 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/slide-effect/
   */
  
  
  var effectSlide = $.effects.effect.slide = function( o, done ) {
  
    // Create element
    var el = $( this ),
      props = [ "position", "top", "bottom", "left", "right", "width", "height" ],
      mode = $.effects.setMode( el, o.mode || "show" ),
      show = mode === "show",
      direction = o.direction || "left",
      ref = (direction === "up" || direction === "down") ? "top" : "left",
      positiveMotion = (direction === "up" || direction === "left"),
      distance,
      animation = {};
  
    // Adjust
    $.effects.save( el, props );
    el.show();
    distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );
  
    $.effects.createWrapper( el ).css({
      overflow: "hidden"
    });
  
    if ( show ) {
      el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );
    }
  
    // Animation
    animation[ ref ] = ( show ?
      ( positiveMotion ? "+=" : "-=") :
      ( positiveMotion ? "-=" : "+=")) +
      distance;
  
    // Animate
    el.animate( animation, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: function() {
        if ( mode === "hide" ) {
          el.hide();
        }
        $.effects.restore( el, props );
        $.effects.removeWrapper( el );
        done();
      }
    });
  };
  
  
  /*!
   * jQuery UI Effects Transfer 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/transfer-effect/
   */
  
  
  var effectTransfer = $.effects.effect.transfer = function( o, done ) {
    var elem = $( this ),
      target = $( o.to ),
      targetFixed = target.css( "position" ) === "fixed",
      body = $("body"),
      fixTop = targetFixed ? body.scrollTop() : 0,
      fixLeft = targetFixed ? body.scrollLeft() : 0,
      endPosition = target.offset(),
      animation = {
        top: endPosition.top - fixTop,
        left: endPosition.left - fixLeft,
        height: target.innerHeight(),
        width: target.innerWidth()
      },
      startPosition = elem.offset(),
      transfer = $( "<div class='ui-effects-transfer'></div>" )
        .appendTo( document.body )
        .addClass( o.className )
        .css({
          top: startPosition.top - fixTop,
          left: startPosition.left - fixLeft,
          height: elem.innerHeight(),
          width: elem.innerWidth(),
          position: targetFixed ? "fixed" : "absolute"
        })
        .animate( animation, o.duration, o.easing, function() {
          transfer.remove();
          done();
        });
  };
  
  
  /*!
   * jQuery UI Progressbar 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/progressbar/
   */
  
  
  var progressbar = $.widget( "ui.progressbar", {
    version: "1.11.4",
    options: {
      max: 100,
      value: 0,
  
      change: null,
      complete: null
    },
  
    min: 0,
  
    _create: function() {
      // Constrain initial value
      this.oldValue = this.options.value = this._constrainedValue();
  
      this.element
        .addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
        .attr({
          // Only set static values, aria-valuenow and aria-valuemax are
          // set inside _refreshValue()
          role: "progressbar",
          "aria-valuemin": this.min
        });
  
      this.valueDiv = $( "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>" )
        .appendTo( this.element );
  
      this._refreshValue();
    },
  
    _destroy: function() {
      this.element
        .removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
        .removeAttr( "role" )
        .removeAttr( "aria-valuemin" )
        .removeAttr( "aria-valuemax" )
        .removeAttr( "aria-valuenow" );
  
      this.valueDiv.remove();
    },
  
    value: function( newValue ) {
      if ( newValue === undefined ) {
        return this.options.value;
      }
  
      this.options.value = this._constrainedValue( newValue );
      this._refreshValue();
    },
  
    _constrainedValue: function( newValue ) {
      if ( newValue === undefined ) {
        newValue = this.options.value;
      }
  
      this.indeterminate = newValue === false;
  
      // sanitize value
      if ( typeof newValue !== "number" ) {
        newValue = 0;
      }
  
      return this.indeterminate ? false :
        Math.min( this.options.max, Math.max( this.min, newValue ) );
    },
  
    _setOptions: function( options ) {
      // Ensure "value" option is set after other values (like max)
      var value = options.value;
      delete options.value;
  
      this._super( options );
  
      this.options.value = this._constrainedValue( value );
      this._refreshValue();
    },
  
    _setOption: function( key, value ) {
      if ( key === "max" ) {
        // Don't allow a max less than min
        value = Math.max( this.min, value );
      }
      if ( key === "disabled" ) {
        this.element
          .toggleClass( "ui-state-disabled", !!value )
          .attr( "aria-disabled", value );
      }
      this._super( key, value );
    },
  
    _percentage: function() {
      return this.indeterminate ? 100 : 100 * ( this.options.value - this.min ) / ( this.options.max - this.min );
    },
  
    _refreshValue: function() {
      var value = this.options.value,
        percentage = this._percentage();
  
      this.valueDiv
        .toggle( this.indeterminate || value > this.min )
        .toggleClass( "ui-corner-right", value === this.options.max )
        .width( percentage.toFixed(0) + "%" );
  
      this.element.toggleClass( "ui-progressbar-indeterminate", this.indeterminate );
  
      if ( this.indeterminate ) {
        this.element.removeAttr( "aria-valuenow" );
        if ( !this.overlayDiv ) {
          this.overlayDiv = $( "<div class='ui-progressbar-overlay'></div>" ).appendTo( this.valueDiv );
        }
      } else {
        this.element.attr({
          "aria-valuemax": this.options.max,
          "aria-valuenow": value
        });
        if ( this.overlayDiv ) {
          this.overlayDiv.remove();
          this.overlayDiv = null;
        }
      }
  
      if ( this.oldValue !== value ) {
        this.oldValue = value;
        this._trigger( "change" );
      }
      if ( value === this.options.max ) {
        this._trigger( "complete" );
      }
    }
  });
  
  
  /*!
   * jQuery UI Selectable 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/selectable/
   */
  
  
  var selectable = $.widget("ui.selectable", $.ui.mouse, {
    version: "1.11.4",
    options: {
      appendTo: "body",
      autoRefresh: true,
      distance: 0,
      filter: "*",
      tolerance: "touch",
  
      // callbacks
      selected: null,
      selecting: null,
      start: null,
      stop: null,
      unselected: null,
      unselecting: null
    },
    _create: function() {
      var selectees,
        that = this;
  
      this.element.addClass("ui-selectable");
  
      this.dragged = false;
  
      // cache selectee children based on filter
      this.refresh = function() {
        selectees = $(that.options.filter, that.element[0]);
        selectees.addClass("ui-selectee");
        selectees.each(function() {
          var $this = $(this),
            pos = $this.offset();
          $.data(this, "selectable-item", {
            element: this,
            $element: $this,
            left: pos.left,
            top: pos.top,
            right: pos.left + $this.outerWidth(),
            bottom: pos.top + $this.outerHeight(),
            startselected: false,
            selected: $this.hasClass("ui-selected"),
            selecting: $this.hasClass("ui-selecting"),
            unselecting: $this.hasClass("ui-unselecting")
          });
        });
      };
      this.refresh();
  
      this.selectees = selectees.addClass("ui-selectee");
  
      this._mouseInit();
  
      this.helper = $("<div class='ui-selectable-helper'></div>");
    },
  
    _destroy: function() {
      this.selectees
        .removeClass("ui-selectee")
        .removeData("selectable-item");
      this.element
        .removeClass("ui-selectable ui-selectable-disabled");
      this._mouseDestroy();
    },
  
    _mouseStart: function(event) {
      var that = this,
        options = this.options;
  
      this.opos = [ event.pageX, event.pageY ];
  
      if (this.options.disabled) {
        return;
      }
  
      this.selectees = $(options.filter, this.element[0]);
  
      this._trigger("start", event);
  
      $(options.appendTo).append(this.helper);
      // position helper (lasso)
      this.helper.css({
        "left": event.pageX,
        "top": event.pageY,
        "width": 0,
        "height": 0
      });
  
      if (options.autoRefresh) {
        this.refresh();
      }
  
      this.selectees.filter(".ui-selected").each(function() {
        var selectee = $.data(this, "selectable-item");
        selectee.startselected = true;
        if (!event.metaKey && !event.ctrlKey) {
          selectee.$element.removeClass("ui-selected");
          selectee.selected = false;
          selectee.$element.addClass("ui-unselecting");
          selectee.unselecting = true;
          // selectable UNSELECTING callback
          that._trigger("unselecting", event, {
            unselecting: selectee.element
          });
        }
      });
  
      $(event.target).parents().addBack().each(function() {
        var doSelect,
          selectee = $.data(this, "selectable-item");
        if (selectee) {
          doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass("ui-selected");
          selectee.$element
            .removeClass(doSelect ? "ui-unselecting" : "ui-selected")
            .addClass(doSelect ? "ui-selecting" : "ui-unselecting");
          selectee.unselecting = !doSelect;
          selectee.selecting = doSelect;
          selectee.selected = doSelect;
          // selectable (UN)SELECTING callback
          if (doSelect) {
            that._trigger("selecting", event, {
              selecting: selectee.element
            });
          } else {
            that._trigger("unselecting", event, {
              unselecting: selectee.element
            });
          }
          return false;
        }
      });
  
    },
  
    _mouseDrag: function(event) {
  
      this.dragged = true;
  
      if (this.options.disabled) {
        return;
      }
  
      var tmp,
        that = this,
        options = this.options,
        x1 = this.opos[0],
        y1 = this.opos[1],
        x2 = event.pageX,
        y2 = event.pageY;
  
      if (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }
      if (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }
      this.helper.css({ left: x1, top: y1, width: x2 - x1, height: y2 - y1 });
  
      this.selectees.each(function() {
        var selectee = $.data(this, "selectable-item"),
          hit = false;
  
        //prevent helper from being selected if appendTo: selectable
        if (!selectee || selectee.element === that.element[0]) {
          return;
        }
  
        if (options.tolerance === "touch") {
          hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
        } else if (options.tolerance === "fit") {
          hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
        }
  
        if (hit) {
          // SELECT
          if (selectee.selected) {
            selectee.$element.removeClass("ui-selected");
            selectee.selected = false;
          }
          if (selectee.unselecting) {
            selectee.$element.removeClass("ui-unselecting");
            selectee.unselecting = false;
          }
          if (!selectee.selecting) {
            selectee.$element.addClass("ui-selecting");
            selectee.selecting = true;
            // selectable SELECTING callback
            that._trigger("selecting", event, {
              selecting: selectee.element
            });
          }
        } else {
          // UNSELECT
          if (selectee.selecting) {
            if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
              selectee.$element.removeClass("ui-selecting");
              selectee.selecting = false;
              selectee.$element.addClass("ui-selected");
              selectee.selected = true;
            } else {
              selectee.$element.removeClass("ui-selecting");
              selectee.selecting = false;
              if (selectee.startselected) {
                selectee.$element.addClass("ui-unselecting");
                selectee.unselecting = true;
              }
              // selectable UNSELECTING callback
              that._trigger("unselecting", event, {
                unselecting: selectee.element
              });
            }
          }
          if (selectee.selected) {
            if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
              selectee.$element.removeClass("ui-selected");
              selectee.selected = false;
  
              selectee.$element.addClass("ui-unselecting");
              selectee.unselecting = true;
              // selectable UNSELECTING callback
              that._trigger("unselecting", event, {
                unselecting: selectee.element
              });
            }
          }
        }
      });
  
      return false;
    },
  
    _mouseStop: function(event) {
      var that = this;
  
      this.dragged = false;
  
      $(".ui-unselecting", this.element[0]).each(function() {
        var selectee = $.data(this, "selectable-item");
        selectee.$element.removeClass("ui-unselecting");
        selectee.unselecting = false;
        selectee.startselected = false;
        that._trigger("unselected", event, {
          unselected: selectee.element
        });
      });
      $(".ui-selecting", this.element[0]).each(function() {
        var selectee = $.data(this, "selectable-item");
        selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
        selectee.selecting = false;
        selectee.selected = true;
        selectee.startselected = true;
        that._trigger("selected", event, {
          selected: selectee.element
        });
      });
      this._trigger("stop", event);
  
      this.helper.remove();
  
      return false;
    }
  
  });
  
  
  /*!
   * jQuery UI Selectmenu 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/selectmenu
   */
  
  
  var selectmenu = $.widget( "ui.selectmenu", {
    version: "1.11.4",
    defaultElement: "<select>",
    options: {
      appendTo: null,
      disabled: null,
      icons: {
        button: "ui-icon-triangle-1-s"
      },
      position: {
        my: "left top",
        at: "left bottom",
        collision: "none"
      },
      width: null,
  
      // callbacks
      change: null,
      close: null,
      focus: null,
      open: null,
      select: null
    },
  
    _create: function() {
      var selectmenuId = this.element.uniqueId().attr( "id" );
      this.ids = {
        element: selectmenuId,
        button: selectmenuId + "-button",
        menu: selectmenuId + "-menu"
      };
  
      this._drawButton();
      this._drawMenu();
  
      if ( this.options.disabled ) {
        this.disable();
      }
    },
  
    _drawButton: function() {
      var that = this;
  
      // Associate existing label with the new button
      this.label = $( "label[for='" + this.ids.element + "']" ).attr( "for", this.ids.button );
      this._on( this.label, {
        click: function( event ) {
          this.button.focus();
          event.preventDefault();
        }
      });
  
      // Hide original select element
      this.element.hide();
  
      // Create button
      this.button = $( "<span>", {
        "class": "ui-selectmenu-button ui-widget ui-state-default ui-corner-all",
        tabindex: this.options.disabled ? -1 : 0,
        id: this.ids.button,
        role: "combobox",
        "aria-expanded": "false",
        "aria-autocomplete": "list",
        "aria-owns": this.ids.menu,
        "aria-haspopup": "true"
      })
        .insertAfter( this.element );
  
      $( "<span>", {
        "class": "ui-icon " + this.options.icons.button
      })
        .prependTo( this.button );
  
      this.buttonText = $( "<span>", {
        "class": "ui-selectmenu-text"
      })
        .appendTo( this.button );
  
      this._setText( this.buttonText, this.element.find( "option:selected" ).text() );
      this._resizeButton();
  
      this._on( this.button, this._buttonEvents );
      this.button.one( "focusin", function() {
  
        // Delay rendering the menu items until the button receives focus.
        // The menu may have already been rendered via a programmatic open.
        if ( !that.menuItems ) {
          that._refreshMenu();
        }
      });
      this._hoverable( this.button );
      this._focusable( this.button );
    },
  
    _drawMenu: function() {
      var that = this;
  
      // Create menu
      this.menu = $( "<ul>", {
        "aria-hidden": "true",
        "aria-labelledby": this.ids.button,
        id: this.ids.menu
      });
  
      // Wrap menu
      this.menuWrap = $( "<div>", {
        "class": "ui-selectmenu-menu ui-front"
      })
        .append( this.menu )
        .appendTo( this._appendTo() );
  
      // Initialize menu widget
      this.menuInstance = this.menu
        .menu({
          role: "listbox",
          select: function( event, ui ) {
            event.preventDefault();
  
            // support: IE8
            // If the item was selected via a click, the text selection
            // will be destroyed in IE
            that._setSelection();
  
            that._select( ui.item.data( "ui-selectmenu-item" ), event );
          },
          focus: function( event, ui ) {
            var item = ui.item.data( "ui-selectmenu-item" );
  
            // Prevent inital focus from firing and check if its a newly focused item
            if ( that.focusIndex != null && item.index !== that.focusIndex ) {
              that._trigger( "focus", event, { item: item } );
              if ( !that.isOpen ) {
                that._select( item, event );
              }
            }
            that.focusIndex = item.index;
  
            that.button.attr( "aria-activedescendant",
              that.menuItems.eq( item.index ).attr( "id" ) );
          }
        })
        .menu( "instance" );
  
      // Adjust menu styles to dropdown
      this.menu
        .addClass( "ui-corner-bottom" )
        .removeClass( "ui-corner-all" );
  
      // Don't close the menu on mouseleave
      this.menuInstance._off( this.menu, "mouseleave" );
  
      // Cancel the menu's collapseAll on document click
      this.menuInstance._closeOnDocumentClick = function() {
        return false;
      };
  
      // Selects often contain empty items, but never contain dividers
      this.menuInstance._isDivider = function() {
        return false;
      };
    },
  
    refresh: function() {
      this._refreshMenu();
      this._setText( this.buttonText, this._getSelectedItem().text() );
      if ( !this.options.width ) {
        this._resizeButton();
      }
    },
  
    _refreshMenu: function() {
      this.menu.empty();
  
      var item,
        options = this.element.find( "option" );
  
      if ( !options.length ) {
        return;
      }
  
      this._parseOptions( options );
      this._renderMenu( this.menu, this.items );
  
      this.menuInstance.refresh();
      this.menuItems = this.menu.find( "li" ).not( ".ui-selectmenu-optgroup" );
  
      item = this._getSelectedItem();
  
      // Update the menu to have the correct item focused
      this.menuInstance.focus( null, item );
      this._setAria( item.data( "ui-selectmenu-item" ) );
  
      // Set disabled state
      this._setOption( "disabled", this.element.prop( "disabled" ) );
    },
  
    open: function( event ) {
      if ( this.options.disabled ) {
        return;
      }
  
      // If this is the first time the menu is being opened, render the items
      if ( !this.menuItems ) {
        this._refreshMenu();
      } else {
  
        // Menu clears focus on close, reset focus to selected item
        this.menu.find( ".ui-state-focus" ).removeClass( "ui-state-focus" );
        this.menuInstance.focus( null, this._getSelectedItem() );
      }
  
      this.isOpen = true;
      this._toggleAttr();
      this._resizeMenu();
      this._position();
  
      this._on( this.document, this._documentClick );
  
      this._trigger( "open", event );
    },
  
    _position: function() {
      this.menuWrap.position( $.extend( { of: this.button }, this.options.position ) );
    },
  
    close: function( event ) {
      if ( !this.isOpen ) {
        return;
      }
  
      this.isOpen = false;
      this._toggleAttr();
  
      this.range = null;
      this._off( this.document );
  
      this._trigger( "close", event );
    },
  
    widget: function() {
      return this.button;
    },
  
    menuWidget: function() {
      return this.menu;
    },
  
    _renderMenu: function( ul, items ) {
      var that = this,
        currentOptgroup = "";
  
      $.each( items, function( index, item ) {
        if ( item.optgroup !== currentOptgroup ) {
          $( "<li>", {
            "class": "ui-selectmenu-optgroup ui-menu-divider" +
              ( item.element.parent( "optgroup" ).prop( "disabled" ) ?
                " ui-state-disabled" :
                "" ),
            text: item.optgroup
          })
            .appendTo( ul );
  
          currentOptgroup = item.optgroup;
        }
  
        that._renderItemData( ul, item );
      });
    },
  
    _renderItemData: function( ul, item ) {
      return this._renderItem( ul, item ).data( "ui-selectmenu-item", item );
    },
  
    _renderItem: function( ul, item ) {
      var li = $( "<li>" );
  
      if ( item.disabled ) {
        li.addClass( "ui-state-disabled" );
      }
      this._setText( li, item.label );
  
      return li.appendTo( ul );
    },
  
    _setText: function( element, value ) {
      if ( value ) {
        element.text( value );
      } else {
        element.html( "&#160;" );
      }
    },
  
    _move: function( direction, event ) {
      var item, next,
        filter = ".ui-menu-item";
  
      if ( this.isOpen ) {
        item = this.menuItems.eq( this.focusIndex );
      } else {
        item = this.menuItems.eq( this.element[ 0 ].selectedIndex );
        filter += ":not(.ui-state-disabled)";
      }
  
      if ( direction === "first" || direction === "last" ) {
        next = item[ direction === "first" ? "prevAll" : "nextAll" ]( filter ).eq( -1 );
      } else {
        next = item[ direction + "All" ]( filter ).eq( 0 );
      }
  
      if ( next.length ) {
        this.menuInstance.focus( event, next );
      }
    },
  
    _getSelectedItem: function() {
      return this.menuItems.eq( this.element[ 0 ].selectedIndex );
    },
  
    _toggle: function( event ) {
      this[ this.isOpen ? "close" : "open" ]( event );
    },
  
    _setSelection: function() {
      var selection;
  
      if ( !this.range ) {
        return;
      }
  
      if ( window.getSelection ) {
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange( this.range );
  
      // support: IE8
      } else {
        this.range.select();
      }
  
      // support: IE
      // Setting the text selection kills the button focus in IE, but
      // restoring the focus doesn't kill the selection.
      this.button.focus();
    },
  
    _documentClick: {
      mousedown: function( event ) {
        if ( !this.isOpen ) {
          return;
        }
  
        if ( !$( event.target ).closest( ".ui-selectmenu-menu, #" + this.ids.button ).length ) {
          this.close( event );
        }
      }
    },
  
    _buttonEvents: {
  
      // Prevent text selection from being reset when interacting with the selectmenu (#10144)
      mousedown: function() {
        var selection;
  
        if ( window.getSelection ) {
          selection = window.getSelection();
          if ( selection.rangeCount ) {
            this.range = selection.getRangeAt( 0 );
          }
  
        // support: IE8
        } else {
          this.range = document.selection.createRange();
        }
      },
  
      click: function( event ) {
        this._setSelection();
        this._toggle( event );
      },
  
      keydown: function( event ) {
        var preventDefault = true;
        switch ( event.keyCode ) {
          case $.ui.keyCode.TAB:
          case $.ui.keyCode.ESCAPE:
            this.close( event );
            preventDefault = false;
            break;
          case $.ui.keyCode.ENTER:
            if ( this.isOpen ) {
              this._selectFocusedItem( event );
            }
            break;
          case $.ui.keyCode.UP:
            if ( event.altKey ) {
              this._toggle( event );
            } else {
              this._move( "prev", event );
            }
            break;
          case $.ui.keyCode.DOWN:
            if ( event.altKey ) {
              this._toggle( event );
            } else {
              this._move( "next", event );
            }
            break;
          case $.ui.keyCode.SPACE:
            if ( this.isOpen ) {
              this._selectFocusedItem( event );
            } else {
              this._toggle( event );
            }
            break;
          case $.ui.keyCode.LEFT:
            this._move( "prev", event );
            break;
          case $.ui.keyCode.RIGHT:
            this._move( "next", event );
            break;
          case $.ui.keyCode.HOME:
          case $.ui.keyCode.PAGE_UP:
            this._move( "first", event );
            break;
          case $.ui.keyCode.END:
          case $.ui.keyCode.PAGE_DOWN:
            this._move( "last", event );
            break;
          default:
            this.menu.trigger( event );
            preventDefault = false;
        }
  
        if ( preventDefault ) {
          event.preventDefault();
        }
      }
    },
  
    _selectFocusedItem: function( event ) {
      var item = this.menuItems.eq( this.focusIndex );
      if ( !item.hasClass( "ui-state-disabled" ) ) {
        this._select( item.data( "ui-selectmenu-item" ), event );
      }
    },
  
    _select: function( item, event ) {
      var oldIndex = this.element[ 0 ].selectedIndex;
  
      // Change native select element
      this.element[ 0 ].selectedIndex = item.index;
      this._setText( this.buttonText, item.label );
      this._setAria( item );
      this._trigger( "select", event, { item: item } );
  
      if ( item.index !== oldIndex ) {
        this._trigger( "change", event, { item: item } );
      }
  
      this.close( event );
    },
  
    _setAria: function( item ) {
      var id = this.menuItems.eq( item.index ).attr( "id" );
  
      this.button.attr({
        "aria-labelledby": id,
        "aria-activedescendant": id
      });
      this.menu.attr( "aria-activedescendant", id );
    },
  
    _setOption: function( key, value ) {
      if ( key === "icons" ) {
        this.button.find( "span.ui-icon" )
          .removeClass( this.options.icons.button )
          .addClass( value.button );
      }
  
      this._super( key, value );
  
      if ( key === "appendTo" ) {
        this.menuWrap.appendTo( this._appendTo() );
      }
  
      if ( key === "disabled" ) {
        this.menuInstance.option( "disabled", value );
        this.button
          .toggleClass( "ui-state-disabled", value )
          .attr( "aria-disabled", value );
  
        this.element.prop( "disabled", value );
        if ( value ) {
          this.button.attr( "tabindex", -1 );
          this.close();
        } else {
          this.button.attr( "tabindex", 0 );
        }
      }
  
      if ( key === "width" ) {
        this._resizeButton();
      }
    },
  
    _appendTo: function() {
      var element = this.options.appendTo;
  
      if ( element ) {
        element = element.jquery || element.nodeType ?
          $( element ) :
          this.document.find( element ).eq( 0 );
      }
  
      if ( !element || !element[ 0 ] ) {
        element = this.element.closest( ".ui-front" );
      }
  
      if ( !element.length ) {
        element = this.document[ 0 ].body;
      }
  
      return element;
    },
  
    _toggleAttr: function() {
      this.button
        .toggleClass( "ui-corner-top", this.isOpen )
        .toggleClass( "ui-corner-all", !this.isOpen )
        .attr( "aria-expanded", this.isOpen );
      this.menuWrap.toggleClass( "ui-selectmenu-open", this.isOpen );
      this.menu.attr( "aria-hidden", !this.isOpen );
    },
  
    _resizeButton: function() {
      var width = this.options.width;
  
      if ( !width ) {
        width = this.element.show().outerWidth();
        this.element.hide();
      }
  
      this.button.outerWidth( width );
    },
  
    _resizeMenu: function() {
      this.menu.outerWidth( Math.max(
        this.button.outerWidth(),
  
        // support: IE10
        // IE10 wraps long text (possibly a rounding bug)
        // so we add 1px to avoid the wrapping
        this.menu.width( "" ).outerWidth() + 1
      ) );
    },
  
    _getCreateOptions: function() {
      return { disabled: this.element.prop( "disabled" ) };
    },
  
    _parseOptions: function( options ) {
      var data = [];
      options.each(function( index, item ) {
        var option = $( item ),
          optgroup = option.parent( "optgroup" );
        data.push({
          element: option,
          index: index,
          value: option.val(),
          label: option.text(),
          optgroup: optgroup.attr( "label" ) || "",
          disabled: optgroup.prop( "disabled" ) || option.prop( "disabled" )
        });
      });
      this.items = data;
    },
  
    _destroy: function() {
      this.menuWrap.remove();
      this.button.remove();
      this.element.show();
      this.element.removeUniqueId();
      this.label.attr( "for", this.ids.element );
    }
  });
  
  
  /*!
   * jQuery UI Slider 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/slider/
   */
  
  
  var slider = $.widget( "ui.slider", $.ui.mouse, {
    version: "1.11.4",
    widgetEventPrefix: "slide",
  
    options: {
      animate: false,
      distance: 0,
      max: 100,
      min: 0,
      orientation: "horizontal",
      range: false,
      step: 1,
      value: 0,
      values: null,
  
      // callbacks
      change: null,
      slide: null,
      start: null,
      stop: null
    },
  
    // number of pages in a slider
    // (how many times can you page up/down to go through the whole range)
    numPages: 5,
  
    _create: function() {
      this._keySliding = false;
      this._mouseSliding = false;
      this._animateOff = true;
      this._handleIndex = null;
      this._detectOrientation();
      this._mouseInit();
      this._calculateNewMax();
  
      this.element
        .addClass( "ui-slider" +
          " ui-slider-" + this.orientation +
          " ui-widget" +
          " ui-widget-content" +
          " ui-corner-all");
  
      this._refresh();
      this._setOption( "disabled", this.options.disabled );
  
      this._animateOff = false;
    },
  
    _refresh: function() {
      this._createRange();
      this._createHandles();
      this._setupEvents();
      this._refreshValue();
    },
  
    _createHandles: function() {
      var i, handleCount,
        options = this.options,
        existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
        handle = "<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>",
        handles = [];
  
      handleCount = ( options.values && options.values.length ) || 1;
  
      if ( existingHandles.length > handleCount ) {
        existingHandles.slice( handleCount ).remove();
        existingHandles = existingHandles.slice( 0, handleCount );
      }
  
      for ( i = existingHandles.length; i < handleCount; i++ ) {
        handles.push( handle );
      }
  
      this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );
  
      this.handle = this.handles.eq( 0 );
  
      this.handles.each(function( i ) {
        $( this ).data( "ui-slider-handle-index", i );
      });
    },
  
    _createRange: function() {
      var options = this.options,
        classes = "";
  
      if ( options.range ) {
        if ( options.range === true ) {
          if ( !options.values ) {
            options.values = [ this._valueMin(), this._valueMin() ];
          } else if ( options.values.length && options.values.length !== 2 ) {
            options.values = [ options.values[0], options.values[0] ];
          } else if ( $.isArray( options.values ) ) {
            options.values = options.values.slice(0);
          }
        }
  
        if ( !this.range || !this.range.length ) {
          this.range = $( "<div></div>" )
            .appendTo( this.element );
  
          classes = "ui-slider-range" +
          // note: this isn't the most fittingly semantic framework class for this element,
          // but worked best visually with a variety of themes
          " ui-widget-header ui-corner-all";
        } else {
          this.range.removeClass( "ui-slider-range-min ui-slider-range-max" )
            // Handle range switching from true to min/max
            .css({
              "left": "",
              "bottom": ""
            });
        }
  
        this.range.addClass( classes +
          ( ( options.range === "min" || options.range === "max" ) ? " ui-slider-range-" + options.range : "" ) );
      } else {
        if ( this.range ) {
          this.range.remove();
        }
        this.range = null;
      }
    },
  
    _setupEvents: function() {
      this._off( this.handles );
      this._on( this.handles, this._handleEvents );
      this._hoverable( this.handles );
      this._focusable( this.handles );
    },
  
    _destroy: function() {
      this.handles.remove();
      if ( this.range ) {
        this.range.remove();
      }
  
      this.element
        .removeClass( "ui-slider" +
          " ui-slider-horizontal" +
          " ui-slider-vertical" +
          " ui-widget" +
          " ui-widget-content" +
          " ui-corner-all" );
  
      this._mouseDestroy();
    },
  
    _mouseCapture: function( event ) {
      var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
        that = this,
        o = this.options;
  
      if ( o.disabled ) {
        return false;
      }
  
      this.elementSize = {
        width: this.element.outerWidth(),
        height: this.element.outerHeight()
      };
      this.elementOffset = this.element.offset();
  
      position = { x: event.pageX, y: event.pageY };
      normValue = this._normValueFromMouse( position );
      distance = this._valueMax() - this._valueMin() + 1;
      this.handles.each(function( i ) {
        var thisDistance = Math.abs( normValue - that.values(i) );
        if (( distance > thisDistance ) ||
          ( distance === thisDistance &&
            (i === that._lastChangedValue || that.values(i) === o.min ))) {
          distance = thisDistance;
          closestHandle = $( this );
          index = i;
        }
      });
  
      allowed = this._start( event, index );
      if ( allowed === false ) {
        return false;
      }
      this._mouseSliding = true;
  
      this._handleIndex = index;
  
      closestHandle
        .addClass( "ui-state-active" )
        .focus();
  
      offset = closestHandle.offset();
      mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
      this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
        left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
        top: event.pageY - offset.top -
          ( closestHandle.height() / 2 ) -
          ( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
          ( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
          ( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
      };
  
      if ( !this.handles.hasClass( "ui-state-hover" ) ) {
        this._slide( event, index, normValue );
      }
      this._animateOff = true;
      return true;
    },
  
    _mouseStart: function() {
      return true;
    },
  
    _mouseDrag: function( event ) {
      var position = { x: event.pageX, y: event.pageY },
        normValue = this._normValueFromMouse( position );
  
      this._slide( event, this._handleIndex, normValue );
  
      return false;
    },
  
    _mouseStop: function( event ) {
      this.handles.removeClass( "ui-state-active" );
      this._mouseSliding = false;
  
      this._stop( event, this._handleIndex );
      this._change( event, this._handleIndex );
  
      this._handleIndex = null;
      this._clickOffset = null;
      this._animateOff = false;
  
      return false;
    },
  
    _detectOrientation: function() {
      this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
    },
  
    _normValueFromMouse: function( position ) {
      var pixelTotal,
        pixelMouse,
        percentMouse,
        valueTotal,
        valueMouse;
  
      if ( this.orientation === "horizontal" ) {
        pixelTotal = this.elementSize.width;
        pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
      } else {
        pixelTotal = this.elementSize.height;
        pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
      }
  
      percentMouse = ( pixelMouse / pixelTotal );
      if ( percentMouse > 1 ) {
        percentMouse = 1;
      }
      if ( percentMouse < 0 ) {
        percentMouse = 0;
      }
      if ( this.orientation === "vertical" ) {
        percentMouse = 1 - percentMouse;
      }
  
      valueTotal = this._valueMax() - this._valueMin();
      valueMouse = this._valueMin() + percentMouse * valueTotal;
  
      return this._trimAlignValue( valueMouse );
    },
  
    _start: function( event, index ) {
      var uiHash = {
        handle: this.handles[ index ],
        value: this.value()
      };
      if ( this.options.values && this.options.values.length ) {
        uiHash.value = this.values( index );
        uiHash.values = this.values();
      }
      return this._trigger( "start", event, uiHash );
    },
  
    _slide: function( event, index, newVal ) {
      var otherVal,
        newValues,
        allowed;
  
      if ( this.options.values && this.options.values.length ) {
        otherVal = this.values( index ? 0 : 1 );
  
        if ( ( this.options.values.length === 2 && this.options.range === true ) &&
            ( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
          ) {
          newVal = otherVal;
        }
  
        if ( newVal !== this.values( index ) ) {
          newValues = this.values();
          newValues[ index ] = newVal;
          // A slide can be canceled by returning false from the slide callback
          allowed = this._trigger( "slide", event, {
            handle: this.handles[ index ],
            value: newVal,
            values: newValues
          } );
          otherVal = this.values( index ? 0 : 1 );
          if ( allowed !== false ) {
            this.values( index, newVal );
          }
        }
      } else {
        if ( newVal !== this.value() ) {
          // A slide can be canceled by returning false from the slide callback
          allowed = this._trigger( "slide", event, {
            handle: this.handles[ index ],
            value: newVal
          } );
          if ( allowed !== false ) {
            this.value( newVal );
          }
        }
      }
    },
  
    _stop: function( event, index ) {
      var uiHash = {
        handle: this.handles[ index ],
        value: this.value()
      };
      if ( this.options.values && this.options.values.length ) {
        uiHash.value = this.values( index );
        uiHash.values = this.values();
      }
  
      this._trigger( "stop", event, uiHash );
    },
  
    _change: function( event, index ) {
      if ( !this._keySliding && !this._mouseSliding ) {
        var uiHash = {
          handle: this.handles[ index ],
          value: this.value()
        };
        if ( this.options.values && this.options.values.length ) {
          uiHash.value = this.values( index );
          uiHash.values = this.values();
        }
  
        //store the last changed value index for reference when handles overlap
        this._lastChangedValue = index;
  
        this._trigger( "change", event, uiHash );
      }
    },
  
    value: function( newValue ) {
      if ( arguments.length ) {
        this.options.value = this._trimAlignValue( newValue );
        this._refreshValue();
        this._change( null, 0 );
        return;
      }
  
      return this._value();
    },
  
    values: function( index, newValue ) {
      var vals,
        newValues,
        i;
  
      if ( arguments.length > 1 ) {
        this.options.values[ index ] = this._trimAlignValue( newValue );
        this._refreshValue();
        this._change( null, index );
        return;
      }
  
      if ( arguments.length ) {
        if ( $.isArray( arguments[ 0 ] ) ) {
          vals = this.options.values;
          newValues = arguments[ 0 ];
          for ( i = 0; i < vals.length; i += 1 ) {
            vals[ i ] = this._trimAlignValue( newValues[ i ] );
            this._change( null, i );
          }
          this._refreshValue();
        } else {
          if ( this.options.values && this.options.values.length ) {
            return this._values( index );
          } else {
            return this.value();
          }
        }
      } else {
        return this._values();
      }
    },
  
    _setOption: function( key, value ) {
      var i,
        valsLength = 0;
  
      if ( key === "range" && this.options.range === true ) {
        if ( value === "min" ) {
          this.options.value = this._values( 0 );
          this.options.values = null;
        } else if ( value === "max" ) {
          this.options.value = this._values( this.options.values.length - 1 );
          this.options.values = null;
        }
      }
  
      if ( $.isArray( this.options.values ) ) {
        valsLength = this.options.values.length;
      }
  
      if ( key === "disabled" ) {
        this.element.toggleClass( "ui-state-disabled", !!value );
      }
  
      this._super( key, value );
  
      switch ( key ) {
        case "orientation":
          this._detectOrientation();
          this.element
            .removeClass( "ui-slider-horizontal ui-slider-vertical" )
            .addClass( "ui-slider-" + this.orientation );
          this._refreshValue();
  
          // Reset positioning from previous orientation
          this.handles.css( value === "horizontal" ? "bottom" : "left", "" );
          break;
        case "value":
          this._animateOff = true;
          this._refreshValue();
          this._change( null, 0 );
          this._animateOff = false;
          break;
        case "values":
          this._animateOff = true;
          this._refreshValue();
          for ( i = 0; i < valsLength; i += 1 ) {
            this._change( null, i );
          }
          this._animateOff = false;
          break;
        case "step":
        case "min":
        case "max":
          this._animateOff = true;
          this._calculateNewMax();
          this._refreshValue();
          this._animateOff = false;
          break;
        case "range":
          this._animateOff = true;
          this._refresh();
          this._animateOff = false;
          break;
      }
    },
  
    //internal value getter
    // _value() returns value trimmed by min and max, aligned by step
    _value: function() {
      var val = this.options.value;
      val = this._trimAlignValue( val );
  
      return val;
    },
  
    //internal values getter
    // _values() returns array of values trimmed by min and max, aligned by step
    // _values( index ) returns single value trimmed by min and max, aligned by step
    _values: function( index ) {
      var val,
        vals,
        i;
  
      if ( arguments.length ) {
        val = this.options.values[ index ];
        val = this._trimAlignValue( val );
  
        return val;
      } else if ( this.options.values && this.options.values.length ) {
        // .slice() creates a copy of the array
        // this copy gets trimmed by min and max and then returned
        vals = this.options.values.slice();
        for ( i = 0; i < vals.length; i += 1) {
          vals[ i ] = this._trimAlignValue( vals[ i ] );
        }
  
        return vals;
      } else {
        return [];
      }
    },
  
    // returns the step-aligned value that val is closest to, between (inclusive) min and max
    _trimAlignValue: function( val ) {
      if ( val <= this._valueMin() ) {
        return this._valueMin();
      }
      if ( val >= this._valueMax() ) {
        return this._valueMax();
      }
      var step = ( this.options.step > 0 ) ? this.options.step : 1,
        valModStep = (val - this._valueMin()) % step,
        alignValue = val - valModStep;
  
      if ( Math.abs(valModStep) * 2 >= step ) {
        alignValue += ( valModStep > 0 ) ? step : ( -step );
      }
  
      // Since JavaScript has problems with large floats, round
      // the final value to 5 digits after the decimal point (see #4124)
      return parseFloat( alignValue.toFixed(5) );
    },
  
    _calculateNewMax: function() {
      var max = this.options.max,
        min = this._valueMin(),
        step = this.options.step,
        aboveMin = Math.floor( ( +( max - min ).toFixed( this._precision() ) ) / step ) * step;
      max = aboveMin + min;
      this.max = parseFloat( max.toFixed( this._precision() ) );
    },
  
    _precision: function() {
      var precision = this._precisionOf( this.options.step );
      if ( this.options.min !== null ) {
        precision = Math.max( precision, this._precisionOf( this.options.min ) );
      }
      return precision;
    },
  
    _precisionOf: function( num ) {
      var str = num.toString(),
        decimal = str.indexOf( "." );
      return decimal === -1 ? 0 : str.length - decimal - 1;
    },
  
    _valueMin: function() {
      return this.options.min;
    },
  
    _valueMax: function() {
      return this.max;
    },
  
    _refreshValue: function() {
      var lastValPercent, valPercent, value, valueMin, valueMax,
        oRange = this.options.range,
        o = this.options,
        that = this,
        animate = ( !this._animateOff ) ? o.animate : false,
        _set = {};
  
      if ( this.options.values && this.options.values.length ) {
        this.handles.each(function( i ) {
          valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
          _set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
          $( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
          if ( that.options.range === true ) {
            if ( that.orientation === "horizontal" ) {
              if ( i === 0 ) {
                that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
              }
              if ( i === 1 ) {
                that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
              }
            } else {
              if ( i === 0 ) {
                that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
              }
              if ( i === 1 ) {
                that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
              }
            }
          }
          lastValPercent = valPercent;
        });
      } else {
        value = this.value();
        valueMin = this._valueMin();
        valueMax = this._valueMax();
        valPercent = ( valueMax !== valueMin ) ?
            ( value - valueMin ) / ( valueMax - valueMin ) * 100 :
            0;
        _set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
        this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
  
        if ( oRange === "min" && this.orientation === "horizontal" ) {
          this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
        }
        if ( oRange === "max" && this.orientation === "horizontal" ) {
          this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
        }
        if ( oRange === "min" && this.orientation === "vertical" ) {
          this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
        }
        if ( oRange === "max" && this.orientation === "vertical" ) {
          this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
        }
      }
    },
  
    _handleEvents: {
      keydown: function( event ) {
        var allowed, curVal, newVal, step,
          index = $( event.target ).data( "ui-slider-handle-index" );
  
        switch ( event.keyCode ) {
          case $.ui.keyCode.HOME:
          case $.ui.keyCode.END:
          case $.ui.keyCode.PAGE_UP:
          case $.ui.keyCode.PAGE_DOWN:
          case $.ui.keyCode.UP:
          case $.ui.keyCode.RIGHT:
          case $.ui.keyCode.DOWN:
          case $.ui.keyCode.LEFT:
            event.preventDefault();
            if ( !this._keySliding ) {
              this._keySliding = true;
              $( event.target ).addClass( "ui-state-active" );
              allowed = this._start( event, index );
              if ( allowed === false ) {
                return;
              }
            }
            break;
        }
  
        step = this.options.step;
        if ( this.options.values && this.options.values.length ) {
          curVal = newVal = this.values( index );
        } else {
          curVal = newVal = this.value();
        }
  
        switch ( event.keyCode ) {
          case $.ui.keyCode.HOME:
            newVal = this._valueMin();
            break;
          case $.ui.keyCode.END:
            newVal = this._valueMax();
            break;
          case $.ui.keyCode.PAGE_UP:
            newVal = this._trimAlignValue(
              curVal + ( ( this._valueMax() - this._valueMin() ) / this.numPages )
            );
            break;
          case $.ui.keyCode.PAGE_DOWN:
            newVal = this._trimAlignValue(
              curVal - ( (this._valueMax() - this._valueMin()) / this.numPages ) );
            break;
          case $.ui.keyCode.UP:
          case $.ui.keyCode.RIGHT:
            if ( curVal === this._valueMax() ) {
              return;
            }
            newVal = this._trimAlignValue( curVal + step );
            break;
          case $.ui.keyCode.DOWN:
          case $.ui.keyCode.LEFT:
            if ( curVal === this._valueMin() ) {
              return;
            }
            newVal = this._trimAlignValue( curVal - step );
            break;
        }
  
        this._slide( event, index, newVal );
      },
      keyup: function( event ) {
        var index = $( event.target ).data( "ui-slider-handle-index" );
  
        if ( this._keySliding ) {
          this._keySliding = false;
          this._stop( event, index );
          this._change( event, index );
          $( event.target ).removeClass( "ui-state-active" );
        }
      }
    }
  });
  
  
  /*!
   * jQuery UI Sortable 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/sortable/
   */
  
  
  var sortable = $.widget("ui.sortable", $.ui.mouse, {
    version: "1.11.4",
    widgetEventPrefix: "sort",
    ready: false,
    options: {
      appendTo: "parent",
      axis: false,
      connectWith: false,
      containment: false,
      cursor: "auto",
      cursorAt: false,
      dropOnEmpty: true,
      forcePlaceholderSize: false,
      forceHelperSize: false,
      grid: false,
      handle: false,
      helper: "original",
      items: "> *",
      opacity: false,
      placeholder: false,
      revert: false,
      scroll: true,
      scrollSensitivity: 20,
      scrollSpeed: 20,
      scope: "default",
      tolerance: "intersect",
      zIndex: 1000,
  
      // callbacks
      activate: null,
      beforeStop: null,
      change: null,
      deactivate: null,
      out: null,
      over: null,
      receive: null,
      remove: null,
      sort: null,
      start: null,
      stop: null,
      update: null
    },
  
    _isOverAxis: function( x, reference, size ) {
      return ( x >= reference ) && ( x < ( reference + size ) );
    },
  
    _isFloating: function( item ) {
      return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
    },
  
    _create: function() {
      this.containerCache = {};
      this.element.addClass("ui-sortable");
  
      //Get the items
      this.refresh();
  
      //Let's determine the parent's offset
      this.offset = this.element.offset();
  
      //Initialize mouse events for interaction
      this._mouseInit();
  
      this._setHandleClassName();
  
      //We're ready to go
      this.ready = true;
  
    },
  
    _setOption: function( key, value ) {
      this._super( key, value );
  
      if ( key === "handle" ) {
        this._setHandleClassName();
      }
    },
  
    _setHandleClassName: function() {
      this.element.find( ".ui-sortable-handle" ).removeClass( "ui-sortable-handle" );
      $.each( this.items, function() {
        ( this.instance.options.handle ?
          this.item.find( this.instance.options.handle ) : this.item )
          .addClass( "ui-sortable-handle" );
      });
    },
  
    _destroy: function() {
      this.element
        .removeClass( "ui-sortable ui-sortable-disabled" )
        .find( ".ui-sortable-handle" )
          .removeClass( "ui-sortable-handle" );
      this._mouseDestroy();
  
      for ( var i = this.items.length - 1; i >= 0; i-- ) {
        this.items[i].item.removeData(this.widgetName + "-item");
      }
  
      return this;
    },
  
    _mouseCapture: function(event, overrideHandle) {
      var currentItem = null,
        validHandle = false,
        that = this;
  
      if (this.reverting) {
        return false;
      }
  
      if(this.options.disabled || this.options.type === "static") {
        return false;
      }
  
      //We have to refresh the items data once first
      this._refreshItems(event);
  
      //Find out if the clicked node (or one of its parents) is a actual item in this.items
      $(event.target).parents().each(function() {
        if($.data(this, that.widgetName + "-item") === that) {
          currentItem = $(this);
          return false;
        }
      });
      if($.data(event.target, that.widgetName + "-item") === that) {
        currentItem = $(event.target);
      }
  
      if(!currentItem) {
        return false;
      }
      if(this.options.handle && !overrideHandle) {
        $(this.options.handle, currentItem).find("*").addBack().each(function() {
          if(this === event.target) {
            validHandle = true;
          }
        });
        if(!validHandle) {
          return false;
        }
      }
  
      this.currentItem = currentItem;
      this._removeCurrentsFromItems();
      return true;
  
    },
  
    _mouseStart: function(event, overrideHandle, noActivation) {
  
      var i, body,
        o = this.options;
  
      this.currentContainer = this;
  
      //We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
      this.refreshPositions();
  
      //Create and append the visible helper
      this.helper = this._createHelper(event);
  
      //Cache the helper size
      this._cacheHelperProportions();
  
      /*
       * - Position generation -
       * This block generates everything position related - it's the core of draggables.
       */
  
      //Cache the margins of the original element
      this._cacheMargins();
  
      //Get the next scrolling parent
      this.scrollParent = this.helper.scrollParent();
  
      //The element's absolute position on the page minus margins
      this.offset = this.currentItem.offset();
      this.offset = {
        top: this.offset.top - this.margins.top,
        left: this.offset.left - this.margins.left
      };
  
      $.extend(this.offset, {
        click: { //Where the click happened, relative to the element
          left: event.pageX - this.offset.left,
          top: event.pageY - this.offset.top
        },
        parent: this._getParentOffset(),
        relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
      });
  
      // Only after we got the offset, we can change the helper's position to absolute
      // TODO: Still need to figure out a way to make relative sorting possible
      this.helper.css("position", "absolute");
      this.cssPosition = this.helper.css("position");
  
      //Generate the original position
      this.originalPosition = this._generatePosition(event);
      this.originalPageX = event.pageX;
      this.originalPageY = event.pageY;
  
      //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
      (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));
  
      //Cache the former DOM position
      this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };
  
      //If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
      if(this.helper[0] !== this.currentItem[0]) {
        this.currentItem.hide();
      }
  
      //Create the placeholder
      this._createPlaceholder();
  
      //Set a containment if given in the options
      if(o.containment) {
        this._setContainment();
      }
  
      if( o.cursor && o.cursor !== "auto" ) { // cursor option
        body = this.document.find( "body" );
  
        // support: IE
        this.storedCursor = body.css( "cursor" );
        body.css( "cursor", o.cursor );
  
        this.storedStylesheet = $( "<style>*{ cursor: "+o.cursor+" !important; }</style>" ).appendTo( body );
      }
  
      if(o.opacity) { // opacity option
        if (this.helper.css("opacity")) {
          this._storedOpacity = this.helper.css("opacity");
        }
        this.helper.css("opacity", o.opacity);
      }
  
      if(o.zIndex) { // zIndex option
        if (this.helper.css("zIndex")) {
          this._storedZIndex = this.helper.css("zIndex");
        }
        this.helper.css("zIndex", o.zIndex);
      }
  
      //Prepare scrolling
      if(this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
        this.overflowOffset = this.scrollParent.offset();
      }
  
      //Call callbacks
      this._trigger("start", event, this._uiHash());
  
      //Recache the helper size
      if(!this._preserveHelperProportions) {
        this._cacheHelperProportions();
      }
  
  
      //Post "activate" events to possible containers
      if( !noActivation ) {
        for ( i = this.containers.length - 1; i >= 0; i-- ) {
          this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
        }
      }
  
      //Prepare possible droppables
      if($.ui.ddmanager) {
        $.ui.ddmanager.current = this;
      }
  
      if ($.ui.ddmanager && !o.dropBehaviour) {
        $.ui.ddmanager.prepareOffsets(this, event);
      }
  
      this.dragging = true;
  
      this.helper.addClass("ui-sortable-helper");
      this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
      return true;
  
    },
  
    _mouseDrag: function(event) {
      var i, item, itemElement, intersection,
        o = this.options,
        scrolled = false;
  
      //Compute the helpers position
      this.position = this._generatePosition(event);
      this.positionAbs = this._convertPositionTo("absolute");
  
      if (!this.lastPositionAbs) {
        this.lastPositionAbs = this.positionAbs;
      }
  
      //Do scrolling
      if(this.options.scroll) {
        if(this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
  
          if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
            this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
          } else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
            this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
          }
  
          if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
            this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
          } else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
            this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
          }
  
        } else {
  
          if(event.pageY - this.document.scrollTop() < o.scrollSensitivity) {
            scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);
          } else if(this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {
            scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);
          }
  
          if(event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {
            scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);
          } else if(this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {
            scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);
          }
  
        }
  
        if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
          $.ui.ddmanager.prepareOffsets(this, event);
        }
      }
  
      //Regenerate the absolute position used for position checks
      this.positionAbs = this._convertPositionTo("absolute");
  
      //Set the helper position
      if(!this.options.axis || this.options.axis !== "y") {
        this.helper[0].style.left = this.position.left+"px";
      }
      if(!this.options.axis || this.options.axis !== "x") {
        this.helper[0].style.top = this.position.top+"px";
      }
  
      //Rearrange
      for (i = this.items.length - 1; i >= 0; i--) {
  
        //Cache variables and intersection, continue if no intersection
        item = this.items[i];
        itemElement = item.item[0];
        intersection = this._intersectsWithPointer(item);
        if (!intersection) {
          continue;
        }
  
        // Only put the placeholder inside the current Container, skip all
        // items from other containers. This works because when moving
        // an item from one container to another the
        // currentContainer is switched before the placeholder is moved.
        //
        // Without this, moving items in "sub-sortables" can cause
        // the placeholder to jitter between the outer and inner container.
        if (item.instance !== this.currentContainer) {
          continue;
        }
  
        // cannot intersect with itself
        // no useless actions that have been done before
        // no action if the item moved is the parent of the item checked
        if (itemElement !== this.currentItem[0] &&
          this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
          !$.contains(this.placeholder[0], itemElement) &&
          (this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
        ) {
  
          this.direction = intersection === 1 ? "down" : "up";
  
          if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
            this._rearrange(event, item);
          } else {
            break;
          }
  
          this._trigger("change", event, this._uiHash());
          break;
        }
      }
  
      //Post events to containers
      this._contactContainers(event);
  
      //Interconnect with droppables
      if($.ui.ddmanager) {
        $.ui.ddmanager.drag(this, event);
      }
  
      //Call callbacks
      this._trigger("sort", event, this._uiHash());
  
      this.lastPositionAbs = this.positionAbs;
      return false;
  
    },
  
    _mouseStop: function(event, noPropagation) {
  
      if(!event) {
        return;
      }
  
      //If we are using droppables, inform the manager about the drop
      if ($.ui.ddmanager && !this.options.dropBehaviour) {
        $.ui.ddmanager.drop(this, event);
      }
  
      if(this.options.revert) {
        var that = this,
          cur = this.placeholder.offset(),
          axis = this.options.axis,
          animation = {};
  
        if ( !axis || axis === "x" ) {
          animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);
        }
        if ( !axis || axis === "y" ) {
          animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);
        }
        this.reverting = true;
        $(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {
          that._clear(event);
        });
      } else {
        this._clear(event, noPropagation);
      }
  
      return false;
  
    },
  
    cancel: function() {
  
      if(this.dragging) {
  
        this._mouseUp({ target: null });
  
        if(this.options.helper === "original") {
          this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
        } else {
          this.currentItem.show();
        }
  
        //Post deactivating events to containers
        for (var i = this.containers.length - 1; i >= 0; i--){
          this.containers[i]._trigger("deactivate", null, this._uiHash(this));
          if(this.containers[i].containerCache.over) {
            this.containers[i]._trigger("out", null, this._uiHash(this));
            this.containers[i].containerCache.over = 0;
          }
        }
  
      }
  
      if (this.placeholder) {
        //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
        if(this.placeholder[0].parentNode) {
          this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
        }
        if(this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
          this.helper.remove();
        }
  
        $.extend(this, {
          helper: null,
          dragging: false,
          reverting: false,
          _noFinalSort: null
        });
  
        if(this.domPosition.prev) {
          $(this.domPosition.prev).after(this.currentItem);
        } else {
          $(this.domPosition.parent).prepend(this.currentItem);
        }
      }
  
      return this;
  
    },
  
    serialize: function(o) {
  
      var items = this._getItemsAsjQuery(o && o.connected),
        str = [];
      o = o || {};
  
      $(items).each(function() {
        var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
        if (res) {
          str.push((o.key || res[1]+"[]")+"="+(o.key && o.expression ? res[1] : res[2]));
        }
      });
  
      if(!str.length && o.key) {
        str.push(o.key + "=");
      }
  
      return str.join("&");
  
    },
  
    toArray: function(o) {
  
      var items = this._getItemsAsjQuery(o && o.connected),
        ret = [];
  
      o = o || {};
  
      items.each(function() { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
      return ret;
  
    },
  
    /* Be careful with the following core functions */
    _intersectsWith: function(item) {
  
      var x1 = this.positionAbs.left,
        x2 = x1 + this.helperProportions.width,
        y1 = this.positionAbs.top,
        y2 = y1 + this.helperProportions.height,
        l = item.left,
        r = l + item.width,
        t = item.top,
        b = t + item.height,
        dyClick = this.offset.click.top,
        dxClick = this.offset.click.left,
        isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),
        isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),
        isOverElement = isOverElementHeight && isOverElementWidth;
  
      if ( this.options.tolerance === "pointer" ||
        this.options.forcePointerForContainers ||
        (this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
      ) {
        return isOverElement;
      } else {
  
        return (l < x1 + (this.helperProportions.width / 2) && // Right Half
          x2 - (this.helperProportions.width / 2) < r && // Left Half
          t < y1 + (this.helperProportions.height / 2) && // Bottom Half
          y2 - (this.helperProportions.height / 2) < b ); // Top Half
  
      }
    },
  
    _intersectsWithPointer: function(item) {
  
      var isOverElementHeight = (this.options.axis === "x") || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
        isOverElementWidth = (this.options.axis === "y") || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
        isOverElement = isOverElementHeight && isOverElementWidth,
        verticalDirection = this._getDragVerticalDirection(),
        horizontalDirection = this._getDragHorizontalDirection();
  
      if (!isOverElement) {
        return false;
      }
  
      return this.floating ?
        ( ((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1 )
        : ( verticalDirection && (verticalDirection === "down" ? 2 : 1) );
  
    },
  
    _intersectsWithSides: function(item) {
  
      var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
        isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
        verticalDirection = this._getDragVerticalDirection(),
        horizontalDirection = this._getDragHorizontalDirection();
  
      if (this.floating && horizontalDirection) {
        return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
      } else {
        return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
      }
  
    },
  
    _getDragVerticalDirection: function() {
      var delta = this.positionAbs.top - this.lastPositionAbs.top;
      return delta !== 0 && (delta > 0 ? "down" : "up");
    },
  
    _getDragHorizontalDirection: function() {
      var delta = this.positionAbs.left - this.lastPositionAbs.left;
      return delta !== 0 && (delta > 0 ? "right" : "left");
    },
  
    refresh: function(event) {
      this._refreshItems(event);
      this._setHandleClassName();
      this.refreshPositions();
      return this;
    },
  
    _connectWith: function() {
      var options = this.options;
      return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
    },
  
    _getItemsAsjQuery: function(connected) {
  
      var i, j, cur, inst,
        items = [],
        queries = [],
        connectWith = this._connectWith();
  
      if(connectWith && connected) {
        for (i = connectWith.length - 1; i >= 0; i--){
          cur = $(connectWith[i], this.document[0]);
          for ( j = cur.length - 1; j >= 0; j--){
            inst = $.data(cur[j], this.widgetFullName);
            if(inst && inst !== this && !inst.options.disabled) {
              queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
            }
          }
        }
      }
  
      queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);
  
      function addItems() {
        items.push( this );
      }
      for (i = queries.length - 1; i >= 0; i--){
        queries[i][0].each( addItems );
      }
  
      return $(items);
  
    },
  
    _removeCurrentsFromItems: function() {
  
      var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
  
      this.items = $.grep(this.items, function (item) {
        for (var j=0; j < list.length; j++) {
          if(list[j] === item.item[0]) {
            return false;
          }
        }
        return true;
      });
  
    },
  
    _refreshItems: function(event) {
  
      this.items = [];
      this.containers = [this];
  
      var i, j, cur, inst, targetData, _queries, item, queriesLength,
        items = this.items,
        queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
        connectWith = this._connectWith();
  
      if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
        for (i = connectWith.length - 1; i >= 0; i--){
          cur = $(connectWith[i], this.document[0]);
          for (j = cur.length - 1; j >= 0; j--){
            inst = $.data(cur[j], this.widgetFullName);
            if(inst && inst !== this && !inst.options.disabled) {
              queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
              this.containers.push(inst);
            }
          }
        }
      }
  
      for (i = queries.length - 1; i >= 0; i--) {
        targetData = queries[i][1];
        _queries = queries[i][0];
  
        for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {
          item = $(_queries[j]);
  
          item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)
  
          items.push({
            item: item,
            instance: targetData,
            width: 0, height: 0,
            left: 0, top: 0
          });
        }
      }
  
    },
  
    refreshPositions: function(fast) {
  
      // Determine whether items are being displayed horizontally
      this.floating = this.items.length ?
        this.options.axis === "x" || this._isFloating( this.items[ 0 ].item ) :
        false;
  
      //This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
      if(this.offsetParent && this.helper) {
        this.offset.parent = this._getParentOffset();
      }
  
      var i, item, t, p;
  
      for (i = this.items.length - 1; i >= 0; i--){
        item = this.items[i];
  
        //We ignore calculating positions of all connected containers when we're not over them
        if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
          continue;
        }
  
        t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
  
        if (!fast) {
          item.width = t.outerWidth();
          item.height = t.outerHeight();
        }
  
        p = t.offset();
        item.left = p.left;
        item.top = p.top;
      }
  
      if(this.options.custom && this.options.custom.refreshContainers) {
        this.options.custom.refreshContainers.call(this);
      } else {
        for (i = this.containers.length - 1; i >= 0; i--){
          p = this.containers[i].element.offset();
          this.containers[i].containerCache.left = p.left;
          this.containers[i].containerCache.top = p.top;
          this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
          this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
        }
      }
  
      return this;
    },
  
    _createPlaceholder: function(that) {
      that = that || this;
      var className,
        o = that.options;
  
      if(!o.placeholder || o.placeholder.constructor === String) {
        className = o.placeholder;
        o.placeholder = {
          element: function() {
  
            var nodeName = that.currentItem[0].nodeName.toLowerCase(),
              element = $( "<" + nodeName + ">", that.document[0] )
                .addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
                .removeClass("ui-sortable-helper");
  
            if ( nodeName === "tbody" ) {
              that._createTrPlaceholder(
                that.currentItem.find( "tr" ).eq( 0 ),
                $( "<tr>", that.document[ 0 ] ).appendTo( element )
              );
            } else if ( nodeName === "tr" ) {
              that._createTrPlaceholder( that.currentItem, element );
            } else if ( nodeName === "img" ) {
              element.attr( "src", that.currentItem.attr( "src" ) );
            }
  
            if ( !className ) {
              element.css( "visibility", "hidden" );
            }
  
            return element;
          },
          update: function(container, p) {
  
            // 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
            // 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
            if(className && !o.forcePlaceholderSize) {
              return;
            }
  
            //If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
            if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop")||0, 10) - parseInt(that.currentItem.css("paddingBottom")||0, 10)); }
            if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft")||0, 10) - parseInt(that.currentItem.css("paddingRight")||0, 10)); }
          }
        };
      }
  
      //Create the placeholder
      that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
  
      //Append it after the actual current item
      that.currentItem.after(that.placeholder);
  
      //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
      o.placeholder.update(that, that.placeholder);
  
    },
  
    _createTrPlaceholder: function( sourceTr, targetTr ) {
      var that = this;
  
      sourceTr.children().each(function() {
        $( "<td>&#160;</td>", that.document[ 0 ] )
          .attr( "colspan", $( this ).attr( "colspan" ) || 1 )
          .appendTo( targetTr );
      });
    },
  
    _contactContainers: function(event) {
      var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom, floating, axis,
        innermostContainer = null,
        innermostIndex = null;
  
      // get innermost container that intersects with item
      for (i = this.containers.length - 1; i >= 0; i--) {
  
        // never consider a container that's located within the item itself
        if($.contains(this.currentItem[0], this.containers[i].element[0])) {
          continue;
        }
  
        if(this._intersectsWith(this.containers[i].containerCache)) {
  
          // if we've already found a container and it's more "inner" than this, then continue
          if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
            continue;
          }
  
          innermostContainer = this.containers[i];
          innermostIndex = i;
  
        } else {
          // container doesn't intersect. trigger "out" event if necessary
          if(this.containers[i].containerCache.over) {
            this.containers[i]._trigger("out", event, this._uiHash(this));
            this.containers[i].containerCache.over = 0;
          }
        }
  
      }
  
      // if no intersecting containers found, return
      if(!innermostContainer) {
        return;
      }
  
      // move the item into the container if it's not there already
      if(this.containers.length === 1) {
        if (!this.containers[innermostIndex].containerCache.over) {
          this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
          this.containers[innermostIndex].containerCache.over = 1;
        }
      } else {
  
        //When entering a new container, we will find the item with the least distance and append our item near it
        dist = 10000;
        itemWithLeastDistance = null;
        floating = innermostContainer.floating || this._isFloating(this.currentItem);
        posProperty = floating ? "left" : "top";
        sizeProperty = floating ? "width" : "height";
        axis = floating ? "clientX" : "clientY";
  
        for (j = this.items.length - 1; j >= 0; j--) {
          if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
            continue;
          }
          if(this.items[j].item[0] === this.currentItem[0]) {
            continue;
          }
  
          cur = this.items[j].item.offset()[posProperty];
          nearBottom = false;
          if ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) {
            nearBottom = true;
          }
  
          if ( Math.abs( event[ axis ] - cur ) < dist ) {
            dist = Math.abs( event[ axis ] - cur );
            itemWithLeastDistance = this.items[ j ];
            this.direction = nearBottom ? "up": "down";
          }
        }
  
        //Check if dropOnEmpty is enabled
        if(!itemWithLeastDistance && !this.options.dropOnEmpty) {
          return;
        }
  
        if(this.currentContainer === this.containers[innermostIndex]) {
          if ( !this.currentContainer.containerCache.over ) {
            this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash() );
            this.currentContainer.containerCache.over = 1;
          }
          return;
        }
  
        itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
        this._trigger("change", event, this._uiHash());
        this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
        this.currentContainer = this.containers[innermostIndex];
  
        //Update the placeholder
        this.options.placeholder.update(this.currentContainer, this.placeholder);
  
        this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
        this.containers[innermostIndex].containerCache.over = 1;
      }
  
  
    },
  
    _createHelper: function(event) {
  
      var o = this.options,
        helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);
  
      //Add the helper to the DOM if that didn't happen already
      if(!helper.parents("body").length) {
        $(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
      }
  
      if(helper[0] === this.currentItem[0]) {
        this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
      }
  
      if(!helper[0].style.width || o.forceHelperSize) {
        helper.width(this.currentItem.width());
      }
      if(!helper[0].style.height || o.forceHelperSize) {
        helper.height(this.currentItem.height());
      }
  
      return helper;
  
    },
  
    _adjustOffsetFromHelper: function(obj) {
      if (typeof obj === "string") {
        obj = obj.split(" ");
      }
      if ($.isArray(obj)) {
        obj = {left: +obj[0], top: +obj[1] || 0};
      }
      if ("left" in obj) {
        this.offset.click.left = obj.left + this.margins.left;
      }
      if ("right" in obj) {
        this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
      }
      if ("top" in obj) {
        this.offset.click.top = obj.top + this.margins.top;
      }
      if ("bottom" in obj) {
        this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
      }
    },
  
    _getParentOffset: function() {
  
  
      //Get the offsetParent and cache its position
      this.offsetParent = this.helper.offsetParent();
      var po = this.offsetParent.offset();
  
      // This is a special case where we need to modify a offset calculated on start, since the following happened:
      // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
      // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
      //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
      if(this.cssPosition === "absolute" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {
        po.left += this.scrollParent.scrollLeft();
        po.top += this.scrollParent.scrollTop();
      }
  
      // This needs to be actually done for all browsers, since pageX/pageY includes this information
      // with an ugly IE fix
      if( this.offsetParent[0] === this.document[0].body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
        po = { top: 0, left: 0 };
      }
  
      return {
        top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
        left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
      };
  
    },
  
    _getRelativeOffset: function() {
  
      if(this.cssPosition === "relative") {
        var p = this.currentItem.position();
        return {
          top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
          left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
        };
      } else {
        return { top: 0, left: 0 };
      }
  
    },
  
    _cacheMargins: function() {
      this.margins = {
        left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
        top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
      };
    },
  
    _cacheHelperProportions: function() {
      this.helperProportions = {
        width: this.helper.outerWidth(),
        height: this.helper.outerHeight()
      };
    },
  
    _setContainment: function() {
  
      var ce, co, over,
        o = this.options;
      if(o.containment === "parent") {
        o.containment = this.helper[0].parentNode;
      }
      if(o.containment === "document" || o.containment === "window") {
        this.containment = [
          0 - this.offset.relative.left - this.offset.parent.left,
          0 - this.offset.relative.top - this.offset.parent.top,
          o.containment === "document" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left,
          (o.containment === "document" ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
        ];
      }
  
      if(!(/^(document|window|parent)$/).test(o.containment)) {
        ce = $(o.containment)[0];
        co = $(o.containment).offset();
        over = ($(ce).css("overflow") !== "hidden");
  
        this.containment = [
          co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
          co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
          co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
          co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
        ];
      }
  
    },
  
    _convertPositionTo: function(d, pos) {
  
      if(!pos) {
        pos = this.position;
      }
      var mod = d === "absolute" ? 1 : -1,
        scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
        scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
  
      return {
        top: (
          pos.top	+																// The absolute mouse position
          this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.parent.top * mod -											// The offsetParent's offset without borders (offset + border)
          ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
        ),
        left: (
          pos.left +																// The absolute mouse position
          this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
          ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
        )
      };
  
    },
  
    _generatePosition: function(event) {
  
      var top, left,
        o = this.options,
        pageX = event.pageX,
        pageY = event.pageY,
        scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
  
      // This is another very weird special case that only happens for relative elements:
      // 1. If the css position is relative
      // 2. and the scroll parent is the document or similar to the offset parent
      // we have to refresh the relative offset during the scroll so there are no jumps
      if(this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {
        this.offset.relative = this._getRelativeOffset();
      }
  
      /*
       * - Position constraining -
       * Constrain the position to a mix of grid, containment.
       */
  
      if(this.originalPosition) { //If we are not dragging yet, we won't check for options
  
        if(this.containment) {
          if(event.pageX - this.offset.click.left < this.containment[0]) {
            pageX = this.containment[0] + this.offset.click.left;
          }
          if(event.pageY - this.offset.click.top < this.containment[1]) {
            pageY = this.containment[1] + this.offset.click.top;
          }
          if(event.pageX - this.offset.click.left > this.containment[2]) {
            pageX = this.containment[2] + this.offset.click.left;
          }
          if(event.pageY - this.offset.click.top > this.containment[3]) {
            pageY = this.containment[3] + this.offset.click.top;
          }
        }
  
        if(o.grid) {
          top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
          pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;
  
          left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
          pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
        }
  
      }
  
      return {
        top: (
          pageY -																// The absolute mouse position
          this.offset.click.top -													// Click offset (relative to the element)
          this.offset.relative.top	-											// Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
          ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
        ),
        left: (
          pageX -																// The absolute mouse position
          this.offset.click.left -												// Click offset (relative to the element)
          this.offset.relative.left	-											// Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
          ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
        )
      };
  
    },
  
    _rearrange: function(event, i, a, hardRefresh) {
  
      a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));
  
      //Various things done here to improve the performance:
      // 1. we create a setTimeout, that calls refreshPositions
      // 2. on the instance, we have a counter variable, that get's higher after every append
      // 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
      // 4. this lets only the last addition to the timeout stack through
      this.counter = this.counter ? ++this.counter : 1;
      var counter = this.counter;
  
      this._delay(function() {
        if(counter === this.counter) {
          this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
        }
      });
  
    },
  
    _clear: function(event, noPropagation) {
  
      this.reverting = false;
      // We delay all events that have to be triggered to after the point where the placeholder has been removed and
      // everything else normalized again
      var i,
        delayedTriggers = [];
  
      // We first have to update the dom position of the actual currentItem
      // Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
      if(!this._noFinalSort && this.currentItem.parent().length) {
        this.placeholder.before(this.currentItem);
      }
      this._noFinalSort = null;
  
      if(this.helper[0] === this.currentItem[0]) {
        for(i in this._storedCSS) {
          if(this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
            this._storedCSS[i] = "";
          }
        }
        this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
      } else {
        this.currentItem.show();
      }
  
      if(this.fromOutside && !noPropagation) {
        delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
      }
      if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
        delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
      }
  
      // Check if the items Container has Changed and trigger appropriate
      // events.
      if (this !== this.currentContainer) {
        if(!noPropagation) {
          delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
          delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
          delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
        }
      }
  
  
      //Post events to containers
      function delayEvent( type, instance, container ) {
        return function( event ) {
          container._trigger( type, event, instance._uiHash( instance ) );
        };
      }
      for (i = this.containers.length - 1; i >= 0; i--){
        if (!noPropagation) {
          delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );
        }
        if(this.containers[i].containerCache.over) {
          delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );
          this.containers[i].containerCache.over = 0;
        }
      }
  
      //Do what was originally in plugins
      if ( this.storedCursor ) {
        this.document.find( "body" ).css( "cursor", this.storedCursor );
        this.storedStylesheet.remove();
      }
      if(this._storedOpacity) {
        this.helper.css("opacity", this._storedOpacity);
      }
      if(this._storedZIndex) {
        this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
      }
  
      this.dragging = false;
  
      if(!noPropagation) {
        this._trigger("beforeStop", event, this._uiHash());
      }
  
      //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
      this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
  
      if ( !this.cancelHelperRemoval ) {
        if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
          this.helper.remove();
        }
        this.helper = null;
      }
  
      if(!noPropagation) {
        for (i=0; i < delayedTriggers.length; i++) {
          delayedTriggers[i].call(this, event);
        } //Trigger all delayed events
        this._trigger("stop", event, this._uiHash());
      }
  
      this.fromOutside = false;
      return !this.cancelHelperRemoval;
  
    },
  
    _trigger: function() {
      if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
        this.cancel();
      }
    },
  
    _uiHash: function(_inst) {
      var inst = _inst || this;
      return {
        helper: inst.helper,
        placeholder: inst.placeholder || $([]),
        position: inst.position,
        originalPosition: inst.originalPosition,
        offset: inst.positionAbs,
        item: inst.currentItem,
        sender: _inst ? _inst.element : null
      };
    }
  
  });
  
  
  /*!
   * jQuery UI Spinner 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/spinner/
   */
  
  
  function spinner_modifier( fn ) {
    return function() {
      var previous = this.element.val();
      fn.apply( this, arguments );
      this._refresh();
      if ( previous !== this.element.val() ) {
        this._trigger( "change" );
      }
    };
  }
  
  var spinner = $.widget( "ui.spinner", {
    version: "1.11.4",
    defaultElement: "<input>",
    widgetEventPrefix: "spin",
    options: {
      culture: null,
      icons: {
        down: "ui-icon-triangle-1-s",
        up: "ui-icon-triangle-1-n"
      },
      incremental: true,
      max: null,
      min: null,
      numberFormat: null,
      page: 10,
      step: 1,
  
      change: null,
      spin: null,
      start: null,
      stop: null
    },
  
    _create: function() {
      // handle string values that need to be parsed
      this._setOption( "max", this.options.max );
      this._setOption( "min", this.options.min );
      this._setOption( "step", this.options.step );
  
      // Only format if there is a value, prevents the field from being marked
      // as invalid in Firefox, see #9573.
      if ( this.value() !== "" ) {
        // Format the value, but don't constrain.
        this._value( this.element.val(), true );
      }
  
      this._draw();
      this._on( this._events );
      this._refresh();
  
      // turning off autocomplete prevents the browser from remembering the
      // value when navigating through history, so we re-enable autocomplete
      // if the page is unloaded before the widget is destroyed. #7790
      this._on( this.window, {
        beforeunload: function() {
          this.element.removeAttr( "autocomplete" );
        }
      });
    },
  
    _getCreateOptions: function() {
      var options = {},
        element = this.element;
  
      $.each( [ "min", "max", "step" ], function( i, option ) {
        var value = element.attr( option );
        if ( value !== undefined && value.length ) {
          options[ option ] = value;
        }
      });
  
      return options;
    },
  
    _events: {
      keydown: function( event ) {
        if ( this._start( event ) && this._keydown( event ) ) {
          event.preventDefault();
        }
      },
      keyup: "_stop",
      focus: function() {
        this.previous = this.element.val();
      },
      blur: function( event ) {
        if ( this.cancelBlur ) {
          delete this.cancelBlur;
          return;
        }
  
        this._stop();
        this._refresh();
        if ( this.previous !== this.element.val() ) {
          this._trigger( "change", event );
        }
      },
      mousewheel: function( event, delta ) {
        if ( !delta ) {
          return;
        }
        if ( !this.spinning && !this._start( event ) ) {
          return false;
        }
  
        this._spin( (delta > 0 ? 1 : -1) * this.options.step, event );
        clearTimeout( this.mousewheelTimer );
        this.mousewheelTimer = this._delay(function() {
          if ( this.spinning ) {
            this._stop( event );
          }
        }, 100 );
        event.preventDefault();
      },
      "mousedown .ui-spinner-button": function( event ) {
        var previous;
  
        // We never want the buttons to have focus; whenever the user is
        // interacting with the spinner, the focus should be on the input.
        // If the input is focused then this.previous is properly set from
        // when the input first received focus. If the input is not focused
        // then we need to set this.previous based on the value before spinning.
        previous = this.element[0] === this.document[0].activeElement ?
          this.previous : this.element.val();
        function checkFocus() {
          var isActive = this.element[0] === this.document[0].activeElement;
          if ( !isActive ) {
            this.element.focus();
            this.previous = previous;
            // support: IE
            // IE sets focus asynchronously, so we need to check if focus
            // moved off of the input because the user clicked on the button.
            this._delay(function() {
              this.previous = previous;
            });
          }
        }
  
        // ensure focus is on (or stays on) the text field
        event.preventDefault();
        checkFocus.call( this );
  
        // support: IE
        // IE doesn't prevent moving focus even with event.preventDefault()
        // so we set a flag to know when we should ignore the blur event
        // and check (again) if focus moved off of the input.
        this.cancelBlur = true;
        this._delay(function() {
          delete this.cancelBlur;
          checkFocus.call( this );
        });
  
        if ( this._start( event ) === false ) {
          return;
        }
  
        this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
      },
      "mouseup .ui-spinner-button": "_stop",
      "mouseenter .ui-spinner-button": function( event ) {
        // button will add ui-state-active if mouse was down while mouseleave and kept down
        if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
          return;
        }
  
        if ( this._start( event ) === false ) {
          return false;
        }
        this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
      },
      // TODO: do we really want to consider this a stop?
      // shouldn't we just stop the repeater and wait until mouseup before
      // we trigger the stop event?
      "mouseleave .ui-spinner-button": "_stop"
    },
  
    _draw: function() {
      var uiSpinner = this.uiSpinner = this.element
        .addClass( "ui-spinner-input" )
        .attr( "autocomplete", "off" )
        .wrap( this._uiSpinnerHtml() )
        .parent()
          // add buttons
          .append( this._buttonHtml() );
  
      this.element.attr( "role", "spinbutton" );
  
      // button bindings
      this.buttons = uiSpinner.find( ".ui-spinner-button" )
        .attr( "tabIndex", -1 )
        .button()
        .removeClass( "ui-corner-all" );
  
      // IE 6 doesn't understand height: 50% for the buttons
      // unless the wrapper has an explicit height
      if ( this.buttons.height() > Math.ceil( uiSpinner.height() * 0.5 ) &&
          uiSpinner.height() > 0 ) {
        uiSpinner.height( uiSpinner.height() );
      }
  
      // disable spinner if element was already disabled
      if ( this.options.disabled ) {
        this.disable();
      }
    },
  
    _keydown: function( event ) {
      var options = this.options,
        keyCode = $.ui.keyCode;
  
      switch ( event.keyCode ) {
      case keyCode.UP:
        this._repeat( null, 1, event );
        return true;
      case keyCode.DOWN:
        this._repeat( null, -1, event );
        return true;
      case keyCode.PAGE_UP:
        this._repeat( null, options.page, event );
        return true;
      case keyCode.PAGE_DOWN:
        this._repeat( null, -options.page, event );
        return true;
      }
  
      return false;
    },
  
    _uiSpinnerHtml: function() {
      return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
    },
  
    _buttonHtml: function() {
      return "" +
        "<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" +
          "<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" +
        "</a>" +
        "<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" +
          "<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" +
        "</a>";
    },
  
    _start: function( event ) {
      if ( !this.spinning && this._trigger( "start", event ) === false ) {
        return false;
      }
  
      if ( !this.counter ) {
        this.counter = 1;
      }
      this.spinning = true;
      return true;
    },
  
    _repeat: function( i, steps, event ) {
      i = i || 500;
  
      clearTimeout( this.timer );
      this.timer = this._delay(function() {
        this._repeat( 40, steps, event );
      }, i );
  
      this._spin( steps * this.options.step, event );
    },
  
    _spin: function( step, event ) {
      var value = this.value() || 0;
  
      if ( !this.counter ) {
        this.counter = 1;
      }
  
      value = this._adjustValue( value + step * this._increment( this.counter ) );
  
      if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false) {
        this._value( value );
        this.counter++;
      }
    },
  
    _increment: function( i ) {
      var incremental = this.options.incremental;
  
      if ( incremental ) {
        return $.isFunction( incremental ) ?
          incremental( i ) :
          Math.floor( i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1 );
      }
  
      return 1;
    },
  
    _precision: function() {
      var precision = this._precisionOf( this.options.step );
      if ( this.options.min !== null ) {
        precision = Math.max( precision, this._precisionOf( this.options.min ) );
      }
      return precision;
    },
  
    _precisionOf: function( num ) {
      var str = num.toString(),
        decimal = str.indexOf( "." );
      return decimal === -1 ? 0 : str.length - decimal - 1;
    },
  
    _adjustValue: function( value ) {
      var base, aboveMin,
        options = this.options;
  
      // make sure we're at a valid step
      // - find out where we are relative to the base (min or 0)
      base = options.min !== null ? options.min : 0;
      aboveMin = value - base;
      // - round to the nearest step
      aboveMin = Math.round(aboveMin / options.step) * options.step;
      // - rounding is based on 0, so adjust back to our base
      value = base + aboveMin;
  
      // fix precision from bad JS floating point math
      value = parseFloat( value.toFixed( this._precision() ) );
  
      // clamp the value
      if ( options.max !== null && value > options.max) {
        return options.max;
      }
      if ( options.min !== null && value < options.min ) {
        return options.min;
      }
  
      return value;
    },
  
    _stop: function( event ) {
      if ( !this.spinning ) {
        return;
      }
  
      clearTimeout( this.timer );
      clearTimeout( this.mousewheelTimer );
      this.counter = 0;
      this.spinning = false;
      this._trigger( "stop", event );
    },
  
    _setOption: function( key, value ) {
      if ( key === "culture" || key === "numberFormat" ) {
        var prevValue = this._parse( this.element.val() );
        this.options[ key ] = value;
        this.element.val( this._format( prevValue ) );
        return;
      }
  
      if ( key === "max" || key === "min" || key === "step" ) {
        if ( typeof value === "string" ) {
          value = this._parse( value );
        }
      }
      if ( key === "icons" ) {
        this.buttons.first().find( ".ui-icon" )
          .removeClass( this.options.icons.up )
          .addClass( value.up );
        this.buttons.last().find( ".ui-icon" )
          .removeClass( this.options.icons.down )
          .addClass( value.down );
      }
  
      this._super( key, value );
  
      if ( key === "disabled" ) {
        this.widget().toggleClass( "ui-state-disabled", !!value );
        this.element.prop( "disabled", !!value );
        this.buttons.button( value ? "disable" : "enable" );
      }
    },
  
    _setOptions: spinner_modifier(function( options ) {
      this._super( options );
    }),
  
    _parse: function( val ) {
      if ( typeof val === "string" && val !== "" ) {
        val = window.Globalize && this.options.numberFormat ?
          Globalize.parseFloat( val, 10, this.options.culture ) : +val;
      }
      return val === "" || isNaN( val ) ? null : val;
    },
  
    _format: function( value ) {
      if ( value === "" ) {
        return "";
      }
      return window.Globalize && this.options.numberFormat ?
        Globalize.format( value, this.options.numberFormat, this.options.culture ) :
        value;
    },
  
    _refresh: function() {
      this.element.attr({
        "aria-valuemin": this.options.min,
        "aria-valuemax": this.options.max,
        // TODO: what should we do with values that can't be parsed?
        "aria-valuenow": this._parse( this.element.val() )
      });
    },
  
    isValid: function() {
      var value = this.value();
  
      // null is invalid
      if ( value === null ) {
        return false;
      }
  
      // if value gets adjusted, it's invalid
      return value === this._adjustValue( value );
    },
  
    // update the value without triggering change
    _value: function( value, allowAny ) {
      var parsed;
      if ( value !== "" ) {
        parsed = this._parse( value );
        if ( parsed !== null ) {
          if ( !allowAny ) {
            parsed = this._adjustValue( parsed );
          }
          value = this._format( parsed );
        }
      }
      this.element.val( value );
      this._refresh();
    },
  
    _destroy: function() {
      this.element
        .removeClass( "ui-spinner-input" )
        .prop( "disabled", false )
        .removeAttr( "autocomplete" )
        .removeAttr( "role" )
        .removeAttr( "aria-valuemin" )
        .removeAttr( "aria-valuemax" )
        .removeAttr( "aria-valuenow" );
      this.uiSpinner.replaceWith( this.element );
    },
  
    stepUp: spinner_modifier(function( steps ) {
      this._stepUp( steps );
    }),
    _stepUp: function( steps ) {
      if ( this._start() ) {
        this._spin( (steps || 1) * this.options.step );
        this._stop();
      }
    },
  
    stepDown: spinner_modifier(function( steps ) {
      this._stepDown( steps );
    }),
    _stepDown: function( steps ) {
      if ( this._start() ) {
        this._spin( (steps || 1) * -this.options.step );
        this._stop();
      }
    },
  
    pageUp: spinner_modifier(function( pages ) {
      this._stepUp( (pages || 1) * this.options.page );
    }),
  
    pageDown: spinner_modifier(function( pages ) {
      this._stepDown( (pages || 1) * this.options.page );
    }),
  
    value: function( newVal ) {
      if ( !arguments.length ) {
        return this._parse( this.element.val() );
      }
      spinner_modifier( this._value ).call( this, newVal );
    },
  
    widget: function() {
      return this.uiSpinner;
    }
  });
  
  
  /*!
   * jQuery UI Tabs 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/tabs/
   */
  
  
  var tabs = $.widget( "ui.tabs", {
    version: "1.11.4",
    delay: 300,
    options: {
      active: null,
      collapsible: false,
      event: "click",
      heightStyle: "content",
      hide: null,
      show: null,
  
      // callbacks
      activate: null,
      beforeActivate: null,
      beforeLoad: null,
      load: null
    },
  
    _isLocal: (function() {
      var rhash = /#.*$/;
  
      return function( anchor ) {
        var anchorUrl, locationUrl;
  
        // support: IE7
        // IE7 doesn't normalize the href property when set via script (#9317)
        anchor = anchor.cloneNode( false );
  
        anchorUrl = anchor.href.replace( rhash, "" );
        locationUrl = location.href.replace( rhash, "" );
  
        // decoding may throw an error if the URL isn't UTF-8 (#9518)
        try {
          anchorUrl = decodeURIComponent( anchorUrl );
        } catch ( error ) {}
        try {
          locationUrl = decodeURIComponent( locationUrl );
        } catch ( error ) {}
  
        return anchor.hash.length > 1 && anchorUrl === locationUrl;
      };
    })(),
  
    _create: function() {
      var that = this,
        options = this.options;
  
      this.running = false;
  
      this.element
        .addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" )
        .toggleClass( "ui-tabs-collapsible", options.collapsible );
  
      this._processTabs();
      options.active = this._initialActive();
  
      // Take disabling tabs via class attribute from HTML
      // into account and update option properly.
      if ( $.isArray( options.disabled ) ) {
        options.disabled = $.unique( options.disabled.concat(
          $.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
            return that.tabs.index( li );
          })
        ) ).sort();
      }
  
      // check for length avoids error when initializing empty list
      if ( this.options.active !== false && this.anchors.length ) {
        this.active = this._findActive( options.active );
      } else {
        this.active = $();
      }
  
      this._refresh();
  
      if ( this.active.length ) {
        this.load( options.active );
      }
    },
  
    _initialActive: function() {
      var active = this.options.active,
        collapsible = this.options.collapsible,
        locationHash = location.hash.substring( 1 );
  
      if ( active === null ) {
        // check the fragment identifier in the URL
        if ( locationHash ) {
          this.tabs.each(function( i, tab ) {
            if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
              active = i;
              return false;
            }
          });
        }
  
        // check for a tab marked active via a class
        if ( active === null ) {
          active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
        }
  
        // no active tab, set to false
        if ( active === null || active === -1 ) {
          active = this.tabs.length ? 0 : false;
        }
      }
  
      // handle numbers: negative, out of range
      if ( active !== false ) {
        active = this.tabs.index( this.tabs.eq( active ) );
        if ( active === -1 ) {
          active = collapsible ? false : 0;
        }
      }
  
      // don't allow collapsible: false and active: false
      if ( !collapsible && active === false && this.anchors.length ) {
        active = 0;
      }
  
      return active;
    },
  
    _getCreateEventData: function() {
      return {
        tab: this.active,
        panel: !this.active.length ? $() : this._getPanelForTab( this.active )
      };
    },
  
    _tabKeydown: function( event ) {
      var focusedTab = $( this.document[0].activeElement ).closest( "li" ),
        selectedIndex = this.tabs.index( focusedTab ),
        goingForward = true;
  
      if ( this._handlePageNav( event ) ) {
        return;
      }
  
      switch ( event.keyCode ) {
        case $.ui.keyCode.RIGHT:
        case $.ui.keyCode.DOWN:
          selectedIndex++;
          break;
        case $.ui.keyCode.UP:
        case $.ui.keyCode.LEFT:
          goingForward = false;
          selectedIndex--;
          break;
        case $.ui.keyCode.END:
          selectedIndex = this.anchors.length - 1;
          break;
        case $.ui.keyCode.HOME:
          selectedIndex = 0;
          break;
        case $.ui.keyCode.SPACE:
          // Activate only, no collapsing
          event.preventDefault();
          clearTimeout( this.activating );
          this._activate( selectedIndex );
          return;
        case $.ui.keyCode.ENTER:
          // Toggle (cancel delayed activation, allow collapsing)
          event.preventDefault();
          clearTimeout( this.activating );
          // Determine if we should collapse or activate
          this._activate( selectedIndex === this.options.active ? false : selectedIndex );
          return;
        default:
          return;
      }
  
      // Focus the appropriate tab, based on which key was pressed
      event.preventDefault();
      clearTimeout( this.activating );
      selectedIndex = this._focusNextTab( selectedIndex, goingForward );
  
      // Navigating with control/command key will prevent automatic activation
      if ( !event.ctrlKey && !event.metaKey ) {
  
        // Update aria-selected immediately so that AT think the tab is already selected.
        // Otherwise AT may confuse the user by stating that they need to activate the tab,
        // but the tab will already be activated by the time the announcement finishes.
        focusedTab.attr( "aria-selected", "false" );
        this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );
  
        this.activating = this._delay(function() {
          this.option( "active", selectedIndex );
        }, this.delay );
      }
    },
  
    _panelKeydown: function( event ) {
      if ( this._handlePageNav( event ) ) {
        return;
      }
  
      // Ctrl+up moves focus to the current tab
      if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
        event.preventDefault();
        this.active.focus();
      }
    },
  
    // Alt+page up/down moves focus to the previous/next tab (and activates)
    _handlePageNav: function( event ) {
      if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
        this._activate( this._focusNextTab( this.options.active - 1, false ) );
        return true;
      }
      if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
        this._activate( this._focusNextTab( this.options.active + 1, true ) );
        return true;
      }
    },
  
    _findNextTab: function( index, goingForward ) {
      var lastTabIndex = this.tabs.length - 1;
  
      function constrain() {
        if ( index > lastTabIndex ) {
          index = 0;
        }
        if ( index < 0 ) {
          index = lastTabIndex;
        }
        return index;
      }
  
      while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
        index = goingForward ? index + 1 : index - 1;
      }
  
      return index;
    },
  
    _focusNextTab: function( index, goingForward ) {
      index = this._findNextTab( index, goingForward );
      this.tabs.eq( index ).focus();
      return index;
    },
  
    _setOption: function( key, value ) {
      if ( key === "active" ) {
        // _activate() will handle invalid values and update this.options
        this._activate( value );
        return;
      }
  
      if ( key === "disabled" ) {
        // don't use the widget factory's disabled handling
        this._setupDisabled( value );
        return;
      }
  
      this._super( key, value);
  
      if ( key === "collapsible" ) {
        this.element.toggleClass( "ui-tabs-collapsible", value );
        // Setting collapsible: false while collapsed; open first panel
        if ( !value && this.options.active === false ) {
          this._activate( 0 );
        }
      }
  
      if ( key === "event" ) {
        this._setupEvents( value );
      }
  
      if ( key === "heightStyle" ) {
        this._setupHeightStyle( value );
      }
    },
  
    _sanitizeSelector: function( hash ) {
      return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
    },
  
    refresh: function() {
      var options = this.options,
        lis = this.tablist.children( ":has(a[href])" );
  
      // get disabled tabs from class attribute from HTML
      // this will get converted to a boolean if needed in _refresh()
      options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
        return lis.index( tab );
      });
  
      this._processTabs();
  
      // was collapsed or no tabs
      if ( options.active === false || !this.anchors.length ) {
        options.active = false;
        this.active = $();
      // was active, but active tab is gone
      } else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {
        // all remaining tabs are disabled
        if ( this.tabs.length === options.disabled.length ) {
          options.active = false;
          this.active = $();
        // activate previous tab
        } else {
          this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
        }
      // was active, active tab still exists
      } else {
        // make sure active index is correct
        options.active = this.tabs.index( this.active );
      }
  
      this._refresh();
    },
  
    _refresh: function() {
      this._setupDisabled( this.options.disabled );
      this._setupEvents( this.options.event );
      this._setupHeightStyle( this.options.heightStyle );
  
      this.tabs.not( this.active ).attr({
        "aria-selected": "false",
        "aria-expanded": "false",
        tabIndex: -1
      });
      this.panels.not( this._getPanelForTab( this.active ) )
        .hide()
        .attr({
          "aria-hidden": "true"
        });
  
      // Make sure one tab is in the tab order
      if ( !this.active.length ) {
        this.tabs.eq( 0 ).attr( "tabIndex", 0 );
      } else {
        this.active
          .addClass( "ui-tabs-active ui-state-active" )
          .attr({
            "aria-selected": "true",
            "aria-expanded": "true",
            tabIndex: 0
          });
        this._getPanelForTab( this.active )
          .show()
          .attr({
            "aria-hidden": "false"
          });
      }
    },
  
    _processTabs: function() {
      var that = this,
        prevTabs = this.tabs,
        prevAnchors = this.anchors,
        prevPanels = this.panels;
  
      this.tablist = this._getList()
        .addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
        .attr( "role", "tablist" )
  
        // Prevent users from focusing disabled tabs via click
        .delegate( "> li", "mousedown" + this.eventNamespace, function( event ) {
          if ( $( this ).is( ".ui-state-disabled" ) ) {
            event.preventDefault();
          }
        })
  
        // support: IE <9
        // Preventing the default action in mousedown doesn't prevent IE
        // from focusing the element, so if the anchor gets focused, blur.
        // We don't have to worry about focusing the previously focused
        // element since clicking on a non-focusable element should focus
        // the body anyway.
        .delegate( ".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
          if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
            this.blur();
          }
        });
  
      this.tabs = this.tablist.find( "> li:has(a[href])" )
        .addClass( "ui-state-default ui-corner-top" )
        .attr({
          role: "tab",
          tabIndex: -1
        });
  
      this.anchors = this.tabs.map(function() {
          return $( "a", this )[ 0 ];
        })
        .addClass( "ui-tabs-anchor" )
        .attr({
          role: "presentation",
          tabIndex: -1
        });
  
      this.panels = $();
  
      this.anchors.each(function( i, anchor ) {
        var selector, panel, panelId,
          anchorId = $( anchor ).uniqueId().attr( "id" ),
          tab = $( anchor ).closest( "li" ),
          originalAriaControls = tab.attr( "aria-controls" );
  
        // inline tab
        if ( that._isLocal( anchor ) ) {
          selector = anchor.hash;
          panelId = selector.substring( 1 );
          panel = that.element.find( that._sanitizeSelector( selector ) );
        // remote tab
        } else {
          // If the tab doesn't already have aria-controls,
          // generate an id by using a throw-away element
          panelId = tab.attr( "aria-controls" ) || $( {} ).uniqueId()[ 0 ].id;
          selector = "#" + panelId;
          panel = that.element.find( selector );
          if ( !panel.length ) {
            panel = that._createPanel( panelId );
            panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
          }
          panel.attr( "aria-live", "polite" );
        }
  
        if ( panel.length) {
          that.panels = that.panels.add( panel );
        }
        if ( originalAriaControls ) {
          tab.data( "ui-tabs-aria-controls", originalAriaControls );
        }
        tab.attr({
          "aria-controls": panelId,
          "aria-labelledby": anchorId
        });
        panel.attr( "aria-labelledby", anchorId );
      });
  
      this.panels
        .addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
        .attr( "role", "tabpanel" );
  
      // Avoid memory leaks (#10056)
      if ( prevTabs ) {
        this._off( prevTabs.not( this.tabs ) );
        this._off( prevAnchors.not( this.anchors ) );
        this._off( prevPanels.not( this.panels ) );
      }
    },
  
    // allow overriding how to find the list for rare usage scenarios (#7715)
    _getList: function() {
      return this.tablist || this.element.find( "ol,ul" ).eq( 0 );
    },
  
    _createPanel: function( id ) {
      return $( "<div>" )
        .attr( "id", id )
        .addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
        .data( "ui-tabs-destroy", true );
    },
  
    _setupDisabled: function( disabled ) {
      if ( $.isArray( disabled ) ) {
        if ( !disabled.length ) {
          disabled = false;
        } else if ( disabled.length === this.anchors.length ) {
          disabled = true;
        }
      }
  
      // disable tabs
      for ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {
        if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
          $( li )
            .addClass( "ui-state-disabled" )
            .attr( "aria-disabled", "true" );
        } else {
          $( li )
            .removeClass( "ui-state-disabled" )
            .removeAttr( "aria-disabled" );
        }
      }
  
      this.options.disabled = disabled;
    },
  
    _setupEvents: function( event ) {
      var events = {};
      if ( event ) {
        $.each( event.split(" "), function( index, eventName ) {
          events[ eventName ] = "_eventHandler";
        });
      }
  
      this._off( this.anchors.add( this.tabs ).add( this.panels ) );
      // Always prevent the default action, even when disabled
      this._on( true, this.anchors, {
        click: function( event ) {
          event.preventDefault();
        }
      });
      this._on( this.anchors, events );
      this._on( this.tabs, { keydown: "_tabKeydown" } );
      this._on( this.panels, { keydown: "_panelKeydown" } );
  
      this._focusable( this.tabs );
      this._hoverable( this.tabs );
    },
  
    _setupHeightStyle: function( heightStyle ) {
      var maxHeight,
        parent = this.element.parent();
  
      if ( heightStyle === "fill" ) {
        maxHeight = parent.height();
        maxHeight -= this.element.outerHeight() - this.element.height();
  
        this.element.siblings( ":visible" ).each(function() {
          var elem = $( this ),
            position = elem.css( "position" );
  
          if ( position === "absolute" || position === "fixed" ) {
            return;
          }
          maxHeight -= elem.outerHeight( true );
        });
  
        this.element.children().not( this.panels ).each(function() {
          maxHeight -= $( this ).outerHeight( true );
        });
  
        this.panels.each(function() {
          $( this ).height( Math.max( 0, maxHeight -
            $( this ).innerHeight() + $( this ).height() ) );
        })
        .css( "overflow", "auto" );
      } else if ( heightStyle === "auto" ) {
        maxHeight = 0;
        this.panels.each(function() {
          maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
        }).height( maxHeight );
      }
    },
  
    _eventHandler: function( event ) {
      var options = this.options,
        active = this.active,
        anchor = $( event.currentTarget ),
        tab = anchor.closest( "li" ),
        clickedIsActive = tab[ 0 ] === active[ 0 ],
        collapsing = clickedIsActive && options.collapsible,
        toShow = collapsing ? $() : this._getPanelForTab( tab ),
        toHide = !active.length ? $() : this._getPanelForTab( active ),
        eventData = {
          oldTab: active,
          oldPanel: toHide,
          newTab: collapsing ? $() : tab,
          newPanel: toShow
        };
  
      event.preventDefault();
  
      if ( tab.hasClass( "ui-state-disabled" ) ||
          // tab is already loading
          tab.hasClass( "ui-tabs-loading" ) ||
          // can't switch durning an animation
          this.running ||
          // click on active header, but not collapsible
          ( clickedIsActive && !options.collapsible ) ||
          // allow canceling activation
          ( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
        return;
      }
  
      options.active = collapsing ? false : this.tabs.index( tab );
  
      this.active = clickedIsActive ? $() : tab;
      if ( this.xhr ) {
        this.xhr.abort();
      }
  
      if ( !toHide.length && !toShow.length ) {
        $.error( "jQuery UI Tabs: Mismatching fragment identifier." );
      }
  
      if ( toShow.length ) {
        this.load( this.tabs.index( tab ), event );
      }
      this._toggle( event, eventData );
    },
  
    // handles show/hide for selecting tabs
    _toggle: function( event, eventData ) {
      var that = this,
        toShow = eventData.newPanel,
        toHide = eventData.oldPanel;
  
      this.running = true;
  
      function complete() {
        that.running = false;
        that._trigger( "activate", event, eventData );
      }
  
      function show() {
        eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );
  
        if ( toShow.length && that.options.show ) {
          that._show( toShow, that.options.show, complete );
        } else {
          toShow.show();
          complete();
        }
      }
  
      // start out by hiding, then showing, then completing
      if ( toHide.length && this.options.hide ) {
        this._hide( toHide, this.options.hide, function() {
          eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
          show();
        });
      } else {
        eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
        toHide.hide();
        show();
      }
  
      toHide.attr( "aria-hidden", "true" );
      eventData.oldTab.attr({
        "aria-selected": "false",
        "aria-expanded": "false"
      });
      // If we're switching tabs, remove the old tab from the tab order.
      // If we're opening from collapsed state, remove the previous tab from the tab order.
      // If we're collapsing, then keep the collapsing tab in the tab order.
      if ( toShow.length && toHide.length ) {
        eventData.oldTab.attr( "tabIndex", -1 );
      } else if ( toShow.length ) {
        this.tabs.filter(function() {
          return $( this ).attr( "tabIndex" ) === 0;
        })
        .attr( "tabIndex", -1 );
      }
  
      toShow.attr( "aria-hidden", "false" );
      eventData.newTab.attr({
        "aria-selected": "true",
        "aria-expanded": "true",
        tabIndex: 0
      });
    },
  
    _activate: function( index ) {
      var anchor,
        active = this._findActive( index );
  
      // trying to activate the already active panel
      if ( active[ 0 ] === this.active[ 0 ] ) {
        return;
      }
  
      // trying to collapse, simulate a click on the current active header
      if ( !active.length ) {
        active = this.active;
      }
  
      anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
      this._eventHandler({
        target: anchor,
        currentTarget: anchor,
        preventDefault: $.noop
      });
    },
  
    _findActive: function( index ) {
      return index === false ? $() : this.tabs.eq( index );
    },
  
    _getIndex: function( index ) {
      // meta-function to give users option to provide a href string instead of a numerical index.
      if ( typeof index === "string" ) {
        index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
      }
  
      return index;
    },
  
    _destroy: function() {
      if ( this.xhr ) {
        this.xhr.abort();
      }
  
      this.element.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" );
  
      this.tablist
        .removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
        .removeAttr( "role" );
  
      this.anchors
        .removeClass( "ui-tabs-anchor" )
        .removeAttr( "role" )
        .removeAttr( "tabIndex" )
        .removeUniqueId();
  
      this.tablist.unbind( this.eventNamespace );
  
      this.tabs.add( this.panels ).each(function() {
        if ( $.data( this, "ui-tabs-destroy" ) ) {
          $( this ).remove();
        } else {
          $( this )
            .removeClass( "ui-state-default ui-state-active ui-state-disabled " +
              "ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel" )
            .removeAttr( "tabIndex" )
            .removeAttr( "aria-live" )
            .removeAttr( "aria-busy" )
            .removeAttr( "aria-selected" )
            .removeAttr( "aria-labelledby" )
            .removeAttr( "aria-hidden" )
            .removeAttr( "aria-expanded" )
            .removeAttr( "role" );
        }
      });
  
      this.tabs.each(function() {
        var li = $( this ),
          prev = li.data( "ui-tabs-aria-controls" );
        if ( prev ) {
          li
            .attr( "aria-controls", prev )
            .removeData( "ui-tabs-aria-controls" );
        } else {
          li.removeAttr( "aria-controls" );
        }
      });
  
      this.panels.show();
  
      if ( this.options.heightStyle !== "content" ) {
        this.panels.css( "height", "" );
      }
    },
  
    enable: function( index ) {
      var disabled = this.options.disabled;
      if ( disabled === false ) {
        return;
      }
  
      if ( index === undefined ) {
        disabled = false;
      } else {
        index = this._getIndex( index );
        if ( $.isArray( disabled ) ) {
          disabled = $.map( disabled, function( num ) {
            return num !== index ? num : null;
          });
        } else {
          disabled = $.map( this.tabs, function( li, num ) {
            return num !== index ? num : null;
          });
        }
      }
      this._setupDisabled( disabled );
    },
  
    disable: function( index ) {
      var disabled = this.options.disabled;
      if ( disabled === true ) {
        return;
      }
  
      if ( index === undefined ) {
        disabled = true;
      } else {
        index = this._getIndex( index );
        if ( $.inArray( index, disabled ) !== -1 ) {
          return;
        }
        if ( $.isArray( disabled ) ) {
          disabled = $.merge( [ index ], disabled ).sort();
        } else {
          disabled = [ index ];
        }
      }
      this._setupDisabled( disabled );
    },
  
    load: function( index, event ) {
      index = this._getIndex( index );
      var that = this,
        tab = this.tabs.eq( index ),
        anchor = tab.find( ".ui-tabs-anchor" ),
        panel = this._getPanelForTab( tab ),
        eventData = {
          tab: tab,
          panel: panel
        },
        complete = function( jqXHR, status ) {
          if ( status === "abort" ) {
            that.panels.stop( false, true );
          }
  
          tab.removeClass( "ui-tabs-loading" );
          panel.removeAttr( "aria-busy" );
  
          if ( jqXHR === that.xhr ) {
            delete that.xhr;
          }
        };
  
      // not remote
      if ( this._isLocal( anchor[ 0 ] ) ) {
        return;
      }
  
      this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );
  
      // support: jQuery <1.8
      // jQuery <1.8 returns false if the request is canceled in beforeSend,
      // but as of 1.8, $.ajax() always returns a jqXHR object.
      if ( this.xhr && this.xhr.statusText !== "canceled" ) {
        tab.addClass( "ui-tabs-loading" );
        panel.attr( "aria-busy", "true" );
  
        this.xhr
          .done(function( response, status, jqXHR ) {
            // support: jQuery <1.8
            // http://bugs.jquery.com/ticket/11778
            setTimeout(function() {
              panel.html( response );
              that._trigger( "load", event, eventData );
  
              complete( jqXHR, status );
            }, 1 );
          })
          .fail(function( jqXHR, status ) {
            // support: jQuery <1.8
            // http://bugs.jquery.com/ticket/11778
            setTimeout(function() {
              complete( jqXHR, status );
            }, 1 );
          });
      }
    },
  
    _ajaxSettings: function( anchor, event, eventData ) {
      var that = this;
      return {
        url: anchor.attr( "href" ),
        beforeSend: function( jqXHR, settings ) {
          return that._trigger( "beforeLoad", event,
            $.extend( { jqXHR: jqXHR, ajaxSettings: settings }, eventData ) );
        }
      };
    },
  
    _getPanelForTab: function( tab ) {
      var id = $( tab ).attr( "aria-controls" );
      return this.element.find( this._sanitizeSelector( "#" + id ) );
    }
  });
  
  
  /*!
   * jQuery UI Tooltip 1.11.4
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/tooltip/
   */
  
  
  var tooltip = $.widget( "ui.tooltip", {
    version: "1.11.4",
    options: {
      content: function() {
        // support: IE<9, Opera in jQuery <1.7
        // .text() can't accept undefined, so coerce to a string
        var title = $( this ).attr( "title" ) || "";
        // Escape title, since we're going from an attribute to raw HTML
        return $( "<a>" ).text( title ).html();
      },
      hide: true,
      // Disabled elements have inconsistent behavior across browsers (#8661)
      items: "[title]:not([disabled])",
      position: {
        my: "left top+15",
        at: "left bottom",
        collision: "flipfit flip"
      },
      show: true,
      tooltipClass: null,
      track: false,
  
      // callbacks
      close: null,
      open: null
    },
  
    _addDescribedBy: function( elem, id ) {
      var describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ );
      describedby.push( id );
      elem
        .data( "ui-tooltip-id", id )
        .attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
    },
  
    _removeDescribedBy: function( elem ) {
      var id = elem.data( "ui-tooltip-id" ),
        describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ ),
        index = $.inArray( id, describedby );
  
      if ( index !== -1 ) {
        describedby.splice( index, 1 );
      }
  
      elem.removeData( "ui-tooltip-id" );
      describedby = $.trim( describedby.join( " " ) );
      if ( describedby ) {
        elem.attr( "aria-describedby", describedby );
      } else {
        elem.removeAttr( "aria-describedby" );
      }
    },
  
    _create: function() {
      this._on({
        mouseover: "open",
        focusin: "open"
      });
  
      // IDs of generated tooltips, needed for destroy
      this.tooltips = {};
  
      // IDs of parent tooltips where we removed the title attribute
      this.parents = {};
  
      if ( this.options.disabled ) {
        this._disable();
      }
  
      // Append the aria-live region so tooltips announce correctly
      this.liveRegion = $( "<div>" )
        .attr({
          role: "log",
          "aria-live": "assertive",
          "aria-relevant": "additions"
        })
        .addClass( "ui-helper-hidden-accessible" )
        .appendTo( this.document[ 0 ].body );
    },
  
    _setOption: function( key, value ) {
      var that = this;
  
      if ( key === "disabled" ) {
        this[ value ? "_disable" : "_enable" ]();
        this.options[ key ] = value;
        // disable element style changes
        return;
      }
  
      this._super( key, value );
  
      if ( key === "content" ) {
        $.each( this.tooltips, function( id, tooltipData ) {
          that._updateContent( tooltipData.element );
        });
      }
    },
  
    _disable: function() {
      var that = this;
  
      // close open tooltips
      $.each( this.tooltips, function( id, tooltipData ) {
        var event = $.Event( "blur" );
        event.target = event.currentTarget = tooltipData.element[ 0 ];
        that.close( event, true );
      });
  
      // remove title attributes to prevent native tooltips
      this.element.find( this.options.items ).addBack().each(function() {
        var element = $( this );
        if ( element.is( "[title]" ) ) {
          element
            .data( "ui-tooltip-title", element.attr( "title" ) )
            .removeAttr( "title" );
        }
      });
    },
  
    _enable: function() {
      // restore title attributes
      this.element.find( this.options.items ).addBack().each(function() {
        var element = $( this );
        if ( element.data( "ui-tooltip-title" ) ) {
          element.attr( "title", element.data( "ui-tooltip-title" ) );
        }
      });
    },
  
    open: function( event ) {
      var that = this,
        target = $( event ? event.target : this.element )
          // we need closest here due to mouseover bubbling,
          // but always pointing at the same event target
          .closest( this.options.items );
  
      // No element to show a tooltip for or the tooltip is already open
      if ( !target.length || target.data( "ui-tooltip-id" ) ) {
        return;
      }
  
      if ( target.attr( "title" ) ) {
        target.data( "ui-tooltip-title", target.attr( "title" ) );
      }
  
      target.data( "ui-tooltip-open", true );
  
      // kill parent tooltips, custom or native, for hover
      if ( event && event.type === "mouseover" ) {
        target.parents().each(function() {
          var parent = $( this ),
            blurEvent;
          if ( parent.data( "ui-tooltip-open" ) ) {
            blurEvent = $.Event( "blur" );
            blurEvent.target = blurEvent.currentTarget = this;
            that.close( blurEvent, true );
          }
          if ( parent.attr( "title" ) ) {
            parent.uniqueId();
            that.parents[ this.id ] = {
              element: this,
              title: parent.attr( "title" )
            };
            parent.attr( "title", "" );
          }
        });
      }
  
      this._registerCloseHandlers( event, target );
      this._updateContent( target, event );
    },
  
    _updateContent: function( target, event ) {
      var content,
        contentOption = this.options.content,
        that = this,
        eventType = event ? event.type : null;
  
      if ( typeof contentOption === "string" ) {
        return this._open( event, target, contentOption );
      }
  
      content = contentOption.call( target[0], function( response ) {
  
        // IE may instantly serve a cached response for ajax requests
        // delay this call to _open so the other call to _open runs first
        that._delay(function() {
  
          // Ignore async response if tooltip was closed already
          if ( !target.data( "ui-tooltip-open" ) ) {
            return;
          }
  
          // jQuery creates a special event for focusin when it doesn't
          // exist natively. To improve performance, the native event
          // object is reused and the type is changed. Therefore, we can't
          // rely on the type being correct after the event finished
          // bubbling, so we set it back to the previous value. (#8740)
          if ( event ) {
            event.type = eventType;
          }
          this._open( event, target, response );
        });
      });
      if ( content ) {
        this._open( event, target, content );
      }
    },
  
    _open: function( event, target, content ) {
      var tooltipData, tooltip, delayedShow, a11yContent,
        positionOption = $.extend( {}, this.options.position );
  
      if ( !content ) {
        return;
      }
  
      // Content can be updated multiple times. If the tooltip already
      // exists, then just update the content and bail.
      tooltipData = this._find( target );
      if ( tooltipData ) {
        tooltipData.tooltip.find( ".ui-tooltip-content" ).html( content );
        return;
      }
  
      // if we have a title, clear it to prevent the native tooltip
      // we have to check first to avoid defining a title if none exists
      // (we don't want to cause an element to start matching [title])
      //
      // We use removeAttr only for key events, to allow IE to export the correct
      // accessible attributes. For mouse events, set to empty string to avoid
      // native tooltip showing up (happens only when removing inside mouseover).
      if ( target.is( "[title]" ) ) {
        if ( event && event.type === "mouseover" ) {
          target.attr( "title", "" );
        } else {
          target.removeAttr( "title" );
        }
      }
  
      tooltipData = this._tooltip( target );
      tooltip = tooltipData.tooltip;
      this._addDescribedBy( target, tooltip.attr( "id" ) );
      tooltip.find( ".ui-tooltip-content" ).html( content );
  
      // Support: Voiceover on OS X, JAWS on IE <= 9
      // JAWS announces deletions even when aria-relevant="additions"
      // Voiceover will sometimes re-read the entire log region's contents from the beginning
      this.liveRegion.children().hide();
      if ( content.clone ) {
        a11yContent = content.clone();
        a11yContent.removeAttr( "id" ).find( "[id]" ).removeAttr( "id" );
      } else {
        a11yContent = content;
      }
      $( "<div>" ).html( a11yContent ).appendTo( this.liveRegion );
  
      function position( event ) {
        positionOption.of = event;
        if ( tooltip.is( ":hidden" ) ) {
          return;
        }
        tooltip.position( positionOption );
      }
      if ( this.options.track && event && /^mouse/.test( event.type ) ) {
        this._on( this.document, {
          mousemove: position
        });
        // trigger once to override element-relative positioning
        position( event );
      } else {
        tooltip.position( $.extend({
          of: target
        }, this.options.position ) );
      }
  
      tooltip.hide();
  
      this._show( tooltip, this.options.show );
      // Handle tracking tooltips that are shown with a delay (#8644). As soon
      // as the tooltip is visible, position the tooltip using the most recent
      // event.
      if ( this.options.show && this.options.show.delay ) {
        delayedShow = this.delayedShow = setInterval(function() {
          if ( tooltip.is( ":visible" ) ) {
            position( positionOption.of );
            clearInterval( delayedShow );
          }
        }, $.fx.interval );
      }
  
      this._trigger( "open", event, { tooltip: tooltip } );
    },
  
    _registerCloseHandlers: function( event, target ) {
      var events = {
        keyup: function( event ) {
          if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
            var fakeEvent = $.Event(event);
            fakeEvent.currentTarget = target[0];
            this.close( fakeEvent, true );
          }
        }
      };
  
      // Only bind remove handler for delegated targets. Non-delegated
      // tooltips will handle this in destroy.
      if ( target[ 0 ] !== this.element[ 0 ] ) {
        events.remove = function() {
          this._removeTooltip( this._find( target ).tooltip );
        };
      }
  
      if ( !event || event.type === "mouseover" ) {
        events.mouseleave = "close";
      }
      if ( !event || event.type === "focusin" ) {
        events.focusout = "close";
      }
      this._on( true, target, events );
    },
  
    close: function( event ) {
      var tooltip,
        that = this,
        target = $( event ? event.currentTarget : this.element ),
        tooltipData = this._find( target );
  
      // The tooltip may already be closed
      if ( !tooltipData ) {
  
        // We set ui-tooltip-open immediately upon open (in open()), but only set the
        // additional data once there's actually content to show (in _open()). So even if the
        // tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in
        // the period between open() and _open().
        target.removeData( "ui-tooltip-open" );
        return;
      }
  
      tooltip = tooltipData.tooltip;
  
      // disabling closes the tooltip, so we need to track when we're closing
      // to avoid an infinite loop in case the tooltip becomes disabled on close
      if ( tooltipData.closing ) {
        return;
      }
  
      // Clear the interval for delayed tracking tooltips
      clearInterval( this.delayedShow );
  
      // only set title if we had one before (see comment in _open())
      // If the title attribute has changed since open(), don't restore
      if ( target.data( "ui-tooltip-title" ) && !target.attr( "title" ) ) {
        target.attr( "title", target.data( "ui-tooltip-title" ) );
      }
  
      this._removeDescribedBy( target );
  
      tooltipData.hiding = true;
      tooltip.stop( true );
      this._hide( tooltip, this.options.hide, function() {
        that._removeTooltip( $( this ) );
      });
  
      target.removeData( "ui-tooltip-open" );
      this._off( target, "mouseleave focusout keyup" );
  
      // Remove 'remove' binding only on delegated targets
      if ( target[ 0 ] !== this.element[ 0 ] ) {
        this._off( target, "remove" );
      }
      this._off( this.document, "mousemove" );
  
      if ( event && event.type === "mouseleave" ) {
        $.each( this.parents, function( id, parent ) {
          $( parent.element ).attr( "title", parent.title );
          delete that.parents[ id ];
        });
      }
  
      tooltipData.closing = true;
      this._trigger( "close", event, { tooltip: tooltip } );
      if ( !tooltipData.hiding ) {
        tooltipData.closing = false;
      }
    },
  
    _tooltip: function( element ) {
      var tooltip = $( "<div>" )
          .attr( "role", "tooltip" )
          .addClass( "ui-tooltip ui-widget ui-corner-all ui-widget-content " +
            ( this.options.tooltipClass || "" ) ),
        id = tooltip.uniqueId().attr( "id" );
  
      $( "<div>" )
        .addClass( "ui-tooltip-content" )
        .appendTo( tooltip );
  
      tooltip.appendTo( this.document[0].body );
  
      return this.tooltips[ id ] = {
        element: element,
        tooltip: tooltip
      };
    },
  
    _find: function( target ) {
      var id = target.data( "ui-tooltip-id" );
      return id ? this.tooltips[ id ] : null;
    },
  
    _removeTooltip: function( tooltip ) {
      tooltip.remove();
      delete this.tooltips[ tooltip.attr( "id" ) ];
    },
  
    _destroy: function() {
      var that = this;
  
      // close open tooltips
      $.each( this.tooltips, function( id, tooltipData ) {
        // Delegate to close method to handle common cleanup
        var event = $.Event( "blur" ),
          element = tooltipData.element;
        event.target = event.currentTarget = element[ 0 ];
        that.close( event, true );
  
        // Remove immediately; destroying an open tooltip doesn't use the
        // hide animation
        $( "#" + id ).remove();
  
        // Restore the title
        if ( element.data( "ui-tooltip-title" ) ) {
          // If the title attribute has changed since open(), don't restore
          if ( !element.attr( "title" ) ) {
            element.attr( "title", element.data( "ui-tooltip-title" ) );
          }
          element.removeData( "ui-tooltip-title" );
        }
      });
      this.liveRegion.remove();
    }
  });
  
  
  
  }));
  
  /***/ }),
  
  /***/ "./vendor/assets/javascripts/datepicker.js":
  /*!*************************************************!*\
    !*** ./vendor/assets/javascripts/datepicker.js ***!
    \*************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  /* WEBPACK VAR INJECTION */(function(jQuery) {/**
   *
   * Date picker
   * Author: Stefan Petre www.eyecon.ro
   * 
   * Dual licensed under the MIT and GPL licenses
   * 
   */
  (function ($) {
    var DatePicker = function () {
      var	ids = {},
        views = {
          years: 'datepickerViewYears',
          moths: 'datepickerViewMonths',
          days: 'datepickerViewDays'
        },
        tpl = {
          wrapper: '<div class="datepicker"><div class="datepickerBorderT" /><div class="datepickerBorderB" /><div class="datepickerBorderL" /><div class="datepickerBorderR" /><div class="datepickerBorderTL" /><div class="datepickerBorderTR" /><div class="datepickerBorderBL" /><div class="datepickerBorderBR" /><div class="datepickerContainer"><table cellspacing="0" cellpadding="0"><tbody><tr></tr></tbody></table></div></div>',
          head: [
            '<td>',
            '<table cellspacing="0" cellpadding="0">',
              '<thead>',
                '<tr>',
                  '<th class="datepickerGoPrev"><a href="#"><span><%=prev%></span></a></th>',
                  '<th colspan="5" class="datepickerMonth"><a href="#"><span></span></a></th>',
                  '<th class="datepickerGoNext"><a href="#"><span><%=next%></span></a></th>',
                '</tr>',
                '<tr class="datepickerDoW">',
                  '<th><span><%=week%></span></th>',
                  '<th><span><%=day1%></span></th>',
                  '<th><span><%=day2%></span></th>',
                  '<th><span><%=day3%></span></th>',
                  '<th><span><%=day4%></span></th>',
                  '<th><span><%=day5%></span></th>',
                  '<th><span><%=day6%></span></th>',
                  '<th><span><%=day7%></span></th>',
                '</tr>',
              '</thead>',
            '</table></td>'
          ],
          space : '<td class="datepickerSpace"><div></div></td>',
          days: [
            '<tbody class="datepickerDays">',
              '<tr>',
                '<th class="datepickerWeek"><a href="#"><span><%=weeks[0].week%></span></a></th>',
                '<td class="<%=weeks[0].days[0].classname%>"><a href="#"><span><%=weeks[0].days[0].text%></span></a></td>',
                '<td class="<%=weeks[0].days[1].classname%>"><a href="#"><span><%=weeks[0].days[1].text%></span></a></td>',
                '<td class="<%=weeks[0].days[2].classname%>"><a href="#"><span><%=weeks[0].days[2].text%></span></a></td>',
                '<td class="<%=weeks[0].days[3].classname%>"><a href="#"><span><%=weeks[0].days[3].text%></span></a></td>',
                '<td class="<%=weeks[0].days[4].classname%>"><a href="#"><span><%=weeks[0].days[4].text%></span></a></td>',
                '<td class="<%=weeks[0].days[5].classname%>"><a href="#"><span><%=weeks[0].days[5].text%></span></a></td>',
                '<td class="<%=weeks[0].days[6].classname%>"><a href="#"><span><%=weeks[0].days[6].text%></span></a></td>',
              '</tr>',
              '<tr>',
                '<th class="datepickerWeek"><a href="#"><span><%=weeks[1].week%></span></a></th>',
                '<td class="<%=weeks[1].days[0].classname%>"><a href="#"><span><%=weeks[1].days[0].text%></span></a></td>',
                '<td class="<%=weeks[1].days[1].classname%>"><a href="#"><span><%=weeks[1].days[1].text%></span></a></td>',
                '<td class="<%=weeks[1].days[2].classname%>"><a href="#"><span><%=weeks[1].days[2].text%></span></a></td>',
                '<td class="<%=weeks[1].days[3].classname%>"><a href="#"><span><%=weeks[1].days[3].text%></span></a></td>',
                '<td class="<%=weeks[1].days[4].classname%>"><a href="#"><span><%=weeks[1].days[4].text%></span></a></td>',
                '<td class="<%=weeks[1].days[5].classname%>"><a href="#"><span><%=weeks[1].days[5].text%></span></a></td>',
                '<td class="<%=weeks[1].days[6].classname%>"><a href="#"><span><%=weeks[1].days[6].text%></span></a></td>',
              '</tr>',
              '<tr>',
                '<th class="datepickerWeek"><a href="#"><span><%=weeks[2].week%></span></a></th>',
                '<td class="<%=weeks[2].days[0].classname%>"><a href="#"><span><%=weeks[2].days[0].text%></span></a></td>',
                '<td class="<%=weeks[2].days[1].classname%>"><a href="#"><span><%=weeks[2].days[1].text%></span></a></td>',
                '<td class="<%=weeks[2].days[2].classname%>"><a href="#"><span><%=weeks[2].days[2].text%></span></a></td>',
                '<td class="<%=weeks[2].days[3].classname%>"><a href="#"><span><%=weeks[2].days[3].text%></span></a></td>',
                '<td class="<%=weeks[2].days[4].classname%>"><a href="#"><span><%=weeks[2].days[4].text%></span></a></td>',
                '<td class="<%=weeks[2].days[5].classname%>"><a href="#"><span><%=weeks[2].days[5].text%></span></a></td>',
                '<td class="<%=weeks[2].days[6].classname%>"><a href="#"><span><%=weeks[2].days[6].text%></span></a></td>',
              '</tr>',
              '<tr>',
                '<th class="datepickerWeek"><a href="#"><span><%=weeks[3].week%></span></a></th>',
                '<td class="<%=weeks[3].days[0].classname%>"><a href="#"><span><%=weeks[3].days[0].text%></span></a></td>',
                '<td class="<%=weeks[3].days[1].classname%>"><a href="#"><span><%=weeks[3].days[1].text%></span></a></td>',
                '<td class="<%=weeks[3].days[2].classname%>"><a href="#"><span><%=weeks[3].days[2].text%></span></a></td>',
                '<td class="<%=weeks[3].days[3].classname%>"><a href="#"><span><%=weeks[3].days[3].text%></span></a></td>',
                '<td class="<%=weeks[3].days[4].classname%>"><a href="#"><span><%=weeks[3].days[4].text%></span></a></td>',
                '<td class="<%=weeks[3].days[5].classname%>"><a href="#"><span><%=weeks[3].days[5].text%></span></a></td>',
                '<td class="<%=weeks[3].days[6].classname%>"><a href="#"><span><%=weeks[3].days[6].text%></span></a></td>',
              '</tr>',
              '<tr>',
                '<th class="datepickerWeek"><a href="#"><span><%=weeks[4].week%></span></a></th>',
                '<td class="<%=weeks[4].days[0].classname%>"><a href="#"><span><%=weeks[4].days[0].text%></span></a></td>',
                '<td class="<%=weeks[4].days[1].classname%>"><a href="#"><span><%=weeks[4].days[1].text%></span></a></td>',
                '<td class="<%=weeks[4].days[2].classname%>"><a href="#"><span><%=weeks[4].days[2].text%></span></a></td>',
                '<td class="<%=weeks[4].days[3].classname%>"><a href="#"><span><%=weeks[4].days[3].text%></span></a></td>',
                '<td class="<%=weeks[4].days[4].classname%>"><a href="#"><span><%=weeks[4].days[4].text%></span></a></td>',
                '<td class="<%=weeks[4].days[5].classname%>"><a href="#"><span><%=weeks[4].days[5].text%></span></a></td>',
                '<td class="<%=weeks[4].days[6].classname%>"><a href="#"><span><%=weeks[4].days[6].text%></span></a></td>',
              '</tr>',
              '<tr>',
                '<th class="datepickerWeek"><a href="#"><span><%=weeks[5].week%></span></a></th>',
                '<td class="<%=weeks[5].days[0].classname%>"><a href="#"><span><%=weeks[5].days[0].text%></span></a></td>',
                '<td class="<%=weeks[5].days[1].classname%>"><a href="#"><span><%=weeks[5].days[1].text%></span></a></td>',
                '<td class="<%=weeks[5].days[2].classname%>"><a href="#"><span><%=weeks[5].days[2].text%></span></a></td>',
                '<td class="<%=weeks[5].days[3].classname%>"><a href="#"><span><%=weeks[5].days[3].text%></span></a></td>',
                '<td class="<%=weeks[5].days[4].classname%>"><a href="#"><span><%=weeks[5].days[4].text%></span></a></td>',
                '<td class="<%=weeks[5].days[5].classname%>"><a href="#"><span><%=weeks[5].days[5].text%></span></a></td>',
                '<td class="<%=weeks[5].days[6].classname%>"><a href="#"><span><%=weeks[5].days[6].text%></span></a></td>',
              '</tr>',
            '</tbody>'
          ],
          months: [
            '<tbody class="<%=className%>">',
              '<tr>',
                '<td colspan="2"><a href="#"><span><%=data[0]%></span></a></td>',
                '<td colspan="2"><a href="#"><span><%=data[1]%></span></a></td>',
                '<td colspan="2"><a href="#"><span><%=data[2]%></span></a></td>',
                '<td colspan="2"><a href="#"><span><%=data[3]%></span></a></td>',
              '</tr>',
              '<tr>',
                '<td colspan="2"><a href="#"><span><%=data[4]%></span></a></td>',
                '<td colspan="2"><a href="#"><span><%=data[5]%></span></a></td>',
                '<td colspan="2"><a href="#"><span><%=data[6]%></span></a></td>',
                '<td colspan="2"><a href="#"><span><%=data[7]%></span></a></td>',
              '</tr>',
              '<tr>',
                '<td colspan="2"><a href="#"><span><%=data[8]%></span></a></td>',
                '<td colspan="2"><a href="#"><span><%=data[9]%></span></a></td>',
                '<td colspan="2"><a href="#"><span><%=data[10]%></span></a></td>',
                '<td colspan="2"><a href="#"><span><%=data[11]%></span></a></td>',
              '</tr>',
            '</tbody>'
          ]
        },
        defaults = {
          flat: false,
          starts: 1,
          prev: '&#9664;',
          next: '&#9654;',
          lastSel: false,
          mode: 'single',
          view: 'days',
          calendars: 1,
          format: 'Y-m-d',
          position: 'bottom',
          eventName: 'click',
          onRender: function(){return {};},
          onChange: function(){return true;},
          onShow: function(){return true;},
          onBeforeShow: function(){return true;},
          onHide: function(){return true;},
          locale: {
            days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
            daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
            daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
            months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            weekMin: 'wk'
          }
        },
        fill = function(el) {
          var options = $(el).data('datepicker');
          var cal = $(el);
          var currentCal = Math.floor(options.calendars/2), date, data, dow, month, cnt = 0, week, days, indic, indic2, html, tblCal;
          cal.find('td>table tbody').remove();
          for (var i = 0; i < options.calendars; i++) {
            date = new Date(options.current);
            date.addMonths(-currentCal + i);
            tblCal = cal.find('table').eq(i+1);
            switch (tblCal[0].className) {
              case 'datepickerViewDays':
                dow = formatDate(date, 'B, Y');
                break;
              case 'datepickerViewMonths':
                dow = date.getFullYear();
                break;
              case 'datepickerViewYears':
                dow = (date.getFullYear()-6) + ' - ' + (date.getFullYear()+5);
                break;
            } 
            tblCal.find('thead tr:first th:eq(1) span').text(dow);
            dow = date.getFullYear()-6;
            data = {
              data: [],
              className: 'datepickerYears'
            }
            for ( var j = 0; j < 12; j++) {
              data.data.push(dow + j);
            }
            html = tmpl(tpl.months.join(''), data);
            date.setDate(1);
            data = {weeks:[], test: 10};
            month = date.getMonth();
            var dow = (date.getDay() - options.starts) % 7;
            date.addDays(-(dow + (dow < 0 ? 7 : 0)));
            week = -1;
            cnt = 0;
            while (cnt < 42) {
              indic = parseInt(cnt/7,10);
              indic2 = cnt%7;
              if (!data.weeks[indic]) {
                week = date.getWeekNumber();
                data.weeks[indic] = {
                  week: week,
                  days: []
                };
              }
              data.weeks[indic].days[indic2] = {
                text: date.getDate(),
                classname: []
              };
              if (month != date.getMonth()) {
                data.weeks[indic].days[indic2].classname.push('datepickerNotInMonth');
              }
              if (date.getDay() == 0) {
                data.weeks[indic].days[indic2].classname.push('datepickerSunday');
              }
              if (date.getDay() == 6) {
                data.weeks[indic].days[indic2].classname.push('datepickerSaturday');
              }
              var fromUser = options.onRender(date);
              var val = date.valueOf();
  
              if (val === options.date[0]) {
                data.weeks[indic].days[indic2].classname.push('datepickerSelectedFirst');
              }
              if ((val + 86399000) === options.date[1]) {
                data.weeks[indic].days[indic2].classname.push('datepickerSelectedLast');
              }
              if (fromUser.selected || options.date == val || $.inArray(val, options.date) > -1 || (options.mode == 'range' && val >= options.date[0] && val <= options.date[1])) {
                data.weeks[indic].days[indic2].classname.push('datepickerSelected');
              }
              if (fromUser.disabled) {
                data.weeks[indic].days[indic2].classname.push('datepickerDisabled');
              }
              if (fromUser.className) {
                data.weeks[indic].days[indic2].classname.push(fromUser.className);
              }
              data.weeks[indic].days[indic2].classname = data.weeks[indic].days[indic2].classname.join(' ');
              cnt++;
              date.addDays(1);
            }
            html = tmpl(tpl.days.join(''), data) + html;
            data = {
              data: options.locale.monthsShort,
              className: 'datepickerMonths'
            };
            html = tmpl(tpl.months.join(''), data) + html;
            tblCal.append(html);
          }
        },
        parseDate = function (date, format) {
          if (date.constructor == Date) {
            return new Date(date);
          }
          var parts = date.split(/\W+/);
          var against = format.split(/\W+/), d, m, y, h, min, now = new Date();
          for (var i = 0; i < parts.length; i++) {
            switch (against[i]) {
              case 'd':
              case 'e':
                d = parseInt(parts[i],10);
                break;
              case 'm':
                m = parseInt(parts[i], 10)-1;
                break;
              case 'Y':
              case 'y':
                y = parseInt(parts[i], 10);
                y += y > 100 ? 0 : (y < 29 ? 2000 : 1900);
                break;
              case 'H':
              case 'I':
              case 'k':
              case 'l':
                h = parseInt(parts[i], 10);
                break;
              case 'P':
              case 'p':
                if (/pm/i.test(parts[i]) && h < 12) {
                  h += 12;
                } else if (/am/i.test(parts[i]) && h >= 12) {
                  h -= 12;
                }
                break;
              case 'M':
                min = parseInt(parts[i], 10);
                break;
            }
          }
          return new Date(
            y === undefined ? now.getFullYear() : y,
            m === undefined ? now.getMonth() : m,
            d === undefined ? now.getDate() : d,
            h === undefined ? now.getHours() : h,
            min === undefined ? now.getMinutes() : min,
            0
          );
        },
        formatDate = function(date, format) {
          var m = date.getMonth();
          var d = date.getDate();
          var y = date.getFullYear();
          var wn = date.getWeekNumber();
          var w = date.getDay();
          var s = {};
          var hr = date.getHours();
          var pm = (hr >= 12);
          var ir = (pm) ? (hr - 12) : hr;
          var dy = date.getDayOfYear();
          if (ir == 0) {
            ir = 12;
          }
          var min = date.getMinutes();
          var sec = date.getSeconds();
          var parts = format.split(''), part;
          for ( var i = 0; i < parts.length; i++ ) {
            part = parts[i];
            switch (parts[i]) {
              case 'a':
                part = date.getDayName();
                break;
              case 'A':
                part = date.getDayName(true);
                break;
              case 'b':
                part = date.getMonthName();
                break;
              case 'B':
                part = date.getMonthName(true);
                break;
              case 'C':
                part = 1 + Math.floor(y / 100);
                break;
              case 'd':
                part = (d < 10) ? ("0" + d) : d;
                break;
              case 'e':
                part = d;
                break;
              case 'H':
                part = (hr < 10) ? ("0" + hr) : hr;
                break;
              case 'I':
                part = (ir < 10) ? ("0" + ir) : ir;
                break;
              case 'j':
                part = (dy < 100) ? ((dy < 10) ? ("00" + dy) : ("0" + dy)) : dy;
                break;
              case 'k':
                part = hr;
                break;
              case 'l':
                part = ir;
                break;
              case 'm':
                part = (m < 9) ? ("0" + (1+m)) : (1+m);
                break;
              case 'M':
                part = (min < 10) ? ("0" + min) : min;
                break;
              case 'p':
              case 'P':
                part = pm ? "PM" : "AM";
                break;
              case 's':
                part = Math.floor(date.getTime() / 1000);
                break;
              case 'S':
                part = (sec < 10) ? ("0" + sec) : sec;
                break;
              case 'u':
                part = w + 1;
                break;
              case 'w':
                part = w;
                break;
              case 'y':
                part = ('' + y).substr(2, 2);
                break;
              case 'Y':
                part = y;
                break;
            }
            parts[i] = part;
          }
          return parts.join('');
        },
        extendDate = function(options) {
          if (Date.prototype.tempDate) {
            return;
          }
          Date.prototype.tempDate = null;
          Date.prototype.months = options.months;
          Date.prototype.monthsShort = options.monthsShort;
          Date.prototype.days = options.days;
          Date.prototype.daysShort = options.daysShort;
          Date.prototype.getMonthName = function(fullName) {
            return this[fullName ? 'months' : 'monthsShort'][this.getMonth()];
          };
          Date.prototype.getDayName = function(fullName) {
            return this[fullName ? 'days' : 'daysShort'][this.getDay()];
          };
          Date.prototype.addDays = function (n) {
            this.setDate(this.getDate() + n);
            this.tempDate = this.getDate();
          };
          Date.prototype.addMonths = function (n) {
            if (this.tempDate == null) {
              this.tempDate = this.getDate();
            }
            this.setDate(1);
            this.setMonth(this.getMonth() + n);
            this.setDate(Math.min(this.tempDate, this.getMaxDays()));
          };
          Date.prototype.addYears = function (n) {
            if (this.tempDate == null) {
              this.tempDate = this.getDate();
            }
            this.setDate(1);
            this.setFullYear(this.getFullYear() + n);
            this.setDate(Math.min(this.tempDate, this.getMaxDays()));
          };
          Date.prototype.getMaxDays = function() {
            var tmpDate = new Date(Date.parse(this)),
              d = 28, m;
            m = tmpDate.getMonth();
            d = 28;
            while (tmpDate.getMonth() == m) {
              d ++;
              tmpDate.setDate(d);
            }
            return d - 1;
          };
          Date.prototype.getFirstDay = function() {
            var tmpDate = new Date(Date.parse(this));
            tmpDate.setDate(1);
            return tmpDate.getDay();
          };
          Date.prototype.getWeekNumber = function() {
            var tempDate = new Date(this);
            tempDate.setDate(tempDate.getDate() - (tempDate.getDay() + 6) % 7 + 3);
            var dms = tempDate.valueOf();
            tempDate.setMonth(0);
            tempDate.setDate(4);
            return Math.round((dms - tempDate.valueOf()) / (604800000)) + 1;
          };
          Date.prototype.getDayOfYear = function() {
            var now = new Date(this.getFullYear(), this.getMonth(), this.getDate(), 0, 0, 0);
            var then = new Date(this.getFullYear(), 0, 0, 0, 0, 0);
            var time = now - then;
            return Math.floor(time / 24*60*60*1000);
          };
        },
        layout = function (el) {
          var options = $(el).data('datepicker');
          var cal = $('#' + options.id);
          if (!options.extraHeight) {
            var divs = $(el).find('div');
            options.extraHeight = divs.get(0).offsetHeight + divs.get(1).offsetHeight;
            options.extraWidth = divs.get(2).offsetWidth + divs.get(3).offsetWidth;
          }
          var tbl = cal.find('table:first').get(0);
          var width = tbl.offsetWidth;
          var height = tbl.offsetHeight;
          cal.css({
            width: width + options.extraWidth + 'px',
            height: height + options.extraHeight + 'px'
          }).find('div.datepickerContainer').css({
            width: width + 'px',
            height: height + 'px'
          });
        },
        click = function(ev) {
          if ($(ev.target).is('span')) {
            ev.target = ev.target.parentNode;
          }
          var el = $(ev.target);
          if (el.is('a')) {
            ev.target.blur();
            if (el.hasClass('datepickerDisabled')) {
              return false;
            }
            var options = $(this).data('datepicker');
            var parentEl = el.parent();
            var tblEl = parentEl.parent().parent().parent();
            var tblIndex = $('table', this).index(tblEl.get(0)) - 1;
            var tmp = new Date(options.current);
            var changed = false;
            var fillIt = false;
            if (parentEl.is('th')) {
              if (parentEl.hasClass('datepickerWeek') && options.mode == 'range' && !parentEl.next().hasClass('datepickerDisabled')) {
                var val = parseInt(parentEl.next().text(), 10);
                tmp.addMonths(tblIndex - Math.floor(options.calendars/2));
                if (parentEl.next().hasClass('datepickerNotInMonth')) {
                  tmp.addMonths(val > 15 ? -1 : 1);
                }
                tmp.setDate(val);
                options.date[0] = (tmp.setHours(0,0,0,0)).valueOf();
                tmp.setHours(23,59,59,0);
                tmp.addDays(6);
                options.date[1] = tmp.valueOf();
                fillIt = true;
                changed = true;
                options.lastSel = false;
              } else if (parentEl.hasClass('datepickerMonth')) {
                return false;
                // tmp.addMonths(tblIndex - Math.floor(options.calendars/2));
                // switch (tblEl.get(0).className) {
                // 	case 'datepickerViewDays':
                // 		tblEl.get(0).className = 'datepickerViewMonths';
                // 		el.find('span').text(tmp.getFullYear());
                // 		break;
                // 	case 'datepickerViewMonths':
                // 		tblEl.get(0).className = 'datepickerViewYears';
                // 		el.find('span').text((tmp.getFullYear()-6) + ' - ' + (tmp.getFullYear()+5));
                // 		break;
                // 	case 'datepickerViewYears':
                // 		tblEl.get(0).className = 'datepickerViewDays';
                // 		el.find('span').text(formatDate(tmp, 'B, Y'));
                // 		break;
                // }
              } else if (parentEl.parent().parent().is('thead')) {
                switch (tblEl.get(0).className) {
                  case 'datepickerViewDays':
                    options.current.addMonths(parentEl.hasClass('datepickerGoPrev') ? -1 : 1);
                    break;
                  case 'datepickerViewMonths':
                    options.current.addYears(parentEl.hasClass('datepickerGoPrev') ? -1 : 1);
                    break;
                  case 'datepickerViewYears':
                    options.current.addYears(parentEl.hasClass('datepickerGoPrev') ? -12 : 12);
                    break;
                }
                fillIt = true;
              }
            } else if (parentEl.is('td') && !parentEl.hasClass('datepickerDisabled')) {
              switch (tblEl.get(0).className) {
                case 'datepickerViewMonths':
                  options.current.setMonth(tblEl.find('tbody.datepickerMonths td').index(parentEl));
                  options.current.setFullYear(parseInt(tblEl.find('thead th.datepickerMonth span').text(), 10));
                  options.current.addMonths(Math.floor(options.calendars/2) - tblIndex);
                  tblEl.get(0).className = 'datepickerViewDays';
                  break;
                case 'datepickerViewYears':
                  options.current.setFullYear(parseInt(el.text(), 10));
                  tblEl.get(0).className = 'datepickerViewMonths';
                  break;
                default:
                  var val = parseInt(el.text(), 10);
                  tmp.addMonths(tblIndex - Math.floor(options.calendars/2));
                  if (parentEl.hasClass('datepickerNotInMonth')) {
                    tmp.addMonths(val > 15 ? -1 : 1);
                  }
                  tmp.setDate(val);
                  switch (options.mode) {
                    case 'multiple':
                      val = (tmp.setHours(0,0,0,0)).valueOf();
                      if ($.inArray(val, options.date) > -1) {
                        $.each(options.date, function(nr, dat){
                          if (dat == val) {
                            options.date.splice(nr,1);
                            return false;
                          }
                        });
                      } else {
                        options.date.push(val);
                      }
                      break;
                    case 'range':
                      if (!options.lastSel) {
                        options.date[0] = (tmp.setHours(0,0,0,0)).valueOf();
                      }
                      val = (tmp.setHours(23,59,59,0)).valueOf();
                      if (val < options.date[0]) {
                        options.date[1] = options.date[0] + 86399000;
                        options.date[0] = val - 86399000;
                      } else {
                        options.date[1] = val;
                      }
                      options.lastSel = !options.lastSel;
                      break;
                    default:
                      options.date = tmp.valueOf();
                      break;
                  }
                  break;
              }
              fillIt = true;
              changed = true;
            }
            if (fillIt) {
              fill(this);
            }
            if (changed) {
              options.onChange.apply(this, prepareDate(options));
            }
          }
          return false;
        },
        prepareDate = function (options) {
          var tmp;
          if (options.mode == 'single') {
            tmp = new Date(options.date);
            return [formatDate(tmp, options.format), tmp, options.el];
          } else {
            tmp = [[],[], options.el];
            $.each(options.date, function(nr, val){
              var date = new Date(val);
              tmp[0].push(formatDate(date, options.format));
              tmp[1].push(date);
            });
            return tmp;
          }
        },
        getViewport = function () {
          var m = document.compatMode == 'CSS1Compat';
          return {
            l : window.pageXOffset || (m ? document.documentElement.scrollLeft : document.body.scrollLeft),
            t : window.pageYOffset || (m ? document.documentElement.scrollTop : document.body.scrollTop),
            w : window.innerWidth || (m ? document.documentElement.clientWidth : document.body.clientWidth),
            h : window.innerHeight || (m ? document.documentElement.clientHeight : document.body.clientHeight)
          };
        },
        isChildOf = function(parentEl, el, container) {
          if (parentEl == el) {
            return true;
          }
          if (parentEl.contains) {
            return parentEl.contains(el);
          }
          if ( parentEl.compareDocumentPosition ) {
            return !!(parentEl.compareDocumentPosition(el) & 16);
          }
          var prEl = el.parentNode;
          while(prEl && prEl != container) {
            if (prEl == parentEl)
              return true;
            prEl = prEl.parentNode;
          }
          return false;
        },
        show = function (ev) {
          var cal = $('#' + $(this).data('datepickerId'));
          if (!cal.is(':visible')) {
            var calEl = cal.get(0);
            fill(calEl);
            var options = cal.data('datepicker');
            options.onBeforeShow.apply(this, [cal.get(0)]);
            var pos = $(this).offset();
            var viewPort = getViewport();
            var top = pos.top;
            var left = pos.left;
            var oldDisplay = $.curCSS(calEl, 'display');
            cal.css({
              visibility: 'hidden',
              display: 'block'
            });
            layout(calEl);
            switch (options.position){
              case 'top':
                top -= calEl.offsetHeight;
                break;
              case 'left':
                left -= calEl.offsetWidth;
                break;
              case 'right':
                left += this.offsetWidth;
                break;
              case 'bottom':
                top += this.offsetHeight;
                break;
            }
            if (top + calEl.offsetHeight > viewPort.t + viewPort.h) {
              top = pos.top  - calEl.offsetHeight;
            }
            if (top < viewPort.t) {
              top = pos.top + this.offsetHeight + calEl.offsetHeight;
            }
            if (left + calEl.offsetWidth > viewPort.l + viewPort.w) {
              left = pos.left - calEl.offsetWidth;
            }
            if (left < viewPort.l) {
              left = pos.left + this.offsetWidth
            }
            cal.css({
              visibility: 'visible',
              display: 'block',
              top: top + 'px',
              left: left + 'px'
            });
            if (options.onShow.apply(this, [cal.get(0)]) != false) {
              cal.show();
            }
            $(document).bind('mousedown', {cal: cal, trigger: this}, hide);
          }
          return false;
        },
        hide = function (ev) {
          if (ev.target != ev.data.trigger && !isChildOf(ev.data.cal.get(0), ev.target, ev.data.cal.get(0))) {
            if (ev.data.cal.data('datepicker').onHide.apply(this, [ev.data.cal.get(0)]) != false) {
              ev.data.cal.hide();
            }
            $(document).unbind('mousedown', hide);
          }
        };
      return {
        init: function(options){
          options = $.extend({}, defaults, options||{});
          extendDate(options.locale);
          options.calendars = Math.max(1, parseInt(options.calendars,10)||1);
          options.mode = /single|multiple|range/.test(options.mode) ? options.mode : 'single';
          return this.each(function(){
            if (!$(this).data('datepicker')) {
              options.el = this;
              if (options.date.constructor == String) {
                options.date = parseDate(options.date, options.format);
                options.date.setHours(0,0,0,0);
              }
              if (options.mode != 'single') {
                if (options.date.constructor != Array) {
                  options.date = [options.date.valueOf()];
                  if (options.mode == 'range') {
                    options.date.push(((new Date(options.date[0])).setHours(23,59,59,0)).valueOf());
                  }
                } else {
                  for (var i = 0; i < options.date.length; i++) {
                    options.date[i] = (parseDate(options.date[i], options.format).setHours(0,0,0,0)).valueOf();
                  }
                  if (options.mode == 'range') {
                    options.date[1] = ((new Date(options.date[1])).setHours(23,59,59,0)).valueOf();
                  }
                }
              } else {
                options.date = options.date.valueOf();
              }
              if (!options.current) {
                options.current = new Date();
              } else {
                options.current = parseDate(options.current, options.format);
              } 
              options.current.setDate(1);
              options.current.setHours(0,0,0,0);
              var id = 'datepicker_' + parseInt(Math.random() * 1000), cnt;
              options.id = id;
              $(this).data('datepickerId', options.id);
              var cal = $(tpl.wrapper).attr('id', id).bind('click', click).data('datepicker', options);
              if (options.className) {
                cal.addClass(options.className);
              }
              var html = '';
              for (var i = 0; i < options.calendars; i++) {
                cnt = options.starts;
                if (i > 0) {
                  html += tpl.space;
                }
                html += tmpl(tpl.head.join(''), {
                    week: options.locale.weekMin,
                    prev: options.prev,
                    next: options.next,
                    day1: options.locale.daysMin[(cnt++)%7],
                    day2: options.locale.daysMin[(cnt++)%7],
                    day3: options.locale.daysMin[(cnt++)%7],
                    day4: options.locale.daysMin[(cnt++)%7],
                    day5: options.locale.daysMin[(cnt++)%7],
                    day6: options.locale.daysMin[(cnt++)%7],
                    day7: options.locale.daysMin[(cnt++)%7]
                  });
              }
              cal
                .find('tr:first').append(html)
                  .find('table').addClass(views[options.view]);
              fill(cal.get(0));
              if (options.flat) {
                cal.appendTo(this).show().css('position', 'relative');
                layout(cal.get(0));
              } else {
                cal.appendTo(document.body);
                $(this).bind(options.eventName, show);
              }
            }
          });
        },
        showPicker: function() {
          return this.each( function () {
            if ($(this).data('datepickerId')) {
              show.apply(this);
            }
          });
        },
        hidePicker: function() {
          return this.each( function () {
            if ($(this).data('datepickerId')) {
              $('#' + $(this).data('datepickerId')).hide();
            }
          });
        },
        setDate: function(date, shiftTo){
          return this.each(function(){
            if ($(this).data('datepickerId')) {
              var cal = $('#' + $(this).data('datepickerId'));
              var options = cal.data('datepicker');
              options.date = date;
              if (options.date.constructor == String) {
                options.date = parseDate(options.date, options.format);
                options.date.setHours(0,0,0,0);
              }
              if (options.mode != 'single') {
                if (options.date.constructor != Array) {
                  options.date = [options.date.valueOf()];
                  if (options.mode == 'range') {
                    options.date.push(((new Date(options.date[0])).setHours(23,59,59,0)).valueOf());
                  }
                } else {
                  for (var i = 0; i < options.date.length; i++) {
                    options.date[i] = (parseDate(options.date[i], options.format).setHours(0,0,0,0)).valueOf();
                  }
                  if (options.mode == 'range') {
                    options.date[1] = ((new Date(options.date[1])).setHours(23,59,59,0)).valueOf();
                  }
                }
              } else {
                options.date = options.date.valueOf();
              }
              if (shiftTo) {
                options.current = new Date (options.mode != 'single' ? options.date[0] : options.date);
              }
              fill(cal.get(0));
            }
          });
        },
        getDate: function(formated) {
          if (this.size() > 0) {
            return prepareDate($('#' + $(this).data('datepickerId')).data('datepicker'))[formated ? 0 : 1];
          }
        },
        clear: function(){
          return this.each(function(){
            if ($(this).data('datepickerId')) {
              var cal = $('#' + $(this).data('datepickerId'));
              var options = cal.data('datepicker');
              if (options.mode != 'single') {
                options.date = [];
                fill(cal.get(0));
              }
            }
          });
        },
        fixLayout: function(){
          return this.each(function(){
            if ($(this).data('datepickerId')) {
              var cal = $('#' + $(this).data('datepickerId'));
              var options = cal.data('datepicker');
              if (options.flat) {
                layout(cal.get(0));
              }
            }
          });
        }
      };
    }();
    $.fn.extend({
      DatePicker: DatePicker.init,
      DatePickerHide: DatePicker.hidePicker,
      DatePickerShow: DatePicker.showPicker,
      DatePickerSetDate: DatePicker.setDate,
      DatePickerGetDate: DatePicker.getDate,
      DatePickerClear: DatePicker.clear,
      DatePickerLayout: DatePicker.fixLayout
    });
  })(jQuery);
  
  (function(){
    var cache = {};
   
    this.tmpl = function tmpl(str, data){
      // Figure out if we're getting a template, or if we need to
      // load the template - and be sure to cache the result.
      var fn = !/\W/.test(str) ?
        cache[str] = cache[str] ||
          tmpl(document.getElementById(str).innerHTML) :
       
        // Generate a reusable function that will serve as a template
        // generator (and which will be cached).
        new Function("obj",
          "var p=[],print=function(){p.push.apply(p,arguments);};" +
         
          // Introduce the data as local variables using with(){}
          "with(obj){p.push('" +
         
          // Convert the template into pure JavaScript
          str
            .replace(/[\r\t\n]/g, " ")
            .split("<%").join("\t")
            .replace(/((^|%>)[^\t]*)'/g, "$1\r")
            .replace(/\t=(.*?)%>/g, "',$1,'")
            .split("\t").join("');")
            .split("%>").join("p.push('")
            .split("\r").join("\\'")
        + "');}return p.join('');");
     
      // Provide some basic currying to the user
      return data ? fn( data ) : fn;
    };
  })();
  /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))
  
  /***/ }),
  
  /***/ "./vendor/assets/javascripts/dragster.js":
  /*!***********************************************!*\
    !*** ./vendor/assets/javascripts/dragster.js ***!
    \***********************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  
  (function() {
    var Dragster,
        __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
  
    Dragster = (function() {
      function Dragster(el) {
        this.el = el;
        this.dragleave = __bind(this.dragleave, this);
        this.dragenter = __bind(this.dragenter, this);
        this.first = false;
        this.second = false;
        this.el.addEventListener("dragenter", this.dragenter, false);
        this.el.addEventListener("dragleave", this.dragleave, false);
      }
  
      Dragster.prototype.dragenter = function(event) {
        if (this.first) {
          return this.second = true;
        } else {
          this.first = true;
          this.customEvent = document.createEvent("CustomEvent");
          this.customEvent.initCustomEvent("dragster:enter", true, true, {
            dataTransfer: event.dataTransfer,
            sourceEvent: event
          });
          return this.el.dispatchEvent(this.customEvent);
        }
      };
  
      Dragster.prototype.dragleave = function(event) {
        if (this.second) {
          this.second = false;
        } else if (this.first) {
          this.first = false;
        }
        if (!this.first && !this.second) {
          this.customEvent = document.createEvent("CustomEvent");
          this.customEvent.initCustomEvent("dragster:leave", true, true, {
            dataTransfer: event.dataTransfer,
            sourceEvent: event
          });
          return this.el.dispatchEvent(this.customEvent);
        }
      };
  
      Dragster.prototype.removeListeners = function() {
        this.el.removeEventListener("dragenter", this.dragenter, false);
        return this.el.removeEventListener("dragleave", this.dragleave, false);
      };
  
      Dragster.prototype.reset = function() {
        this.first = false;
        return this.second = false;
      };
  
      return Dragster;
  
    })();
  
    window.Dragster = Dragster;
  
  }).call(this);
  
  
  /***/ }),
  
  /***/ "./vendor/assets/javascripts/dropzone.js":
  /*!***********************************************!*\
    !*** ./vendor/assets/javascripts/dropzone.js ***!
    \***********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  /* WEBPACK VAR INJECTION */(function(jQuery, module) {
  /*
   *
   * More info at [www.dropzonejs.com](http://www.dropzonejs.com)
   *
   * Copyright (c) 2012, Matias Meno
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *
   */
  
  (function() {
    var Dropzone, Emitter, camelize, contentLoaded, detectVerticalSquash, drawImageIOSFix, noop, without,
      __slice = [].slice,
      __hasProp = {}.hasOwnProperty,
      __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
  
    noop = function() {};
  
    Emitter = (function() {
      function Emitter() {}
  
      Emitter.prototype.addEventListener = Emitter.prototype.on;
  
      Emitter.prototype.on = function(event, fn) {
        this._callbacks = this._callbacks || {};
        if (!this._callbacks[event]) {
          this._callbacks[event] = [];
        }
        this._callbacks[event].push(fn);
        return this;
      };
  
      Emitter.prototype.emit = function() {
        var args, callback, callbacks, event, _i, _len;
        event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        this._callbacks = this._callbacks || {};
        callbacks = this._callbacks[event];
        if (callbacks) {
          for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
            callback = callbacks[_i];
            callback.apply(this, args);
          }
        }
        return this;
      };
  
      Emitter.prototype.removeListener = Emitter.prototype.off;
  
      Emitter.prototype.removeAllListeners = Emitter.prototype.off;
  
      Emitter.prototype.removeEventListener = Emitter.prototype.off;
  
      Emitter.prototype.off = function(event, fn) {
        var callback, callbacks, i, _i, _len;
        if (!this._callbacks || arguments.length === 0) {
          this._callbacks = {};
          return this;
        }
        callbacks = this._callbacks[event];
        if (!callbacks) {
          return this;
        }
        if (arguments.length === 1) {
          delete this._callbacks[event];
          return this;
        }
        for (i = _i = 0, _len = callbacks.length; _i < _len; i = ++_i) {
          callback = callbacks[i];
          if (callback === fn) {
            callbacks.splice(i, 1);
            break;
          }
        }
        return this;
      };
  
      return Emitter;
  
    })();
  
    Dropzone = (function(_super) {
      var extend, resolveOption;
  
      __extends(Dropzone, _super);
  
      Dropzone.prototype.Emitter = Emitter;
  
  
      /*
      This is a list of all available events you can register on a dropzone object.
      
      You can register an event handler like this:
      
          dropzone.on("dragEnter", function() { });
       */
  
      Dropzone.prototype.events = ["drop", "dragstart", "dragend", "dragenter", "dragover", "dragleave", "addedfile", "removedfile", "thumbnail", "error", "errormultiple", "processing", "processingmultiple", "uploadprogress", "totaluploadprogress", "sending", "sendingmultiple", "success", "successmultiple", "canceled", "canceledmultiple", "complete", "completemultiple", "reset", "maxfilesexceeded", "maxfilesreached", "queuecomplete"];
  
      Dropzone.prototype.defaultOptions = {
        url: null,
        method: "post",
        withCredentials: false,
        parallelUploads: 2,
        uploadMultiple: false,
        maxFilesize: 256,
        paramName: "file",
        createImageThumbnails: true,
        maxThumbnailFilesize: 10,
        thumbnailWidth: 120,
        thumbnailHeight: 120,
        filesizeBase: 1000,
        maxFiles: null,
        filesizeBase: 1000,
        params: {},
        clickable: true,
        ignoreHiddenFiles: true,
        acceptedFiles: null,
        acceptedMimeTypes: null,
        autoProcessQueue: true,
        autoQueue: true,
        addRemoveLinks: false,
        previewsContainer: null,
        capture: null,
        dictDefaultMessage: "Drop files here to upload",
        dictFallbackMessage: "Your browser does not support drag'n'drop file uploads.",
        dictFallbackText: "Please use the fallback form below to upload your files like in the olden days.",
        dictFileTooBig: "File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.",
        dictInvalidFileType: "You can't upload files of this type.",
        dictResponseError: "Server responded with {{statusCode}} code.",
        dictCancelUpload: "Cancel upload",
        dictCancelUploadConfirmation: "Are you sure you want to cancel this upload?",
        dictRemoveFile: "Remove file",
        dictRemoveFileConfirmation: null,
        dictMaxFilesExceeded: "You can not upload any more files.",
        accept: function(file, done) {
          return done();
        },
        init: function() {
          return noop;
        },
        forceFallback: false,
        fallback: function() {
          var child, messageElement, span, _i, _len, _ref;
          this.element.className = "" + this.element.className + " dz-browser-not-supported";
          _ref = this.element.getElementsByTagName("div");
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            child = _ref[_i];
            if (/(^| )dz-message($| )/.test(child.className)) {
              messageElement = child;
              child.className = "dz-message";
              continue;
            }
          }
          if (!messageElement) {
            messageElement = Dropzone.createElement("<div class=\"dz-message\"><span></span></div>");
            this.element.appendChild(messageElement);
          }
          span = messageElement.getElementsByTagName("span")[0];
          if (span) {
            span.textContent = this.options.dictFallbackMessage;
          }
          return this.element.appendChild(this.getFallbackForm());
        },
        resize: function(file) {
          var info, srcRatio, trgRatio;
          info = {
            srcX: 0,
            srcY: 0,
            srcWidth: file.width,
            srcHeight: file.height
          };
          srcRatio = file.width / file.height;
          info.optWidth = this.options.thumbnailWidth;
          info.optHeight = this.options.thumbnailHeight;
          if ((info.optWidth == null) && (info.optHeight == null)) {
            info.optWidth = info.srcWidth;
            info.optHeight = info.srcHeight;
          } else if (info.optWidth == null) {
            info.optWidth = srcRatio * info.optHeight;
          } else if (info.optHeight == null) {
            info.optHeight = (1 / srcRatio) * info.optWidth;
          }
          trgRatio = info.optWidth / info.optHeight;
          if (file.height < info.optHeight || file.width < info.optWidth) {
            info.trgHeight = info.srcHeight;
            info.trgWidth = info.srcWidth;
          } else {
            if (srcRatio > trgRatio) {
              info.srcHeight = file.height;
              info.srcWidth = info.srcHeight * trgRatio;
            } else {
              info.srcWidth = file.width;
              info.srcHeight = info.srcWidth / trgRatio;
            }
          }
          info.srcX = (file.width - info.srcWidth) / 2;
          info.srcY = (file.height - info.srcHeight) / 2;
          return info;
        },
  
        /*
        Those functions register themselves to the events on init and handle all
        the user interface specific stuff. Overwriting them won't break the upload
        but can break the way it's displayed.
        You can overwrite them if you don't like the default behavior. If you just
        want to add an additional event handler, register it on the dropzone object
        and don't overwrite those options.
         */
        drop: function(e) {
          return this.element.classList.remove("dz-drag-hover");
        },
        dragstart: noop,
        dragend: function(e) {
          return this.element.classList.remove("dz-drag-hover");
        },
        dragenter: function(e) {
          return this.element.classList.add("dz-drag-hover");
        },
        dragover: function(e) {
          return this.element.classList.add("dz-drag-hover");
        },
        dragleave: function(e) {
          return this.element.classList.remove("dz-drag-hover");
        },
        paste: noop,
        reset: function() {
          return this.element.classList.remove("dz-started");
        },
        addedfile: function(file) {
          var node, removeFileEvent, removeLink, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
          if (this.element === this.previewsContainer) {
            this.element.classList.add("dz-started");
          }
          if (this.previewsContainer) {
            file.previewElement = Dropzone.createElement(this.options.previewTemplate.trim());
            file.previewTemplate = file.previewElement;
            this.previewsContainer.appendChild(file.previewElement);
            _ref = file.previewElement.querySelectorAll("[data-dz-name]");
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              node = _ref[_i];
              node.textContent = file.name;
            }
            _ref1 = file.previewElement.querySelectorAll("[data-dz-size]");
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              node = _ref1[_j];
              node.innerHTML = this.filesize(file.size);
            }
            if (this.options.addRemoveLinks) {
              file._removeLink = Dropzone.createElement("<a class=\"dz-remove\" href=\"javascript:undefined;\" data-dz-remove>" + this.options.dictRemoveFile + "</a>");
              file.previewElement.appendChild(file._removeLink);
            }
            removeFileEvent = (function(_this) {
              return function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (file.status === Dropzone.UPLOADING) {
                  return Dropzone.confirm(_this.options.dictCancelUploadConfirmation, function() {
                    return _this.removeFile(file);
                  });
                } else {
                  if (_this.options.dictRemoveFileConfirmation) {
                    return Dropzone.confirm(_this.options.dictRemoveFileConfirmation, function() {
                      return _this.removeFile(file);
                    });
                  } else {
                    return _this.removeFile(file);
                  }
                }
              };
            })(this);
            _ref2 = file.previewElement.querySelectorAll("[data-dz-remove]");
            _results = [];
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              removeLink = _ref2[_k];
              _results.push(removeLink.addEventListener("click", removeFileEvent));
            }
            return _results;
          }
        },
        removedfile: function(file) {
          var _ref;
          if (file.previewElement) {
            if ((_ref = file.previewElement) != null) {
              _ref.parentNode.removeChild(file.previewElement);
            }
          }
          return this._updateMaxFilesReachedClass();
        },
        thumbnail: function(file, dataUrl) {
          var thumbnailElement, _i, _len, _ref;
          if (file.previewElement) {
            file.previewElement.classList.remove("dz-file-preview");
            _ref = file.previewElement.querySelectorAll("[data-dz-thumbnail]");
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              thumbnailElement = _ref[_i];
              thumbnailElement.alt = file.name;
              thumbnailElement.src = dataUrl;
            }
            return setTimeout(((function(_this) {
              return function() {
                return file.previewElement.classList.add("dz-image-preview");
              };
            })(this)), 1);
          }
        },
        error: function(file, message) {
          var node, _i, _len, _ref, _results;
          if (file.previewElement) {
            file.previewElement.classList.add("dz-error");
            if (typeof message !== "String" && message.error) {
              message = message.error;
            }
            _ref = file.previewElement.querySelectorAll("[data-dz-errormessage]");
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              node = _ref[_i];
              _results.push(node.textContent = message);
            }
            return _results;
          }
        },
        errormultiple: noop,
        processing: function(file) {
          if (file.previewElement) {
            file.previewElement.classList.add("dz-processing");
            if (file._removeLink) {
              return file._removeLink.textContent = this.options.dictCancelUpload;
            }
          }
        },
        processingmultiple: noop,
        uploadprogress: function(file, progress, bytesSent) {
          var node, _i, _len, _ref, _results;
          if (file.previewElement) {
            _ref = file.previewElement.querySelectorAll("[data-dz-uploadprogress]");
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              node = _ref[_i];
              if (node.nodeName === 'PROGRESS') {
                _results.push(node.value = progress);
              } else {
                _results.push(node.style.width = "" + progress + "%");
              }
            }
            return _results;
          }
        },
        totaluploadprogress: noop,
        sending: noop,
        sendingmultiple: noop,
        success: function(file) {
          if (file.previewElement) {
            return file.previewElement.classList.add("dz-success");
          }
        },
        successmultiple: noop,
        canceled: function(file) {
          return this.emit("error", file, "Upload canceled.");
        },
        canceledmultiple: noop,
        complete: function(file) {
          if (file._removeLink) {
            file._removeLink.textContent = this.options.dictRemoveFile;
          }
          if (file.previewElement) {
            return file.previewElement.classList.add("dz-complete");
          }
        },
        completemultiple: noop,
        maxfilesexceeded: noop,
        maxfilesreached: noop,
        queuecomplete: noop,
        previewTemplate: "<div class=\"dz-preview dz-file-preview\">\n  <div class=\"dz-image\"><img data-dz-thumbnail /></div>\n  <div class=\"dz-details\">\n    <div class=\"dz-size\"><span data-dz-size></span></div>\n    <div class=\"dz-filename\"><span data-dz-name></span></div>\n  </div>\n  <div class=\"dz-progress\"><span class=\"dz-upload\" data-dz-uploadprogress></span></div>\n  <div class=\"dz-error-message\"><span data-dz-errormessage></span></div>\n  <div class=\"dz-success-mark\">\n    <svg width=\"54px\" height=\"54px\" viewBox=\"0 0 54 54\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:sketch=\"http://www.bohemiancoding.com/sketch/ns\">\n      <title>Check</title>\n      <defs></defs>\n      <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" sketch:type=\"MSPage\">\n        <path d=\"M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\" id=\"Oval-2\" stroke-opacity=\"0.198794158\" stroke=\"#747474\" fill-opacity=\"0.816519475\" fill=\"#FFFFFF\" sketch:type=\"MSShapeGroup\"></path>\n      </g>\n    </svg>\n  </div>\n  <div class=\"dz-error-mark\">\n    <svg width=\"54px\" height=\"54px\" viewBox=\"0 0 54 54\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:sketch=\"http://www.bohemiancoding.com/sketch/ns\">\n      <title>Error</title>\n      <defs></defs>\n      <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" sketch:type=\"MSPage\">\n        <g id=\"Check-+-Oval-2\" sketch:type=\"MSLayerGroup\" stroke=\"#747474\" stroke-opacity=\"0.198794158\" fill=\"#FFFFFF\" fill-opacity=\"0.816519475\">\n          <path d=\"M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\" id=\"Oval-2\" sketch:type=\"MSShapeGroup\"></path>\n        </g>\n      </g>\n    </svg>\n  </div>\n</div>"
      };
  
      extend = function() {
        var key, object, objects, target, val, _i, _len;
        target = arguments[0], objects = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        for (_i = 0, _len = objects.length; _i < _len; _i++) {
          object = objects[_i];
          for (key in object) {
            val = object[key];
            target[key] = val;
          }
        }
        return target;
      };
  
      function Dropzone(element, options) {
        var elementOptions, fallback, _ref;
        this.element = element;
        this.version = Dropzone.version;
        this.defaultOptions.previewTemplate = this.defaultOptions.previewTemplate.replace(/\n*/g, "");
        this.clickableElements = [];
        this.listeners = [];
        this.files = [];
        if (typeof this.element === "string") {
          this.element = document.querySelector(this.element);
        }
        if (!(this.element && (this.element.nodeType != null))) {
          throw new Error("Invalid dropzone element.");
        }
        if (this.element.dropzone) {
          throw new Error("Dropzone already attached.");
        }
        Dropzone.instances.push(this);
        this.element.dropzone = this;
        elementOptions = (_ref = Dropzone.optionsForElement(this.element)) != null ? _ref : {};
        this.options = extend({}, this.defaultOptions, elementOptions, options != null ? options : {});
        if (this.options.forceFallback || !Dropzone.isBrowserSupported()) {
          return this.options.fallback.call(this);
        }
        if (this.options.url == null) {
          this.options.url = this.element.getAttribute("action");
        }
        if (!this.options.url) {
          throw new Error("No URL provided.");
        }
        if (this.options.acceptedFiles && this.options.acceptedMimeTypes) {
          throw new Error("You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.");
        }
        if (this.options.acceptedMimeTypes) {
          this.options.acceptedFiles = this.options.acceptedMimeTypes;
          delete this.options.acceptedMimeTypes;
        }
        this.options.method = this.options.method.toUpperCase();
        if ((fallback = this.getExistingFallback()) && fallback.parentNode) {
          fallback.parentNode.removeChild(fallback);
        }
        if (this.options.previewsContainer !== false) {
          if (this.options.previewsContainer) {
            this.previewsContainer = Dropzone.getElement(this.options.previewsContainer, "previewsContainer");
          } else {
            this.previewsContainer = this.element;
          }
        }
        if (this.options.clickable) {
          if (this.options.clickable === true) {
            this.clickableElements = [this.element];
          } else {
            this.clickableElements = Dropzone.getElements(this.options.clickable, "clickable");
          }
        }
        this.init();
      }
  
      Dropzone.prototype.getAcceptedFiles = function() {
        var file, _i, _len, _ref, _results;
        _ref = this.files;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          if (file.accepted) {
            _results.push(file);
          }
        }
        return _results;
      };
  
      Dropzone.prototype.getRejectedFiles = function() {
        var file, _i, _len, _ref, _results;
        _ref = this.files;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          if (!file.accepted) {
            _results.push(file);
          }
        }
        return _results;
      };
  
      Dropzone.prototype.getFilesWithStatus = function(status) {
        var file, _i, _len, _ref, _results;
        _ref = this.files;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          if (file.status === status) {
            _results.push(file);
          }
        }
        return _results;
      };
  
      Dropzone.prototype.getQueuedFiles = function() {
        return this.getFilesWithStatus(Dropzone.QUEUED);
      };
  
      Dropzone.prototype.getUploadingFiles = function() {
        return this.getFilesWithStatus(Dropzone.UPLOADING);
      };
  
      Dropzone.prototype.getActiveFiles = function() {
        var file, _i, _len, _ref, _results;
        _ref = this.files;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          if (file.status === Dropzone.UPLOADING || file.status === Dropzone.QUEUED) {
            _results.push(file);
          }
        }
        return _results;
      };
  
      Dropzone.prototype.init = function() {
        var eventName, noPropagation, setupHiddenFileInput, _i, _len, _ref, _ref1;
        if (this.element.tagName === "form") {
          this.element.setAttribute("enctype", "multipart/form-data");
        }
        if (this.element.classList.contains("dropzone") && !this.element.querySelector(".dz-message")) {
          this.element.appendChild(Dropzone.createElement("<div class=\"dz-default dz-message\"><span>" + this.options.dictDefaultMessage + "</span></div>"));
        }
        if (this.clickableElements.length) {
          setupHiddenFileInput = (function(_this) {
            return function() {
              if (_this.hiddenFileInput) {
                document.body.removeChild(_this.hiddenFileInput);
              }
              _this.hiddenFileInput = document.createElement("input");
              _this.hiddenFileInput.setAttribute("type", "file");
              if ((_this.options.maxFiles == null) || _this.options.maxFiles > 1) {
                _this.hiddenFileInput.setAttribute("multiple", "multiple");
              }
              _this.hiddenFileInput.className = "dz-hidden-input";
              if (_this.options.acceptedFiles != null) {
                _this.hiddenFileInput.setAttribute("accept", _this.options.acceptedFiles);
              }
              if (_this.options.capture != null) {
                _this.hiddenFileInput.setAttribute("capture", _this.options.capture);
              }
              _this.hiddenFileInput.style.visibility = "hidden";
              _this.hiddenFileInput.style.position = "absolute";
              _this.hiddenFileInput.style.top = "0";
              _this.hiddenFileInput.style.left = "0";
              _this.hiddenFileInput.style.height = "0";
              _this.hiddenFileInput.style.width = "0";
              document.body.appendChild(_this.hiddenFileInput);
              return _this.hiddenFileInput.addEventListener("change", function() {
                var file, files, _i, _len;
                files = _this.hiddenFileInput.files;
                if (files.length) {
                  for (_i = 0, _len = files.length; _i < _len; _i++) {
                    file = files[_i];
                    _this.addFile(file);
                  }
                }
                return setupHiddenFileInput();
              });
            };
          })(this);
          setupHiddenFileInput();
        }
        this.URL = (_ref = window.URL) != null ? _ref : window.webkitURL;
        _ref1 = this.events;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          eventName = _ref1[_i];
          this.on(eventName, this.options[eventName]);
        }
        this.on("uploadprogress", (function(_this) {
          return function() {
            return _this.updateTotalUploadProgress();
          };
        })(this));
        this.on("removedfile", (function(_this) {
          return function() {
            return _this.updateTotalUploadProgress();
          };
        })(this));
        this.on("canceled", (function(_this) {
          return function(file) {
            return _this.emit("complete", file);
          };
        })(this));
        this.on("complete", (function(_this) {
          return function(file) {
            if (_this.getUploadingFiles().length === 0 && _this.getQueuedFiles().length === 0) {
              return setTimeout((function() {
                return _this.emit("queuecomplete");
              }), 0);
            }
          };
        })(this));
        noPropagation = function(e) {
          e.stopPropagation();
          if (e.preventDefault) {
            return e.preventDefault();
          } else {
            return e.returnValue = false;
          }
        };
        this.listeners = [
          {
            element: this.element,
            events: {
              "dragstart": (function(_this) {
                return function(e) {
                  return _this.emit("dragstart", e);
                };
              })(this),
              "dragenter": (function(_this) {
                return function(e) {
                  noPropagation(e);
                  return _this.emit("dragenter", e);
                };
              })(this),
              "dragover": (function(_this) {
                return function(e) {
                  var efct;
                  try {
                    efct = e.dataTransfer.effectAllowed;
                  } catch (_error) {}
                  e.dataTransfer.dropEffect = 'move' === efct || 'linkMove' === efct ? 'move' : 'copy';
                  noPropagation(e);
                  return _this.emit("dragover", e);
                };
              })(this),
              "dragleave": (function(_this) {
                return function(e) {
                  return _this.emit("dragleave", e);
                };
              })(this),
              "drop": (function(_this) {
                return function(e) {
                  noPropagation(e);
                  return _this.drop(e);
                };
              })(this),
              "dragend": (function(_this) {
                return function(e) {
                  return _this.emit("dragend", e);
                };
              })(this)
            }
          }
        ];
        this.clickableElements.forEach((function(_this) {
          return function(clickableElement) {
            return _this.listeners.push({
              element: clickableElement,
              events: {
                "click": function(evt) {
                  if ((clickableElement !== _this.element) || (evt.target === _this.element || Dropzone.elementInside(evt.target, _this.element.querySelector(".dz-message")))) {
                    return _this.hiddenFileInput.click();
                  }
                }
              }
            });
          };
        })(this));
        this.enable();
        return this.options.init.call(this);
      };
  
      Dropzone.prototype.destroy = function() {
        var _ref;
        this.disable();
        this.removeAllFiles(true);
        if ((_ref = this.hiddenFileInput) != null ? _ref.parentNode : void 0) {
          this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);
          this.hiddenFileInput = null;
        }
        delete this.element.dropzone;
        return Dropzone.instances.splice(Dropzone.instances.indexOf(this), 1);
      };
  
      Dropzone.prototype.updateTotalUploadProgress = function() {
        var activeFiles, file, totalBytes, totalBytesSent, totalUploadProgress, _i, _len, _ref;
        totalBytesSent = 0;
        totalBytes = 0;
        activeFiles = this.getActiveFiles();
        if (activeFiles.length) {
          _ref = this.getActiveFiles();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            file = _ref[_i];
            totalBytesSent += file.upload.bytesSent;
            totalBytes += file.upload.total;
          }
          totalUploadProgress = 100 * totalBytesSent / totalBytes;
        } else {
          totalUploadProgress = 100;
        }
        return this.emit("totaluploadprogress", totalUploadProgress, totalBytes, totalBytesSent);
      };
  
      Dropzone.prototype._getParamName = function(n) {
        if (typeof this.options.paramName === "function") {
          return this.options.paramName(n);
        } else {
          return "" + this.options.paramName + (this.options.uploadMultiple ? "[" + n + "]" : "");
        }
      };
  
      Dropzone.prototype.getFallbackForm = function() {
        var existingFallback, fields, fieldsString, form;
        if (existingFallback = this.getExistingFallback()) {
          return existingFallback;
        }
        fieldsString = "<div class=\"dz-fallback\">";
        if (this.options.dictFallbackText) {
          fieldsString += "<p>" + this.options.dictFallbackText + "</p>";
        }
        fieldsString += "<input type=\"file\" name=\"" + (this._getParamName(0)) + "\" " + (this.options.uploadMultiple ? 'multiple="multiple"' : void 0) + " /><input type=\"submit\" value=\"Upload!\"></div>";
        fields = Dropzone.createElement(fieldsString);
        if (this.element.tagName !== "FORM") {
          form = Dropzone.createElement("<form action=\"" + this.options.url + "\" enctype=\"multipart/form-data\" method=\"" + this.options.method + "\"></form>");
          form.appendChild(fields);
        } else {
          this.element.setAttribute("enctype", "multipart/form-data");
          this.element.setAttribute("method", this.options.method);
        }
        return form != null ? form : fields;
      };
  
      Dropzone.prototype.getExistingFallback = function() {
        var fallback, getFallback, tagName, _i, _len, _ref;
        getFallback = function(elements) {
          var el, _i, _len;
          for (_i = 0, _len = elements.length; _i < _len; _i++) {
            el = elements[_i];
            if (/(^| )fallback($| )/.test(el.className)) {
              return el;
            }
          }
        };
        _ref = ["div", "form"];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          tagName = _ref[_i];
          if (fallback = getFallback(this.element.getElementsByTagName(tagName))) {
            return fallback;
          }
        }
      };
  
      Dropzone.prototype.setupEventListeners = function() {
        var elementListeners, event, listener, _i, _len, _ref, _results;
        _ref = this.listeners;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          elementListeners = _ref[_i];
          _results.push((function() {
            var _ref1, _results1;
            _ref1 = elementListeners.events;
            _results1 = [];
            for (event in _ref1) {
              listener = _ref1[event];
              _results1.push(elementListeners.element.addEventListener(event, listener, false));
            }
            return _results1;
          })());
        }
        return _results;
      };
  
      Dropzone.prototype.removeEventListeners = function() {
        var elementListeners, event, listener, _i, _len, _ref, _results;
        _ref = this.listeners;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          elementListeners = _ref[_i];
          _results.push((function() {
            var _ref1, _results1;
            _ref1 = elementListeners.events;
            _results1 = [];
            for (event in _ref1) {
              listener = _ref1[event];
              _results1.push(elementListeners.element.removeEventListener(event, listener, false));
            }
            return _results1;
          })());
        }
        return _results;
      };
  
      Dropzone.prototype.disable = function() {
        var file, _i, _len, _ref, _results;
        this.clickableElements.forEach(function(element) {
          return element.classList.remove("dz-clickable");
        });
        this.removeEventListeners();
        _ref = this.files;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          _results.push(this.cancelUpload(file));
        }
        return _results;
      };
  
      Dropzone.prototype.enable = function() {
        this.clickableElements.forEach(function(element) {
          return element.classList.add("dz-clickable");
        });
        return this.setupEventListeners();
      };
  
      Dropzone.prototype.filesize = function(size) {
        var cutoff, i, selectedSize, selectedUnit, unit, units, _i, _len;
        units = ['TB', 'GB', 'MB', 'KB', 'b'];
        selectedSize = selectedUnit = null;
        for (i = _i = 0, _len = units.length; _i < _len; i = ++_i) {
          unit = units[i];
          cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;
          if (size >= cutoff) {
            selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);
            selectedUnit = unit;
            break;
          }
        }
        selectedSize = Math.round(10 * selectedSize) / 10;
        return "<strong>" + selectedSize + "</strong> " + selectedUnit;
      };
  
      Dropzone.prototype._updateMaxFilesReachedClass = function() {
        if ((this.options.maxFiles != null) && this.getAcceptedFiles().length >= this.options.maxFiles) {
          if (this.getAcceptedFiles().length === this.options.maxFiles) {
            this.emit('maxfilesreached', this.files);
          }
          return this.element.classList.add("dz-max-files-reached");
        } else {
          return this.element.classList.remove("dz-max-files-reached");
        }
      };
  
      Dropzone.prototype.drop = function(e) {
        var files, items;
        if (!e.dataTransfer) {
          return;
        }
        this.emit("drop", e);
        files = e.dataTransfer.files;
        if (files.length) {
          items = e.dataTransfer.items;
          if (items && items.length && (items[0].webkitGetAsEntry != null)) {
            this._addFilesFromItems(items);
          } else {
            this.handleFiles(files);
          }
        }
      };
  
      Dropzone.prototype.paste = function(e) {
        var items, _ref;
        if ((e != null ? (_ref = e.clipboardData) != null ? _ref.items : void 0 : void 0) == null) {
          return;
        }
        this.emit("paste", e);
        items = e.clipboardData.items;
        if (items.length) {
          return this._addFilesFromItems(items);
        }
      };
  
      Dropzone.prototype.handleFiles = function(files) {
        var file, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          _results.push(this.addFile(file));
        }
        return _results;
      };
  
      Dropzone.prototype._addFilesFromItems = function(items) {
        var entry, item, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          if ((item.webkitGetAsEntry != null) && (entry = item.webkitGetAsEntry())) {
            if (entry.isFile) {
              _results.push(this.addFile(item.getAsFile()));
            } else if (entry.isDirectory) {
              _results.push(this._addFilesFromDirectory(entry, entry.name));
            } else {
              _results.push(void 0);
            }
          } else if (item.getAsFile != null) {
            if ((item.kind == null) || item.kind === "file") {
              _results.push(this.addFile(item.getAsFile()));
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
  
      Dropzone.prototype._addFilesFromDirectory = function(directory, path) {
        var dirReader, entriesReader;
        dirReader = directory.createReader();
        entriesReader = (function(_this) {
          return function(entries) {
            var entry, _i, _len;
            for (_i = 0, _len = entries.length; _i < _len; _i++) {
              entry = entries[_i];
              if (entry.isFile) {
                entry.file(function(file) {
                  if (_this.options.ignoreHiddenFiles && file.name.substring(0, 1) === '.') {
                    return;
                  }
                  file.fullPath = "" + path + "/" + file.name;
                  return _this.addFile(file);
                });
              } else if (entry.isDirectory) {
                _this._addFilesFromDirectory(entry, "" + path + "/" + entry.name);
              }
            }
          };
        })(this);
        return dirReader.readEntries(entriesReader, function(error) {
          return typeof console !== "undefined" && console !== null ? typeof console.log === "function" ? console.log(error) : void 0 : void 0;
        });
      };
  
      Dropzone.prototype.accept = function(file, done) {
        if (file.size > this.options.maxFilesize * 1024 * 1024) {
          return done(this.options.dictFileTooBig.replace("{{filesize}}", Math.round(file.size / 1024 / 10.24) / 100).replace("{{maxFilesize}}", this.options.maxFilesize));
        } else if (!Dropzone.isValidFile(file, this.options.acceptedFiles)) {
          return done(this.options.dictInvalidFileType);
        } else if ((this.options.maxFiles != null) && this.getAcceptedFiles().length >= this.options.maxFiles) {
          done(this.options.dictMaxFilesExceeded.replace("{{maxFiles}}", this.options.maxFiles));
          return this.emit("maxfilesexceeded", file);
        } else {
          return this.options.accept.call(this, file, done);
        }
      };
  
      Dropzone.prototype.addFile = function(file) {
        file.upload = {
          progress: 0,
          total: file.size,
          bytesSent: 0
        };
        this.files.push(file);
        file.status = Dropzone.ADDED;
        this.emit("addedfile", file);
        this._enqueueThumbnail(file);
        return this.accept(file, (function(_this) {
          return function(error) {
            if (error) {
              file.accepted = false;
              _this._errorProcessing([file], error);
            } else {
              file.accepted = true;
              if (_this.options.autoQueue) {
                _this.enqueueFile(file);
              }
            }
            return _this._updateMaxFilesReachedClass();
          };
        })(this));
      };
  
      Dropzone.prototype.enqueueFiles = function(files) {
        var file, _i, _len;
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          this.enqueueFile(file);
        }
        return null;
      };
  
      Dropzone.prototype.enqueueFile = function(file) {
        if (file.status === Dropzone.ADDED && file.accepted === true) {
          file.status = Dropzone.QUEUED;
          if (this.options.autoProcessQueue) {
            return setTimeout(((function(_this) {
              return function() {
                return _this.processQueue();
              };
            })(this)), 0);
          }
        } else {
          throw new Error("This file can't be queued because it has already been processed or was rejected.");
        }
      };
  
      Dropzone.prototype._thumbnailQueue = [];
  
      Dropzone.prototype._processingThumbnail = false;
  
      Dropzone.prototype._enqueueThumbnail = function(file) {
        if (this.options.createImageThumbnails && file.type.match(/image.*/) && file.size <= this.options.maxThumbnailFilesize * 1024 * 1024) {
          this._thumbnailQueue.push(file);
          return setTimeout(((function(_this) {
            return function() {
              return _this._processThumbnailQueue();
            };
          })(this)), 0);
        }
      };
  
      Dropzone.prototype._processThumbnailQueue = function() {
        if (this._processingThumbnail || this._thumbnailQueue.length === 0) {
          return;
        }
        this._processingThumbnail = true;
        return this.createThumbnail(this._thumbnailQueue.shift(), (function(_this) {
          return function() {
            _this._processingThumbnail = false;
            return _this._processThumbnailQueue();
          };
        })(this));
      };
  
      Dropzone.prototype.removeFile = function(file) {
        if (file.status === Dropzone.UPLOADING) {
          this.cancelUpload(file);
        }
        this.files = without(this.files, file);
        this.emit("removedfile", file);
        if (this.files.length === 0) {
          return this.emit("reset");
        }
      };
  
      Dropzone.prototype.removeAllFiles = function(cancelIfNecessary) {
        var file, _i, _len, _ref;
        if (cancelIfNecessary == null) {
          cancelIfNecessary = false;
        }
        _ref = this.files.slice();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          if (file.status !== Dropzone.UPLOADING || cancelIfNecessary) {
            this.removeFile(file);
          }
        }
        return null;
      };
  
      Dropzone.prototype.createThumbnail = function(file, callback) {
        var fileReader;
        fileReader = new FileReader;
        fileReader.onload = (function(_this) {
          return function() {
            if (file.type === "image/svg+xml") {
              _this.emit("thumbnail", file, fileReader.result);
              if (callback != null) {
                callback();
              }
              return;
            }
            return _this.createThumbnailFromUrl(file, fileReader.result, callback);
          };
        })(this);
        return fileReader.readAsDataURL(file);
      };
  
      Dropzone.prototype.createThumbnailFromUrl = function(file, imageUrl, callback) {
        var img;
        img = document.createElement("img");
        img.onload = (function(_this) {
          return function() {
            var canvas, ctx, resizeInfo, thumbnail, _ref, _ref1, _ref2, _ref3;
            file.width = img.width;
            file.height = img.height;
            resizeInfo = _this.options.resize.call(_this, file);
            if (resizeInfo.trgWidth == null) {
              resizeInfo.trgWidth = resizeInfo.optWidth;
            }
            if (resizeInfo.trgHeight == null) {
              resizeInfo.trgHeight = resizeInfo.optHeight;
            }
            canvas = document.createElement("canvas");
            ctx = canvas.getContext("2d");
            canvas.width = resizeInfo.trgWidth;
            canvas.height = resizeInfo.trgHeight;
            drawImageIOSFix(ctx, img, (_ref = resizeInfo.srcX) != null ? _ref : 0, (_ref1 = resizeInfo.srcY) != null ? _ref1 : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, (_ref2 = resizeInfo.trgX) != null ? _ref2 : 0, (_ref3 = resizeInfo.trgY) != null ? _ref3 : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);
            thumbnail = canvas.toDataURL("image/png");
            _this.emit("thumbnail", file, thumbnail);
            if (callback != null) {
              return callback();
            }
          };
        })(this);
        if (callback != null) {
          img.onerror = callback;
        }
        return img.src = imageUrl;
      };
  
      Dropzone.prototype.processQueue = function() {
        var i, parallelUploads, processingLength, queuedFiles;
        parallelUploads = this.options.parallelUploads;
        processingLength = this.getUploadingFiles().length;
        i = processingLength;
        if (processingLength >= parallelUploads) {
          return;
        }
        queuedFiles = this.getQueuedFiles();
        if (!(queuedFiles.length > 0)) {
          return;
        }
        if (this.options.uploadMultiple) {
          return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));
        } else {
          while (i < parallelUploads) {
            if (!queuedFiles.length) {
              return;
            }
            this.processFile(queuedFiles.shift());
            i++;
          }
        }
      };
  
      Dropzone.prototype.processFile = function(file) {
        return this.processFiles([file]);
      };
  
      Dropzone.prototype.processFiles = function(files) {
        var file, _i, _len;
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          file.processing = true;
          file.status = Dropzone.UPLOADING;
          this.emit("processing", file);
        }
        if (this.options.uploadMultiple) {
          this.emit("processingmultiple", files);
        }
        return this.uploadFiles(files);
      };
  
      Dropzone.prototype._getFilesWithXhr = function(xhr) {
        var file, files;
        return files = (function() {
          var _i, _len, _ref, _results;
          _ref = this.files;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            file = _ref[_i];
            if (file.xhr === xhr) {
              _results.push(file);
            }
          }
          return _results;
        }).call(this);
      };
  
      Dropzone.prototype.cancelUpload = function(file) {
        var groupedFile, groupedFiles, _i, _j, _len, _len1, _ref;
        if (file.status === Dropzone.UPLOADING) {
          groupedFiles = this._getFilesWithXhr(file.xhr);
          for (_i = 0, _len = groupedFiles.length; _i < _len; _i++) {
            groupedFile = groupedFiles[_i];
            groupedFile.status = Dropzone.CANCELED;
          }
          file.xhr.abort();
          for (_j = 0, _len1 = groupedFiles.length; _j < _len1; _j++) {
            groupedFile = groupedFiles[_j];
            this.emit("canceled", groupedFile);
          }
          if (this.options.uploadMultiple) {
            this.emit("canceledmultiple", groupedFiles);
          }
        } else if ((_ref = file.status) === Dropzone.ADDED || _ref === Dropzone.QUEUED) {
          file.status = Dropzone.CANCELED;
          this.emit("canceled", file);
          if (this.options.uploadMultiple) {
            this.emit("canceledmultiple", [file]);
          }
        }
        if (this.options.autoProcessQueue) {
          return this.processQueue();
        }
      };
  
      resolveOption = function() {
        var args, option;
        option = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (typeof option === 'function') {
          return option.apply(this, args);
        }
        return option;
      };
  
      Dropzone.prototype.uploadFile = function(file) {
        return this.uploadFiles([file]);
      };
  
      Dropzone.prototype.uploadFiles = function(files) {
        var file, formData, handleError, headerName, headerValue, headers, i, input, inputName, inputType, key, method, option, progressObj, response, updateProgress, url, value, xhr, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        xhr = new XMLHttpRequest();
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          file.xhr = xhr;
        }
        method = resolveOption(this.options.method, files);
        url = resolveOption(this.options.url, files);
        xhr.open(method, url, true);
        xhr.withCredentials = !!this.options.withCredentials;
        response = null;
        handleError = (function(_this) {
          return function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
              file = files[_j];
              _results.push(_this._errorProcessing(files, response || _this.options.dictResponseError.replace("{{statusCode}}", xhr.status), xhr));
            }
            return _results;
          };
        })(this);
        updateProgress = (function(_this) {
          return function(e) {
            var allFilesFinished, progress, _j, _k, _l, _len1, _len2, _len3, _results;
            if (e != null) {
              progress = 100 * e.loaded / e.total;
              for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
                file = files[_j];
                file.upload = {
                  progress: progress,
                  total: e.total,
                  bytesSent: e.loaded
                };
              }
            } else {
              allFilesFinished = true;
              progress = 100;
              for (_k = 0, _len2 = files.length; _k < _len2; _k++) {
                file = files[_k];
                if (!(file.upload.progress === 100 && file.upload.bytesSent === file.upload.total)) {
                  allFilesFinished = false;
                }
                file.upload.progress = progress;
                file.upload.bytesSent = file.upload.total;
              }
              if (allFilesFinished) {
                return;
              }
            }
            _results = [];
            for (_l = 0, _len3 = files.length; _l < _len3; _l++) {
              file = files[_l];
              _results.push(_this.emit("uploadprogress", file, progress, file.upload.bytesSent));
            }
            return _results;
          };
        })(this);
        xhr.onload = (function(_this) {
          return function(e) {
            var _ref;
            if (files[0].status === Dropzone.CANCELED) {
              return;
            }
            if (xhr.readyState !== 4) {
              return;
            }
            response = xhr.responseText;
            if (xhr.getResponseHeader("content-type") && ~xhr.getResponseHeader("content-type").indexOf("application/json")) {
              try {
                response = JSON.parse(response);
              } catch (_error) {
                e = _error;
                response = "Invalid JSON response from server.";
              }
            }
            updateProgress();
            if (!((200 <= (_ref = xhr.status) && _ref < 300))) {
              return handleError();
            } else {
              return _this._finished(files, response, e);
            }
          };
        })(this);
        xhr.onerror = (function(_this) {
          return function() {
            if (files[0].status === Dropzone.CANCELED) {
              return;
            }
            return handleError();
          };
        })(this);
        progressObj = (_ref = xhr.upload) != null ? _ref : xhr;
        progressObj.onprogress = updateProgress;
        headers = {
          "Accept": "application/json",
          "Cache-Control": "no-cache",
          "X-Requested-With": "XMLHttpRequest"
        };
        if (this.options.headers) {
          extend(headers, this.options.headers);
        }
        for (headerName in headers) {
          headerValue = headers[headerName];
          xhr.setRequestHeader(headerName, headerValue);
        }
        formData = new FormData();
        if (this.options.params) {
          _ref1 = this.options.params;
          for (key in _ref1) {
            value = _ref1[key];
            formData.append(key, value);
          }
        }
        for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
          file = files[_j];
          this.emit("sending", file, xhr, formData);
        }
        if (this.options.uploadMultiple) {
          this.emit("sendingmultiple", files, xhr, formData);
        }
        if (this.element.tagName === "FORM") {
          _ref2 = this.element.querySelectorAll("input, textarea, select, button");
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            input = _ref2[_k];
            inputName = input.getAttribute("name");
            inputType = input.getAttribute("type");
            if (input.tagName === "SELECT" && input.hasAttribute("multiple")) {
              _ref3 = input.options;
              for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
                option = _ref3[_l];
                if (option.selected) {
                  formData.append(inputName, option.value);
                }
              }
            } else if (!inputType || ((_ref4 = inputType.toLowerCase()) !== "checkbox" && _ref4 !== "radio") || input.checked) {
              formData.append(inputName, input.value);
            }
          }
        }
        for (i = _m = 0, _ref5 = files.length - 1; 0 <= _ref5 ? _m <= _ref5 : _m >= _ref5; i = 0 <= _ref5 ? ++_m : --_m) {
          formData.append(this._getParamName(i), files[i], files[i].name);
        }
        return xhr.send(formData);
      };
  
      Dropzone.prototype._finished = function(files, responseText, e) {
        var file, _i, _len;
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          file.status = Dropzone.SUCCESS;
          this.emit("success", file, responseText, e);
          this.emit("complete", file);
        }
        if (this.options.uploadMultiple) {
          this.emit("successmultiple", files, responseText, e);
          this.emit("completemultiple", files);
        }
        if (this.options.autoProcessQueue) {
          return this.processQueue();
        }
      };
  
      Dropzone.prototype._errorProcessing = function(files, message, xhr) {
        var file, _i, _len;
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          file.status = Dropzone.ERROR;
          this.emit("error", file, message, xhr);
          this.emit("complete", file);
        }
        if (this.options.uploadMultiple) {
          this.emit("errormultiple", files, message, xhr);
          this.emit("completemultiple", files);
        }
        if (this.options.autoProcessQueue) {
          return this.processQueue();
        }
      };
  
      return Dropzone;
  
    })(Emitter);
  
    Dropzone.version = "4.0.1";
  
    Dropzone.options = {};
  
    Dropzone.optionsForElement = function(element) {
      if (element.getAttribute("id")) {
        return Dropzone.options[camelize(element.getAttribute("id"))];
      } else {
        return void 0;
      }
    };
  
    Dropzone.instances = [];
  
    Dropzone.forElement = function(element) {
      if (typeof element === "string") {
        element = document.querySelector(element);
      }
      if ((element != null ? element.dropzone : void 0) == null) {
        throw new Error("No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.");
      }
      return element.dropzone;
    };
  
    Dropzone.autoDiscover = true;
  
    Dropzone.discover = function() {
      var checkElements, dropzone, dropzones, _i, _len, _results;
      if (document.querySelectorAll) {
        dropzones = document.querySelectorAll(".dropzone");
      } else {
        dropzones = [];
        checkElements = function(elements) {
          var el, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = elements.length; _i < _len; _i++) {
            el = elements[_i];
            if (/(^| )dropzone($| )/.test(el.className)) {
              _results.push(dropzones.push(el));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };
        checkElements(document.getElementsByTagName("div"));
        checkElements(document.getElementsByTagName("form"));
      }
      _results = [];
      for (_i = 0, _len = dropzones.length; _i < _len; _i++) {
        dropzone = dropzones[_i];
        if (Dropzone.optionsForElement(dropzone) !== false) {
          _results.push(new Dropzone(dropzone));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
  
    Dropzone.blacklistedBrowsers = [/opera.*Macintosh.*version\/12/i];
  
    Dropzone.isBrowserSupported = function() {
      var capableBrowser, regex, _i, _len, _ref;
      capableBrowser = true;
      if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {
        if (!("classList" in document.createElement("a"))) {
          capableBrowser = false;
        } else {
          _ref = Dropzone.blacklistedBrowsers;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            regex = _ref[_i];
            if (regex.test(navigator.userAgent)) {
              capableBrowser = false;
              continue;
            }
          }
        }
      } else {
        capableBrowser = false;
      }
      return capableBrowser;
    };
  
    without = function(list, rejectedItem) {
      var item, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        item = list[_i];
        if (item !== rejectedItem) {
          _results.push(item);
        }
      }
      return _results;
    };
  
    camelize = function(str) {
      return str.replace(/[\-_](\w)/g, function(match) {
        return match.charAt(1).toUpperCase();
      });
    };
  
    Dropzone.createElement = function(string) {
      var div;
      div = document.createElement("div");
      div.innerHTML = string;
      return div.childNodes[0];
    };
  
    Dropzone.elementInside = function(element, container) {
      if (element === container) {
        return true;
      }
      while (element = element.parentNode) {
        if (element === container) {
          return true;
        }
      }
      return false;
    };
  
    Dropzone.getElement = function(el, name) {
      var element;
      if (typeof el === "string") {
        element = document.querySelector(el);
      } else if (el.nodeType != null) {
        element = el;
      }
      if (element == null) {
        throw new Error("Invalid `" + name + "` option provided. Please provide a CSS selector or a plain HTML element.");
      }
      return element;
    };
  
    Dropzone.getElements = function(els, name) {
      var e, el, elements, _i, _j, _len, _len1, _ref;
      if (els instanceof Array) {
        elements = [];
        try {
          for (_i = 0, _len = els.length; _i < _len; _i++) {
            el = els[_i];
            elements.push(this.getElement(el, name));
          }
        } catch (_error) {
          e = _error;
          elements = null;
        }
      } else if (typeof els === "string") {
        elements = [];
        _ref = document.querySelectorAll(els);
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          el = _ref[_j];
          elements.push(el);
        }
      } else if (els.nodeType != null) {
        elements = [els];
      }
      if (!((elements != null) && elements.length)) {
        throw new Error("Invalid `" + name + "` option provided. Please provide a CSS selector, a plain HTML element or a list of those.");
      }
      return elements;
    };
  
    Dropzone.confirm = function(question, accepted, rejected) {
      if (window.confirm(question)) {
        return accepted();
      } else if (rejected != null) {
        return rejected();
      }
    };
  
    Dropzone.isValidFile = function(file, acceptedFiles) {
      var baseMimeType, mimeType, validType, _i, _len;
      if (!acceptedFiles) {
        return true;
      }
      acceptedFiles = acceptedFiles.split(",");
      mimeType = file.type;
      baseMimeType = mimeType.replace(/\/.*$/, "");
      for (_i = 0, _len = acceptedFiles.length; _i < _len; _i++) {
        validType = acceptedFiles[_i];
        validType = validType.trim();
        if (validType.charAt(0) === ".") {
          if (file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.length - validType.length) !== -1) {
            return true;
          }
        } else if (/\/\*$/.test(validType)) {
          if (baseMimeType === validType.replace(/\/.*$/, "")) {
            return true;
          }
        } else {
          if (mimeType === validType) {
            return true;
          }
        }
      }
      return false;
    };
  
    if (typeof jQuery !== "undefined" && jQuery !== null) {
      jQuery.fn.dropzone = function(options) {
        return this.each(function() {
          return new Dropzone(this, options);
        });
      };
    }
  
    if (typeof module !== "undefined" && module !== null) {
      module.exports = Dropzone;
    } else {
      window.Dropzone = Dropzone;
    }
  
    Dropzone.ADDED = "added";
  
    Dropzone.QUEUED = "queued";
  
    Dropzone.ACCEPTED = Dropzone.QUEUED;
  
    Dropzone.UPLOADING = "uploading";
  
    Dropzone.PROCESSING = Dropzone.UPLOADING;
  
    Dropzone.CANCELED = "canceled";
  
    Dropzone.ERROR = "error";
  
    Dropzone.SUCCESS = "success";
  
  
    /*
    
    Bugfix for iOS 6 and 7
    Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios
    based on the work of https://github.com/stomita/ios-imagefile-megapixel
     */
  
    detectVerticalSquash = function(img) {
      var alpha, canvas, ctx, data, ey, ih, iw, py, ratio, sy;
      iw = img.naturalWidth;
      ih = img.naturalHeight;
      canvas = document.createElement("canvas");
      canvas.width = 1;
      canvas.height = ih;
      ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0);
      data = ctx.getImageData(0, 0, 1, ih).data;
      sy = 0;
      ey = ih;
      py = ih;
      while (py > sy) {
        alpha = data[(py - 1) * 4 + 3];
        if (alpha === 0) {
          ey = py;
        } else {
          sy = py;
        }
        py = (ey + sy) >> 1;
      }
      ratio = py / ih;
      if (ratio === 0) {
        return 1;
      } else {
        return ratio;
      }
    };
  
    drawImageIOSFix = function(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {
      var vertSquashRatio;
      vertSquashRatio = detectVerticalSquash(img);
      return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);
    };
  
  
    /*
     * contentloaded.js
     *
     * Author: Diego Perini (diego.perini at gmail.com)
     * Summary: cross-browser wrapper for DOMContentLoaded
     * Updated: 20101020
     * License: MIT
     * Version: 1.2
     *
     * URL:
     * http://javascript.nwbox.com/ContentLoaded/
     * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE
     */
  
    contentLoaded = function(win, fn) {
      var add, doc, done, init, poll, pre, rem, root, top;
      done = false;
      top = true;
      doc = win.document;
      root = doc.documentElement;
      add = (doc.addEventListener ? "addEventListener" : "attachEvent");
      rem = (doc.addEventListener ? "removeEventListener" : "detachEvent");
      pre = (doc.addEventListener ? "" : "on");
      init = function(e) {
        if (e.type === "readystatechange" && doc.readyState !== "complete") {
          return;
        }
        (e.type === "load" ? win : doc)[rem](pre + e.type, init, false);
        if (!done && (done = true)) {
          return fn.call(win, e.type || e);
        }
      };
      poll = function() {
        var e;
        try {
          root.doScroll("left");
        } catch (_error) {
          e = _error;
          setTimeout(poll, 50);
          return;
        }
        return init("poll");
      };
      if (doc.readyState !== "complete") {
        if (doc.createEventObject && root.doScroll) {
          try {
            top = !win.frameElement;
          } catch (_error) {}
          if (top) {
            poll();
          }
        }
        doc[add](pre + "DOMContentLoaded", init, false);
        doc[add](pre + "readystatechange", init, false);
        return win[add](pre + "load", init, false);
      }
    };
  
    Dropzone._autoDiscoverFunction = function() {
      if (Dropzone.autoDiscover) {
        return Dropzone.discover();
      }
    };
  
    contentLoaded(window, Dropzone._autoDiscoverFunction);
  
  }).call(this);
  /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))
  
  /***/ }),
  
  /***/ "./vendor/assets/javascripts/filestyle.js":
  /*!************************************************!*\
    !*** ./vendor/assets/javascripts/filestyle.js ***!
    \************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  /* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {/*
   * bootstrap-filestyle
   * doc: http://dev.tudosobreweb.com.br/bootstrap-filestyle/
   * github: https://github.com/markusslima/bootstrap-filestyle
   *
   * Copyright (c) 2014 Markus Vinicius da Silva Lima
   * Version 1.1.0
   * Licensed under the MIT license.
   */
  (function ($) {
      "use strict";
  
      var Filestyle = function (element, options) {
          this.options = options;
          this.$elementFilestyle = [];
          this.$element = $(element);
      };
  
      Filestyle.prototype = {
          clear: function () {
              this.$element.val('');
              this.$elementFilestyle.find(':text').val('');
          },
  
          destroy: function () {
              this.$element
                  .removeAttr('style')
                  .removeData('filestyle')
                  .val('');
              this.$elementFilestyle.remove();
          },
          
          disabled: function (value) {
            if (value === true) {
              if (!this.options.disabled) {
                this.$element
                      .attr('disabled', 'true');
                  this.$elementFilestyle.find('label').attr('disabled', 'true');
                  this.options.disabled = true;
              }
            } else if (value === false) {
              if (this.options.disabled) {
                  this.$element
                      .removeAttr('disabled');
                  this.$elementFilestyle.find('label').removeAttr('disabled');
                  this.options.disabled = false;
              }
              } else {
                  return this.options.disabled;
              }
          },
          
          buttonBefore: function (value) {
            if (value === true) {
              if (!this.options.buttonBefore) {
                this.options.buttonBefore = true;
                if (this.options.input) {
                  this.$elementFilestyle.remove();
                  this.constructor();
                  this.pushNameFiles();
                }
              }
            } else if (value === false) {
              if (this.options.buttonBefore) {
                  this.options.buttonBefore = false;
                  if (this.options.input) {
                  this.$elementFilestyle.remove();
                  this.constructor();
                  this.pushNameFiles();
                }
              }
              } else {
                  return this.options.buttonBefore;
              }
          },
  
          icon: function (value) {
              if (value === true) {
                  if (!this.options.icon) {
                      this.options.icon = true;
                      this.$elementFilestyle.find('label').prepend(this.htmlIcon());
                  }
              } else if (value === false) {
                  if (this.options.icon) {
                      this.options.icon = false;
                      this.$elementFilestyle.find('.glyphicon').remove();
                  }
              } else {
                  return this.options.icon;
              }
          },
  
          input: function (value) {
              if (value === true) {
                  if (!this.options.input) {
                      this.options.input = true;
                      
                      if (this.options.buttonBefore) {
                        this.$elementFilestyle.append(this.htmlInput());
                      } else {
                        this.$elementFilestyle.prepend(this.htmlInput());
                      }
                      
                      this.$elementFilestyle.find('.badge').remove();
  
                      var content = '',
                          files = [];
                      if (this.$element[0].files === undefined) {
                          files[0] = {'name': this.$element[0].value};
                      } else {
                          files = this.$element[0].files;
                      }
  
                      for (var i = 0; i < files.length; i++) {
                          content += files[i].name.split("\\").pop() + ', ';
                      }
                      if (content !== '') {
                          this.$elementFilestyle.find(':text').val(content.replace(/\, $/g, ''));
                      }
                      
                      this.$elementFilestyle.find('.group-span-filestyle').addClass('input-group-btn');
                  }
              } else if (value === false) {
                  if (this.options.input) {
                      this.options.input = false;
                      this.$elementFilestyle.find(':text').remove();
                      var files = [];
                    if (this.$element[0].files === undefined) {
                        files[0] = {'name': this.$element[0].value};
                    } else {
                        files = this.$element[0].files;
                    }
                    if (files.length > 0) {
                      this.$elementFilestyle.find('label').append(' <span class="badge">'+files.length+'</span>');
                    }
                    this.$elementFilestyle.find('.group-span-filestyle').removeClass('input-group-btn');
                  }
              } else {
                  return this.options.input;
              }
          },
          
          size: function (value) {
            if (value !== undefined) {
                  var btn = this.$elementFilestyle.find('label'),
                      input = this.$elementFilestyle.find('input');
                      
                  btn.removeClass('btn-lg btn-sm');
                  input.removeClass('input-lg input-sm');
                  if (value != 'nr') {
                    btn.addClass('btn-'+value);
                    input.addClass('input-'+value);
                  }
              } else {
                  return this.options.size;
              }
          },
  
          buttonText: function (value) {
              if (value !== undefined) {
                  this.options.buttonText = value;
                  this.$elementFilestyle.find('label span').html(this.options.buttonText);
              } else {
                  return this.options.buttonText;
              }
          },
  
          buttonName: function (value) {
              if (value !== undefined) {
                  this.options.buttonName = value;
                  this.$elementFilestyle.find('label').attr({'class': 'btn '+this.options.buttonName});
              } else {
                  return this.options.buttonName;
              }
          },
  
          iconName: function (value) {
              if (value !== undefined) {
                  this.$elementFilestyle.find('.glyphicon').attr({'class': '.glyphicon ' + this.options.iconName});
              } else {
                  return this.options.iconName;
              }
          },
  
          htmlIcon: function () {
              if (this.options.icon) {
                  return '<span class="glyphicon '+this.options.iconName+'"></span> ';
              } else {
                  return '';
              }
          },
  
          htmlInput: function () {
              if (this.options.input) {
                  return '<input type="text" class="form-control '+(this.options.size=='nr'?'':'input-'+this.options.size)+'" disabled> ';
              } else {
                  return '';
              }
          },
          
          // puts the name of the input files
          pushNameFiles: function () {
            var content = '',
                files = [];
              if (this.$element[0].files === undefined) {
                  files[0] = {'name': this.$element.value};
              } else {
                  files = this.$element[0].files;
              }
              
              for (var i = 0; i < files.length; i++) {
                  content += files[i].name.split("\\").pop() + ', ';
              }
  
              if (content !== '') {
                  this.$elementFilestyle.find(':text').val(content.replace(/\, $/g, ''));
              } else {
                this.$elementFilestyle.find(':text').val('');
              }
          },
  
          constructor: function () {
              var _self = this,
                  html = '',
                  id = this.$element.attr('id'),
                  files = [],
                  btn = '',
                  $label,
                  $labelFocusableContainer;
  
              if (id === '' || !id) {
                  id = 'filestyle-'+$('.bootstrap-filestyle').length;
                  this.$element.attr({'id': id});
              }
              
              btn = '<span class="group-span-filestyle '+(this.options.input ? 'input-group-btn' : '') +'">'+
                    '<label for="'+id+'" class="btn '+this.options.buttonName+' '+(this.options.size=='nr'?'':'btn-'+this.options.size)+'" '+(this.options.disabled?'disabled="true"':'')+'>'+
                            this.htmlIcon()+this.options.buttonText+
                        '</label>'+
                    '</span>';
  
              html = this.options.buttonBefore ? btn+this.htmlInput() : this.htmlInput()+btn;
  
              this.$elementFilestyle = $('<div class="bootstrap-filestyle input-group">'+html+'</div>');
  
              $label = this.$elementFilestyle.find('label');
              $labelFocusableContainer = $label.parent();
  
              $labelFocusableContainer
                  .attr('tabindex', "0")
                  .keypress(function(e) {
                      if (e.keyCode === 13 || e.charCode === 32) {
                          $label.click();
                      }
                  });
  
              // hidding input file and add filestyle
              this.$element
                  .css({'position':'absolute','clip':'rect(0,0,0,0)'})
                  .attr('tabindex', "-1")
                  .after(this.$elementFilestyle);
                  
              if (this.options.disabled) {
                this.$element.attr('disabled', 'true');
              }
  
              // Getting input file value
              this.$element.change(function () {
                  var content = '';
                  if (this.files === undefined) {
                      files[0] = {'name': this.value};
                  } else {
                      files = this.files;
                  }
  
                  for (var i = 0; i < files.length; i++) {
                      content += files[i].name.split("\\").pop() + ', ';
                  }
  
                  if (content !== '') {
                      _self.$elementFilestyle.find(':text').val(content.replace(/\, $/g, ''));
                  } else {
                    _self.$elementFilestyle.find(':text').val('');
                  }
                  
                  if (_self.options.input == false) {
                    if (_self.$elementFilestyle.find('.badge').length == 0) {
                      _self.$elementFilestyle.find('label').append(' <span class="badge">'+files.length+'</span>');
                    } else if (files.length == 0) {
                      _self.$elementFilestyle.find('.badge').remove();
                    } else {
                      _self.$elementFilestyle.find('.badge').html(files.length);
                    }
                  } else {
                    _self.$elementFilestyle.find('.badge').remove();
                  }
              });
  
              // Check if browser is Firefox
              if (window.navigator.userAgent.search(/firefox/i) > -1) {
                  // Simulating choose file for firefox
                  this.$elementFilestyle.find('label').click(function () {
                      _self.$element.click();
                      return false;
                  });
              }
          }
      };
  
      var old = $.fn.filestyle;
  
      $.fn.filestyle = function (option, value) {
          var get = '',
              element = this.each(function () {
                  if ($(this).attr('type') === 'file') {
                      var $this = $(this),
                          data = $this.data('filestyle'),
                          options = $.extend({}, $.fn.filestyle.defaults, option, typeof option === 'object' && option);
  
                      if (!data) {
                          $this.data('filestyle', (data = new Filestyle(this, options)));
                          data.constructor();
                      }
  
                      if (typeof option === 'string') {
                          get = data[option](value);
                      }
                  }
              });
  
          if (typeof get !== undefined) {
              return get;
          } else {
              return element;
          }
      };
  
      $.fn.filestyle.defaults = {
          'buttonText': 'Choose file',
          'iconName': 'glyphicon-folder-open',
          'buttonName': 'btn-default',
          'size': 'nr',
          'input': true,
          'icon': true,
          'buttonBefore': false,
          'disabled': false
      };
  
      $.fn.filestyle.noConflict = function () {
          $.fn.filestyle = old;
          return this;
      };
  
      // Data attributes register
      $(function() {
          $('.filestyle').each(function () {
              var $this = $(this),
                  options = {
                      
                      'input': $this.attr('data-input') === 'false' ? false : true,
                      'icon': $this.attr('data-icon') === 'false' ? false : true,
                      'buttonBefore': $this.attr('data-buttonBefore') === 'true' ? true : false,
                      'disabled': $this.attr('data-disabled') === 'true' ? true : false,
                      'size': $this.attr('data-size'),
                      'buttonText': $this.attr('data-buttonText'),
                      'buttonName': $this.attr('data-buttonName'),
                      'iconName': $this.attr('data-iconName')
                  };
      
              $this.filestyle(options);
          });
      });
  })(__webpack_provided_window_dot_jQuery);
  /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))
  
  /***/ }),
  
  /***/ "./vendor/assets/javascripts/jquery.tipsy.js":
  /*!***************************************************!*\
    !*** ./vendor/assets/javascripts/jquery.tipsy.js ***!
    \***************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  /* WEBPACK VAR INJECTION */(function(jQuery) {// tipsy, facebook style tooltips for jquery with fancy fading
  // version 1.0.0a
  // (c) 2008-2010 jason frame [jason@onehackoranother.com] and modificated by Sergio Alvarez @saleiva
  // released under the MIT license
  //
  //  Changes:
  //  April 27 2016: fixed problem with element size.
  //  June 3 2013: Added the custom class before the calc of the position.
  
  (function($) {
  
    var MOVE_OFFSET = 6;
  
    function maybeCall(thing, ctx, argument) {
      return (typeof thing == 'function') ? (thing.call(ctx, argument)) : thing;
    };
  
    function isElementInDOM(ele) {
      while (ele = ele.parentNode) {
        if (ele == document) return true;
      }
      return false;
    };
  
    function Tipsy(element, options) {
      this.$element = $(element);
      this.options = options;
      this.enabled = true;
      this.fixTitle();
    };
  
    Tipsy.prototype = {
      show: function() {
        var title = this.getTitle();
        if (title && this.enabled) {
          var $tip = this.tip();
  
          $tip.find('.tipsy-inner')[this.options.html ? 'html' : 'text'](title);
              $tip[0].className = 'tipsy'; // reset classname in case of dynamic gravity
              $tip.remove().css({top: 0, left: 0, visibility: 'hidden', display: 'block'}).prependTo(document.body);
  
              // Modified so we can use custom class names
              if (this.options.className) {
                $tip.addClass(maybeCall(this.options.className, this.$element[0]));
              }
  
              // Modified
              var pos = $.extend({}, this.$element.offset(), {
                width: this.$element[0].getBoundingClientRect().width,
                height: this.$element[0].getBoundingClientRect().height
              });
  
              var actualWidth = $tip[0].offsetWidth,
              actualHeight = $tip[0].offsetHeight,
              gravity = maybeCall(this.options.gravity, this.$element[0], $tip[0]);
  
              var tp;
              switch (gravity.charAt(0)) {
                case 'n':
                tp = {top: pos.top + pos.height + this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2};
                mo = {top: parseInt(pos.top + pos.height + this.options.offset + MOVE_OFFSET), opacity: this.options.opacity};
                break;
                case 's':
                tp = {top: pos.top - actualHeight - this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2};
                mo = {top: parseInt(pos.top - actualHeight - this.options.offset - MOVE_OFFSET), opacity: this.options.opacity};
                break;
                case 'e':
                tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth - this.options.offset};
                mo = {left: parseInt(pos.left - actualWidth - this.options.offset - MOVE_OFFSET), opacity: this.options.opacity};
                break;
                case 'w':
                tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width + this.options.offset};
                mo = {left: parseInt(pos.left + pos.width + this.options.offset + MOVE_OFFSET), opacity: this.options.opacity};
                break;
              }
  
              if (gravity.length == 2) {
                if (gravity.charAt(1) == 'w') {
                  tp.left = pos.left + pos.width / 2 - 15;
                } else {
                  tp.left = pos.left + pos.width / 2 - actualWidth + 15;
                }
              }
  
              $tip.css(tp).addClass('tipsy-' + gravity);
              $tip.find('.tipsy-arrow')[0].className = 'tipsy-arrow tipsy-arrow-' + gravity.charAt(0);
  
              if (this.options.fade) {
                $tip.stop().css({opacity: 0, display: 'block', visibility: 'visible'}).animate(mo, 200);
              } else {
                $tip.css({visibility: 'visible', opacity: this.options.opacity});
              }
            }
          },
  
          hide: function() {
  
            gravity = maybeCall(this.options.gravity, this.$element[0]);
  
            switch (gravity.charAt(0)) {
              case 'n':
              mo = {top: parseInt(this.tip().css("top")) + MOVE_OFFSET, opacity: 0};
              break;
              case 's':
              mo = {top: parseInt(this.tip().css("top")) - MOVE_OFFSET, opacity: 0};
              break;
              case 'e':
              mo = {left: parseInt(this.tip().css("left")) - MOVE_OFFSET, opacity: 0};
              break;
              case 'w':
              mo = {left: parseInt(this.tip().css("left")) + MOVE_OFFSET, opacity: 0};
              break;
            }
  
            if (this.options.fade) {
              this.tip().stop().animate(mo, 200, function(){$(this).remove();});
            } else {
              this.tip().remove();
            }
          },
  
          fixTitle: function() {
            var $e = this.$element;
            if ($e.attr('title') || typeof($e.attr('original-title')) != 'string') {
              $e.attr('original-title', $e.attr('title') || '').removeAttr('title');
            }
          },
  
          getTitle: function() {
            var title, $e = this.$element, o = this.options;
            this.fixTitle();
            var title, o = this.options;
            if (typeof o.title == 'string') {
              title = $e.attr(o.title == 'title' ? 'original-title' : o.title);
            } else if (typeof o.title == 'function') {
              title = o.title.call($e[0]);
            }
            title = ('' + title).replace(/(^\s*|\s*$)/, "");
            return title || o.fallback;
          },
  
          tip: function() {
            if (!this.$tip) {
              this.$tip = $('<div class="tipsy"></div>').html('<div class="tipsy-arrow"></div><div class="tipsy-inner"></div>');
              this.$tip.data('tipsy-pointee', this.$element[0]);
            }
            return this.$tip;
          },
  
          validate: function() {
            if (!this.$element[0].parentNode) {
              this.hide();
              this.$element = null;
              this.options = null;
            }
          },
  
          remove: function() { this.enabled = false; this.$tip && this.$tip.remove(); },
          enable: function() { this.enabled = true; },
          disable: function() { this.enabled = false; },
          toggleEnabled: function() { this.enabled = !this.enabled; }
        };
  
        $.fn.tipsy = function(options) {
  
          if (options === true) {
            return this.data('tipsy');
          } else if (typeof options == 'string') {
            var tipsy = this.data('tipsy');
            if (tipsy) tipsy[options]();
            return this;
          }
  
          options = $.extend({}, $.fn.tipsy.defaults, options);
  
          function get(ele) {
            var tipsy = $.data(ele, 'tipsy');
            if (!tipsy) {
              tipsy = new Tipsy(ele, $.fn.tipsy.elementOptions(ele, options));
              $.data(ele, 'tipsy', tipsy);
            }
            return tipsy;
          }
  
          function enter() {
            var tipsy = get(this);
            tipsy.hoverState = 'in';
            if (options.delayIn == 0) {
              tipsy.show();
            } else {
              tipsy.fixTitle();
              setTimeout(function() { if (tipsy.hoverState == 'in') tipsy.show(); }, options.delayIn);
            }
          };
  
          function leave() {
            var tipsy = get(this);
            tipsy.hoverState = 'out';
            if (options.delayOut == 0) {
              tipsy.hide();
            } else {
              setTimeout(function() { if (tipsy.hoverState == 'out') tipsy.hide(); }, options.delayOut);
            }
          };
  
          if (!options.live) this.each(function() { get(this); });
  
          if (options.trigger != 'manual') {
            var binder   = options.live ? 'live' : 'bind',
            eventIn  = options.trigger == 'hover' ? 'mouseenter' : 'focus',
            eventOut = options.trigger == 'hover' ? 'mouseleave' : 'blur';
            this[binder](eventIn, enter)[binder](eventOut, leave);
          }
  
          return this;
  
        };
  
        $.fn.tipsy.defaults = {
          className: null,
          delayIn: 0,
          delayOut: 0,
          fade: false,
          fallback: '',
          gravity: 'n',
          html: false,
          live: false,
          offset: 0,
          opacity: 0.8,
          title: 'title',
          trigger: 'hover'
        };
  
        $.fn.tipsy.revalidate = function() {
          $('.tipsy').each(function() {
            var pointee = $.data(this, 'tipsy-pointee');
            if (!pointee || !isElementInDOM(pointee)) {
              $(this).remove();
            }
          });
        };
  
      // Overwrite this method to provide options on a per-element basis.
      // For example, you could store the gravity in a 'tipsy-gravity' attribute:
      // return $.extend({}, options, {gravity: $(ele).attr('tipsy-gravity') || 'n' });
      // (remember - do not modify 'options' in place!)
      $.fn.tipsy.elementOptions = function(ele, options) {
        return $.metadata ? $.extend({}, options, $(ele).metadata()) : options;
      };
  
      $.fn.tipsy.autoNS = function() {
        return $(this).offset().top > ($(document).scrollTop() + $(window).height() / 2) ? 's' : 'n';
      };
  
      $.fn.tipsy.autoWE = function() {
        return $(this).offset().left > ($(document).scrollLeft() + $(window).width() / 2) ? 'e' : 'w';
      };
  
      /**
       * yields a closure of the supplied parameters, producing a function that takes
       * no arguments and is suitable for use as an autogravity function like so:
       *
       * @param margin (int) - distance from the viewable region edge that an
       *        element should be before setting its tooltip's gravity to be away
       *        from that edge.
       * @param prefer (string, e.g. 'n', 'sw', 'w') - the direction to prefer
       *        if there are no viewable region edges effecting the tooltip's
       *        gravity. It will try to vary from this minimally, for example,
       *        if 'sw' is preferred and an element is near the right viewable
       *        region edge, but not the top edge, it will set the gravity for
       *        that element's tooltip to be 'se', preserving the southern
       *        component.
       */
       $.fn.tipsy.autoBounds = function(margin, prefer) {
        return function() {
         var dir = {ns: prefer[0], ew: (prefer.length > 1 ? prefer[1] : false)},
         boundTop = $(document).scrollTop() + margin,
         boundLeft = $(document).scrollLeft() + margin,
         $this = $(this);
  
         if ($this.offset().top < boundTop) dir.ns = 'n';
         if ($this.offset().left < boundLeft) dir.ew = 'w';
         if ($(window).width() + $(document).scrollLeft() - $this.offset().left < margin) dir.ew = 'e';
         if ($(window).height() + $(document).scrollTop() - $this.offset().top < margin) dir.ns = 's';
  
         return dir.ns + (dir.ew ? dir.ew : '');
       }
     };
  
   })(jQuery);
  
  /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))
  
  /***/ }),
  
  /***/ "./vendor/assets/javascripts/markdown.js":
  /*!***********************************************!*\
    !*** ./vendor/assets/javascripts/markdown.js ***!
    \***********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // Released under MIT license
  // Copyright (c) 2009-2010 Dominic Baggott
  // Copyright (c) 2009-2010 Ash Berlin
  // Copyright (c) 2011 Christoph Dorn <christoph@christophdorn.com> (http://www.christophdorn.com)
  
  /*jshint browser:true, devel:true */
  
  (function( expose ) {
  
  /**
   *  class Markdown
   *
   *  Markdown processing in Javascript done right. We have very particular views
   *  on what constitutes 'right' which include:
   *
   *  - produces well-formed HTML (this means that em and strong nesting is
   *    important)
   *
   *  - has an intermediate representation to allow processing of parsed data (We
   *    in fact have two, both as [JsonML]: a markdown tree and an HTML tree).
   *
   *  - is easily extensible to add new dialects without having to rewrite the
   *    entire parsing mechanics
   *
   *  - has a good test suite
   *
   *  This implementation fulfills all of these (except that the test suite could
   *  do with expanding to automatically run all the fixtures from other Markdown
   *  implementations.)
   *
   *  ##### Intermediate Representation
   *
   *  *TODO* Talk about this :) Its JsonML, but document the node names we use.
   *
   *  [JsonML]: http://jsonml.org/ "JSON Markup Language"
   **/
  var Markdown = expose.Markdown = function(dialect) {
    switch (typeof dialect) {
      case "undefined":
        this.dialect = Markdown.dialects.Gruber;
        break;
      case "object":
        this.dialect = dialect;
        break;
      default:
        if ( dialect in Markdown.dialects ) {
          this.dialect = Markdown.dialects[dialect];
        }
        else {
          throw new Error("Unknown Markdown dialect '" + String(dialect) + "'");
        }
        break;
    }
    this.em_state = [];
    this.strong_state = [];
    this.debug_indent = "";
  };
  
  /**
   *  parse( markdown, [dialect] ) -> JsonML
   *  - markdown (String): markdown string to parse
   *  - dialect (String | Dialect): the dialect to use, defaults to gruber
   *
   *  Parse `markdown` and return a markdown document as a Markdown.JsonML tree.
   **/
  expose.parse = function( source, dialect ) {
    // dialect will default if undefined
    var md = new Markdown( dialect );
    return md.toTree( source );
  };
  
  /**
   *  toHTML( markdown, [dialect]  ) -> String
   *  toHTML( md_tree ) -> String
   *  - markdown (String): markdown string to parse
   *  - md_tree (Markdown.JsonML): parsed markdown tree
   *
   *  Take markdown (either as a string or as a JsonML tree) and run it through
   *  [[toHTMLTree]] then turn it into a well-formated HTML fragment.
   **/
  expose.toHTML = function toHTML( source , dialect , options ) {
    var input = expose.toHTMLTree( source , dialect , options );
  
    return expose.renderJsonML( input );
  };
  
  /**
   *  toHTMLTree( markdown, [dialect] ) -> JsonML
   *  toHTMLTree( md_tree ) -> JsonML
   *  - markdown (String): markdown string to parse
   *  - dialect (String | Dialect): the dialect to use, defaults to gruber
   *  - md_tree (Markdown.JsonML): parsed markdown tree
   *
   *  Turn markdown into HTML, represented as a JsonML tree. If a string is given
   *  to this function, it is first parsed into a markdown tree by calling
   *  [[parse]].
   **/
  expose.toHTMLTree = function toHTMLTree( input, dialect , options ) {
    // convert string input to an MD tree
    if ( typeof input ==="string" ) input = this.parse( input, dialect );
  
    // Now convert the MD tree to an HTML tree
  
    // remove references from the tree
    var attrs = extract_attr( input ),
        refs = {};
  
    if ( attrs && attrs.references ) {
      refs = attrs.references;
    }
  
    var html = convert_tree_to_html( input, refs , options );
    merge_text_nodes( html );
    return html;
  };
  
  // For Spidermonkey based engines
  function mk_block_toSource() {
    return "Markdown.mk_block( " +
            uneval(this.toString()) +
            ", " +
            uneval(this.trailing) +
            ", " +
            uneval(this.lineNumber) +
            " )";
  }
  
  // node
  function mk_block_inspect() {
    var util = __webpack_require__(/*! util */ "./node_modules/node-libs-browser/node_modules/util/util.js");
    return "Markdown.mk_block( " +
            util.inspect(this.toString()) +
            ", " +
            util.inspect(this.trailing) +
            ", " +
            util.inspect(this.lineNumber) +
            " )";
  
  }
  
  var mk_block = Markdown.mk_block = function(block, trail, line) {
    // Be helpful for default case in tests.
    if ( arguments.length == 1 ) trail = "\n\n";
  
    var s = new String(block);
    s.trailing = trail;
    // To make it clear its not just a string
    s.inspect = mk_block_inspect;
    s.toSource = mk_block_toSource;
  
    if ( line != undefined )
      s.lineNumber = line;
  
    return s;
  };
  
  function count_lines( str ) {
    var n = 0, i = -1;
    while ( ( i = str.indexOf("\n", i + 1) ) !== -1 ) n++;
    return n;
  }
  
  // Internal - split source into rough blocks
  Markdown.prototype.split_blocks = function splitBlocks( input, startLine ) {
    input = input.replace(/(\r\n|\n|\r)/g, "\n");
    // [\s\S] matches _anything_ (newline or space)
    // [^] is equivalent but doesn't work in IEs.
    var re = /([\s\S]+?)($|\n#|\n(?:\s*\n|$)+)/g,
        blocks = [],
        m;
  
    var line_no = 1;
  
    if ( ( m = /^(\s*\n)/.exec(input) ) != null ) {
      // skip (but count) leading blank lines
      line_no += count_lines( m[0] );
      re.lastIndex = m[0].length;
    }
  
    while ( ( m = re.exec(input) ) !== null ) {
      if (m[2] == "\n#") {
        m[2] = "\n";
        re.lastIndex--;
      }
      blocks.push( mk_block( m[1], m[2], line_no ) );
      line_no += count_lines( m[0] );
    }
  
    return blocks;
  };
  
  /**
   *  Markdown#processBlock( block, next ) -> undefined | [ JsonML, ... ]
   *  - block (String): the block to process
   *  - next (Array): the following blocks
   *
   * Process `block` and return an array of JsonML nodes representing `block`.
   *
   * It does this by asking each block level function in the dialect to process
   * the block until one can. Succesful handling is indicated by returning an
   * array (with zero or more JsonML nodes), failure by a false value.
   *
   * Blocks handlers are responsible for calling [[Markdown#processInline]]
   * themselves as appropriate.
   *
   * If the blocks were split incorrectly or adjacent blocks need collapsing you
   * can adjust `next` in place using shift/splice etc.
   *
   * If any of this default behaviour is not right for the dialect, you can
   * define a `__call__` method on the dialect that will get invoked to handle
   * the block processing.
   */
  Markdown.prototype.processBlock = function processBlock( block, next ) {
    var cbs = this.dialect.block,
        ord = cbs.__order__;
  
    if ( "__call__" in cbs ) {
      return cbs.__call__.call(this, block, next);
    }
  
    for ( var i = 0; i < ord.length; i++ ) {
      //D:this.debug( "Testing", ord[i] );
      var res = cbs[ ord[i] ].call( this, block, next );
      if ( res ) {
        //D:this.debug("  matched");
        if ( !isArray(res) || ( res.length > 0 && !( isArray(res[0]) ) ) )
          this.debug(ord[i], "didn't return a proper array");
        //D:this.debug( "" );
        return res;
      }
    }
  
    // Uhoh! no match! Should we throw an error?
    return [];
  };
  
  Markdown.prototype.processInline = function processInline( block ) {
    return this.dialect.inline.__call__.call( this, String( block ) );
  };
  
  /**
   *  Markdown#toTree( source ) -> JsonML
   *  - source (String): markdown source to parse
   *
   *  Parse `source` into a JsonML tree representing the markdown document.
   **/
  // custom_tree means set this.tree to `custom_tree` and restore old value on return
  Markdown.prototype.toTree = function toTree( source, custom_root ) {
    var blocks = source instanceof Array ? source : this.split_blocks( source );
  
    // Make tree a member variable so its easier to mess with in extensions
    var old_tree = this.tree;
    try {
      this.tree = custom_root || this.tree || [ "markdown" ];
  
      blocks:
      while ( blocks.length ) {
        var b = this.processBlock( blocks.shift(), blocks );
  
        // Reference blocks and the like won't return any content
        if ( !b.length ) continue blocks;
  
        this.tree.push.apply( this.tree, b );
      }
      return this.tree;
    }
    finally {
      if ( custom_root ) {
        this.tree = old_tree;
      }
    }
  };
  
  // Noop by default
  Markdown.prototype.debug = function () {
    var args = Array.prototype.slice.call( arguments);
    args.unshift(this.debug_indent);
    if ( typeof print !== "undefined" )
        print.apply( print, args );
    if ( typeof console !== "undefined" && typeof console.log !== "undefined" )
        console.log.apply( null, args );
  }
  
  Markdown.prototype.loop_re_over_block = function( re, block, cb ) {
    // Dont use /g regexps with this
    var m,
        b = block.valueOf();
  
    while ( b.length && (m = re.exec(b) ) != null ) {
      b = b.substr( m[0].length );
      cb.call(this, m);
    }
    return b;
  };
  
  /**
   * Markdown.dialects
   *
   * Namespace of built-in dialects.
   **/
  Markdown.dialects = {};
  
  /**
   * Markdown.dialects.Gruber
   *
   * The default dialect that follows the rules set out by John Gruber's
   * markdown.pl as closely as possible. Well actually we follow the behaviour of
   * that script which in some places is not exactly what the syntax web page
   * says.
   **/
  Markdown.dialects.Gruber = {
    block: {
      atxHeader: function atxHeader( block, next ) {
        var m = block.match( /^(#{1,6})\s*(.*?)\s*#*\s*(?:\n|$)/ );
  
        if ( !m ) return undefined;
  
        var header = [ "header", { level: m[ 1 ].length } ];
        Array.prototype.push.apply(header, this.processInline(m[ 2 ]));
  
        if ( m[0].length < block.length )
          next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );
  
        return [ header ];
      },
  
      setextHeader: function setextHeader( block, next ) {
        var m = block.match( /^(.*)\n([-=])\2\2+(?:\n|$)/ );
  
        if ( !m ) return undefined;
  
        var level = ( m[ 2 ] === "=" ) ? 1 : 2;
        var header = [ "header", { level : level }, m[ 1 ] ];
  
        if ( m[0].length < block.length )
          next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );
  
        return [ header ];
      },
  
      code: function code( block, next ) {
        // |    Foo
        // |bar
        // should be a code block followed by a paragraph. Fun
        //
        // There might also be adjacent code block to merge.
  
        var ret = [],
            re = /^(?: {0,3}\t| {4})(.*)\n?/,
            lines;
  
        // 4 spaces + content
        if ( !block.match( re ) ) return undefined;
  
        block_search:
        do {
          // Now pull out the rest of the lines
          var b = this.loop_re_over_block(
                    re, block.valueOf(), function( m ) { ret.push( m[1] ); } );
  
          if ( b.length ) {
            // Case alluded to in first comment. push it back on as a new block
            next.unshift( mk_block(b, block.trailing) );
            break block_search;
          }
          else if ( next.length ) {
            // Check the next block - it might be code too
            if ( !next[0].match( re ) ) break block_search;
  
            // Pull how how many blanks lines follow - minus two to account for .join
            ret.push ( block.trailing.replace(/[^\n]/g, "").substring(2) );
  
            block = next.shift();
          }
          else {
            break block_search;
          }
        } while ( true );
  
        return [ [ "code_block", ret.join("\n") ] ];
      },
  
      horizRule: function horizRule( block, next ) {
        // this needs to find any hr in the block to handle abutting blocks
        var m = block.match( /^(?:([\s\S]*?)\n)?[ \t]*([-_*])(?:[ \t]*\2){2,}[ \t]*(?:\n([\s\S]*))?$/ );
  
        if ( !m ) {
          return undefined;
        }
  
        var jsonml = [ [ "hr" ] ];
  
        // if there's a leading abutting block, process it
        if ( m[ 1 ] ) {
          jsonml.unshift.apply( jsonml, this.processBlock( m[ 1 ], [] ) );
        }
  
        // if there's a trailing abutting block, stick it into next
        if ( m[ 3 ] ) {
          next.unshift( mk_block( m[ 3 ] ) );
        }
  
        return jsonml;
      },
  
      // There are two types of lists. Tight and loose. Tight lists have no whitespace
      // between the items (and result in text just in the <li>) and loose lists,
      // which have an empty line between list items, resulting in (one or more)
      // paragraphs inside the <li>.
      //
      // There are all sorts weird edge cases about the original markdown.pl's
      // handling of lists:
      //
      // * Nested lists are supposed to be indented by four chars per level. But
      //   if they aren't, you can get a nested list by indenting by less than
      //   four so long as the indent doesn't match an indent of an existing list
      //   item in the 'nest stack'.
      //
      // * The type of the list (bullet or number) is controlled just by the
      //    first item at the indent. Subsequent changes are ignored unless they
      //    are for nested lists
      //
      lists: (function( ) {
        // Use a closure to hide a few variables.
        var any_list = "[*+-]|\\d+\\.",
            bullet_list = /[*+-]/,
            number_list = /\d+\./,
            // Capture leading indent as it matters for determining nested lists.
            is_list_re = new RegExp( "^( {0,3})(" + any_list + ")[ \t]+" ),
            indent_re = "(?: {0,3}\\t| {4})";
  
        // TODO: Cache this regexp for certain depths.
        // Create a regexp suitable for matching an li for a given stack depth
        function regex_for_depth( depth ) {
  
          return new RegExp(
            // m[1] = indent, m[2] = list_type
            "(?:^(" + indent_re + "{0," + depth + "} {0,3})(" + any_list + ")\\s+)|" +
            // m[3] = cont
            "(^" + indent_re + "{0," + (depth-1) + "}[ ]{0,4})"
          );
        }
        function expand_tab( input ) {
          return input.replace( / {0,3}\t/g, "    " );
        }
  
        // Add inline content `inline` to `li`. inline comes from processInline
        // so is an array of content
        function add(li, loose, inline, nl) {
          if ( loose ) {
            li.push( [ "para" ].concat(inline) );
            return;
          }
          // Hmmm, should this be any block level element or just paras?
          var add_to = li[li.length -1] instanceof Array && li[li.length - 1][0] == "para"
                     ? li[li.length -1]
                     : li;
  
          // If there is already some content in this list, add the new line in
          if ( nl && li.length > 1 ) inline.unshift(nl);
  
          for ( var i = 0; i < inline.length; i++ ) {
            var what = inline[i],
                is_str = typeof what == "string";
            if ( is_str && add_to.length > 1 && typeof add_to[add_to.length-1] == "string" ) {
              add_to[ add_to.length-1 ] += what;
            }
            else {
              add_to.push( what );
            }
          }
        }
  
        // contained means have an indent greater than the current one. On
        // *every* line in the block
        function get_contained_blocks( depth, blocks ) {
  
          var re = new RegExp( "^(" + indent_re + "{" + depth + "}.*?\\n?)*$" ),
              replace = new RegExp("^" + indent_re + "{" + depth + "}", "gm"),
              ret = [];
  
          while ( blocks.length > 0 ) {
            if ( re.exec( blocks[0] ) ) {
              var b = blocks.shift(),
                  // Now remove that indent
                  x = b.replace( replace, "");
  
              ret.push( mk_block( x, b.trailing, b.lineNumber ) );
            }
            else {
              break;
            }
          }
          return ret;
        }
  
        // passed to stack.forEach to turn list items up the stack into paras
        function paragraphify(s, i, stack) {
          var list = s.list;
          var last_li = list[list.length-1];
  
          if ( last_li[1] instanceof Array && last_li[1][0] == "para" ) {
            return;
          }
          if ( i + 1 == stack.length ) {
            // Last stack frame
            // Keep the same array, but replace the contents
            last_li.push( ["para"].concat( last_li.splice(1, last_li.length - 1) ) );
          }
          else {
            var sublist = last_li.pop();
            last_li.push( ["para"].concat( last_li.splice(1, last_li.length - 1) ), sublist );
          }
        }
  
        // The matcher function
        return function( block, next ) {
          var m = block.match( is_list_re );
          if ( !m ) return undefined;
  
          function make_list( m ) {
            var list = bullet_list.exec( m[2] )
                     ? ["bulletlist"]
                     : ["numberlist"];
  
            stack.push( { list: list, indent: m[1] } );
            return list;
          }
  
  
          var stack = [], // Stack of lists for nesting.
              list = make_list( m ),
              last_li,
              loose = false,
              ret = [ stack[0].list ],
              i;
  
          // Loop to search over block looking for inner block elements and loose lists
          loose_search:
          while ( true ) {
            // Split into lines preserving new lines at end of line
            var lines = block.split( /(?=\n)/ );
  
            // We have to grab all lines for a li and call processInline on them
            // once as there are some inline things that can span lines.
            var li_accumulate = "";
  
            // Loop over the lines in this block looking for tight lists.
            tight_search:
            for ( var line_no = 0; line_no < lines.length; line_no++ ) {
              var nl = "",
                  l = lines[line_no].replace(/^\n/, function(n) { nl = n; return ""; });
  
              // TODO: really should cache this
              var line_re = regex_for_depth( stack.length );
  
              m = l.match( line_re );
              //print( "line:", uneval(l), "\nline match:", uneval(m) );
  
              // We have a list item
              if ( m[1] !== undefined ) {
                // Process the previous list item, if any
                if ( li_accumulate.length ) {
                  add( last_li, loose, this.processInline( li_accumulate ), nl );
                  // Loose mode will have been dealt with. Reset it
                  loose = false;
                  li_accumulate = "";
                }
  
                m[1] = expand_tab( m[1] );
                var wanted_depth = Math.floor(m[1].length/4)+1;
                //print( "want:", wanted_depth, "stack:", stack.length);
                if ( wanted_depth > stack.length ) {
                  // Deep enough for a nested list outright
                  //print ( "new nested list" );
                  list = make_list( m );
                  last_li.push( list );
                  last_li = list[1] = [ "listitem" ];
                }
                else {
                  // We aren't deep enough to be strictly a new level. This is
                  // where Md.pl goes nuts. If the indent matches a level in the
                  // stack, put it there, else put it one deeper then the
                  // wanted_depth deserves.
                  var found = false;
                  for ( i = 0; i < stack.length; i++ ) {
                    if ( stack[ i ].indent != m[1] ) continue;
                    list = stack[ i ].list;
                    stack.splice( i+1, stack.length - (i+1) );
                    found = true;
                    break;
                  }
  
                  if (!found) {
                    //print("not found. l:", uneval(l));
                    wanted_depth++;
                    if ( wanted_depth <= stack.length ) {
                      stack.splice(wanted_depth, stack.length - wanted_depth);
                      //print("Desired depth now", wanted_depth, "stack:", stack.length);
                      list = stack[wanted_depth-1].list;
                      //print("list:", uneval(list) );
                    }
                    else {
                      //print ("made new stack for messy indent");
                      list = make_list(m);
                      last_li.push(list);
                    }
                  }
  
                  //print( uneval(list), "last", list === stack[stack.length-1].list );
                  last_li = [ "listitem" ];
                  list.push(last_li);
                } // end depth of shenegains
                nl = "";
              }
  
              // Add content
              if ( l.length > m[0].length ) {
                li_accumulate += nl + l.substr( m[0].length );
              }
            } // tight_search
  
            if ( li_accumulate.length ) {
              add( last_li, loose, this.processInline( li_accumulate ), nl );
              // Loose mode will have been dealt with. Reset it
              loose = false;
              li_accumulate = "";
            }
  
            // Look at the next block - we might have a loose list. Or an extra
            // paragraph for the current li
            var contained = get_contained_blocks( stack.length, next );
  
            // Deal with code blocks or properly nested lists
            if ( contained.length > 0 ) {
              // Make sure all listitems up the stack are paragraphs
              forEach( stack, paragraphify, this);
  
              last_li.push.apply( last_li, this.toTree( contained, [] ) );
            }
  
            var next_block = next[0] && next[0].valueOf() || "";
  
            if ( next_block.match(is_list_re) || next_block.match( /^ / ) ) {
              block = next.shift();
  
              // Check for an HR following a list: features/lists/hr_abutting
              var hr = this.dialect.block.horizRule( block, next );
  
              if ( hr ) {
                ret.push.apply(ret, hr);
                break;
              }
  
              // Make sure all listitems up the stack are paragraphs
              forEach( stack, paragraphify, this);
  
              loose = true;
              continue loose_search;
            }
            break;
          } // loose_search
  
          return ret;
        };
      })(),
  
      blockquote: function blockquote( block, next ) {
        if ( !block.match( /^>/m ) )
          return undefined;
  
        var jsonml = [];
  
        // separate out the leading abutting block, if any. I.e. in this case:
        //
        //  a
        //  > b
        //
        if ( block[ 0 ] != ">" ) {
          var lines = block.split( /\n/ ),
              prev = [],
              line_no = block.lineNumber;
  
          // keep shifting lines until you find a crotchet
          while ( lines.length && lines[ 0 ][ 0 ] != ">" ) {
              prev.push( lines.shift() );
              line_no++;
          }
  
          var abutting = mk_block( prev.join( "\n" ), "\n", block.lineNumber );
          jsonml.push.apply( jsonml, this.processBlock( abutting, [] ) );
          // reassemble new block of just block quotes!
          block = mk_block( lines.join( "\n" ), block.trailing, line_no );
        }
  
  
        // if the next block is also a blockquote merge it in
        while ( next.length && next[ 0 ][ 0 ] == ">" ) {
          var b = next.shift();
          block = mk_block( block + block.trailing + b, b.trailing, block.lineNumber );
        }
  
        // Strip off the leading "> " and re-process as a block.
        var input = block.replace( /^> ?/gm, "" ),
            old_tree = this.tree,
            processedBlock = this.toTree( input, [ "blockquote" ] ),
            attr = extract_attr( processedBlock );
  
        // If any link references were found get rid of them
        if ( attr && attr.references ) {
          delete attr.references;
          // And then remove the attribute object if it's empty
          if ( isEmpty( attr ) ) {
            processedBlock.splice( 1, 1 );
          }
        }
  
        jsonml.push( processedBlock );
        return jsonml;
      },
  
      referenceDefn: function referenceDefn( block, next) {
        var re = /^\s*\[(.*?)\]:\s*(\S+)(?:\s+(?:(['"])(.*?)\3|\((.*?)\)))?\n?/;
        // interesting matches are [ , ref_id, url, , title, title ]
  
        if ( !block.match(re) )
          return undefined;
  
        // make an attribute node if it doesn't exist
        if ( !extract_attr( this.tree ) ) {
          this.tree.splice( 1, 0, {} );
        }
  
        var attrs = extract_attr( this.tree );
  
        // make a references hash if it doesn't exist
        if ( attrs.references === undefined ) {
          attrs.references = {};
        }
  
        var b = this.loop_re_over_block(re, block, function( m ) {
  
          if ( m[2] && m[2][0] == "<" && m[2][m[2].length-1] == ">" )
            m[2] = m[2].substring( 1, m[2].length - 1 );
  
          var ref = attrs.references[ m[1].toLowerCase() ] = {
            href: m[2]
          };
  
          if ( m[4] !== undefined )
            ref.title = m[4];
          else if ( m[5] !== undefined )
            ref.title = m[5];
  
        } );
  
        if ( b.length )
          next.unshift( mk_block( b, block.trailing ) );
  
        return [];
      },
  
      para: function para( block, next ) {
        // everything's a para!
        return [ ["para"].concat( this.processInline( block ) ) ];
      }
    }
  };
  
  Markdown.dialects.Gruber.inline = {
  
      __oneElement__: function oneElement( text, patterns_or_re, previous_nodes ) {
        var m,
            res,
            lastIndex = 0;
  
        patterns_or_re = patterns_or_re || this.dialect.inline.__patterns__;
        var re = new RegExp( "([\\s\\S]*?)(" + (patterns_or_re.source || patterns_or_re) + ")" );
  
        m = re.exec( text );
        if (!m) {
          // Just boring text
          return [ text.length, text ];
        }
        else if ( m[1] ) {
          // Some un-interesting text matched. Return that first
          return [ m[1].length, m[1] ];
        }
  
        var res;
        if ( m[2] in this.dialect.inline ) {
          res = this.dialect.inline[ m[2] ].call(
                    this,
                    text.substr( m.index ), m, previous_nodes || [] );
        }
        // Default for now to make dev easier. just slurp special and output it.
        res = res || [ m[2].length, m[2] ];
        return res;
      },
  
      __call__: function inline( text, patterns ) {
  
        var out = [],
            res;
  
        function add(x) {
          //D:self.debug("  adding output", uneval(x));
          if ( typeof x == "string" && typeof out[out.length-1] == "string" )
            out[ out.length-1 ] += x;
          else
            out.push(x);
        }
  
        while ( text.length > 0 ) {
          res = this.dialect.inline.__oneElement__.call(this, text, patterns, out );
          text = text.substr( res.shift() );
          forEach(res, add )
        }
  
        return out;
      },
  
      // These characters are intersting elsewhere, so have rules for them so that
      // chunks of plain text blocks don't include them
      "]": function () {},
      "}": function () {},
  
      __escape__ : /^\\[\\`\*_{}\[\]()#\+.!\-]/,
  
      "\\": function escaped( text ) {
        // [ length of input processed, node/children to add... ]
        // Only esacape: \ ` * _ { } [ ] ( ) # * + - . !
        if ( this.dialect.inline.__escape__.exec( text ) )
          return [ 2, text.charAt( 1 ) ];
        else
          // Not an esacpe
          return [ 1, "\\" ];
      },
  
      "![": function image( text ) {
  
        // Unlike images, alt text is plain text only. no other elements are
        // allowed in there
  
        // ![Alt text](/path/to/img.jpg "Optional title")
        //      1          2            3       4         <--- captures
        var m = text.match( /^!\[(.*?)\][ \t]*\([ \t]*([^")]*?)(?:[ \t]+(["'])(.*?)\3)?[ \t]*\)/ );
  
        if ( m ) {
          if ( m[2] && m[2][0] == "<" && m[2][m[2].length-1] == ">" )
            m[2] = m[2].substring( 1, m[2].length - 1 );
  
          m[2] = this.dialect.inline.__call__.call( this, m[2], /\\/ )[0];
  
          var attrs = { alt: m[1], href: m[2] || "" };
          if ( m[4] !== undefined)
            attrs.title = m[4];
  
          return [ m[0].length, [ "img", attrs ] ];
        }
  
        // ![Alt text][id]
        m = text.match( /^!\[(.*?)\][ \t]*\[(.*?)\]/ );
  
        if ( m ) {
          // We can't check if the reference is known here as it likely wont be
          // found till after. Check it in md tree->hmtl tree conversion
          return [ m[0].length, [ "img_ref", { alt: m[1], ref: m[2].toLowerCase(), original: m[0] } ] ];
        }
  
        // Just consume the '!['
        return [ 2, "![" ];
      },
  
      "[": function link( text ) {
  
        var orig = String(text);
        // Inline content is possible inside `link text`
        var res = Markdown.DialectHelpers.inline_until_char.call( this, text.substr(1), "]" );
  
        // No closing ']' found. Just consume the [
        if ( !res ) return [ 1, "[" ];
  
        var consumed = 1 + res[ 0 ],
            children = res[ 1 ],
            link,
            attrs;
  
        // At this point the first [...] has been parsed. See what follows to find
        // out which kind of link we are (reference or direct url)
        text = text.substr( consumed );
  
        // [link text](/path/to/img.jpg "Optional title")
        //                 1            2       3         <--- captures
        // This will capture up to the last paren in the block. We then pull
        // back based on if there a matching ones in the url
        //    ([here](/url/(test))
        // The parens have to be balanced
        var m = text.match( /^\s*\([ \t]*([^"']*)(?:[ \t]+(["'])(.*?)\2)?[ \t]*\)/ );
        if ( m ) {
          var url = m[1];
          consumed += m[0].length;
  
          if ( url && url[0] == "<" && url[url.length-1] == ">" )
            url = url.substring( 1, url.length - 1 );
  
          // If there is a title we don't have to worry about parens in the url
          if ( !m[3] ) {
            var open_parens = 1; // One open that isn't in the capture
            for ( var len = 0; len < url.length; len++ ) {
              switch ( url[len] ) {
              case "(":
                open_parens++;
                break;
              case ")":
                if ( --open_parens == 0) {
                  consumed -= url.length - len;
                  url = url.substring(0, len);
                }
                break;
              }
            }
          }
  
          // Process escapes only
          url = this.dialect.inline.__call__.call( this, url, /\\/ )[0];
  
          attrs = { href: url || "" };
          if ( m[3] !== undefined)
            attrs.title = m[3];
  
          link = [ "link", attrs ].concat( children );
          return [ consumed, link ];
        }
  
        // [Alt text][id]
        // [Alt text] [id]
        m = text.match( /^\s*\[(.*?)\]/ );
  
        if ( m ) {
  
          consumed += m[ 0 ].length;
  
          // [links][] uses links as its reference
          attrs = { ref: ( m[ 1 ] || String(children) ).toLowerCase(),  original: orig.substr( 0, consumed ) };
  
          link = [ "link_ref", attrs ].concat( children );
  
          // We can't check if the reference is known here as it likely wont be
          // found till after. Check it in md tree->hmtl tree conversion.
          // Store the original so that conversion can revert if the ref isn't found.
          return [ consumed, link ];
        }
  
        // [id]
        // Only if id is plain (no formatting.)
        if ( children.length == 1 && typeof children[0] == "string" ) {
  
          attrs = { ref: children[0].toLowerCase(),  original: orig.substr( 0, consumed ) };
          link = [ "link_ref", attrs, children[0] ];
          return [ consumed, link ];
        }
  
        // Just consume the "["
        return [ 1, "[" ];
      },
  
  
      "<": function autoLink( text ) {
        var m;
  
        if ( ( m = text.match( /^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\.[a-zA-Z]+))>/ ) ) != null ) {
          if ( m[3] ) {
            return [ m[0].length, [ "link", { href: "mailto:" + m[3] }, m[3] ] ];
  
          }
          else if ( m[2] == "mailto" ) {
            return [ m[0].length, [ "link", { href: m[1] }, m[1].substr("mailto:".length ) ] ];
          }
          else
            return [ m[0].length, [ "link", { href: m[1] }, m[1] ] ];
        }
  
        return [ 1, "<" ];
      },
  
      "`": function inlineCode( text ) {
        // Inline code block. as many backticks as you like to start it
        // Always skip over the opening ticks.
        var m = text.match( /(`+)(([\s\S]*?)\1)/ );
  
        if ( m && m[2] )
          return [ m[1].length + m[2].length, [ "inlinecode", m[3] ] ];
        else {
          // TODO: No matching end code found - warn!
          return [ 1, "`" ];
        }
      },
  
      "  \n": function lineBreak( text ) {
        return [ 3, [ "linebreak" ] ];
      }
  
  };
  
  // Meta Helper/generator method for em and strong handling
  function strong_em( tag, md ) {
  
    var state_slot = tag + "_state",
        other_slot = tag == "strong" ? "em_state" : "strong_state";
  
    function CloseTag(len) {
      this.len_after = len;
      this.name = "close_" + md;
    }
  
    return function ( text, orig_match ) {
  
      if ( this[state_slot][0] == md ) {
        // Most recent em is of this type
        //D:this.debug("closing", md);
        this[state_slot].shift();
  
        // "Consume" everything to go back to the recrusion in the else-block below
        return[ text.length, new CloseTag(text.length-md.length) ];
      }
      else {
        // Store a clone of the em/strong states
        var other = this[other_slot].slice(),
            state = this[state_slot].slice();
  
        this[state_slot].unshift(md);
  
        //D:this.debug_indent += "  ";
  
        // Recurse
        var res = this.processInline( text.substr( md.length ) );
        //D:this.debug_indent = this.debug_indent.substr(2);
  
        var last = res[res.length - 1];
  
        //D:this.debug("processInline from", tag + ": ", uneval( res ) );
  
        var check = this[state_slot].shift();
        if ( last instanceof CloseTag ) {
          res.pop();
          // We matched! Huzzah.
          var consumed = text.length - last.len_after;
          return [ consumed, [ tag ].concat(res) ];
        }
        else {
          // Restore the state of the other kind. We might have mistakenly closed it.
          this[other_slot] = other;
          this[state_slot] = state;
  
          // We can't reuse the processed result as it could have wrong parsing contexts in it.
          return [ md.length, md ];
        }
      }
    }; // End returned function
  }
  
  Markdown.dialects.Gruber.inline["**"] = strong_em("strong", "**");
  Markdown.dialects.Gruber.inline["__"] = strong_em("strong", "__");
  Markdown.dialects.Gruber.inline["*"]  = strong_em("em", "*");
  Markdown.dialects.Gruber.inline["_"]  = strong_em("em", "_");
  
  
  // Build default order from insertion order.
  Markdown.buildBlockOrder = function(d) {
    var ord = [];
    for ( var i in d ) {
      if ( i == "__order__" || i == "__call__" ) continue;
      ord.push( i );
    }
    d.__order__ = ord;
  };
  
  // Build patterns for inline matcher
  Markdown.buildInlinePatterns = function(d) {
    var patterns = [];
  
    for ( var i in d ) {
      // __foo__ is reserved and not a pattern
      if ( i.match( /^__.*__$/) ) continue;
      var l = i.replace( /([\\.*+?|()\[\]{}])/g, "\\$1" )
               .replace( /\n/, "\\n" );
      patterns.push( i.length == 1 ? l : "(?:" + l + ")" );
    }
  
    patterns = patterns.join("|");
    d.__patterns__ = patterns;
    //print("patterns:", uneval( patterns ) );
  
    var fn = d.__call__;
    d.__call__ = function(text, pattern) {
      if ( pattern != undefined ) {
        return fn.call(this, text, pattern);
      }
      else
      {
        return fn.call(this, text, patterns);
      }
    };
  };
  
  Markdown.DialectHelpers = {};
  Markdown.DialectHelpers.inline_until_char = function( text, want ) {
    var consumed = 0,
        nodes = [];
  
    while ( true ) {
      if ( text.charAt( consumed ) == want ) {
        // Found the character we were looking for
        consumed++;
        return [ consumed, nodes ];
      }
  
      if ( consumed >= text.length ) {
        // No closing char found. Abort.
        return null;
      }
  
      var res = this.dialect.inline.__oneElement__.call(this, text.substr( consumed ) );
      consumed += res[ 0 ];
      // Add any returned nodes.
      nodes.push.apply( nodes, res.slice( 1 ) );
    }
  }
  
  // Helper function to make sub-classing a dialect easier
  Markdown.subclassDialect = function( d ) {
    function Block() {}
    Block.prototype = d.block;
    function Inline() {}
    Inline.prototype = d.inline;
  
    return { block: new Block(), inline: new Inline() };
  };
  
  Markdown.buildBlockOrder ( Markdown.dialects.Gruber.block );
  Markdown.buildInlinePatterns( Markdown.dialects.Gruber.inline );
  
  Markdown.dialects.Maruku = Markdown.subclassDialect( Markdown.dialects.Gruber );
  
  Markdown.dialects.Maruku.processMetaHash = function processMetaHash( meta_string ) {
    var meta = split_meta_hash( meta_string ),
        attr = {};
  
    for ( var i = 0; i < meta.length; ++i ) {
      // id: #foo
      if ( /^#/.test( meta[ i ] ) ) {
        attr.id = meta[ i ].substring( 1 );
      }
      // class: .foo
      else if ( /^\./.test( meta[ i ] ) ) {
        // if class already exists, append the new one
        if ( attr["class"] ) {
          attr["class"] = attr["class"] + meta[ i ].replace( /./, " " );
        }
        else {
          attr["class"] = meta[ i ].substring( 1 );
        }
      }
      // attribute: foo=bar
      else if ( /\=/.test( meta[ i ] ) ) {
        var s = meta[ i ].split( /\=/ );
        attr[ s[ 0 ] ] = s[ 1 ];
      }
    }
  
    return attr;
  }
  
  function split_meta_hash( meta_string ) {
    var meta = meta_string.split( "" ),
        parts = [ "" ],
        in_quotes = false;
  
    while ( meta.length ) {
      var letter = meta.shift();
      switch ( letter ) {
        case " " :
          // if we're in a quoted section, keep it
          if ( in_quotes ) {
            parts[ parts.length - 1 ] += letter;
          }
          // otherwise make a new part
          else {
            parts.push( "" );
          }
          break;
        case "'" :
        case '"' :
          // reverse the quotes and move straight on
          in_quotes = !in_quotes;
          break;
        case "\\" :
          // shift off the next letter to be used straight away.
          // it was escaped so we'll keep it whatever it is
          letter = meta.shift();
        default :
          parts[ parts.length - 1 ] += letter;
          break;
      }
    }
  
    return parts;
  }
  
  Markdown.dialects.Maruku.block.document_meta = function document_meta( block, next ) {
    // we're only interested in the first block
    if ( block.lineNumber > 1 ) return undefined;
  
    // document_meta blocks consist of one or more lines of `Key: Value\n`
    if ( ! block.match( /^(?:\w+:.*\n)*\w+:.*$/ ) ) return undefined;
  
    // make an attribute node if it doesn't exist
    if ( !extract_attr( this.tree ) ) {
      this.tree.splice( 1, 0, {} );
    }
  
    var pairs = block.split( /\n/ );
    for ( p in pairs ) {
      var m = pairs[ p ].match( /(\w+):\s*(.*)$/ ),
          key = m[ 1 ].toLowerCase(),
          value = m[ 2 ];
  
      this.tree[ 1 ][ key ] = value;
    }
  
    // document_meta produces no content!
    return [];
  };
  
  Markdown.dialects.Maruku.block.block_meta = function block_meta( block, next ) {
    // check if the last line of the block is an meta hash
    var m = block.match( /(^|\n) {0,3}\{:\s*((?:\\\}|[^\}])*)\s*\}$/ );
    if ( !m ) return undefined;
  
    // process the meta hash
    var attr = this.dialect.processMetaHash( m[ 2 ] );
  
    var hash;
  
    // if we matched ^ then we need to apply meta to the previous block
    if ( m[ 1 ] === "" ) {
      var node = this.tree[ this.tree.length - 1 ];
      hash = extract_attr( node );
  
      // if the node is a string (rather than JsonML), bail
      if ( typeof node === "string" ) return undefined;
  
      // create the attribute hash if it doesn't exist
      if ( !hash ) {
        hash = {};
        node.splice( 1, 0, hash );
      }
  
      // add the attributes in
      for ( a in attr ) {
        hash[ a ] = attr[ a ];
      }
  
      // return nothing so the meta hash is removed
      return [];
    }
  
    // pull the meta hash off the block and process what's left
    var b = block.replace( /\n.*$/, "" ),
        result = this.processBlock( b, [] );
  
    // get or make the attributes hash
    hash = extract_attr( result[ 0 ] );
    if ( !hash ) {
      hash = {};
      result[ 0 ].splice( 1, 0, hash );
    }
  
    // attach the attributes to the block
    for ( a in attr ) {
      hash[ a ] = attr[ a ];
    }
  
    return result;
  };
  
  Markdown.dialects.Maruku.block.definition_list = function definition_list( block, next ) {
    // one or more terms followed by one or more definitions, in a single block
    var tight = /^((?:[^\s:].*\n)+):\s+([\s\S]+)$/,
        list = [ "dl" ],
        i, m;
  
    // see if we're dealing with a tight or loose block
    if ( ( m = block.match( tight ) ) ) {
      // pull subsequent tight DL blocks out of `next`
      var blocks = [ block ];
      while ( next.length && tight.exec( next[ 0 ] ) ) {
        blocks.push( next.shift() );
      }
  
      for ( var b = 0; b < blocks.length; ++b ) {
        var m = blocks[ b ].match( tight ),
            terms = m[ 1 ].replace( /\n$/, "" ).split( /\n/ ),
            defns = m[ 2 ].split( /\n:\s+/ );
  
        // print( uneval( m ) );
  
        for ( i = 0; i < terms.length; ++i ) {
          list.push( [ "dt", terms[ i ] ] );
        }
  
        for ( i = 0; i < defns.length; ++i ) {
          // run inline processing over the definition
          list.push( [ "dd" ].concat( this.processInline( defns[ i ].replace( /(\n)\s+/, "$1" ) ) ) );
        }
      }
    }
    else {
      return undefined;
    }
  
    return [ list ];
  };
  
  // splits on unescaped instances of @ch. If @ch is not a character the result
  // can be unpredictable
  
  Markdown.dialects.Maruku.block.table = function table (block, next) {
  
      var _split_on_unescaped = function(s, ch) {
          ch = ch || '\\s';
          if (ch.match(/^[\\|\[\]{}?*.+^$]$/)) { ch = '\\' + ch; }
          var res = [ ],
              r = new RegExp('^((?:\\\\.|[^\\\\' + ch + '])*)' + ch + '(.*)'),
              m;
          while(m = s.match(r)) {
              res.push(m[1]);
              s = m[2];
          }
          res.push(s);
          return res;
      }
  
      var leading_pipe = /^ {0,3}\|(.+)\n {0,3}\|\s*([\-:]+[\-| :]*)\n((?:\s*\|.*(?:\n|$))*)(?=\n|$)/,
          // find at least an unescaped pipe in each line
          no_leading_pipe = /^ {0,3}(\S(?:\\.|[^\\|])*\|.*)\n {0,3}([\-:]+\s*\|[\-| :]*)\n((?:(?:\\.|[^\\|])*\|.*(?:\n|$))*)(?=\n|$)/,
          i, m;
      if (m = block.match(leading_pipe)) {
          // remove leading pipes in contents
          // (header and horizontal rule already have the leading pipe left out)
          m[3] = m[3].replace(/^\s*\|/gm, '');
      } else if (! ( m = block.match(no_leading_pipe))) {
          return undefined;
      }
  
      var table = [ "table", [ "thead", [ "tr" ] ], [ "tbody" ] ];
  
      // remove trailing pipes, then split on pipes
      // (no escaped pipes are allowed in horizontal rule)
      m[2] = m[2].replace(/\|\s*$/, '').split('|');
  
      // process alignment
      var html_attrs = [ ];
      forEach (m[2], function (s) {
          if (s.match(/^\s*-+:\s*$/))       html_attrs.push({align: "right"});
          else if (s.match(/^\s*:-+\s*$/))  html_attrs.push({align: "left"});
          else if (s.match(/^\s*:-+:\s*$/)) html_attrs.push({align: "center"});
          else                              html_attrs.push({});
      });
  
      // now for the header, avoid escaped pipes
      m[1] = _split_on_unescaped(m[1].replace(/\|\s*$/, ''), '|');
      for (i = 0; i < m[1].length; i++) {
          table[1][1].push(['th', html_attrs[i] || {}].concat(
              this.processInline(m[1][i].trim())));
      }
  
      // now for body contents
      forEach (m[3].replace(/\|\s*$/mg, '').split('\n'), function (row) {
          var html_row = ['tr'];
          row = _split_on_unescaped(row, '|');
          for (i = 0; i < row.length; i++) {
              html_row.push(['td', html_attrs[i] || {}].concat(this.processInline(row[i].trim())));
          }
          table[2].push(html_row);
      }, this);
  
      return [table];
  }
  
  Markdown.dialects.Maruku.inline[ "{:" ] = function inline_meta( text, matches, out ) {
    if ( !out.length ) {
      return [ 2, "{:" ];
    }
  
    // get the preceeding element
    var before = out[ out.length - 1 ];
  
    if ( typeof before === "string" ) {
      return [ 2, "{:" ];
    }
  
    // match a meta hash
    var m = text.match( /^\{:\s*((?:\\\}|[^\}])*)\s*\}/ );
  
    // no match, false alarm
    if ( !m ) {
      return [ 2, "{:" ];
    }
  
    // attach the attributes to the preceeding element
    var meta = this.dialect.processMetaHash( m[ 1 ] ),
        attr = extract_attr( before );
  
    if ( !attr ) {
      attr = {};
      before.splice( 1, 0, attr );
    }
  
    for ( var k in meta ) {
      attr[ k ] = meta[ k ];
    }
  
    // cut out the string and replace it with nothing
    return [ m[ 0 ].length, "" ];
  };
  
  Markdown.dialects.Maruku.inline.__escape__ = /^\\[\\`\*_{}\[\]()#\+.!\-|:]/;
  
  Markdown.buildBlockOrder ( Markdown.dialects.Maruku.block );
  Markdown.buildInlinePatterns( Markdown.dialects.Maruku.inline );
  
  var isArray = Array.isArray || function(obj) {
    return Object.prototype.toString.call(obj) == "[object Array]";
  };
  
  var forEach;
  // Don't mess with Array.prototype. Its not friendly
  if ( Array.prototype.forEach ) {
    forEach = function( arr, cb, thisp ) {
      return arr.forEach( cb, thisp );
    };
  }
  else {
    forEach = function(arr, cb, thisp) {
      for (var i = 0; i < arr.length; i++) {
        cb.call(thisp || arr, arr[i], i, arr);
      }
    }
  }
  
  var isEmpty = function( obj ) {
    for ( var key in obj ) {
      if ( hasOwnProperty.call( obj, key ) ) {
        return false;
      }
    }
  
    return true;
  }
  
  function extract_attr( jsonml ) {
    return isArray(jsonml)
        && jsonml.length > 1
        && typeof jsonml[ 1 ] === "object"
        && !( isArray(jsonml[ 1 ]) )
        ? jsonml[ 1 ]
        : undefined;
  }
  
  
  
  /**
   *  renderJsonML( jsonml[, options] ) -> String
   *  - jsonml (Array): JsonML array to render to XML
   *  - options (Object): options
   *
   *  Converts the given JsonML into well-formed XML.
   *
   *  The options currently understood are:
   *
   *  - root (Boolean): wether or not the root node should be included in the
   *    output, or just its children. The default `false` is to not include the
   *    root itself.
   */
  expose.renderJsonML = function( jsonml, options ) {
    options = options || {};
    // include the root element in the rendered output?
    options.root = options.root || false;
  
    var content = [];
  
    if ( options.root ) {
      content.push( render_tree( jsonml ) );
    }
    else {
      jsonml.shift(); // get rid of the tag
      if ( jsonml.length && typeof jsonml[ 0 ] === "object" && !( jsonml[ 0 ] instanceof Array ) ) {
        jsonml.shift(); // get rid of the attributes
      }
  
      while ( jsonml.length ) {
        content.push( render_tree( jsonml.shift() ) );
      }
    }
  
    return content.join( "\n\n" );
  };
  
  function escapeHTML( text ) {
    return text.replace( /&/g, "&amp;" )
               .replace( /</g, "&lt;" )
               .replace( />/g, "&gt;" )
               .replace( /"/g, "&quot;" )
               .replace( /'/g, "&#39;" );
  }
  
  function render_tree( jsonml ) {
    // basic case
    if ( typeof jsonml === "string" ) {
      return escapeHTML( jsonml );
    }
  
    var tag = jsonml.shift(),
        attributes = {},
        content = [];
  
    if ( jsonml.length && typeof jsonml[ 0 ] === "object" && !( jsonml[ 0 ] instanceof Array ) ) {
      attributes = jsonml.shift();
    }
  
    while ( jsonml.length ) {
      content.push( render_tree( jsonml.shift() ) );
    }
  
    var tag_attrs = "";
    for ( var a in attributes ) {
      tag_attrs += " " + a + '="' + escapeHTML( attributes[ a ] ) + '"';
    }
  
    // be careful about adding whitespace here for inline elements
    if ( tag == "img" || tag == "br" || tag == "hr" ) {
      return "<"+ tag + tag_attrs + "/>";
    }
    else {
      return "<"+ tag + tag_attrs + ">" + content.join( "" ) + "</" + tag + ">";
    }
  }
  
  function convert_tree_to_html( tree, references, options ) {
    var i;
    options = options || {};
  
    // shallow clone
    var jsonml = tree.slice( 0 );
  
    if ( typeof options.preprocessTreeNode === "function" ) {
        jsonml = options.preprocessTreeNode(jsonml, references);
    }
  
    // Clone attributes if they exist
    var attrs = extract_attr( jsonml );
    if ( attrs ) {
      jsonml[ 1 ] = {};
      for ( i in attrs ) {
        jsonml[ 1 ][ i ] = attrs[ i ];
      }
      attrs = jsonml[ 1 ];
    }
  
    // basic case
    if ( typeof jsonml === "string" ) {
      return jsonml;
    }
  
    // convert this node
    switch ( jsonml[ 0 ] ) {
      case "header":
        jsonml[ 0 ] = "h" + jsonml[ 1 ].level;
        delete jsonml[ 1 ].level;
        break;
      case "bulletlist":
        jsonml[ 0 ] = "ul";
        break;
      case "numberlist":
        jsonml[ 0 ] = "ol";
        break;
      case "listitem":
        jsonml[ 0 ] = "li";
        break;
      case "para":
        jsonml[ 0 ] = "p";
        break;
      case "markdown":
        jsonml[ 0 ] = "html";
        if ( attrs ) delete attrs.references;
        break;
      case "code_block":
        jsonml[ 0 ] = "pre";
        i = attrs ? 2 : 1;
        var code = [ "code" ];
        code.push.apply( code, jsonml.splice( i, jsonml.length - i ) );
        jsonml[ i ] = code;
        break;
      case "inlinecode":
        jsonml[ 0 ] = "code";
        break;
      case "img":
        jsonml[ 1 ].src = jsonml[ 1 ].href;
        delete jsonml[ 1 ].href;
        break;
      case "linebreak":
        jsonml[ 0 ] = "br";
      break;
      case "link":
        jsonml[ 0 ] = "a";
        break;
      case "link_ref":
        jsonml[ 0 ] = "a";
  
        // grab this ref and clean up the attribute node
        var ref = references[ attrs.ref ];
  
        // if the reference exists, make the link
        if ( ref ) {
          delete attrs.ref;
  
          // add in the href and title, if present
          attrs.href = ref.href;
          if ( ref.title ) {
            attrs.title = ref.title;
          }
  
          // get rid of the unneeded original text
          delete attrs.original;
        }
        // the reference doesn't exist, so revert to plain text
        else {
          return attrs.original;
        }
        break;
      case "img_ref":
        jsonml[ 0 ] = "img";
  
        // grab this ref and clean up the attribute node
        var ref = references[ attrs.ref ];
  
        // if the reference exists, make the link
        if ( ref ) {
          delete attrs.ref;
  
          // add in the href and title, if present
          attrs.src = ref.href;
          if ( ref.title ) {
            attrs.title = ref.title;
          }
  
          // get rid of the unneeded original text
          delete attrs.original;
        }
        // the reference doesn't exist, so revert to plain text
        else {
          return attrs.original;
        }
        break;
    }
  
    // convert all the children
    i = 1;
  
    // deal with the attribute node, if it exists
    if ( attrs ) {
      // if there are keys, skip over it
      for ( var key in jsonml[ 1 ] ) {
          i = 2;
          break;
      }
      // if there aren't, remove it
      if ( i === 1 ) {
        jsonml.splice( i, 1 );
      }
    }
  
    for ( ; i < jsonml.length; ++i ) {
      jsonml[ i ] = convert_tree_to_html( jsonml[ i ], references, options );
    }
  
    return jsonml;
  }
  
  
  // merges adjacent text nodes into a single node
  function merge_text_nodes( jsonml ) {
    // skip the tag name and attribute hash
    var i = extract_attr( jsonml ) ? 2 : 1;
  
    while ( i < jsonml.length ) {
      // if it's a string check the next item too
      if ( typeof jsonml[ i ] === "string" ) {
        if ( i + 1 < jsonml.length && typeof jsonml[ i + 1 ] === "string" ) {
          // merge the second string into the first and remove it
          jsonml[ i ] += jsonml.splice( i + 1, 1 )[ 0 ];
        }
        else {
          ++i;
        }
      }
      // if it's not a string recurse
      else {
        merge_text_nodes( jsonml[ i ] );
        ++i;
      }
    }
  }
  
  } )( (function() {
    if ( false ) {}
    else {
      return exports;
    }
  } )() );
  
  
  /***/ }),
  
  /***/ "./vendor/assets/javascripts/tag-it.js":
  /*!*********************************************!*\
    !*** ./vendor/assets/javascripts/tag-it.js ***!
    \*********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  /* WEBPACK VAR INJECTION */(function(jQuery) {/*
  * jQuery UI Tag-it!
  *
  * @version v2.0 (06/2011)
  *
  * Copyright 2011, Levy Carneiro Jr.
  * Released under the MIT license.
  * http://aehlke.github.com/tag-it/LICENSE
  *
  * Homepage:
  *   http://aehlke.github.com/tag-it/
  *
  * Authors:
  *   Levy Carneiro Jr.
  *   Martin Rehfeld
  *   Tobias Schmidt
  *   Skylar Challand
  *   Alex Ehlke
  *
  * Maintainer:
  *   Alex Ehlke - Twitter: @aehlke
  *
  * Dependencies:
  *   jQuery v1.4+
  *   jQuery UI v1.8+
  */
  (function($) {
  
      $.widget('ui.tagit', {
          options: {
              allowDuplicates   : false,
              caseSensitive     : true,
              fieldName         : 'tags',
              placeholderText   : null,   // Sets `placeholder` attr on input field.
              readOnly          : false,  // Disables editing.
              removeConfirmation: false,  // Require confirmation to remove tags.
              tagLimit          : null,   // Max number of tags allowed (null for unlimited).
  
              // Used for autocomplete, unless you override `autocomplete.source`.
              availableTags     : [],
  
              // Use to override or add any options to the autocomplete widget.
              //
              // By default, autocomplete.source will map to availableTags,
              // unless overridden.
              autocomplete: {},
  
              // Shows autocomplete before the user even types anything.
              showAutocompleteOnFocus: false,
  
              // When enabled, quotes are unneccesary for inputting multi-word tags.
              allowSpaces: false,
  
              // The below options are for using a single field instead of several
              // for our form values.
              //
              // When enabled, will use a single hidden field for the form,
              // rather than one per tag. It will delimit tags in the field
              // with singleFieldDelimiter.
              //
              // The easiest way to use singleField is to just instantiate tag-it
              // on an INPUT element, in which case singleField is automatically
              // set to true, and singleFieldNode is set to that element. This
              // way, you don't need to fiddle with these options.
              singleField: false,
  
              // This is just used when preloading data from the field, and for
              // populating the field with delimited tags as the user adds them.
              singleFieldDelimiter: ',',
  
              // Set this to an input DOM node to use an existing form field.
              // Any text in it will be erased on init. But it will be
              // populated with the text of tags as they are created,
              // delimited by singleFieldDelimiter.
              //
              // If this is not set, we create an input node for it,
              // with the name given in settings.fieldName.
              singleFieldNode: null,
  
              // Whether to animate tag removals or not.
              animate: true,
  
              // Optionally set a tabindex attribute on the input that gets
              // created for tag-it.
              tabIndex: null,
  
              // Event callbacks.
              beforeTagAdded      : null,
              afterTagAdded       : null,
  
              beforeTagRemoved    : null,
              afterTagRemoved     : null,
  
              onTagClicked        : null,
              onTagLimitExceeded  : null,
  
  
              // DEPRECATED:
              //
              // /!\ These event callbacks are deprecated and WILL BE REMOVED at some
              // point in the future. They're here for backwards-compatibility.
              // Use the above before/after event callbacks instead.
              onTagAdded  : null,
              onTagRemoved: null,
              // `autocomplete.source` is the replacement for tagSource.
              tagSource: null,
              onSubmitTags: null,
              onFocus: null,
              onBlur: null
              // Do not use the above deprecated options.
          },
  
          _create: function() {
              // for handling static scoping inside callbacks
              var that = this;
  
              // There are 2 kinds of DOM nodes this widget can be instantiated on:
              //     1. UL, OL, or some element containing either of these.
              //     2. INPUT, in which case 'singleField' is overridden to true,
              //        a UL is created and the INPUT is hidden.
              if (this.element.is('input')) {
                  this.tagList = $('<ul></ul>').insertAfter(this.element);
                  this.options.singleField = true;
                  this.options.singleFieldNode = this.element;
                  this.element.addClass('tagit-hidden-field');
              } else {
                  this.tagList = this.element.find('ul, ol').andSelf().last();
              }
  
              this.tagInput = $('<input type="text" />').addClass('ui-widget-content');
  
              if (this.options.readOnly) this.tagInput.attr('disabled', 'disabled');
  
              if (this.options.tabIndex) {
                  this.tagInput.attr('tabindex', this.options.tabIndex);
              }
  
              if (this.options.placeholderText) {
                  this.tagInput.attr('placeholder', this.options.placeholderText);
              }
  
              if (!this.options.autocomplete.source) {
                  this.options.autocomplete.source = function(search, showChoices) {
                      var filter = search.term.toLowerCase();
                      var choices = $.grep(this.options.availableTags, function(element) {
                          // Only match autocomplete options that begin with the search term.
                          // (Case insensitive.)
                          return (element.toLowerCase().indexOf(filter) === 0);
                      });
                      if (!this.options.allowDuplicates) {
                          choices = this._subtractArray(choices, this.assignedTags());
                      }
                      showChoices(choices);
                  };
              }
  
              if (this.options.showAutocompleteOnFocus) {
                  this.tagInput.focus(function(event, ui) {
                      that._showAutocomplete();
                  });
  
                  if (typeof this.options.autocomplete.minLength === 'undefined') {
                      this.options.autocomplete.minLength = 0;
                  }
              }
  
              // Bind autocomplete.source callback functions to this context.
              if ($.isFunction(this.options.autocomplete.source)) {
                  this.options.autocomplete.source = $.proxy(this.options.autocomplete.source, this);
              }
  
              // DEPRECATED.
              if ($.isFunction(this.options.tagSource)) {
                  this.options.tagSource = $.proxy(this.options.tagSource, this);
              }
  
              this.tagList
                  .addClass('tagit')
                  .addClass('ui-widget ui-widget-content ui-corner-all')
                  // Create the input field.
                  .append($('<li class="tagit-new"></li>').append(this.tagInput))
                  .click(function(e) {
                      var target = $(e.target);
                      if (target.hasClass('tagit-label')) {
                          var tag = target.closest('.tagit-choice');
                          if (!tag.hasClass('removed')) {
                              that._trigger('onTagClicked', e, {tag: tag, tagLabel: that.tagLabel(tag)});
                          }
                      } else {
                          // Sets the focus() to the input field, if the user
                          // clicks anywhere inside the UL. This is needed
                          // because the input field needs to be of a small size.
                          that.tagInput.focus();
                      }
                  });
  
              // Single field support.
              var addedExistingFromSingleFieldNode = false;
              if (this.options.singleField) {
                  if (this.options.singleFieldNode) {
                      // Add existing tags from the input field.
                      var node = $(this.options.singleFieldNode);
                      var tags = node.val().split(this.options.singleFieldDelimiter);
                      node.val('');
                      $.each(tags, function(index, tag) {
                          that.createTag(tag, null, true);
                          addedExistingFromSingleFieldNode = true;
                      });
                  } else {
                      // Create our single field input after our list.
                      this.options.singleFieldNode = $('<input type="hidden" style="display:none;" value="" name="' + this.options.fieldName + '" />');
                      this.tagList.after(this.options.singleFieldNode);
                  }
              }
  
              // Add existing tags from the list, if any.
              if (!addedExistingFromSingleFieldNode) {
                  this.tagList.children('li').each(function() {
                      if (!$(this).hasClass('tagit-new')) {
                          that.createTag($(this).text(), $(this).attr('class'), true);
                          $(this).remove();
                      }
                  });
              }
  
              // Events.
              this.tagInput
                  .keydown(function(event) {
                      // Backspace is not detected within a keypress, so it must use keydown.
                      if (event.which == $.ui.keyCode.BACKSPACE && that.tagInput.val() === '') {
                          var tag = that._lastTag();
                          if (!that.options.removeConfirmation || tag.hasClass('remove')) {
                              // When backspace is pressed, the last tag is deleted.
                              that.removeTag(tag);
                          } else if (that.options.removeConfirmation) {
                              tag.addClass('remove ui-state-highlight');
                          }
                      } else if (that.options.removeConfirmation) {
                          that._lastTag().removeClass('remove ui-state-highlight');
                      } else if (event.which == $.ui.keyCode.ENTER && that.tagInput.val() === "") {
                          that._trigger('onSubmitTags', null, that.tagList);
                      }
  
                      // Comma/Space/Enter are all valid delimiters for new tags,
                      // except when there is an open quote or if setting allowSpaces = true.
                      // Tab will also create a tag, unless the tag input is empty,
                      // in which case it isn't caught.
                      if (
                          (event.which === $.ui.keyCode.COMMA && event.shiftKey === false) ||
                          event.which === $.ui.keyCode.ENTER ||
                          (
                              event.which == $.ui.keyCode.TAB &&
                              that.tagInput.val() !== ''
                          ) ||
                          (
                              event.which == $.ui.keyCode.SPACE &&
                              that.options.allowSpaces !== true &&
                              (
                                  $.trim(that.tagInput.val()).replace( /^s*/, '' ).charAt(0) != '"' ||
                                  (
                                      $.trim(that.tagInput.val()).charAt(0) == '"' &&
                                      $.trim(that.tagInput.val()).charAt($.trim(that.tagInput.val()).length - 1) == '"' &&
                                      $.trim(that.tagInput.val()).length - 1 !== 0
                                  )
                              )
                          )
                      ) {
                          // Enter submits the form if there's no text in the input.
                          if (!(event.which === $.ui.keyCode.ENTER && that.tagInput.val() === '')) {
                              event.preventDefault();
                          }
  
                          // Autocomplete will create its own tag from a selection and close automatically.
                          if (!(that.options.autocomplete.autoFocus && that.tagInput.data('autocomplete-open'))) {
                              that.tagInput.autocomplete('close');
                              that.createTag(that._cleanedInput());
                          }
                      }
                  }).blur(function(e){
                      that._trigger('onBlur', null, null);
                      // Create a tag when the element loses focus.
                      // If autocomplete is enabled and suggestion was clicked, don't add it.
                      if (!that.tagInput.data('autocomplete-open')) {
                          that.createTag(that._cleanedInput());
                      }
                  }).focus(function(e) {
                      that._trigger('onFocus', null, null);
                  })
  
              // Autocomplete.
              if (this.options.availableTags || this.options.tagSource || this.options.autocomplete.source) {
                  var autocompleteOptions = {
                      select: function(event, ui) {
                          that.createTag(ui.item.value);
                          // Preventing the tag input to be updated with the chosen value.
                          return false;
                      }
                  };
                  $.extend(autocompleteOptions, this.options.autocomplete);
  
                  // tagSource is deprecated, but takes precedence here since autocomplete.source is set by default,
                  // while tagSource is left null by default.
                  autocompleteOptions.source = this.options.tagSource || autocompleteOptions.source;
  
                  this.tagInput.autocomplete(autocompleteOptions).bind('autocompleteopen.tagit', function(event, ui) {
                      that.tagInput.data('autocomplete-open', true);
                  }).bind('autocompleteclose.tagit', function(event, ui) {
                      that.tagInput.data('autocomplete-open', false);
                  });
  
                  this.tagInput.autocomplete('widget').addClass('tagit-autocomplete');
              }
          },
  
          destroy: function() {
              $.Widget.prototype.destroy.call(this);
  
              this.element.unbind('.tagit');
              this.tagList.unbind('.tagit');
  
              this.tagInput.removeData('autocomplete-open');
  
              this.tagList.removeClass([
                  'tagit',
                  'ui-widget',
                  'ui-widget-content',
                  'ui-corner-all',
                  'tagit-hidden-field'
              ].join(' '));
  
              if (this.element.is('input')) {
                  this.element.removeClass('tagit-hidden-field');
                  this.tagList.remove();
              } else {
                  this.element.children('li').each(function() {
                      if ($(this).hasClass('tagit-new')) {
                          $(this).remove();
                      } else {
                          $(this).removeClass([
                              'tagit-choice',
                              'ui-widget-content',
                              'ui-state-default',
                              'ui-state-highlight',
                              'ui-corner-all',
                              'remove',
                              'tagit-choice-editable',
                              'tagit-choice-read-only'
                          ].join(' '));
  
                          $(this).text($(this).children('.tagit-label').text());
                      }
                  });
  
                  if (this.singleFieldNode) {
                      this.singleFieldNode.remove();
                  }
              }
  
              return this;
          },
  
          _cleanedInput: function() {
              // Returns the contents of the tag input, cleaned and ready to be passed to createTag
              return $.trim(this.tagInput.val().replace(/^"(.*)"$/, '$1'));
          },
  
          _lastTag: function() {
              return this.tagList.find('.tagit-choice:last:not(.removed)');
          },
  
          _tags: function() {
              return this.tagList.find('.tagit-choice:not(.removed)');
          },
  
          assignedTags: function() {
              // Returns an array of tag string values
              var that = this;
              var tags = [];
              if (this.options.singleField) {
                  tags = $(this.options.singleFieldNode).val().split(this.options.singleFieldDelimiter);
                  if (tags[0] === '') {
                      tags = [];
                  }
              } else {
                  this._tags().each(function() {
                      tags.push(that.tagLabel(this));
                  });
              }
              return tags;
          },
  
          _updateSingleTagsField: function(tags) {
              // Takes a list of tag string values, updates this.options.singleFieldNode.val to the tags delimited by this.options.singleFieldDelimiter
              $(this.options.singleFieldNode).val(tags.join(this.options.singleFieldDelimiter)).trigger('change');
          },
  
          _subtractArray: function(a1, a2) {
              var result = [];
              for (var i = 0; i < a1.length; i++) {
                  if ($.inArray(a1[i], a2) == -1) {
                      result.push(a1[i]);
                  }
              }
              return result;
          },
  
          tagLabel: function(tag) {
              // Returns the tag's string label.
              if (this.options.singleField) {
                  return $(tag).find('.tagit-label:first').text();
              } else {
                  return $(tag).find('input:first').val();
              }
          },
  
          _showAutocomplete: function() {
              this.tagInput.autocomplete('search', '');
          },
  
          _findTagByLabel: function(name) {
              var that = this;
              var tag = null;
              this._tags().each(function(i) {
                  if (that._formatStr(name) == that._formatStr(that.tagLabel(this))) {
                      tag = $(this);
                      return false;
                  }
              });
              return tag;
          },
  
          _isNew: function(name) {
              return !this._findTagByLabel(name);
          },
  
          _formatStr: function(str) {
              if (this.options.caseSensitive) {
                  return str;
              }
              return $.trim(str.toLowerCase());
          },
  
          _effectExists: function(name) {
              return Boolean($.effects && ($.effects[name] || ($.effects.effect && $.effects.effect[name])));
          },
  
          createTag: function(value, additionalClass, duringInitialization) {
              var that = this;
  
              value = $.trim(value);
  
              if(this.options.preprocessTag) {
                  value = this.options.preprocessTag(value);
              }
  
              if (value === '') {
                  return false;
              }
  
              if (!this.options.allowDuplicates && !this._isNew(value)) {
                  var existingTag = this._findTagByLabel(value);
                  if (this._trigger('onTagExists', null, {
                      existingTag: existingTag,
                      duringInitialization: duringInitialization
                  }) !== false) {
                      if (this._effectExists('highlight')) {
                          existingTag.effect('highlight');
                      }
                  }
                  return false;
              }
  
              if (this.options.tagLimit && this._tags().length >= this.options.tagLimit) {
                  this._trigger('onTagLimitExceeded', null, {duringInitialization: duringInitialization});
                  return false;
              }
  
              var label = $(this.options.onTagClicked ? '<a class="tagit-label"></a>' : '<span class="tagit-label"></span>').text(value);
  
              // Create tag.
              var tag = $('<li></li>')
                  .addClass('tagit-choice ui-widget-content ui-state-default ui-corner-all')
                  .addClass(additionalClass)
                  .append(label);
  
              if (this.options.readOnly){
                  tag.addClass('tagit-choice-read-only');
              } else {
                  tag.addClass('tagit-choice-editable');
                  // Button for removing the tag.
                  var removeTagIcon = $('<span></span>')
                      .addClass('ui-icon ui-icon-close');
                  var removeTag = $('<a><span class="text-icon">\xd7</span></a>') // \xd7 is an X
                      .addClass('tagit-close')
                      .append(removeTagIcon)
                      .click(function(e) {
                          // Removes a tag when the little 'x' is clicked.
                          that.removeTag(tag);
                      });
                  tag.append(removeTag);
              }
  
              // Unless options.singleField is set, each tag has a hidden input field inline.
              if (!this.options.singleField) {
                  var escapedValue = label.html();
                  tag.append('<input type="hidden" value="' + escapedValue + '" name="' + this.options.fieldName + '" class="tagit-hidden-field" />');
              }
  
              if (this._trigger('beforeTagAdded', null, {
                  tag: tag,
                  tagLabel: this.tagLabel(tag),
                  duringInitialization: duringInitialization
              }) === false) {
                  return;
              }
  
              if (this.options.singleField) {
                  var tags = this.assignedTags();
                  tags.push(value);
                  this._updateSingleTagsField(tags);
              }
  
              // DEPRECATED.
              this._trigger('onTagAdded', null, tag);
  
              this.tagInput.val('');
  
              // Insert tag.
              this.tagInput.parent().before(tag);
  
              this._trigger('afterTagAdded', null, {
                  tag: tag,
                  tagLabel: this.tagLabel(tag),
                  duringInitialization: duringInitialization
              });
  
              if (this.options.showAutocompleteOnFocus && !duringInitialization) {
                  setTimeout(function () { that._showAutocomplete(); }, 0);
              }
          },
  
          removeTag: function(tag, animate) {
              animate = typeof animate === 'undefined' ? this.options.animate : animate;
  
              tag = $(tag);
  
              // DEPRECATED.
              this._trigger('onTagRemoved', null, tag);
  
              if (this._trigger('beforeTagRemoved', null, {tag: tag, tagLabel: this.tagLabel(tag)}) === false) {
                  return;
              }
  
              if (this.options.singleField) {
                  var tags = this.assignedTags();
                  var removedTagLabel = this.tagLabel(tag);
                  tags = $.grep(tags, function(el){
                      return el != removedTagLabel;
                  });
                  this._updateSingleTagsField(tags);
              }
  
              if (animate) {
                  tag.addClass('removed'); // Excludes this tag from _tags.
                  var hide_args = this._effectExists('blind') ? ['blind', {direction: 'horizontal'}, 'fast'] : ['fast'];
  
                  var thisTag = this;
                  hide_args.push(function() {
                      tag.remove();
                      thisTag._trigger('afterTagRemoved', null, {tag: tag, tagLabel: thisTag.tagLabel(tag)});
                  });
  
                  tag.fadeOut('fast').hide.apply(tag, hide_args).dequeue();
              } else {
                  tag.remove();
                  this._trigger('afterTagRemoved', null, {tag: tag, tagLabel: this.tagLabel(tag)});
              }
  
          },
  
          removeTagByLabel: function(tagLabel, animate) {
              var toRemove = this._findTagByLabel(tagLabel);
              if (!toRemove) {
                  throw "No such tag exists with the name '" + tagLabel + "'";
              }
              this.removeTag(toRemove, animate);
          },
  
          removeAll: function() {
              // Removes all tags.
              var that = this;
              this._tags().each(function(index, tag) {
                  that.removeTag(tag, false);
              });
          }
  
      });
  })(jQuery);
  
  /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))
  
  /***/ })
  
  }]);
  //# sourceMappingURL=common.js.map